/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./script.js":
/*!*******************!*\
  !*** ./script.js ***!
  \*******************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _permaweb_aoconnect__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @permaweb/aoconnect */ \"./node_modules/@permaweb/aoconnect/dist/browser.js\");\n/* harmony import */ var arweave_wallet_kit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! arweave-wallet-kit */ \"./node_modules/arweave-wallet-kit/dist/index.es.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _createForOfIteratorHelper(r, e) { var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && \"number\" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t[\"return\"] || t[\"return\"](); } finally { if (u) throw o; } } }; }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = \"function\" == typeof Symbol ? Symbol : {}, a = i.iterator || \"@@iterator\", c = i.asyncIterator || \"@@asyncIterator\", u = i.toStringTag || \"@@toStringTag\"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, \"\"); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, \"_invoke\", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: \"normal\", arg: t.call(e, r) }; } catch (t) { return { type: \"throw\", arg: t }; } } e.wrap = wrap; var h = \"suspendedStart\", l = \"suspendedYield\", f = \"executing\", s = \"completed\", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { [\"next\", \"throw\", \"return\"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if (\"throw\" !== c.type) { var u = c.arg, h = u.value; return h && \"object\" == _typeof(h) && n.call(h, \"__await\") ? e.resolve(h.__await).then(function (t) { invoke(\"next\", t, i, a); }, function (t) { invoke(\"throw\", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke(\"throw\", t, i, a); }); } a(c.arg); } var r; o(this, \"_invoke\", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error(\"Generator is already running\"); if (o === s) { if (\"throw\" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if (\"next\" === n.method) n.sent = n._sent = n.arg;else if (\"throw\" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else \"return\" === n.method && n.abrupt(\"return\", n.arg); o = f; var p = tryCatch(e, r, n); if (\"normal\" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } \"throw\" === p.type && (o = s, n.method = \"throw\", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, \"throw\" === n && e.iterator[\"return\"] && (r.method = \"return\", r.arg = t, maybeInvokeDelegate(e, r), \"throw\" === r.method) || \"return\" !== n && (r.method = \"throw\", r.arg = new TypeError(\"The iterator does not provide a '\" + n + \"' method\")), y; var i = tryCatch(o, e.iterator, r.arg); if (\"throw\" === i.type) return r.method = \"throw\", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, \"return\" !== r.method && (r.method = \"next\", r.arg = t), r.delegate = null, y) : a : (r.method = \"throw\", r.arg = new TypeError(\"iterator result is not an object\"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = \"normal\", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: \"root\" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || \"\" === e) { var r = e[a]; if (r) return r.call(e); if (\"function\" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + \" is not iterable\"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, \"GeneratorFunction\"), e.isGeneratorFunction = function (t) { var e = \"function\" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || \"GeneratorFunction\" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, \"GeneratorFunction\")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, \"Generator\"), define(g, a, function () { return this; }), define(g, \"toString\", function () { return \"[object Generator]\"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) \"t\" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if (\"throw\" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = \"throw\", a.arg = e, r.next = n, o && (r.method = \"next\", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if (\"root\" === i.tryLoc) return handle(\"end\"); if (i.tryLoc <= this.prev) { var c = n.call(i, \"catchLoc\"), u = n.call(i, \"finallyLoc\"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error(\"try statement without catch or finally\"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, \"finallyLoc\") && this.prev < o.finallyLoc) { var i = o; break; } } i && (\"break\" === t || \"continue\" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = \"next\", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if (\"throw\" === t.type) throw t.arg; return \"break\" === t.type || \"continue\" === t.type ? this.next = t.arg : \"return\" === t.type ? (this.rval = this.arg = t.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, \"catch\": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if (\"throw\" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, \"next\" === this.method && (this.arg = t), y; } }, e; }\nfunction asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }\nfunction _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, \"next\", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, \"throw\", n); } _next(void 0); }); }; }\n// import ao from 'ao.js'\n\n\nvar DEFAULT_MODULE = \"SBNb1qPQ1TDwpD_mboxm2YllmMLXpWw4U8P9Ff8W9vk\";\nvar DEFAULT_SCHEDULER = \"_GQ33BkPtZrqxA84vM8Zk-N2aO0toNNu_C-l-rawrBA\";\nvar displayContainer = document.getElementById('contentDiv');\nvar pidSelect = document.getElementById('pidSelect');\nvar pidInput = document.getElementById('pid');\nvar wallet = '';\nvar pid = '';\nvar pidMap = new Map();\nvar getResult = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(MsgId, ProcessTxId) {\n    var _yield$result, Output;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          _context.next = 2;\n          return (0,_permaweb_aoconnect__WEBPACK_IMPORTED_MODULE_1__.result)({\n            message: MsgId,\n            process: ProcessTxId\n          });\n        case 2:\n          _yield$result = _context.sent;\n          Output = _yield$result.Output;\n          return _context.abrupt(\"return\", Output.data.output);\n        case 5:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee);\n  }));\n  return function getResult(_x, _x2) {\n    return _ref.apply(this, arguments);\n  };\n}();\nvar sendMsg = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(processId, Msg) {\n    var messageId;\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) switch (_context2.prev = _context2.next) {\n        case 0:\n          _context2.next = 2;\n          return (0,_permaweb_aoconnect__WEBPACK_IMPORTED_MODULE_1__.message)({\n            process: processId,\n            tags: [{\n              name: 'SDK',\n              value: 'aoconnect'\n            }, {\n              name: 'Action',\n              value: 'Eval'\n            }],\n            signer: (0,_permaweb_aoconnect__WEBPACK_IMPORTED_MODULE_1__.createDataItemSigner)(window.arweaveWallet),\n            data: Msg\n          });\n        case 2:\n          messageId = _context2.sent;\n          _context2.next = 5;\n          return getResult(messageId, processId);\n        case 5:\n          return _context2.abrupt(\"return\", _context2.sent);\n        case 6:\n        case \"end\":\n          return _context2.stop();\n      }\n    }, _callee2);\n  }));\n  return function sendMsg(_x3, _x4) {\n    return _ref2.apply(this, arguments);\n  };\n}();\nvar createProcess = /*#__PURE__*/function () {\n  var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(processName) {\n    var tags, processTxId;\n    return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n      while (1) switch (_context3.prev = _context3.next) {\n        case 0:\n          tags = [{\n            name: \"App-Name\",\n            value: \"aos\"\n          }, {\n            name: \"aos-Version\",\n            value: \"1.10.30\"\n          }, {\n            name: \"Name\",\n            value: processName\n          }];\n          _context3.next = 3;\n          return (0,_permaweb_aoconnect__WEBPACK_IMPORTED_MODULE_1__.spawn)({\n            module: \"SBNb1qPQ1TDwpD_mboxm2YllmMLXpWw4U8P9Ff8W9vk\",\n            scheduler: \"_GQ33BkPtZrqxA84vM8Zk-N2aO0toNNu_C-l-rawrBA\",\n            signer: (0,_permaweb_aoconnect__WEBPACK_IMPORTED_MODULE_1__.createDataItemSigner)(window.arweaveWallet),\n            tags: tags\n          });\n        case 3:\n          processTxId = _context3.sent;\n          return _context3.abrupt(\"return\", processTxId);\n        case 5:\n        case \"end\":\n          return _context3.stop();\n      }\n    }, _callee3);\n  }));\n  return function createProcess(_x5) {\n    return _ref3.apply(this, arguments);\n  };\n}();\nvar queryPids = /*#__PURE__*/function () {\n  var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n    var headers, nextCursor, jsonData, response, _result, _iterator, _step, info, _iterator2, _step2, tag;\n    return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n      while (1) switch (_context4.prev = _context4.next) {\n        case 0:\n          headers = {\n            'Content-Type': 'application/json'\n          };\n          nextCursor = null;\n        case 2:\n          if (false) {}\n          jsonData = {\n            variables: {\n              addresses: [\"\".concat(wallet)],\n              first: 1000,\n              after: nextCursor\n            },\n            query: \"query ($addresses:[String!]!, $first: Int!, $after: String) {\\n                transactions (\\n                    first: $first,\\n                    after: $after,\\n                    owners: $addresses, \\n                    tags: [\\n                        { name: \\\"Data-Protocol\\\", values: [\\\"ao\\\"] },\\n                        { name: \\\"Variant\\\", values: [\\\"ao.TN.1\\\"] },\\n                        { name: \\\"Type\\\", values: [\\\"Process\\\"]},\\n                        { name: \\\"Name\\\", values: [\\\"\\\"]}\\n                    ]\\n                ) {\\n                    edges {\\n                        node {\\n                            id\\n                            tags {\\n                                name\\n                                value\\n                            }\\n                            \\n                        }\\n                        cursor\\n                    }\\n                }\\n            }\"\n          };\n          _context4.next = 6;\n          return fetch('https://arweave-search.goldsky.com/graphql', {\n            method: 'POST',\n            headers: headers,\n            body: JSON.stringify(jsonData)\n          });\n        case 6:\n          response = _context4.sent;\n          _context4.next = 9;\n          return response.json();\n        case 9:\n          _result = _context4.sent;\n          if (!(_result.data.transactions.edges.length === 0)) {\n            _context4.next = 12;\n            break;\n          }\n          return _context4.abrupt(\"break\", 17);\n        case 12:\n          // 处理当前页的数据\n          _iterator = _createForOfIteratorHelper(_result.data.transactions.edges);\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              info = _step.value;\n              _iterator2 = _createForOfIteratorHelper(info.node.tags);\n              try {\n                for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n                  tag = _step2.value;\n                  if (tag.name === 'Name') {\n                    pidMap.set(tag.value, info.node.id);\n                  }\n                }\n              } catch (err) {\n                _iterator2.e(err);\n              } finally {\n                _iterator2.f();\n              }\n            }\n\n            // 更新游标为当前页的最后一个节点的游标\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n          nextCursor = _result.data.transactions.edges[_result.data.transactions.edges.length - 1].cursor;\n          _context4.next = 2;\n          break;\n        case 17:\n        case \"end\":\n          return _context4.stop();\n      }\n    }, _callee4);\n  }));\n  return function queryPids() {\n    return _ref4.apply(this, arguments);\n  };\n}();\npidSelect.addEventListener('change', function () {\n  // 这里可以访问当前选中的值\n  var selectedPid = this.value;\n  if (selectedPid === 'new process') {\n    pidInput.disabled = false;\n    pidInput.value = '';\n    pid = '';\n  } else {\n    pidInput.value = pidMap.get(selectedPid);\n    pidInput.disabled = true;\n  }\n  document.getElementById('connect').innerText = 'connect';\n});\nvar populatePidSelect = /*#__PURE__*/function () {\n  var _ref5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {\n    return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n      while (1) switch (_context5.prev = _context5.next) {\n        case 0:\n          pidMap.clear();\n          initPidSelect();\n          _context5.next = 4;\n          return queryPids().then(function () {\n            // console.log(pidMap);\n            pidMap.forEach(function (value, key) {\n              var option = document.createElement('option');\n              option.value = key;\n              option.textContent = key;\n              pidSelect.appendChild(option);\n            });\n          });\n        case 4:\n        case \"end\":\n          return _context5.stop();\n      }\n    }, _callee5);\n  }));\n  return function populatePidSelect() {\n    return _ref5.apply(this, arguments);\n  };\n}();\nfunction initPidSelect() {\n  pidSelect.innerText = '';\n  var createOption = document.createElement('option');\n  createOption.value = 'new process'; // 可以设置为一个特定的值，例如 'create'\n  createOption.textContent = 'new process';\n  pidSelect.appendChild(createOption);\n}\n\n// 将内容添加到显示容器的函数\nvar appendContent = function appendContent(content, result) {\n  if (!result) {\n    content = 'aos> ' + content;\n  }\n  var newContentDiv = document.createElement('div');\n  newContentDiv.classList.add('display-item');\n  newContentDiv.textContent = content;\n  newContentDiv.style.color = result ? 'white' : 'red';\n  newContentDiv.style.whiteSpace = 'pre-line';\n  displayContainer.appendChild(newContentDiv);\n  displayContainer.scrollTop = displayContainer.scrollHeight;\n};\n\n//页面初始化加载\ndocument.addEventListener('DOMContentLoaded', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {\n  return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n    while (1) switch (_context6.prev = _context6.next) {\n      case 0:\n        appendContent('please connect to arconnect and aos', true);\n        _context6.next = 3;\n        return populatePidSelect();\n      case 3:\n        if (!window.arweaveWallet) {\n          _context6.next = 8;\n          break;\n        }\n        _context6.next = 6;\n        return window.arweaveWallet.getActiveAddress();\n      case 6:\n        wallet = _context6.sent;\n        if (wallet) {\n          document.getElementById('arConncet').textContent = wallet.substring(0, 5) + '...';\n          populatePidSelect();\n        }\n      case 8:\n      case \"end\":\n        return _context6.stop();\n    }\n  }, _callee6);\n})));\ndocument.getElementById('arConncet').addEventListener('click', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {\n  return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n    while (1) switch (_context7.prev = _context7.next) {\n      case 0:\n        if (!(window.arweaveWallet && !wallet)) {\n          _context7.next = 10;\n          break;\n        }\n        _context7.next = 3;\n        return window.arweaveWallet.connect(['ACCESS_ADDRESS', 'SIGN_TRANSACTION']);\n      case 3:\n        _context7.next = 5;\n        return window.arweaveWallet.getActiveAddress();\n      case 5:\n        wallet = _context7.sent;\n        document.getElementById('arConncet').textContent = wallet.substring(0, 10) + '...';\n        populatePidSelect();\n        _context7.next = 20;\n        break;\n      case 10:\n        if (!wallet) {\n          _context7.next = 19;\n          break;\n        }\n        _context7.next = 13;\n        return window.arweaveWallet.disconnect();\n      case 13:\n        wallet = '';\n        document.getElementById('arConncet').textContent = 'ArConnect';\n        pidMap.clear();\n        initPidSelect();\n        _context7.next = 20;\n        break;\n      case 19:\n        if (!window.arweaveWallet) {\n          alert(\"Please install Arweave Wallet\");\n        }\n      case 20:\n      case \"end\":\n        return _context7.stop();\n    }\n  }, _callee7);\n})));\n\n// 为按钮1添加事件监听器\ndocument.getElementById('connect').addEventListener('click', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8() {\n  var selectPid;\n  return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n    while (1) switch (_context8.prev = _context8.next) {\n      case 0:\n        selectPid = pidSelect.value;\n        if (!(selectPid === 'new process')) {\n          _context8.next = 6;\n          break;\n        }\n        _context8.next = 4;\n        return createProcess(pidInput.value).then(function (processId) {\n          pid = processId;\n          pidMap.set(pidInput.value, processId);\n          var option = document.createElement('option');\n          option.value = pidInput.value;\n          option.textContent = pidInput.value;\n          pidSelect.appendChild(option);\n          pidSelect.value = pidInput.value;\n          pidInput.value = processId;\n        });\n      case 4:\n        _context8.next = 8;\n        break;\n      case 6:\n        pidInput.value = pidMap.get(selectPid);\n        pid = pidMap.get(selectPid);\n      case 8:\n        pidInput.disabled = true;\n        appendContent('connect success', true);\n      case 10:\n      case \"end\":\n        return _context8.stop();\n    }\n  }, _callee8);\n})));\n\n// 为按钮2添加事件监听器\ndocument.getElementById('send').addEventListener('click', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10() {\n  var inputText;\n  return _regeneratorRuntime().wrap(function _callee10$(_context10) {\n    while (1) switch (_context10.prev = _context10.next) {\n      case 0:\n        if (wallet) {\n          _context10.next = 3;\n          break;\n        }\n        appendContent('please connect to arconnect first', true);\n        return _context10.abrupt(\"return\");\n      case 3:\n        if (pid) {\n          _context10.next = 6;\n          break;\n        }\n        appendContent('please connect to ao first', true);\n        return _context10.abrupt(\"return\");\n      case 6:\n        inputText = document.getElementById('msg').value;\n        if (inputText) {\n          _context10.next = 9;\n          break;\n        }\n        return _context10.abrupt(\"return\");\n      case 9:\n        document.getElementById('send').disabled = true;\n        document.getElementById('msg').disabled = true;\n        if (!inputText.startsWith('.load ')) {\n          _context10.next = 17;\n          break;\n        }\n        appendContent(inputText, false);\n        document.getElementById('overlay').style.display = 'flex'; // 显示覆盖层\n        document.getElementById('msg').disabled = false;\n        _context10.next = 33;\n        break;\n      case 17:\n        if (!(inputText === '.load-blueprint chat')) {\n          _context10.next = 22;\n          break;\n        }\n        appendContent(inputText, false);\n        // document.getElementById('send').disabled = true;\n        fetch(\"https://raw.githubusercontent.com/permaweb/aos/main/blueprints/chat.lua\").then(function (response) {\n          response.text().then( /*#__PURE__*/function () {\n            var _ref10 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(inputData) {\n              return _regeneratorRuntime().wrap(function _callee9$(_context9) {\n                while (1) switch (_context9.prev = _context9.next) {\n                  case 0:\n                    _context9.next = 2;\n                    return sendMsg(pid, inputData).then(function (resultMsg) {\n                      resultMsg = cleanAnsiString(resultMsg);\n                      appendContent(resultMsg, true);\n                      document.getElementById('send').disabled = false;\n                      document.getElementById('msg').value = '';\n                      document.getElementById('msg').disabled = false;\n                    });\n                  case 2:\n                  case \"end\":\n                    return _context9.stop();\n                }\n              }, _callee9);\n            }));\n            return function (_x6) {\n              return _ref10.apply(this, arguments);\n            };\n          }());\n        });\n        _context10.next = 33;\n        break;\n      case 22:\n        document.getElementById('overlay').style.display = 'none'; // 隐藏覆盖层\n        if (inputText) {\n          appendContent(inputText, false);\n        }\n        _context10.prev = 24;\n        _context10.next = 27;\n        return sendMsg(pid, inputText).then(function (resultMsg) {\n          appendContent(resultMsg, true);\n          document.getElementById('msg').value = '';\n          document.getElementById('send').disabled = false;\n          document.getElementById('msg').disabled = false;\n        });\n      case 27:\n        _context10.next = 33;\n        break;\n      case 29:\n        _context10.prev = 29;\n        _context10.t0 = _context10[\"catch\"](24);\n        console.error('Error fetching Messages:', _context10.t0);\n        appendContent('Error loading data');\n      case 33:\n      case \"end\":\n        return _context10.stop();\n    }\n  }, _callee10, null, [[24, 29]]);\n})));\nfunction cleanAnsiString(str) {\n  // 移除ANSI转义代码\n  var withoutAnsi = str.replace(/\\u001b\\[.*?m/g, '');\n  var withBreaks = withoutAnsi.replace(/\\t/g, '    ');\n  return withBreaks;\n}\n// 返回页面\ndocument.getElementById('back').addEventListener('click', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11() {\n  return _regeneratorRuntime().wrap(function _callee11$(_context11) {\n    while (1) switch (_context11.prev = _context11.next) {\n      case 0:\n        document.getElementById('overlay').style.display = 'none'; // 隐藏覆盖层\n        document.getElementById('msg').value = '';\n      case 2:\n      case \"end\":\n        return _context11.stop();\n    }\n  }, _callee11);\n})));\n// 发送脚本\ndocument.getElementById('sendLua').addEventListener('click', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12() {\n  var inputText;\n  return _regeneratorRuntime().wrap(function _callee12$(_context12) {\n    while (1) switch (_context12.prev = _context12.next) {\n      case 0:\n        document.getElementById('overlay').style.display = 'none'; // 隐藏覆盖层\n        inputText = document.getElementById('large-input').value;\n        if (inputText) {\n          document.getElementById('sendLua').disabled = true;\n        }\n        document.getElementById('send').disabled = true;\n        _context12.prev = 4;\n        _context12.next = 7;\n        return sendMsg(pid, inputText).then(function (resultMsg) {\n          appendContent(resultMsg, true);\n          document.getElementById('send').disabled = false;\n          document.getElementById('msg').value = '';\n        });\n      case 7:\n        _context12.next = 13;\n        break;\n      case 9:\n        _context12.prev = 9;\n        _context12.t0 = _context12[\"catch\"](4);\n        console.error('Error fetching Messages:', _context12.t0);\n        appendContent('Error loading data', true);\n      case 13:\n      case \"end\":\n        return _context12.stop();\n    }\n  }, _callee12, null, [[4, 9]]);\n})));\n\n//# sourceURL=webpack://q2/./script.js?");

/***/ }),

/***/ "./node_modules/react/cjs/react.development.js":
/*!*****************************************************!*\
  !*** ./node_modules/react/cjs/react.development.js ***!
  \*****************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\n/**\n * @license React\n * react.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nif (true) {\n  (function() {\n\n          'use strict';\n\n/* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\nif (\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' &&\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart ===\n    'function'\n) {\n  __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());\n}\n          var ReactVersion = '18.3.1';\n\n// ATTENTION\n// When adding new symbols to this file,\n// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n// The Symbol used to tag the ReactElement-like types.\nvar REACT_ELEMENT_TYPE = Symbol.for('react.element');\nvar REACT_PORTAL_TYPE = Symbol.for('react.portal');\nvar REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');\nvar REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');\nvar REACT_PROFILER_TYPE = Symbol.for('react.profiler');\nvar REACT_PROVIDER_TYPE = Symbol.for('react.provider');\nvar REACT_CONTEXT_TYPE = Symbol.for('react.context');\nvar REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');\nvar REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');\nvar REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');\nvar REACT_MEMO_TYPE = Symbol.for('react.memo');\nvar REACT_LAZY_TYPE = Symbol.for('react.lazy');\nvar REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');\nvar MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\nvar FAUX_ITERATOR_SYMBOL = '@@iterator';\nfunction getIteratorFn(maybeIterable) {\n  if (maybeIterable === null || typeof maybeIterable !== 'object') {\n    return null;\n  }\n\n  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n\n  if (typeof maybeIterator === 'function') {\n    return maybeIterator;\n  }\n\n  return null;\n}\n\n/**\n * Keeps track of the current dispatcher.\n */\nvar ReactCurrentDispatcher = {\n  /**\n   * @internal\n   * @type {ReactComponent}\n   */\n  current: null\n};\n\n/**\n * Keeps track of the current batch's configuration such as how long an update\n * should suspend for if it needs to.\n */\nvar ReactCurrentBatchConfig = {\n  transition: null\n};\n\nvar ReactCurrentActQueue = {\n  current: null,\n  // Used to reproduce behavior of `batchedUpdates` in legacy mode.\n  isBatchingLegacy: false,\n  didScheduleLegacyUpdate: false\n};\n\n/**\n * Keeps track of the current owner.\n *\n * The current owner is the component who should own any components that are\n * currently being constructed.\n */\nvar ReactCurrentOwner = {\n  /**\n   * @internal\n   * @type {ReactComponent}\n   */\n  current: null\n};\n\nvar ReactDebugCurrentFrame = {};\nvar currentExtraStackFrame = null;\nfunction setExtraStackFrame(stack) {\n  {\n    currentExtraStackFrame = stack;\n  }\n}\n\n{\n  ReactDebugCurrentFrame.setExtraStackFrame = function (stack) {\n    {\n      currentExtraStackFrame = stack;\n    }\n  }; // Stack implementation injected by the current renderer.\n\n\n  ReactDebugCurrentFrame.getCurrentStack = null;\n\n  ReactDebugCurrentFrame.getStackAddendum = function () {\n    var stack = ''; // Add an extra top frame while an element is being validated\n\n    if (currentExtraStackFrame) {\n      stack += currentExtraStackFrame;\n    } // Delegate to the injected renderer-specific implementation\n\n\n    var impl = ReactDebugCurrentFrame.getCurrentStack;\n\n    if (impl) {\n      stack += impl() || '';\n    }\n\n    return stack;\n  };\n}\n\n// -----------------------------------------------------------------------------\n\nvar enableScopeAPI = false; // Experimental Create Event Handle API.\nvar enableCacheElement = false;\nvar enableTransitionTracing = false; // No known bugs, but needs performance testing\n\nvar enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber\n// stuff. Intended to enable React core members to more easily debug scheduling\n// issues in DEV builds.\n\nvar enableDebugTracing = false; // Track which Fiber(s) schedule render work.\n\nvar ReactSharedInternals = {\n  ReactCurrentDispatcher: ReactCurrentDispatcher,\n  ReactCurrentBatchConfig: ReactCurrentBatchConfig,\n  ReactCurrentOwner: ReactCurrentOwner\n};\n\n{\n  ReactSharedInternals.ReactDebugCurrentFrame = ReactDebugCurrentFrame;\n  ReactSharedInternals.ReactCurrentActQueue = ReactCurrentActQueue;\n}\n\n// by calls to these methods by a Babel plugin.\n//\n// In PROD (or in packages without access to React internals),\n// they are left as they are instead.\n\nfunction warn(format) {\n  {\n    {\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      printWarning('warn', format, args);\n    }\n  }\n}\nfunction error(format) {\n  {\n    {\n      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n\n      printWarning('error', format, args);\n    }\n  }\n}\n\nfunction printWarning(level, format, args) {\n  // When changing this logic, you might want to also\n  // update consoleWithStackDev.www.js as well.\n  {\n    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n    var stack = ReactDebugCurrentFrame.getStackAddendum();\n\n    if (stack !== '') {\n      format += '%s';\n      args = args.concat([stack]);\n    } // eslint-disable-next-line react-internal/safe-string-coercion\n\n\n    var argsWithFormat = args.map(function (item) {\n      return String(item);\n    }); // Careful: RN currently depends on this prefix\n\n    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it\n    // breaks IE9: https://github.com/facebook/react/issues/13610\n    // eslint-disable-next-line react-internal/no-production-logging\n\n    Function.prototype.apply.call(console[level], console, argsWithFormat);\n  }\n}\n\nvar didWarnStateUpdateForUnmountedComponent = {};\n\nfunction warnNoop(publicInstance, callerName) {\n  {\n    var _constructor = publicInstance.constructor;\n    var componentName = _constructor && (_constructor.displayName || _constructor.name) || 'ReactClass';\n    var warningKey = componentName + \".\" + callerName;\n\n    if (didWarnStateUpdateForUnmountedComponent[warningKey]) {\n      return;\n    }\n\n    error(\"Can't call %s on a component that is not yet mounted. \" + 'This is a no-op, but it might indicate a bug in your application. ' + 'Instead, assign to `this.state` directly or define a `state = {};` ' + 'class property with the desired state in the %s component.', callerName, componentName);\n\n    didWarnStateUpdateForUnmountedComponent[warningKey] = true;\n  }\n}\n/**\n * This is the abstract API for an update queue.\n */\n\n\nvar ReactNoopUpdateQueue = {\n  /**\n   * Checks whether or not this composite component is mounted.\n   * @param {ReactClass} publicInstance The instance we want to test.\n   * @return {boolean} True if mounted, false otherwise.\n   * @protected\n   * @final\n   */\n  isMounted: function (publicInstance) {\n    return false;\n  },\n\n  /**\n   * Forces an update. This should only be invoked when it is known with\n   * certainty that we are **not** in a DOM transaction.\n   *\n   * You may want to call this when you know that some deeper aspect of the\n   * component's state has changed but `setState` was not called.\n   *\n   * This will not invoke `shouldComponentUpdate`, but it will invoke\n   * `componentWillUpdate` and `componentDidUpdate`.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @param {?function} callback Called after component is updated.\n   * @param {?string} callerName name of the calling function in the public API.\n   * @internal\n   */\n  enqueueForceUpdate: function (publicInstance, callback, callerName) {\n    warnNoop(publicInstance, 'forceUpdate');\n  },\n\n  /**\n   * Replaces all of the state. Always use this or `setState` to mutate state.\n   * You should treat `this.state` as immutable.\n   *\n   * There is no guarantee that `this.state` will be immediately updated, so\n   * accessing `this.state` after calling this method may return the old value.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @param {object} completeState Next state.\n   * @param {?function} callback Called after component is updated.\n   * @param {?string} callerName name of the calling function in the public API.\n   * @internal\n   */\n  enqueueReplaceState: function (publicInstance, completeState, callback, callerName) {\n    warnNoop(publicInstance, 'replaceState');\n  },\n\n  /**\n   * Sets a subset of the state. This only exists because _pendingState is\n   * internal. This provides a merging strategy that is not available to deep\n   * properties which is confusing. TODO: Expose pendingState or don't use it\n   * during the merge.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @param {object} partialState Next partial state to be merged with state.\n   * @param {?function} callback Called after component is updated.\n   * @param {?string} Name of the calling function in the public API.\n   * @internal\n   */\n  enqueueSetState: function (publicInstance, partialState, callback, callerName) {\n    warnNoop(publicInstance, 'setState');\n  }\n};\n\nvar assign = Object.assign;\n\nvar emptyObject = {};\n\n{\n  Object.freeze(emptyObject);\n}\n/**\n * Base class helpers for the updating state of a component.\n */\n\n\nfunction Component(props, context, updater) {\n  this.props = props;\n  this.context = context; // If a component has string refs, we will assign a different object later.\n\n  this.refs = emptyObject; // We initialize the default updater but the real one gets injected by the\n  // renderer.\n\n  this.updater = updater || ReactNoopUpdateQueue;\n}\n\nComponent.prototype.isReactComponent = {};\n/**\n * Sets a subset of the state. Always use this to mutate\n * state. You should treat `this.state` as immutable.\n *\n * There is no guarantee that `this.state` will be immediately updated, so\n * accessing `this.state` after calling this method may return the old value.\n *\n * There is no guarantee that calls to `setState` will run synchronously,\n * as they may eventually be batched together.  You can provide an optional\n * callback that will be executed when the call to setState is actually\n * completed.\n *\n * When a function is provided to setState, it will be called at some point in\n * the future (not synchronously). It will be called with the up to date\n * component arguments (state, props, context). These values can be different\n * from this.* because your function may be called after receiveProps but before\n * shouldComponentUpdate, and this new state, props, and context will not yet be\n * assigned to this.\n *\n * @param {object|function} partialState Next partial state or function to\n *        produce next partial state to be merged with current state.\n * @param {?function} callback Called after state is updated.\n * @final\n * @protected\n */\n\nComponent.prototype.setState = function (partialState, callback) {\n  if (typeof partialState !== 'object' && typeof partialState !== 'function' && partialState != null) {\n    throw new Error('setState(...): takes an object of state variables to update or a ' + 'function which returns an object of state variables.');\n  }\n\n  this.updater.enqueueSetState(this, partialState, callback, 'setState');\n};\n/**\n * Forces an update. This should only be invoked when it is known with\n * certainty that we are **not** in a DOM transaction.\n *\n * You may want to call this when you know that some deeper aspect of the\n * component's state has changed but `setState` was not called.\n *\n * This will not invoke `shouldComponentUpdate`, but it will invoke\n * `componentWillUpdate` and `componentDidUpdate`.\n *\n * @param {?function} callback Called after update is complete.\n * @final\n * @protected\n */\n\n\nComponent.prototype.forceUpdate = function (callback) {\n  this.updater.enqueueForceUpdate(this, callback, 'forceUpdate');\n};\n/**\n * Deprecated APIs. These APIs used to exist on classic React classes but since\n * we would like to deprecate them, we're not going to move them over to this\n * modern base class. Instead, we define a getter that warns if it's accessed.\n */\n\n\n{\n  var deprecatedAPIs = {\n    isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],\n    replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).']\n  };\n\n  var defineDeprecationWarning = function (methodName, info) {\n    Object.defineProperty(Component.prototype, methodName, {\n      get: function () {\n        warn('%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]);\n\n        return undefined;\n      }\n    });\n  };\n\n  for (var fnName in deprecatedAPIs) {\n    if (deprecatedAPIs.hasOwnProperty(fnName)) {\n      defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);\n    }\n  }\n}\n\nfunction ComponentDummy() {}\n\nComponentDummy.prototype = Component.prototype;\n/**\n * Convenience component with default shallow equality check for sCU.\n */\n\nfunction PureComponent(props, context, updater) {\n  this.props = props;\n  this.context = context; // If a component has string refs, we will assign a different object later.\n\n  this.refs = emptyObject;\n  this.updater = updater || ReactNoopUpdateQueue;\n}\n\nvar pureComponentPrototype = PureComponent.prototype = new ComponentDummy();\npureComponentPrototype.constructor = PureComponent; // Avoid an extra prototype jump for these methods.\n\nassign(pureComponentPrototype, Component.prototype);\npureComponentPrototype.isPureReactComponent = true;\n\n// an immutable object with a single mutable value\nfunction createRef() {\n  var refObject = {\n    current: null\n  };\n\n  {\n    Object.seal(refObject);\n  }\n\n  return refObject;\n}\n\nvar isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\n\nfunction isArray(a) {\n  return isArrayImpl(a);\n}\n\n/*\n * The `'' + value` pattern (used in in perf-sensitive code) throws for Symbol\n * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n *\n * The functions in this module will throw an easier-to-understand,\n * easier-to-debug exception with a clear errors message message explaining the\n * problem. (Instead of a confusing exception thrown inside the implementation\n * of the `value` object).\n */\n// $FlowFixMe only called in DEV, so void return is not possible.\nfunction typeName(value) {\n  {\n    // toStringTag is needed for namespaced types like Temporal.Instant\n    var hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag;\n    var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || 'Object';\n    return type;\n  }\n} // $FlowFixMe only called in DEV, so void return is not possible.\n\n\nfunction willCoercionThrow(value) {\n  {\n    try {\n      testStringCoercion(value);\n      return false;\n    } catch (e) {\n      return true;\n    }\n  }\n}\n\nfunction testStringCoercion(value) {\n  // If you ended up here by following an exception call stack, here's what's\n  // happened: you supplied an object or symbol value to React (as a prop, key,\n  // DOM attribute, CSS property, string ref, etc.) and when React tried to\n  // coerce it to a string using `'' + value`, an exception was thrown.\n  //\n  // The most common types that will cause this exception are `Symbol` instances\n  // and Temporal objects like `Temporal.Instant`. But any object that has a\n  // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n  // exception. (Library authors do this to prevent users from using built-in\n  // numeric operators like `+` or comparison operators like `>=` because custom\n  // methods are needed to perform accurate arithmetic or comparison.)\n  //\n  // To fix the problem, coerce this object or symbol value to a string before\n  // passing it to React. The most reliable way is usually `String(value)`.\n  //\n  // To find which value is throwing, check the browser or debugger console.\n  // Before this exception was thrown, there should be `console.error` output\n  // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n  // problem and how that type was used: key, atrribute, input value prop, etc.\n  // In most cases, this console output also shows the component and its\n  // ancestor components where the exception happened.\n  //\n  // eslint-disable-next-line react-internal/safe-string-coercion\n  return '' + value;\n}\nfunction checkKeyStringCoercion(value) {\n  {\n    if (willCoercionThrow(value)) {\n      error('The provided key is an unsupported type %s.' + ' This value must be coerced to a string before before using it here.', typeName(value));\n\n      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n    }\n  }\n}\n\nfunction getWrappedName(outerType, innerType, wrapperName) {\n  var displayName = outerType.displayName;\n\n  if (displayName) {\n    return displayName;\n  }\n\n  var functionName = innerType.displayName || innerType.name || '';\n  return functionName !== '' ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n} // Keep in sync with react-reconciler/getComponentNameFromFiber\n\n\nfunction getContextName(type) {\n  return type.displayName || 'Context';\n} // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\n\n\nfunction getComponentNameFromType(type) {\n  if (type == null) {\n    // Host root, text node or just invalid type.\n    return null;\n  }\n\n  {\n    if (typeof type.tag === 'number') {\n      error('Received an unexpected object in getComponentNameFromType(). ' + 'This is likely a bug in React. Please file an issue.');\n    }\n  }\n\n  if (typeof type === 'function') {\n    return type.displayName || type.name || null;\n  }\n\n  if (typeof type === 'string') {\n    return type;\n  }\n\n  switch (type) {\n    case REACT_FRAGMENT_TYPE:\n      return 'Fragment';\n\n    case REACT_PORTAL_TYPE:\n      return 'Portal';\n\n    case REACT_PROFILER_TYPE:\n      return 'Profiler';\n\n    case REACT_STRICT_MODE_TYPE:\n      return 'StrictMode';\n\n    case REACT_SUSPENSE_TYPE:\n      return 'Suspense';\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return 'SuspenseList';\n\n  }\n\n  if (typeof type === 'object') {\n    switch (type.$$typeof) {\n      case REACT_CONTEXT_TYPE:\n        var context = type;\n        return getContextName(context) + '.Consumer';\n\n      case REACT_PROVIDER_TYPE:\n        var provider = type;\n        return getContextName(provider._context) + '.Provider';\n\n      case REACT_FORWARD_REF_TYPE:\n        return getWrappedName(type, type.render, 'ForwardRef');\n\n      case REACT_MEMO_TYPE:\n        var outerName = type.displayName || null;\n\n        if (outerName !== null) {\n          return outerName;\n        }\n\n        return getComponentNameFromType(type.type) || 'Memo';\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            return getComponentNameFromType(init(payload));\n          } catch (x) {\n            return null;\n          }\n        }\n\n      // eslint-disable-next-line no-fallthrough\n    }\n  }\n\n  return null;\n}\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar RESERVED_PROPS = {\n  key: true,\n  ref: true,\n  __self: true,\n  __source: true\n};\nvar specialPropKeyWarningShown, specialPropRefWarningShown, didWarnAboutStringRefs;\n\n{\n  didWarnAboutStringRefs = {};\n}\n\nfunction hasValidRef(config) {\n  {\n    if (hasOwnProperty.call(config, 'ref')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.ref !== undefined;\n}\n\nfunction hasValidKey(config) {\n  {\n    if (hasOwnProperty.call(config, 'key')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.key !== undefined;\n}\n\nfunction defineKeyPropWarningGetter(props, displayName) {\n  var warnAboutAccessingKey = function () {\n    {\n      if (!specialPropKeyWarningShown) {\n        specialPropKeyWarningShown = true;\n\n        error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n      }\n    }\n  };\n\n  warnAboutAccessingKey.isReactWarning = true;\n  Object.defineProperty(props, 'key', {\n    get: warnAboutAccessingKey,\n    configurable: true\n  });\n}\n\nfunction defineRefPropWarningGetter(props, displayName) {\n  var warnAboutAccessingRef = function () {\n    {\n      if (!specialPropRefWarningShown) {\n        specialPropRefWarningShown = true;\n\n        error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n      }\n    }\n  };\n\n  warnAboutAccessingRef.isReactWarning = true;\n  Object.defineProperty(props, 'ref', {\n    get: warnAboutAccessingRef,\n    configurable: true\n  });\n}\n\nfunction warnIfStringRefCannotBeAutoConverted(config) {\n  {\n    if (typeof config.ref === 'string' && ReactCurrentOwner.current && config.__self && ReactCurrentOwner.current.stateNode !== config.__self) {\n      var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);\n\n      if (!didWarnAboutStringRefs[componentName]) {\n        error('Component \"%s\" contains the string ref \"%s\". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', componentName, config.ref);\n\n        didWarnAboutStringRefs[componentName] = true;\n      }\n    }\n  }\n}\n/**\n * Factory method to create a new React element. This no longer adheres to\n * the class pattern, so do not use new to call it. Also, instanceof check\n * will not work. Instead test $$typeof field against Symbol.for('react.element') to check\n * if something is a React Element.\n *\n * @param {*} type\n * @param {*} props\n * @param {*} key\n * @param {string|object} ref\n * @param {*} owner\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @internal\n */\n\n\nvar ReactElement = function (type, key, ref, self, source, owner, props) {\n  var element = {\n    // This tag allows us to uniquely identify this as a React Element\n    $$typeof: REACT_ELEMENT_TYPE,\n    // Built-in properties that belong on the element\n    type: type,\n    key: key,\n    ref: ref,\n    props: props,\n    // Record the component responsible for creating this element.\n    _owner: owner\n  };\n\n  {\n    // The validation flag is currently mutative. We put it on\n    // an external backing store so that we can freeze the whole object.\n    // This can be replaced with a WeakMap once they are implemented in\n    // commonly used development environments.\n    element._store = {}; // To make comparing ReactElements easier for testing purposes, we make\n    // the validation flag non-enumerable (where possible, which should\n    // include every environment we run tests in), so the test framework\n    // ignores it.\n\n    Object.defineProperty(element._store, 'validated', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: false\n    }); // self and source are DEV only properties.\n\n    Object.defineProperty(element, '_self', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: self\n    }); // Two elements created in two different places should be considered\n    // equal for testing purposes and therefore we hide it from enumeration.\n\n    Object.defineProperty(element, '_source', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: source\n    });\n\n    if (Object.freeze) {\n      Object.freeze(element.props);\n      Object.freeze(element);\n    }\n  }\n\n  return element;\n};\n/**\n * Create and return a new ReactElement of the given type.\n * See https://reactjs.org/docs/react-api.html#createelement\n */\n\nfunction createElement(type, config, children) {\n  var propName; // Reserved names are extracted\n\n  var props = {};\n  var key = null;\n  var ref = null;\n  var self = null;\n  var source = null;\n\n  if (config != null) {\n    if (hasValidRef(config)) {\n      ref = config.ref;\n\n      {\n        warnIfStringRefCannotBeAutoConverted(config);\n      }\n    }\n\n    if (hasValidKey(config)) {\n      {\n        checkKeyStringCoercion(config.key);\n      }\n\n      key = '' + config.key;\n    }\n\n    self = config.__self === undefined ? null : config.__self;\n    source = config.__source === undefined ? null : config.__source; // Remaining properties are added to a new props object\n\n    for (propName in config) {\n      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n        props[propName] = config[propName];\n      }\n    }\n  } // Children can be more than one argument, and those are transferred onto\n  // the newly allocated props object.\n\n\n  var childrenLength = arguments.length - 2;\n\n  if (childrenLength === 1) {\n    props.children = children;\n  } else if (childrenLength > 1) {\n    var childArray = Array(childrenLength);\n\n    for (var i = 0; i < childrenLength; i++) {\n      childArray[i] = arguments[i + 2];\n    }\n\n    {\n      if (Object.freeze) {\n        Object.freeze(childArray);\n      }\n    }\n\n    props.children = childArray;\n  } // Resolve default props\n\n\n  if (type && type.defaultProps) {\n    var defaultProps = type.defaultProps;\n\n    for (propName in defaultProps) {\n      if (props[propName] === undefined) {\n        props[propName] = defaultProps[propName];\n      }\n    }\n  }\n\n  {\n    if (key || ref) {\n      var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;\n\n      if (key) {\n        defineKeyPropWarningGetter(props, displayName);\n      }\n\n      if (ref) {\n        defineRefPropWarningGetter(props, displayName);\n      }\n    }\n  }\n\n  return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);\n}\nfunction cloneAndReplaceKey(oldElement, newKey) {\n  var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);\n  return newElement;\n}\n/**\n * Clone and return a new ReactElement using element as the starting point.\n * See https://reactjs.org/docs/react-api.html#cloneelement\n */\n\nfunction cloneElement(element, config, children) {\n  if (element === null || element === undefined) {\n    throw new Error(\"React.cloneElement(...): The argument must be a React element, but you passed \" + element + \".\");\n  }\n\n  var propName; // Original props are copied\n\n  var props = assign({}, element.props); // Reserved names are extracted\n\n  var key = element.key;\n  var ref = element.ref; // Self is preserved since the owner is preserved.\n\n  var self = element._self; // Source is preserved since cloneElement is unlikely to be targeted by a\n  // transpiler, and the original source is probably a better indicator of the\n  // true owner.\n\n  var source = element._source; // Owner will be preserved, unless ref is overridden\n\n  var owner = element._owner;\n\n  if (config != null) {\n    if (hasValidRef(config)) {\n      // Silently steal the ref from the parent.\n      ref = config.ref;\n      owner = ReactCurrentOwner.current;\n    }\n\n    if (hasValidKey(config)) {\n      {\n        checkKeyStringCoercion(config.key);\n      }\n\n      key = '' + config.key;\n    } // Remaining properties override existing props\n\n\n    var defaultProps;\n\n    if (element.type && element.type.defaultProps) {\n      defaultProps = element.type.defaultProps;\n    }\n\n    for (propName in config) {\n      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n        if (config[propName] === undefined && defaultProps !== undefined) {\n          // Resolve default props\n          props[propName] = defaultProps[propName];\n        } else {\n          props[propName] = config[propName];\n        }\n      }\n    }\n  } // Children can be more than one argument, and those are transferred onto\n  // the newly allocated props object.\n\n\n  var childrenLength = arguments.length - 2;\n\n  if (childrenLength === 1) {\n    props.children = children;\n  } else if (childrenLength > 1) {\n    var childArray = Array(childrenLength);\n\n    for (var i = 0; i < childrenLength; i++) {\n      childArray[i] = arguments[i + 2];\n    }\n\n    props.children = childArray;\n  }\n\n  return ReactElement(element.type, key, ref, self, source, owner, props);\n}\n/**\n * Verifies the object is a ReactElement.\n * See https://reactjs.org/docs/react-api.html#isvalidelement\n * @param {?object} object\n * @return {boolean} True if `object` is a ReactElement.\n * @final\n */\n\nfunction isValidElement(object) {\n  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n}\n\nvar SEPARATOR = '.';\nvar SUBSEPARATOR = ':';\n/**\n * Escape and wrap key so it is safe to use as a reactid\n *\n * @param {string} key to be escaped.\n * @return {string} the escaped key.\n */\n\nfunction escape(key) {\n  var escapeRegex = /[=:]/g;\n  var escaperLookup = {\n    '=': '=0',\n    ':': '=2'\n  };\n  var escapedString = key.replace(escapeRegex, function (match) {\n    return escaperLookup[match];\n  });\n  return '$' + escapedString;\n}\n/**\n * TODO: Test that a single child and an array with one item have the same key\n * pattern.\n */\n\n\nvar didWarnAboutMaps = false;\nvar userProvidedKeyEscapeRegex = /\\/+/g;\n\nfunction escapeUserProvidedKey(text) {\n  return text.replace(userProvidedKeyEscapeRegex, '$&/');\n}\n/**\n * Generate a key string that identifies a element within a set.\n *\n * @param {*} element A element that could contain a manual key.\n * @param {number} index Index that is used if a manual key is not provided.\n * @return {string}\n */\n\n\nfunction getElementKey(element, index) {\n  // Do some typechecking here since we call this blindly. We want to ensure\n  // that we don't block potential future ES APIs.\n  if (typeof element === 'object' && element !== null && element.key != null) {\n    // Explicit key\n    {\n      checkKeyStringCoercion(element.key);\n    }\n\n    return escape('' + element.key);\n  } // Implicit key determined by the index in the set\n\n\n  return index.toString(36);\n}\n\nfunction mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {\n  var type = typeof children;\n\n  if (type === 'undefined' || type === 'boolean') {\n    // All of the above are perceived as null.\n    children = null;\n  }\n\n  var invokeCallback = false;\n\n  if (children === null) {\n    invokeCallback = true;\n  } else {\n    switch (type) {\n      case 'string':\n      case 'number':\n        invokeCallback = true;\n        break;\n\n      case 'object':\n        switch (children.$$typeof) {\n          case REACT_ELEMENT_TYPE:\n          case REACT_PORTAL_TYPE:\n            invokeCallback = true;\n        }\n\n    }\n  }\n\n  if (invokeCallback) {\n    var _child = children;\n    var mappedChild = callback(_child); // If it's the only child, treat the name as if it was wrapped in an array\n    // so that it's consistent if the number of children grows:\n\n    var childKey = nameSoFar === '' ? SEPARATOR + getElementKey(_child, 0) : nameSoFar;\n\n    if (isArray(mappedChild)) {\n      var escapedChildKey = '';\n\n      if (childKey != null) {\n        escapedChildKey = escapeUserProvidedKey(childKey) + '/';\n      }\n\n      mapIntoArray(mappedChild, array, escapedChildKey, '', function (c) {\n        return c;\n      });\n    } else if (mappedChild != null) {\n      if (isValidElement(mappedChild)) {\n        {\n          // The `if` statement here prevents auto-disabling of the safe\n          // coercion ESLint rule, so we must manually disable it below.\n          // $FlowFixMe Flow incorrectly thinks React.Portal doesn't have a key\n          if (mappedChild.key && (!_child || _child.key !== mappedChild.key)) {\n            checkKeyStringCoercion(mappedChild.key);\n          }\n        }\n\n        mappedChild = cloneAndReplaceKey(mappedChild, // Keep both the (mapped) and old keys if they differ, just as\n        // traverseAllChildren used to do for objects as children\n        escapedPrefix + ( // $FlowFixMe Flow incorrectly thinks React.Portal doesn't have a key\n        mappedChild.key && (!_child || _child.key !== mappedChild.key) ? // $FlowFixMe Flow incorrectly thinks existing element's key can be a number\n        // eslint-disable-next-line react-internal/safe-string-coercion\n        escapeUserProvidedKey('' + mappedChild.key) + '/' : '') + childKey);\n      }\n\n      array.push(mappedChild);\n    }\n\n    return 1;\n  }\n\n  var child;\n  var nextName;\n  var subtreeCount = 0; // Count of children found in the current subtree.\n\n  var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;\n\n  if (isArray(children)) {\n    for (var i = 0; i < children.length; i++) {\n      child = children[i];\n      nextName = nextNamePrefix + getElementKey(child, i);\n      subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);\n    }\n  } else {\n    var iteratorFn = getIteratorFn(children);\n\n    if (typeof iteratorFn === 'function') {\n      var iterableChildren = children;\n\n      {\n        // Warn about using Maps as children\n        if (iteratorFn === iterableChildren.entries) {\n          if (!didWarnAboutMaps) {\n            warn('Using Maps as children is not supported. ' + 'Use an array of keyed ReactElements instead.');\n          }\n\n          didWarnAboutMaps = true;\n        }\n      }\n\n      var iterator = iteratorFn.call(iterableChildren);\n      var step;\n      var ii = 0;\n\n      while (!(step = iterator.next()).done) {\n        child = step.value;\n        nextName = nextNamePrefix + getElementKey(child, ii++);\n        subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);\n      }\n    } else if (type === 'object') {\n      // eslint-disable-next-line react-internal/safe-string-coercion\n      var childrenString = String(children);\n      throw new Error(\"Objects are not valid as a React child (found: \" + (childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString) + \"). \" + 'If you meant to render a collection of children, use an array ' + 'instead.');\n    }\n  }\n\n  return subtreeCount;\n}\n\n/**\n * Maps children that are typically specified as `props.children`.\n *\n * See https://reactjs.org/docs/react-api.html#reactchildrenmap\n *\n * The provided mapFunction(child, index) will be called for each\n * leaf child.\n *\n * @param {?*} children Children tree container.\n * @param {function(*, int)} func The map function.\n * @param {*} context Context for mapFunction.\n * @return {object} Object containing the ordered map of results.\n */\nfunction mapChildren(children, func, context) {\n  if (children == null) {\n    return children;\n  }\n\n  var result = [];\n  var count = 0;\n  mapIntoArray(children, result, '', '', function (child) {\n    return func.call(context, child, count++);\n  });\n  return result;\n}\n/**\n * Count the number of children that are typically specified as\n * `props.children`.\n *\n * See https://reactjs.org/docs/react-api.html#reactchildrencount\n *\n * @param {?*} children Children tree container.\n * @return {number} The number of children.\n */\n\n\nfunction countChildren(children) {\n  var n = 0;\n  mapChildren(children, function () {\n    n++; // Don't return anything\n  });\n  return n;\n}\n\n/**\n * Iterates through children that are typically specified as `props.children`.\n *\n * See https://reactjs.org/docs/react-api.html#reactchildrenforeach\n *\n * The provided forEachFunc(child, index) will be called for each\n * leaf child.\n *\n * @param {?*} children Children tree container.\n * @param {function(*, int)} forEachFunc\n * @param {*} forEachContext Context for forEachContext.\n */\nfunction forEachChildren(children, forEachFunc, forEachContext) {\n  mapChildren(children, function () {\n    forEachFunc.apply(this, arguments); // Don't return anything.\n  }, forEachContext);\n}\n/**\n * Flatten a children object (typically specified as `props.children`) and\n * return an array with appropriately re-keyed children.\n *\n * See https://reactjs.org/docs/react-api.html#reactchildrentoarray\n */\n\n\nfunction toArray(children) {\n  return mapChildren(children, function (child) {\n    return child;\n  }) || [];\n}\n/**\n * Returns the first child in a collection of children and verifies that there\n * is only one child in the collection.\n *\n * See https://reactjs.org/docs/react-api.html#reactchildrenonly\n *\n * The current implementation of this function assumes that a single child gets\n * passed without a wrapper, but the purpose of this helper function is to\n * abstract away the particular structure of children.\n *\n * @param {?object} children Child collection structure.\n * @return {ReactElement} The first and only `ReactElement` contained in the\n * structure.\n */\n\n\nfunction onlyChild(children) {\n  if (!isValidElement(children)) {\n    throw new Error('React.Children.only expected to receive a single React element child.');\n  }\n\n  return children;\n}\n\nfunction createContext(defaultValue) {\n  // TODO: Second argument used to be an optional `calculateChangedBits`\n  // function. Warn to reserve for future use?\n  var context = {\n    $$typeof: REACT_CONTEXT_TYPE,\n    // As a workaround to support multiple concurrent renderers, we categorize\n    // some renderers as primary and others as secondary. We only expect\n    // there to be two concurrent renderers at most: React Native (primary) and\n    // Fabric (secondary); React DOM (primary) and React ART (secondary).\n    // Secondary renderers store their context values on separate fields.\n    _currentValue: defaultValue,\n    _currentValue2: defaultValue,\n    // Used to track how many concurrent renderers this context currently\n    // supports within in a single renderer. Such as parallel server rendering.\n    _threadCount: 0,\n    // These are circular\n    Provider: null,\n    Consumer: null,\n    // Add these to use same hidden class in VM as ServerContext\n    _defaultValue: null,\n    _globalName: null\n  };\n  context.Provider = {\n    $$typeof: REACT_PROVIDER_TYPE,\n    _context: context\n  };\n  var hasWarnedAboutUsingNestedContextConsumers = false;\n  var hasWarnedAboutUsingConsumerProvider = false;\n  var hasWarnedAboutDisplayNameOnConsumer = false;\n\n  {\n    // A separate object, but proxies back to the original context object for\n    // backwards compatibility. It has a different $$typeof, so we can properly\n    // warn for the incorrect usage of Context as a Consumer.\n    var Consumer = {\n      $$typeof: REACT_CONTEXT_TYPE,\n      _context: context\n    }; // $FlowFixMe: Flow complains about not setting a value, which is intentional here\n\n    Object.defineProperties(Consumer, {\n      Provider: {\n        get: function () {\n          if (!hasWarnedAboutUsingConsumerProvider) {\n            hasWarnedAboutUsingConsumerProvider = true;\n\n            error('Rendering <Context.Consumer.Provider> is not supported and will be removed in ' + 'a future major release. Did you mean to render <Context.Provider> instead?');\n          }\n\n          return context.Provider;\n        },\n        set: function (_Provider) {\n          context.Provider = _Provider;\n        }\n      },\n      _currentValue: {\n        get: function () {\n          return context._currentValue;\n        },\n        set: function (_currentValue) {\n          context._currentValue = _currentValue;\n        }\n      },\n      _currentValue2: {\n        get: function () {\n          return context._currentValue2;\n        },\n        set: function (_currentValue2) {\n          context._currentValue2 = _currentValue2;\n        }\n      },\n      _threadCount: {\n        get: function () {\n          return context._threadCount;\n        },\n        set: function (_threadCount) {\n          context._threadCount = _threadCount;\n        }\n      },\n      Consumer: {\n        get: function () {\n          if (!hasWarnedAboutUsingNestedContextConsumers) {\n            hasWarnedAboutUsingNestedContextConsumers = true;\n\n            error('Rendering <Context.Consumer.Consumer> is not supported and will be removed in ' + 'a future major release. Did you mean to render <Context.Consumer> instead?');\n          }\n\n          return context.Consumer;\n        }\n      },\n      displayName: {\n        get: function () {\n          return context.displayName;\n        },\n        set: function (displayName) {\n          if (!hasWarnedAboutDisplayNameOnConsumer) {\n            warn('Setting `displayName` on Context.Consumer has no effect. ' + \"You should set it directly on the context with Context.displayName = '%s'.\", displayName);\n\n            hasWarnedAboutDisplayNameOnConsumer = true;\n          }\n        }\n      }\n    }); // $FlowFixMe: Flow complains about missing properties because it doesn't understand defineProperty\n\n    context.Consumer = Consumer;\n  }\n\n  {\n    context._currentRenderer = null;\n    context._currentRenderer2 = null;\n  }\n\n  return context;\n}\n\nvar Uninitialized = -1;\nvar Pending = 0;\nvar Resolved = 1;\nvar Rejected = 2;\n\nfunction lazyInitializer(payload) {\n  if (payload._status === Uninitialized) {\n    var ctor = payload._result;\n    var thenable = ctor(); // Transition to the next state.\n    // This might throw either because it's missing or throws. If so, we treat it\n    // as still uninitialized and try again next time. Which is the same as what\n    // happens if the ctor or any wrappers processing the ctor throws. This might\n    // end up fixing it if the resolution was a concurrency bug.\n\n    thenable.then(function (moduleObject) {\n      if (payload._status === Pending || payload._status === Uninitialized) {\n        // Transition to the next state.\n        var resolved = payload;\n        resolved._status = Resolved;\n        resolved._result = moduleObject;\n      }\n    }, function (error) {\n      if (payload._status === Pending || payload._status === Uninitialized) {\n        // Transition to the next state.\n        var rejected = payload;\n        rejected._status = Rejected;\n        rejected._result = error;\n      }\n    });\n\n    if (payload._status === Uninitialized) {\n      // In case, we're still uninitialized, then we're waiting for the thenable\n      // to resolve. Set it as pending in the meantime.\n      var pending = payload;\n      pending._status = Pending;\n      pending._result = thenable;\n    }\n  }\n\n  if (payload._status === Resolved) {\n    var moduleObject = payload._result;\n\n    {\n      if (moduleObject === undefined) {\n        error('lazy: Expected the result of a dynamic imp' + 'ort() call. ' + 'Instead received: %s\\n\\nYour code should look like: \\n  ' + // Break up imports to avoid accidentally parsing them as dependencies.\n        'const MyComponent = lazy(() => imp' + \"ort('./MyComponent'))\\n\\n\" + 'Did you accidentally put curly braces around the import?', moduleObject);\n      }\n    }\n\n    {\n      if (!('default' in moduleObject)) {\n        error('lazy: Expected the result of a dynamic imp' + 'ort() call. ' + 'Instead received: %s\\n\\nYour code should look like: \\n  ' + // Break up imports to avoid accidentally parsing them as dependencies.\n        'const MyComponent = lazy(() => imp' + \"ort('./MyComponent'))\", moduleObject);\n      }\n    }\n\n    return moduleObject.default;\n  } else {\n    throw payload._result;\n  }\n}\n\nfunction lazy(ctor) {\n  var payload = {\n    // We use these fields to store the result.\n    _status: Uninitialized,\n    _result: ctor\n  };\n  var lazyType = {\n    $$typeof: REACT_LAZY_TYPE,\n    _payload: payload,\n    _init: lazyInitializer\n  };\n\n  {\n    // In production, this would just set it on the object.\n    var defaultProps;\n    var propTypes; // $FlowFixMe\n\n    Object.defineProperties(lazyType, {\n      defaultProps: {\n        configurable: true,\n        get: function () {\n          return defaultProps;\n        },\n        set: function (newDefaultProps) {\n          error('React.lazy(...): It is not supported to assign `defaultProps` to ' + 'a lazy component import. Either specify them where the component ' + 'is defined, or create a wrapping component around it.');\n\n          defaultProps = newDefaultProps; // Match production behavior more closely:\n          // $FlowFixMe\n\n          Object.defineProperty(lazyType, 'defaultProps', {\n            enumerable: true\n          });\n        }\n      },\n      propTypes: {\n        configurable: true,\n        get: function () {\n          return propTypes;\n        },\n        set: function (newPropTypes) {\n          error('React.lazy(...): It is not supported to assign `propTypes` to ' + 'a lazy component import. Either specify them where the component ' + 'is defined, or create a wrapping component around it.');\n\n          propTypes = newPropTypes; // Match production behavior more closely:\n          // $FlowFixMe\n\n          Object.defineProperty(lazyType, 'propTypes', {\n            enumerable: true\n          });\n        }\n      }\n    });\n  }\n\n  return lazyType;\n}\n\nfunction forwardRef(render) {\n  {\n    if (render != null && render.$$typeof === REACT_MEMO_TYPE) {\n      error('forwardRef requires a render function but received a `memo` ' + 'component. Instead of forwardRef(memo(...)), use ' + 'memo(forwardRef(...)).');\n    } else if (typeof render !== 'function') {\n      error('forwardRef requires a render function but was given %s.', render === null ? 'null' : typeof render);\n    } else {\n      if (render.length !== 0 && render.length !== 2) {\n        error('forwardRef render functions accept exactly two parameters: props and ref. %s', render.length === 1 ? 'Did you forget to use the ref parameter?' : 'Any additional parameter will be undefined.');\n      }\n    }\n\n    if (render != null) {\n      if (render.defaultProps != null || render.propTypes != null) {\n        error('forwardRef render functions do not support propTypes or defaultProps. ' + 'Did you accidentally pass a React component?');\n      }\n    }\n  }\n\n  var elementType = {\n    $$typeof: REACT_FORWARD_REF_TYPE,\n    render: render\n  };\n\n  {\n    var ownName;\n    Object.defineProperty(elementType, 'displayName', {\n      enumerable: false,\n      configurable: true,\n      get: function () {\n        return ownName;\n      },\n      set: function (name) {\n        ownName = name; // The inner component shouldn't inherit this display name in most cases,\n        // because the component may be used elsewhere.\n        // But it's nice for anonymous functions to inherit the name,\n        // so that our component-stack generation logic will display their frames.\n        // An anonymous function generally suggests a pattern like:\n        //   React.forwardRef((props, ref) => {...});\n        // This kind of inner function is not used elsewhere so the side effect is okay.\n\n        if (!render.name && !render.displayName) {\n          render.displayName = name;\n        }\n      }\n    });\n  }\n\n  return elementType;\n}\n\nvar REACT_MODULE_REFERENCE;\n\n{\n  REACT_MODULE_REFERENCE = Symbol.for('react.module.reference');\n}\n\nfunction isValidElementType(type) {\n  if (typeof type === 'string' || typeof type === 'function') {\n    return true;\n  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\n\n\n  if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing  || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden  || type === REACT_OFFSCREEN_TYPE || enableScopeAPI  || enableCacheElement  || enableTransitionTracing ) {\n    return true;\n  }\n\n  if (typeof type === 'object' && type !== null) {\n    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object\n    // types supported by any Flight configuration anywhere since\n    // we don't know which Flight build this will end up being used\n    // with.\n    type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== undefined) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction memo(type, compare) {\n  {\n    if (!isValidElementType(type)) {\n      error('memo: The first argument must be a component. Instead ' + 'received: %s', type === null ? 'null' : typeof type);\n    }\n  }\n\n  var elementType = {\n    $$typeof: REACT_MEMO_TYPE,\n    type: type,\n    compare: compare === undefined ? null : compare\n  };\n\n  {\n    var ownName;\n    Object.defineProperty(elementType, 'displayName', {\n      enumerable: false,\n      configurable: true,\n      get: function () {\n        return ownName;\n      },\n      set: function (name) {\n        ownName = name; // The inner component shouldn't inherit this display name in most cases,\n        // because the component may be used elsewhere.\n        // But it's nice for anonymous functions to inherit the name,\n        // so that our component-stack generation logic will display their frames.\n        // An anonymous function generally suggests a pattern like:\n        //   React.memo((props) => {...});\n        // This kind of inner function is not used elsewhere so the side effect is okay.\n\n        if (!type.name && !type.displayName) {\n          type.displayName = name;\n        }\n      }\n    });\n  }\n\n  return elementType;\n}\n\nfunction resolveDispatcher() {\n  var dispatcher = ReactCurrentDispatcher.current;\n\n  {\n    if (dispatcher === null) {\n      error('Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for' + ' one of the following reasons:\\n' + '1. You might have mismatching versions of React and the renderer (such as React DOM)\\n' + '2. You might be breaking the Rules of Hooks\\n' + '3. You might have more than one copy of React in the same app\\n' + 'See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.');\n    }\n  } // Will result in a null access error if accessed outside render phase. We\n  // intentionally don't throw our own error because this is in a hot path.\n  // Also helps ensure this is inlined.\n\n\n  return dispatcher;\n}\nfunction useContext(Context) {\n  var dispatcher = resolveDispatcher();\n\n  {\n    // TODO: add a more generic warning for invalid values.\n    if (Context._context !== undefined) {\n      var realContext = Context._context; // Don't deduplicate because this legitimately causes bugs\n      // and nobody should be using this in existing code.\n\n      if (realContext.Consumer === Context) {\n        error('Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be ' + 'removed in a future major release. Did you mean to call useContext(Context) instead?');\n      } else if (realContext.Provider === Context) {\n        error('Calling useContext(Context.Provider) is not supported. ' + 'Did you mean to call useContext(Context) instead?');\n      }\n    }\n  }\n\n  return dispatcher.useContext(Context);\n}\nfunction useState(initialState) {\n  var dispatcher = resolveDispatcher();\n  return dispatcher.useState(initialState);\n}\nfunction useReducer(reducer, initialArg, init) {\n  var dispatcher = resolveDispatcher();\n  return dispatcher.useReducer(reducer, initialArg, init);\n}\nfunction useRef(initialValue) {\n  var dispatcher = resolveDispatcher();\n  return dispatcher.useRef(initialValue);\n}\nfunction useEffect(create, deps) {\n  var dispatcher = resolveDispatcher();\n  return dispatcher.useEffect(create, deps);\n}\nfunction useInsertionEffect(create, deps) {\n  var dispatcher = resolveDispatcher();\n  return dispatcher.useInsertionEffect(create, deps);\n}\nfunction useLayoutEffect(create, deps) {\n  var dispatcher = resolveDispatcher();\n  return dispatcher.useLayoutEffect(create, deps);\n}\nfunction useCallback(callback, deps) {\n  var dispatcher = resolveDispatcher();\n  return dispatcher.useCallback(callback, deps);\n}\nfunction useMemo(create, deps) {\n  var dispatcher = resolveDispatcher();\n  return dispatcher.useMemo(create, deps);\n}\nfunction useImperativeHandle(ref, create, deps) {\n  var dispatcher = resolveDispatcher();\n  return dispatcher.useImperativeHandle(ref, create, deps);\n}\nfunction useDebugValue(value, formatterFn) {\n  {\n    var dispatcher = resolveDispatcher();\n    return dispatcher.useDebugValue(value, formatterFn);\n  }\n}\nfunction useTransition() {\n  var dispatcher = resolveDispatcher();\n  return dispatcher.useTransition();\n}\nfunction useDeferredValue(value) {\n  var dispatcher = resolveDispatcher();\n  return dispatcher.useDeferredValue(value);\n}\nfunction useId() {\n  var dispatcher = resolveDispatcher();\n  return dispatcher.useId();\n}\nfunction useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {\n  var dispatcher = resolveDispatcher();\n  return dispatcher.useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n}\n\n// Helpers to patch console.logs to avoid logging during side-effect free\n// replaying on render function. This currently only patches the object\n// lazily which won't cover if the log function was extracted eagerly.\n// We could also eagerly patch the method.\nvar disabledDepth = 0;\nvar prevLog;\nvar prevInfo;\nvar prevWarn;\nvar prevError;\nvar prevGroup;\nvar prevGroupCollapsed;\nvar prevGroupEnd;\n\nfunction disabledLog() {}\n\ndisabledLog.__reactDisabledLog = true;\nfunction disableLogs() {\n  {\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      prevLog = console.log;\n      prevInfo = console.info;\n      prevWarn = console.warn;\n      prevError = console.error;\n      prevGroup = console.group;\n      prevGroupCollapsed = console.groupCollapsed;\n      prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n\n      var props = {\n        configurable: true,\n        enumerable: true,\n        value: disabledLog,\n        writable: true\n      }; // $FlowFixMe Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        info: props,\n        log: props,\n        warn: props,\n        error: props,\n        group: props,\n        groupCollapsed: props,\n        groupEnd: props\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    disabledDepth++;\n  }\n}\nfunction reenableLogs() {\n  {\n    disabledDepth--;\n\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      var props = {\n        configurable: true,\n        enumerable: true,\n        writable: true\n      }; // $FlowFixMe Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        log: assign({}, props, {\n          value: prevLog\n        }),\n        info: assign({}, props, {\n          value: prevInfo\n        }),\n        warn: assign({}, props, {\n          value: prevWarn\n        }),\n        error: assign({}, props, {\n          value: prevError\n        }),\n        group: assign({}, props, {\n          value: prevGroup\n        }),\n        groupCollapsed: assign({}, props, {\n          value: prevGroupCollapsed\n        }),\n        groupEnd: assign({}, props, {\n          value: prevGroupEnd\n        })\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    if (disabledDepth < 0) {\n      error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');\n    }\n  }\n}\n\nvar ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;\nvar prefix;\nfunction describeBuiltInComponentFrame(name, source, ownerFn) {\n  {\n    if (prefix === undefined) {\n      // Extract the VM specific prefix used by each line.\n      try {\n        throw Error();\n      } catch (x) {\n        var match = x.stack.trim().match(/\\n( *(at )?)/);\n        prefix = match && match[1] || '';\n      }\n    } // We use the prefix to ensure our stacks line up with native stack frames.\n\n\n    return '\\n' + prefix + name;\n  }\n}\nvar reentry = false;\nvar componentFrameCache;\n\n{\n  var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;\n  componentFrameCache = new PossiblyWeakMap();\n}\n\nfunction describeNativeComponentFrame(fn, construct) {\n  // If something asked for a stack inside a fake render, it should get ignored.\n  if ( !fn || reentry) {\n    return '';\n  }\n\n  {\n    var frame = componentFrameCache.get(fn);\n\n    if (frame !== undefined) {\n      return frame;\n    }\n  }\n\n  var control;\n  reentry = true;\n  var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe It does accept undefined.\n\n  Error.prepareStackTrace = undefined;\n  var previousDispatcher;\n\n  {\n    previousDispatcher = ReactCurrentDispatcher$1.current; // Set the dispatcher in DEV because this might be call in the render function\n    // for warnings.\n\n    ReactCurrentDispatcher$1.current = null;\n    disableLogs();\n  }\n\n  try {\n    // This should throw.\n    if (construct) {\n      // Something should be setting the props in the constructor.\n      var Fake = function () {\n        throw Error();\n      }; // $FlowFixMe\n\n\n      Object.defineProperty(Fake.prototype, 'props', {\n        set: function () {\n          // We use a throwing setter instead of frozen or non-writable props\n          // because that won't throw in a non-strict mode function.\n          throw Error();\n        }\n      });\n\n      if (typeof Reflect === 'object' && Reflect.construct) {\n        // We construct a different control for this case to include any extra\n        // frames added by the construct call.\n        try {\n          Reflect.construct(Fake, []);\n        } catch (x) {\n          control = x;\n        }\n\n        Reflect.construct(fn, [], Fake);\n      } else {\n        try {\n          Fake.call();\n        } catch (x) {\n          control = x;\n        }\n\n        fn.call(Fake.prototype);\n      }\n    } else {\n      try {\n        throw Error();\n      } catch (x) {\n        control = x;\n      }\n\n      fn();\n    }\n  } catch (sample) {\n    // This is inlined manually because closure doesn't do it for us.\n    if (sample && control && typeof sample.stack === 'string') {\n      // This extracts the first frame from the sample that isn't also in the control.\n      // Skipping one frame that we assume is the frame that calls the two.\n      var sampleLines = sample.stack.split('\\n');\n      var controlLines = control.stack.split('\\n');\n      var s = sampleLines.length - 1;\n      var c = controlLines.length - 1;\n\n      while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {\n        // We expect at least one stack frame to be shared.\n        // Typically this will be the root most one. However, stack frames may be\n        // cut off due to maximum stack limits. In this case, one maybe cut off\n        // earlier than the other. We assume that the sample is longer or the same\n        // and there for cut off earlier. So we should find the root most frame in\n        // the sample somewhere in the control.\n        c--;\n      }\n\n      for (; s >= 1 && c >= 0; s--, c--) {\n        // Next we find the first one that isn't the same which should be the\n        // frame that called our sample function and the control.\n        if (sampleLines[s] !== controlLines[c]) {\n          // In V8, the first line is describing the message but other VMs don't.\n          // If we're about to return the first line, and the control is also on the same\n          // line, that's a pretty good indicator that our sample threw at same line as\n          // the control. I.e. before we entered the sample frame. So we ignore this result.\n          // This can happen if you passed a class to function component, or non-function.\n          if (s !== 1 || c !== 1) {\n            do {\n              s--;\n              c--; // We may still have similar intermediate frames from the construct call.\n              // The next one that isn't the same should be our match though.\n\n              if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                var _frame = '\\n' + sampleLines[s].replace(' at new ', ' at '); // If our component frame is labeled \"<anonymous>\"\n                // but we have a user-provided \"displayName\"\n                // splice it in to make the stack more readable.\n\n\n                if (fn.displayName && _frame.includes('<anonymous>')) {\n                  _frame = _frame.replace('<anonymous>', fn.displayName);\n                }\n\n                {\n                  if (typeof fn === 'function') {\n                    componentFrameCache.set(fn, _frame);\n                  }\n                } // Return the line we found.\n\n\n                return _frame;\n              }\n            } while (s >= 1 && c >= 0);\n          }\n\n          break;\n        }\n      }\n    }\n  } finally {\n    reentry = false;\n\n    {\n      ReactCurrentDispatcher$1.current = previousDispatcher;\n      reenableLogs();\n    }\n\n    Error.prepareStackTrace = previousPrepareStackTrace;\n  } // Fallback to just using the name if we couldn't make it throw.\n\n\n  var name = fn ? fn.displayName || fn.name : '';\n  var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';\n\n  {\n    if (typeof fn === 'function') {\n      componentFrameCache.set(fn, syntheticFrame);\n    }\n  }\n\n  return syntheticFrame;\n}\nfunction describeFunctionComponentFrame(fn, source, ownerFn) {\n  {\n    return describeNativeComponentFrame(fn, false);\n  }\n}\n\nfunction shouldConstruct(Component) {\n  var prototype = Component.prototype;\n  return !!(prototype && prototype.isReactComponent);\n}\n\nfunction describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {\n\n  if (type == null) {\n    return '';\n  }\n\n  if (typeof type === 'function') {\n    {\n      return describeNativeComponentFrame(type, shouldConstruct(type));\n    }\n  }\n\n  if (typeof type === 'string') {\n    return describeBuiltInComponentFrame(type);\n  }\n\n  switch (type) {\n    case REACT_SUSPENSE_TYPE:\n      return describeBuiltInComponentFrame('Suspense');\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return describeBuiltInComponentFrame('SuspenseList');\n  }\n\n  if (typeof type === 'object') {\n    switch (type.$$typeof) {\n      case REACT_FORWARD_REF_TYPE:\n        return describeFunctionComponentFrame(type.render);\n\n      case REACT_MEMO_TYPE:\n        // Memo may contain any component type so we recursively resolve it.\n        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            // Lazy may contain any component type so we recursively resolve it.\n            return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);\n          } catch (x) {}\n        }\n    }\n  }\n\n  return '';\n}\n\nvar loggedTypeFailures = {};\nvar ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;\n\nfunction setCurrentlyValidatingElement(element) {\n  {\n    if (element) {\n      var owner = element._owner;\n      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n      ReactDebugCurrentFrame$1.setExtraStackFrame(stack);\n    } else {\n      ReactDebugCurrentFrame$1.setExtraStackFrame(null);\n    }\n  }\n}\n\nfunction checkPropTypes(typeSpecs, values, location, componentName, element) {\n  {\n    // $FlowFixMe This is okay but Flow doesn't know it.\n    var has = Function.call.bind(hasOwnProperty);\n\n    for (var typeSpecName in typeSpecs) {\n      if (has(typeSpecs, typeSpecName)) {\n        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to\n        // fail the render phase where it didn't fail before. So we log it.\n        // After these have been cleaned up, we'll let them throw.\n\n        try {\n          // This is intentionally an invariant that gets caught. It's the same\n          // behavior as without this statement except with a better message.\n          if (typeof typeSpecs[typeSpecName] !== 'function') {\n            // eslint-disable-next-line react-internal/prod-error-codes\n            var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');\n            err.name = 'Invariant Violation';\n            throw err;\n          }\n\n          error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');\n        } catch (ex) {\n          error$1 = ex;\n        }\n\n        if (error$1 && !(error$1 instanceof Error)) {\n          setCurrentlyValidatingElement(element);\n\n          error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error$1);\n\n          setCurrentlyValidatingElement(null);\n        }\n\n        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {\n          // Only monitor this failure once because there tends to be a lot of the\n          // same error.\n          loggedTypeFailures[error$1.message] = true;\n          setCurrentlyValidatingElement(element);\n\n          error('Failed %s type: %s', location, error$1.message);\n\n          setCurrentlyValidatingElement(null);\n        }\n      }\n    }\n  }\n}\n\nfunction setCurrentlyValidatingElement$1(element) {\n  {\n    if (element) {\n      var owner = element._owner;\n      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n      setExtraStackFrame(stack);\n    } else {\n      setExtraStackFrame(null);\n    }\n  }\n}\n\nvar propTypesMisspellWarningShown;\n\n{\n  propTypesMisspellWarningShown = false;\n}\n\nfunction getDeclarationErrorAddendum() {\n  if (ReactCurrentOwner.current) {\n    var name = getComponentNameFromType(ReactCurrentOwner.current.type);\n\n    if (name) {\n      return '\\n\\nCheck the render method of `' + name + '`.';\n    }\n  }\n\n  return '';\n}\n\nfunction getSourceInfoErrorAddendum(source) {\n  if (source !== undefined) {\n    var fileName = source.fileName.replace(/^.*[\\\\\\/]/, '');\n    var lineNumber = source.lineNumber;\n    return '\\n\\nCheck your code at ' + fileName + ':' + lineNumber + '.';\n  }\n\n  return '';\n}\n\nfunction getSourceInfoErrorAddendumForProps(elementProps) {\n  if (elementProps !== null && elementProps !== undefined) {\n    return getSourceInfoErrorAddendum(elementProps.__source);\n  }\n\n  return '';\n}\n/**\n * Warn if there's no key explicitly set on dynamic arrays of children or\n * object keys are not valid. This allows us to keep track of children between\n * updates.\n */\n\n\nvar ownerHasKeyUseWarning = {};\n\nfunction getCurrentComponentErrorInfo(parentType) {\n  var info = getDeclarationErrorAddendum();\n\n  if (!info) {\n    var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;\n\n    if (parentName) {\n      info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\n    }\n  }\n\n  return info;\n}\n/**\n * Warn if the element doesn't have an explicit key assigned to it.\n * This element is in an array. The array could grow and shrink or be\n * reordered. All children that haven't already been validated are required to\n * have a \"key\" property assigned to it. Error statuses are cached so a warning\n * will only be shown once.\n *\n * @internal\n * @param {ReactElement} element Element that requires a key.\n * @param {*} parentType element's parent's type.\n */\n\n\nfunction validateExplicitKey(element, parentType) {\n  if (!element._store || element._store.validated || element.key != null) {\n    return;\n  }\n\n  element._store.validated = true;\n  var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n\n  if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n    return;\n  }\n\n  ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a\n  // property, it may be the creator of the child that's responsible for\n  // assigning it a key.\n\n  var childOwner = '';\n\n  if (element && element._owner && element._owner !== ReactCurrentOwner.current) {\n    // Give the component that originally created this child.\n    childOwner = \" It was passed a child from \" + getComponentNameFromType(element._owner.type) + \".\";\n  }\n\n  {\n    setCurrentlyValidatingElement$1(element);\n\n    error('Each child in a list should have a unique \"key\" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);\n\n    setCurrentlyValidatingElement$1(null);\n  }\n}\n/**\n * Ensure that every element either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {ReactNode} node Statically passed child of any type.\n * @param {*} parentType node's parent's type.\n */\n\n\nfunction validateChildKeys(node, parentType) {\n  if (typeof node !== 'object') {\n    return;\n  }\n\n  if (isArray(node)) {\n    for (var i = 0; i < node.length; i++) {\n      var child = node[i];\n\n      if (isValidElement(child)) {\n        validateExplicitKey(child, parentType);\n      }\n    }\n  } else if (isValidElement(node)) {\n    // This element was passed in a valid location.\n    if (node._store) {\n      node._store.validated = true;\n    }\n  } else if (node) {\n    var iteratorFn = getIteratorFn(node);\n\n    if (typeof iteratorFn === 'function') {\n      // Entry iterators used to provide implicit keys,\n      // but now we print a separate warning for them later.\n      if (iteratorFn !== node.entries) {\n        var iterator = iteratorFn.call(node);\n        var step;\n\n        while (!(step = iterator.next()).done) {\n          if (isValidElement(step.value)) {\n            validateExplicitKey(step.value, parentType);\n          }\n        }\n      }\n    }\n  }\n}\n/**\n * Given an element, validate that its props follow the propTypes definition,\n * provided by the type.\n *\n * @param {ReactElement} element\n */\n\n\nfunction validatePropTypes(element) {\n  {\n    var type = element.type;\n\n    if (type === null || type === undefined || typeof type === 'string') {\n      return;\n    }\n\n    var propTypes;\n\n    if (typeof type === 'function') {\n      propTypes = type.propTypes;\n    } else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.\n    // Inner props are checked in the reconciler.\n    type.$$typeof === REACT_MEMO_TYPE)) {\n      propTypes = type.propTypes;\n    } else {\n      return;\n    }\n\n    if (propTypes) {\n      // Intentionally inside to avoid triggering lazy initializers:\n      var name = getComponentNameFromType(type);\n      checkPropTypes(propTypes, element.props, 'prop', name, element);\n    } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {\n      propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:\n\n      var _name = getComponentNameFromType(type);\n\n      error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', _name || 'Unknown');\n    }\n\n    if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) {\n      error('getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');\n    }\n  }\n}\n/**\n * Given a fragment, validate that it can only be provided with fragment props\n * @param {ReactElement} fragment\n */\n\n\nfunction validateFragmentProps(fragment) {\n  {\n    var keys = Object.keys(fragment.props);\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n\n      if (key !== 'children' && key !== 'key') {\n        setCurrentlyValidatingElement$1(fragment);\n\n        error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);\n\n        setCurrentlyValidatingElement$1(null);\n        break;\n      }\n    }\n\n    if (fragment.ref !== null) {\n      setCurrentlyValidatingElement$1(fragment);\n\n      error('Invalid attribute `ref` supplied to `React.Fragment`.');\n\n      setCurrentlyValidatingElement$1(null);\n    }\n  }\n}\nfunction createElementWithValidation(type, props, children) {\n  var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to\n  // succeed and there will likely be errors in render.\n\n  if (!validType) {\n    var info = '';\n\n    if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {\n      info += ' You likely forgot to export your component from the file ' + \"it's defined in, or you might have mixed up default and named imports.\";\n    }\n\n    var sourceInfo = getSourceInfoErrorAddendumForProps(props);\n\n    if (sourceInfo) {\n      info += sourceInfo;\n    } else {\n      info += getDeclarationErrorAddendum();\n    }\n\n    var typeString;\n\n    if (type === null) {\n      typeString = 'null';\n    } else if (isArray(type)) {\n      typeString = 'array';\n    } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n      typeString = \"<\" + (getComponentNameFromType(type.type) || 'Unknown') + \" />\";\n      info = ' Did you accidentally export a JSX literal instead of a component?';\n    } else {\n      typeString = typeof type;\n    }\n\n    {\n      error('React.createElement: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);\n    }\n  }\n\n  var element = createElement.apply(this, arguments); // The result can be nullish if a mock or a custom function is used.\n  // TODO: Drop this when these are no longer allowed as the type argument.\n\n  if (element == null) {\n    return element;\n  } // Skip key warning if the type isn't valid since our key validation logic\n  // doesn't expect a non-string/function type and can throw confusing errors.\n  // We don't want exception behavior to differ between dev and prod.\n  // (Rendering will throw with a helpful message and as soon as the type is\n  // fixed, the key warnings will appear.)\n\n\n  if (validType) {\n    for (var i = 2; i < arguments.length; i++) {\n      validateChildKeys(arguments[i], type);\n    }\n  }\n\n  if (type === REACT_FRAGMENT_TYPE) {\n    validateFragmentProps(element);\n  } else {\n    validatePropTypes(element);\n  }\n\n  return element;\n}\nvar didWarnAboutDeprecatedCreateFactory = false;\nfunction createFactoryWithValidation(type) {\n  var validatedFactory = createElementWithValidation.bind(null, type);\n  validatedFactory.type = type;\n\n  {\n    if (!didWarnAboutDeprecatedCreateFactory) {\n      didWarnAboutDeprecatedCreateFactory = true;\n\n      warn('React.createFactory() is deprecated and will be removed in ' + 'a future major release. Consider using JSX ' + 'or use React.createElement() directly instead.');\n    } // Legacy hook: remove it\n\n\n    Object.defineProperty(validatedFactory, 'type', {\n      enumerable: false,\n      get: function () {\n        warn('Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.');\n\n        Object.defineProperty(this, 'type', {\n          value: type\n        });\n        return type;\n      }\n    });\n  }\n\n  return validatedFactory;\n}\nfunction cloneElementWithValidation(element, props, children) {\n  var newElement = cloneElement.apply(this, arguments);\n\n  for (var i = 2; i < arguments.length; i++) {\n    validateChildKeys(arguments[i], newElement.type);\n  }\n\n  validatePropTypes(newElement);\n  return newElement;\n}\n\nfunction startTransition(scope, options) {\n  var prevTransition = ReactCurrentBatchConfig.transition;\n  ReactCurrentBatchConfig.transition = {};\n  var currentTransition = ReactCurrentBatchConfig.transition;\n\n  {\n    ReactCurrentBatchConfig.transition._updatedFibers = new Set();\n  }\n\n  try {\n    scope();\n  } finally {\n    ReactCurrentBatchConfig.transition = prevTransition;\n\n    {\n      if (prevTransition === null && currentTransition._updatedFibers) {\n        var updatedFibersCount = currentTransition._updatedFibers.size;\n\n        if (updatedFibersCount > 10) {\n          warn('Detected a large number of updates inside startTransition. ' + 'If this is due to a subscription please re-write it to use React provided hooks. ' + 'Otherwise concurrent mode guarantees are off the table.');\n        }\n\n        currentTransition._updatedFibers.clear();\n      }\n    }\n  }\n}\n\nvar didWarnAboutMessageChannel = false;\nvar enqueueTaskImpl = null;\nfunction enqueueTask(task) {\n  if (enqueueTaskImpl === null) {\n    try {\n      // read require off the module object to get around the bundlers.\n      // we don't want them to detect a require and bundle a Node polyfill.\n      var requireString = ('require' + Math.random()).slice(0, 7);\n      var nodeRequire = module && module[requireString]; // assuming we're in node, let's try to get node's\n      // version of setImmediate, bypassing fake timers if any.\n\n      enqueueTaskImpl = nodeRequire.call(module, 'timers').setImmediate;\n    } catch (_err) {\n      // we're in a browser\n      // we can't use regular timers because they may still be faked\n      // so we try MessageChannel+postMessage instead\n      enqueueTaskImpl = function (callback) {\n        {\n          if (didWarnAboutMessageChannel === false) {\n            didWarnAboutMessageChannel = true;\n\n            if (typeof MessageChannel === 'undefined') {\n              error('This browser does not have a MessageChannel implementation, ' + 'so enqueuing tasks via await act(async () => ...) will fail. ' + 'Please file an issue at https://github.com/facebook/react/issues ' + 'if you encounter this warning.');\n            }\n          }\n        }\n\n        var channel = new MessageChannel();\n        channel.port1.onmessage = callback;\n        channel.port2.postMessage(undefined);\n      };\n    }\n  }\n\n  return enqueueTaskImpl(task);\n}\n\nvar actScopeDepth = 0;\nvar didWarnNoAwaitAct = false;\nfunction act(callback) {\n  {\n    // `act` calls can be nested, so we track the depth. This represents the\n    // number of `act` scopes on the stack.\n    var prevActScopeDepth = actScopeDepth;\n    actScopeDepth++;\n\n    if (ReactCurrentActQueue.current === null) {\n      // This is the outermost `act` scope. Initialize the queue. The reconciler\n      // will detect the queue and use it instead of Scheduler.\n      ReactCurrentActQueue.current = [];\n    }\n\n    var prevIsBatchingLegacy = ReactCurrentActQueue.isBatchingLegacy;\n    var result;\n\n    try {\n      // Used to reproduce behavior of `batchedUpdates` in legacy mode. Only\n      // set to `true` while the given callback is executed, not for updates\n      // triggered during an async event, because this is how the legacy\n      // implementation of `act` behaved.\n      ReactCurrentActQueue.isBatchingLegacy = true;\n      result = callback(); // Replicate behavior of original `act` implementation in legacy mode,\n      // which flushed updates immediately after the scope function exits, even\n      // if it's an async function.\n\n      if (!prevIsBatchingLegacy && ReactCurrentActQueue.didScheduleLegacyUpdate) {\n        var queue = ReactCurrentActQueue.current;\n\n        if (queue !== null) {\n          ReactCurrentActQueue.didScheduleLegacyUpdate = false;\n          flushActQueue(queue);\n        }\n      }\n    } catch (error) {\n      popActScope(prevActScopeDepth);\n      throw error;\n    } finally {\n      ReactCurrentActQueue.isBatchingLegacy = prevIsBatchingLegacy;\n    }\n\n    if (result !== null && typeof result === 'object' && typeof result.then === 'function') {\n      var thenableResult = result; // The callback is an async function (i.e. returned a promise). Wait\n      // for it to resolve before exiting the current scope.\n\n      var wasAwaited = false;\n      var thenable = {\n        then: function (resolve, reject) {\n          wasAwaited = true;\n          thenableResult.then(function (returnValue) {\n            popActScope(prevActScopeDepth);\n\n            if (actScopeDepth === 0) {\n              // We've exited the outermost act scope. Recursively flush the\n              // queue until there's no remaining work.\n              recursivelyFlushAsyncActWork(returnValue, resolve, reject);\n            } else {\n              resolve(returnValue);\n            }\n          }, function (error) {\n            // The callback threw an error.\n            popActScope(prevActScopeDepth);\n            reject(error);\n          });\n        }\n      };\n\n      {\n        if (!didWarnNoAwaitAct && typeof Promise !== 'undefined') {\n          // eslint-disable-next-line no-undef\n          Promise.resolve().then(function () {}).then(function () {\n            if (!wasAwaited) {\n              didWarnNoAwaitAct = true;\n\n              error('You called act(async () => ...) without await. ' + 'This could lead to unexpected testing behaviour, ' + 'interleaving multiple act calls and mixing their ' + 'scopes. ' + 'You should - await act(async () => ...);');\n            }\n          });\n        }\n      }\n\n      return thenable;\n    } else {\n      var returnValue = result; // The callback is not an async function. Exit the current scope\n      // immediately, without awaiting.\n\n      popActScope(prevActScopeDepth);\n\n      if (actScopeDepth === 0) {\n        // Exiting the outermost act scope. Flush the queue.\n        var _queue = ReactCurrentActQueue.current;\n\n        if (_queue !== null) {\n          flushActQueue(_queue);\n          ReactCurrentActQueue.current = null;\n        } // Return a thenable. If the user awaits it, we'll flush again in\n        // case additional work was scheduled by a microtask.\n\n\n        var _thenable = {\n          then: function (resolve, reject) {\n            // Confirm we haven't re-entered another `act` scope, in case\n            // the user does something weird like await the thenable\n            // multiple times.\n            if (ReactCurrentActQueue.current === null) {\n              // Recursively flush the queue until there's no remaining work.\n              ReactCurrentActQueue.current = [];\n              recursivelyFlushAsyncActWork(returnValue, resolve, reject);\n            } else {\n              resolve(returnValue);\n            }\n          }\n        };\n        return _thenable;\n      } else {\n        // Since we're inside a nested `act` scope, the returned thenable\n        // immediately resolves. The outer scope will flush the queue.\n        var _thenable2 = {\n          then: function (resolve, reject) {\n            resolve(returnValue);\n          }\n        };\n        return _thenable2;\n      }\n    }\n  }\n}\n\nfunction popActScope(prevActScopeDepth) {\n  {\n    if (prevActScopeDepth !== actScopeDepth - 1) {\n      error('You seem to have overlapping act() calls, this is not supported. ' + 'Be sure to await previous act() calls before making a new one. ');\n    }\n\n    actScopeDepth = prevActScopeDepth;\n  }\n}\n\nfunction recursivelyFlushAsyncActWork(returnValue, resolve, reject) {\n  {\n    var queue = ReactCurrentActQueue.current;\n\n    if (queue !== null) {\n      try {\n        flushActQueue(queue);\n        enqueueTask(function () {\n          if (queue.length === 0) {\n            // No additional work was scheduled. Finish.\n            ReactCurrentActQueue.current = null;\n            resolve(returnValue);\n          } else {\n            // Keep flushing work until there's none left.\n            recursivelyFlushAsyncActWork(returnValue, resolve, reject);\n          }\n        });\n      } catch (error) {\n        reject(error);\n      }\n    } else {\n      resolve(returnValue);\n    }\n  }\n}\n\nvar isFlushing = false;\n\nfunction flushActQueue(queue) {\n  {\n    if (!isFlushing) {\n      // Prevent re-entrance.\n      isFlushing = true;\n      var i = 0;\n\n      try {\n        for (; i < queue.length; i++) {\n          var callback = queue[i];\n\n          do {\n            callback = callback(true);\n          } while (callback !== null);\n        }\n\n        queue.length = 0;\n      } catch (error) {\n        // If something throws, leave the remaining callbacks on the queue.\n        queue = queue.slice(i + 1);\n        throw error;\n      } finally {\n        isFlushing = false;\n      }\n    }\n  }\n}\n\nvar createElement$1 =  createElementWithValidation ;\nvar cloneElement$1 =  cloneElementWithValidation ;\nvar createFactory =  createFactoryWithValidation ;\nvar Children = {\n  map: mapChildren,\n  forEach: forEachChildren,\n  count: countChildren,\n  toArray: toArray,\n  only: onlyChild\n};\n\nexports.Children = Children;\nexports.Component = Component;\nexports.Fragment = REACT_FRAGMENT_TYPE;\nexports.Profiler = REACT_PROFILER_TYPE;\nexports.PureComponent = PureComponent;\nexports.StrictMode = REACT_STRICT_MODE_TYPE;\nexports.Suspense = REACT_SUSPENSE_TYPE;\nexports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactSharedInternals;\nexports.act = act;\nexports.cloneElement = cloneElement$1;\nexports.createContext = createContext;\nexports.createElement = createElement$1;\nexports.createFactory = createFactory;\nexports.createRef = createRef;\nexports.forwardRef = forwardRef;\nexports.isValidElement = isValidElement;\nexports.lazy = lazy;\nexports.memo = memo;\nexports.startTransition = startTransition;\nexports.unstable_act = act;\nexports.useCallback = useCallback;\nexports.useContext = useContext;\nexports.useDebugValue = useDebugValue;\nexports.useDeferredValue = useDeferredValue;\nexports.useEffect = useEffect;\nexports.useId = useId;\nexports.useImperativeHandle = useImperativeHandle;\nexports.useInsertionEffect = useInsertionEffect;\nexports.useLayoutEffect = useLayoutEffect;\nexports.useMemo = useMemo;\nexports.useReducer = useReducer;\nexports.useRef = useRef;\nexports.useState = useState;\nexports.useSyncExternalStore = useSyncExternalStore;\nexports.useTransition = useTransition;\nexports.version = ReactVersion;\n          /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\nif (\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' &&\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop ===\n    'function'\n) {\n  __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());\n}\n        \n  })();\n}\n\n\n//# sourceURL=webpack://q2/./node_modules/react/cjs/react.development.js?");

/***/ }),

/***/ "./node_modules/react/index.js":
/*!*************************************!*\
  !*** ./node_modules/react/index.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react.development.js */ \"./node_modules/react/cjs/react.development.js\");\n}\n\n\n//# sourceURL=webpack://q2/./node_modules/react/index.js?");

/***/ }),

/***/ "./node_modules/@permaweb/aoconnect/dist/browser.js":
/*!**********************************************************!*\
  !*** ./node_modules/@permaweb/aoconnect/dist/browser.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   assign: () => (/* binding */ assign),\n/* harmony export */   connect: () => (/* binding */ connect),\n/* harmony export */   createDataItemSigner: () => (/* binding */ createDataItemSigner2),\n/* harmony export */   dryrun: () => (/* binding */ dryrun),\n/* harmony export */   message: () => (/* binding */ message),\n/* harmony export */   monitor: () => (/* binding */ monitor),\n/* harmony export */   result: () => (/* binding */ result),\n/* harmony export */   results: () => (/* binding */ results),\n/* harmony export */   serializeCron: () => (/* binding */ serializeCron),\n/* harmony export */   spawn: () => (/* binding */ spawn),\n/* harmony export */   unmonitor: () => (/* binding */ unmonitor)\n/* harmony export */ });\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __commonJS = (cb, mod) => function __require() {\n  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n};\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  // If the importer is in node compatibility mode or this is not an ESM\n  // file that has been converted to a CommonJS file using a Babel-\n  // compatible transform (i.e. \"__esModule\" has not been set), then set\n  // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n  mod\n));\n\n// node_modules/obliterator/iterator.js\nvar require_iterator = __commonJS({\n  \"node_modules/obliterator/iterator.js\"(exports, module) {\n    function Iterator(next) {\n      if (typeof next !== \"function\")\n        throw new Error(\"obliterator/iterator: expecting a function!\");\n      this.next = next;\n    }\n    if (typeof Symbol !== \"undefined\")\n      Iterator.prototype[Symbol.iterator] = function() {\n        return this;\n      };\n    Iterator.of = function() {\n      var args = arguments, l = args.length, i = 0;\n      return new Iterator(function() {\n        if (i >= l)\n          return { done: true };\n        return { done: false, value: args[i++] };\n      });\n    };\n    Iterator.empty = function() {\n      var iterator = new Iterator(function() {\n        return { done: true };\n      });\n      return iterator;\n    };\n    Iterator.fromSequence = function(sequence) {\n      var i = 0, l = sequence.length;\n      return new Iterator(function() {\n        if (i >= l)\n          return { done: true };\n        return { done: false, value: sequence[i++] };\n      });\n    };\n    Iterator.is = function(value) {\n      if (value instanceof Iterator)\n        return true;\n      return typeof value === \"object\" && value !== null && typeof value.next === \"function\";\n    };\n    module.exports = Iterator;\n  }\n});\n\n// node_modules/obliterator/support.js\nvar require_support = __commonJS({\n  \"node_modules/obliterator/support.js\"(exports) {\n    exports.ARRAY_BUFFER_SUPPORT = typeof ArrayBuffer !== \"undefined\";\n    exports.SYMBOL_SUPPORT = typeof Symbol !== \"undefined\";\n  }\n});\n\n// node_modules/obliterator/foreach.js\nvar require_foreach = __commonJS({\n  \"node_modules/obliterator/foreach.js\"(exports, module) {\n    var support = require_support();\n    var ARRAY_BUFFER_SUPPORT = support.ARRAY_BUFFER_SUPPORT;\n    var SYMBOL_SUPPORT = support.SYMBOL_SUPPORT;\n    module.exports = function forEach(iterable, callback) {\n      var iterator, k2, i, l, s;\n      if (!iterable)\n        throw new Error(\"obliterator/forEach: invalid iterable.\");\n      if (typeof callback !== \"function\")\n        throw new Error(\"obliterator/forEach: expecting a callback.\");\n      if (Array.isArray(iterable) || ARRAY_BUFFER_SUPPORT && ArrayBuffer.isView(iterable) || typeof iterable === \"string\" || iterable.toString() === \"[object Arguments]\") {\n        for (i = 0, l = iterable.length; i < l; i++)\n          callback(iterable[i], i);\n        return;\n      }\n      if (typeof iterable.forEach === \"function\") {\n        iterable.forEach(callback);\n        return;\n      }\n      if (SYMBOL_SUPPORT && Symbol.iterator in iterable && typeof iterable.next !== \"function\") {\n        iterable = iterable[Symbol.iterator]();\n      }\n      if (typeof iterable.next === \"function\") {\n        iterator = iterable;\n        i = 0;\n        while (s = iterator.next(), s.done !== true) {\n          callback(s.value, i);\n          i++;\n        }\n        return;\n      }\n      for (k2 in iterable) {\n        if (iterable.hasOwnProperty(k2)) {\n          callback(iterable[k2], k2);\n        }\n      }\n      return;\n    };\n  }\n});\n\n// node_modules/mnemonist/utils/typed-arrays.js\nvar require_typed_arrays = __commonJS({\n  \"node_modules/mnemonist/utils/typed-arrays.js\"(exports) {\n    var MAX_8BIT_INTEGER = Math.pow(2, 8) - 1;\n    var MAX_16BIT_INTEGER = Math.pow(2, 16) - 1;\n    var MAX_32BIT_INTEGER = Math.pow(2, 32) - 1;\n    var MAX_SIGNED_8BIT_INTEGER = Math.pow(2, 7) - 1;\n    var MAX_SIGNED_16BIT_INTEGER = Math.pow(2, 15) - 1;\n    var MAX_SIGNED_32BIT_INTEGER = Math.pow(2, 31) - 1;\n    exports.getPointerArray = function(size) {\n      var maxIndex = size - 1;\n      if (maxIndex <= MAX_8BIT_INTEGER)\n        return Uint8Array;\n      if (maxIndex <= MAX_16BIT_INTEGER)\n        return Uint16Array;\n      if (maxIndex <= MAX_32BIT_INTEGER)\n        return Uint32Array;\n      throw new Error(\"mnemonist: Pointer Array of size > 4294967295 is not supported.\");\n    };\n    exports.getSignedPointerArray = function(size) {\n      var maxIndex = size - 1;\n      if (maxIndex <= MAX_SIGNED_8BIT_INTEGER)\n        return Int8Array;\n      if (maxIndex <= MAX_SIGNED_16BIT_INTEGER)\n        return Int16Array;\n      if (maxIndex <= MAX_SIGNED_32BIT_INTEGER)\n        return Int32Array;\n      return Float64Array;\n    };\n    exports.getNumberType = function(value) {\n      if (value === (value | 0)) {\n        if (Math.sign(value) === -1) {\n          if (value <= 127 && value >= -128)\n            return Int8Array;\n          if (value <= 32767 && value >= -32768)\n            return Int16Array;\n          return Int32Array;\n        } else {\n          if (value <= 255)\n            return Uint8Array;\n          if (value <= 65535)\n            return Uint16Array;\n          return Uint32Array;\n        }\n      }\n      return Float64Array;\n    };\n    var TYPE_PRIORITY = {\n      Uint8Array: 1,\n      Int8Array: 2,\n      Uint16Array: 3,\n      Int16Array: 4,\n      Uint32Array: 5,\n      Int32Array: 6,\n      Float32Array: 7,\n      Float64Array: 8\n    };\n    exports.getMinimalRepresentation = function(array, getter) {\n      var maxType = null, maxPriority = 0, p, t, v2, i, l;\n      for (i = 0, l = array.length; i < l; i++) {\n        v2 = getter ? getter(array[i]) : array[i];\n        t = exports.getNumberType(v2);\n        p = TYPE_PRIORITY[t.name];\n        if (p > maxPriority) {\n          maxPriority = p;\n          maxType = t;\n        }\n      }\n      return maxType;\n    };\n    exports.isTypedArray = function(value) {\n      return typeof ArrayBuffer !== \"undefined\" && ArrayBuffer.isView(value);\n    };\n    exports.concat = function() {\n      var length = 0, i, o, l;\n      for (i = 0, l = arguments.length; i < l; i++)\n        length += arguments[i].length;\n      var array = new arguments[0].constructor(length);\n      for (i = 0, o = 0; i < l; i++) {\n        array.set(arguments[i], o);\n        o += arguments[i].length;\n      }\n      return array;\n    };\n    exports.indices = function(length) {\n      var PointerArray = exports.getPointerArray(length);\n      var array = new PointerArray(length);\n      for (var i = 0; i < length; i++)\n        array[i] = i;\n      return array;\n    };\n  }\n});\n\n// node_modules/mnemonist/utils/iterables.js\nvar require_iterables = __commonJS({\n  \"node_modules/mnemonist/utils/iterables.js\"(exports) {\n    var forEach = require_foreach();\n    var typed = require_typed_arrays();\n    function isArrayLike2(target) {\n      return Array.isArray(target) || typed.isTypedArray(target);\n    }\n    function guessLength(target) {\n      if (typeof target.length === \"number\")\n        return target.length;\n      if (typeof target.size === \"number\")\n        return target.size;\n      return;\n    }\n    function toArray(target) {\n      var l = guessLength(target);\n      var array = typeof l === \"number\" ? new Array(l) : [];\n      var i = 0;\n      forEach(target, function(value) {\n        array[i++] = value;\n      });\n      return array;\n    }\n    function toArrayWithIndices(target) {\n      var l = guessLength(target);\n      var IndexArray = typeof l === \"number\" ? typed.getPointerArray(l) : Array;\n      var array = typeof l === \"number\" ? new Array(l) : [];\n      var indices = typeof l === \"number\" ? new IndexArray(l) : [];\n      var i = 0;\n      forEach(target, function(value) {\n        array[i] = value;\n        indices[i] = i++;\n      });\n      return [array, indices];\n    }\n    exports.isArrayLike = isArrayLike2;\n    exports.guessLength = guessLength;\n    exports.toArray = toArray;\n    exports.toArrayWithIndices = toArrayWithIndices;\n  }\n});\n\n// node_modules/mnemonist/lru-cache.js\nvar require_lru_cache = __commonJS({\n  \"node_modules/mnemonist/lru-cache.js\"(exports, module) {\n    var Iterator = require_iterator();\n    var forEach = require_foreach();\n    var typed = require_typed_arrays();\n    var iterables = require_iterables();\n    function LRUCache(Keys, Values, capacity) {\n      if (arguments.length < 2) {\n        capacity = Keys;\n        Keys = null;\n        Values = null;\n      }\n      this.capacity = capacity;\n      if (typeof this.capacity !== \"number\" || this.capacity <= 0)\n        throw new Error(\"mnemonist/lru-cache: capacity should be positive number.\");\n      else if (!isFinite(this.capacity) || Math.floor(this.capacity) !== this.capacity)\n        throw new Error(\"mnemonist/lru-cache: capacity should be a finite positive integer.\");\n      var PointerArray = typed.getPointerArray(capacity);\n      this.forward = new PointerArray(capacity);\n      this.backward = new PointerArray(capacity);\n      this.K = typeof Keys === \"function\" ? new Keys(capacity) : new Array(capacity);\n      this.V = typeof Values === \"function\" ? new Values(capacity) : new Array(capacity);\n      this.size = 0;\n      this.head = 0;\n      this.tail = 0;\n      this.items = {};\n    }\n    LRUCache.prototype.clear = function() {\n      this.size = 0;\n      this.head = 0;\n      this.tail = 0;\n      this.items = {};\n    };\n    LRUCache.prototype.splayOnTop = function(pointer) {\n      var oldHead = this.head;\n      if (this.head === pointer)\n        return this;\n      var previous = this.backward[pointer], next = this.forward[pointer];\n      if (this.tail === pointer) {\n        this.tail = previous;\n      } else {\n        this.backward[next] = previous;\n      }\n      this.forward[previous] = next;\n      this.backward[oldHead] = pointer;\n      this.head = pointer;\n      this.forward[pointer] = oldHead;\n      return this;\n    };\n    LRUCache.prototype.set = function(key, value) {\n      var pointer = this.items[key];\n      if (typeof pointer !== \"undefined\") {\n        this.splayOnTop(pointer);\n        this.V[pointer] = value;\n        return;\n      }\n      if (this.size < this.capacity) {\n        pointer = this.size++;\n      } else {\n        pointer = this.tail;\n        this.tail = this.backward[pointer];\n        delete this.items[this.K[pointer]];\n      }\n      this.items[key] = pointer;\n      this.K[pointer] = key;\n      this.V[pointer] = value;\n      this.forward[pointer] = this.head;\n      this.backward[this.head] = pointer;\n      this.head = pointer;\n    };\n    LRUCache.prototype.setpop = function(key, value) {\n      var oldValue = null;\n      var oldKey = null;\n      var pointer = this.items[key];\n      if (typeof pointer !== \"undefined\") {\n        this.splayOnTop(pointer);\n        oldValue = this.V[pointer];\n        this.V[pointer] = value;\n        return { evicted: false, key, value: oldValue };\n      }\n      if (this.size < this.capacity) {\n        pointer = this.size++;\n      } else {\n        pointer = this.tail;\n        this.tail = this.backward[pointer];\n        oldValue = this.V[pointer];\n        oldKey = this.K[pointer];\n        delete this.items[oldKey];\n      }\n      this.items[key] = pointer;\n      this.K[pointer] = key;\n      this.V[pointer] = value;\n      this.forward[pointer] = this.head;\n      this.backward[this.head] = pointer;\n      this.head = pointer;\n      if (oldKey) {\n        return { evicted: true, key: oldKey, value: oldValue };\n      } else {\n        return null;\n      }\n    };\n    LRUCache.prototype.has = function(key) {\n      return key in this.items;\n    };\n    LRUCache.prototype.get = function(key) {\n      var pointer = this.items[key];\n      if (typeof pointer === \"undefined\")\n        return;\n      this.splayOnTop(pointer);\n      return this.V[pointer];\n    };\n    LRUCache.prototype.peek = function(key) {\n      var pointer = this.items[key];\n      if (typeof pointer === \"undefined\")\n        return;\n      return this.V[pointer];\n    };\n    LRUCache.prototype.forEach = function(callback, scope) {\n      scope = arguments.length > 1 ? scope : this;\n      var i = 0, l = this.size;\n      var pointer = this.head, keys4 = this.K, values = this.V, forward = this.forward;\n      while (i < l) {\n        callback.call(scope, values[pointer], keys4[pointer], this);\n        pointer = forward[pointer];\n        i++;\n      }\n    };\n    LRUCache.prototype.keys = function() {\n      var i = 0, l = this.size;\n      var pointer = this.head, keys4 = this.K, forward = this.forward;\n      return new Iterator(function() {\n        if (i >= l)\n          return { done: true };\n        var key = keys4[pointer];\n        i++;\n        if (i < l)\n          pointer = forward[pointer];\n        return {\n          done: false,\n          value: key\n        };\n      });\n    };\n    LRUCache.prototype.values = function() {\n      var i = 0, l = this.size;\n      var pointer = this.head, values = this.V, forward = this.forward;\n      return new Iterator(function() {\n        if (i >= l)\n          return { done: true };\n        var value = values[pointer];\n        i++;\n        if (i < l)\n          pointer = forward[pointer];\n        return {\n          done: false,\n          value\n        };\n      });\n    };\n    LRUCache.prototype.entries = function() {\n      var i = 0, l = this.size;\n      var pointer = this.head, keys4 = this.K, values = this.V, forward = this.forward;\n      return new Iterator(function() {\n        if (i >= l)\n          return { done: true };\n        var key = keys4[pointer], value = values[pointer];\n        i++;\n        if (i < l)\n          pointer = forward[pointer];\n        return {\n          done: false,\n          value: [key, value]\n        };\n      });\n    };\n    if (typeof Symbol !== \"undefined\")\n      LRUCache.prototype[Symbol.iterator] = LRUCache.prototype.entries;\n    LRUCache.prototype.inspect = function() {\n      var proxy = /* @__PURE__ */ new Map();\n      var iterator = this.entries(), step;\n      while (step = iterator.next(), !step.done)\n        proxy.set(step.value[0], step.value[1]);\n      Object.defineProperty(proxy, \"constructor\", {\n        value: LRUCache,\n        enumerable: false\n      });\n      return proxy;\n    };\n    if (typeof Symbol !== \"undefined\")\n      LRUCache.prototype[Symbol.for(\"nodejs.util.inspect.custom\")] = LRUCache.prototype.inspect;\n    LRUCache.from = function(iterable, Keys, Values, capacity) {\n      if (arguments.length < 2) {\n        capacity = iterables.guessLength(iterable);\n        if (typeof capacity !== \"number\")\n          throw new Error(\"mnemonist/lru-cache.from: could not guess iterable length. Please provide desired capacity as last argument.\");\n      } else if (arguments.length === 2) {\n        capacity = Keys;\n        Keys = null;\n        Values = null;\n      }\n      var cache = new LRUCache(Keys, Values, capacity);\n      forEach(iterable, function(value, key) {\n        cache.set(key, value);\n      });\n      return cache;\n    };\n    module.exports = LRUCache;\n  }\n});\n\n// node_modules/mnemonist/lru-map.js\nvar require_lru_map = __commonJS({\n  \"node_modules/mnemonist/lru-map.js\"(exports, module) {\n    var LRUCache = require_lru_cache();\n    var forEach = require_foreach();\n    var typed = require_typed_arrays();\n    var iterables = require_iterables();\n    function LRUMap(Keys, Values, capacity) {\n      if (arguments.length < 2) {\n        capacity = Keys;\n        Keys = null;\n        Values = null;\n      }\n      this.capacity = capacity;\n      if (typeof this.capacity !== \"number\" || this.capacity <= 0)\n        throw new Error(\"mnemonist/lru-map: capacity should be positive number.\");\n      else if (!isFinite(this.capacity) || Math.floor(this.capacity) !== this.capacity)\n        throw new Error(\"mnemonist/lru-map: capacity should be a finite positive integer.\");\n      var PointerArray = typed.getPointerArray(capacity);\n      this.forward = new PointerArray(capacity);\n      this.backward = new PointerArray(capacity);\n      this.K = typeof Keys === \"function\" ? new Keys(capacity) : new Array(capacity);\n      this.V = typeof Values === \"function\" ? new Values(capacity) : new Array(capacity);\n      this.size = 0;\n      this.head = 0;\n      this.tail = 0;\n      this.items = /* @__PURE__ */ new Map();\n    }\n    LRUMap.prototype.clear = function() {\n      this.size = 0;\n      this.head = 0;\n      this.tail = 0;\n      this.items.clear();\n    };\n    LRUMap.prototype.set = function(key, value) {\n      var pointer = this.items.get(key);\n      if (typeof pointer !== \"undefined\") {\n        this.splayOnTop(pointer);\n        this.V[pointer] = value;\n        return;\n      }\n      if (this.size < this.capacity) {\n        pointer = this.size++;\n      } else {\n        pointer = this.tail;\n        this.tail = this.backward[pointer];\n        this.items.delete(this.K[pointer]);\n      }\n      this.items.set(key, pointer);\n      this.K[pointer] = key;\n      this.V[pointer] = value;\n      this.forward[pointer] = this.head;\n      this.backward[this.head] = pointer;\n      this.head = pointer;\n    };\n    LRUMap.prototype.setpop = function(key, value) {\n      var oldValue = null;\n      var oldKey = null;\n      var pointer = this.items.get(key);\n      if (typeof pointer !== \"undefined\") {\n        this.splayOnTop(pointer);\n        oldValue = this.V[pointer];\n        this.V[pointer] = value;\n        return { evicted: false, key, value: oldValue };\n      }\n      if (this.size < this.capacity) {\n        pointer = this.size++;\n      } else {\n        pointer = this.tail;\n        this.tail = this.backward[pointer];\n        oldValue = this.V[pointer];\n        oldKey = this.K[pointer];\n        this.items.delete(oldKey);\n      }\n      this.items.set(key, pointer);\n      this.K[pointer] = key;\n      this.V[pointer] = value;\n      this.forward[pointer] = this.head;\n      this.backward[this.head] = pointer;\n      this.head = pointer;\n      if (oldKey) {\n        return { evicted: true, key: oldKey, value: oldValue };\n      } else {\n        return null;\n      }\n    };\n    LRUMap.prototype.has = function(key) {\n      return this.items.has(key);\n    };\n    LRUMap.prototype.get = function(key) {\n      var pointer = this.items.get(key);\n      if (typeof pointer === \"undefined\")\n        return;\n      this.splayOnTop(pointer);\n      return this.V[pointer];\n    };\n    LRUMap.prototype.peek = function(key) {\n      var pointer = this.items.get(key);\n      if (typeof pointer === \"undefined\")\n        return;\n      return this.V[pointer];\n    };\n    LRUMap.prototype.splayOnTop = LRUCache.prototype.splayOnTop;\n    LRUMap.prototype.forEach = LRUCache.prototype.forEach;\n    LRUMap.prototype.keys = LRUCache.prototype.keys;\n    LRUMap.prototype.values = LRUCache.prototype.values;\n    LRUMap.prototype.entries = LRUCache.prototype.entries;\n    if (typeof Symbol !== \"undefined\")\n      LRUMap.prototype[Symbol.iterator] = LRUMap.prototype.entries;\n    LRUMap.prototype.inspect = LRUCache.prototype.inspect;\n    LRUMap.from = function(iterable, Keys, Values, capacity) {\n      if (arguments.length < 2) {\n        capacity = iterables.guessLength(iterable);\n        if (typeof capacity !== \"number\")\n          throw new Error(\"mnemonist/lru-cache.from: could not guess iterable length. Please provide desired capacity as last argument.\");\n      } else if (arguments.length === 2) {\n        capacity = Keys;\n        Keys = null;\n        Values = null;\n      }\n      var cache = new LRUMap(Keys, Values, capacity);\n      forEach(iterable, function(value, key) {\n        cache.set(key, value);\n      });\n      return cache;\n    };\n    module.exports = LRUMap;\n  }\n});\n\n// node_modules/ms/index.js\nvar require_ms = __commonJS({\n  \"node_modules/ms/index.js\"(exports, module) {\n    var s = 1e3;\n    var m = s * 60;\n    var h2 = m * 60;\n    var d = h2 * 24;\n    var w2 = d * 7;\n    var y = d * 365.25;\n    module.exports = function(val, options) {\n      options = options || {};\n      var type3 = typeof val;\n      if (type3 === \"string\" && val.length > 0) {\n        return parse(val);\n      } else if (type3 === \"number\" && isFinite(val)) {\n        return options.long ? fmtLong(val) : fmtShort(val);\n      }\n      throw new Error(\n        \"val is not a non-empty string or a valid number. val=\" + JSON.stringify(val)\n      );\n    };\n    function parse(str) {\n      str = String(str);\n      if (str.length > 100) {\n        return;\n      }\n      var match = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(\n        str\n      );\n      if (!match) {\n        return;\n      }\n      var n = parseFloat(match[1]);\n      var type3 = (match[2] || \"ms\").toLowerCase();\n      switch (type3) {\n        case \"years\":\n        case \"year\":\n        case \"yrs\":\n        case \"yr\":\n        case \"y\":\n          return n * y;\n        case \"weeks\":\n        case \"week\":\n        case \"w\":\n          return n * w2;\n        case \"days\":\n        case \"day\":\n        case \"d\":\n          return n * d;\n        case \"hours\":\n        case \"hour\":\n        case \"hrs\":\n        case \"hr\":\n        case \"h\":\n          return n * h2;\n        case \"minutes\":\n        case \"minute\":\n        case \"mins\":\n        case \"min\":\n        case \"m\":\n          return n * m;\n        case \"seconds\":\n        case \"second\":\n        case \"secs\":\n        case \"sec\":\n        case \"s\":\n          return n * s;\n        case \"milliseconds\":\n        case \"millisecond\":\n        case \"msecs\":\n        case \"msec\":\n        case \"ms\":\n          return n;\n        default:\n          return void 0;\n      }\n    }\n    function fmtShort(ms) {\n      var msAbs = Math.abs(ms);\n      if (msAbs >= d) {\n        return Math.round(ms / d) + \"d\";\n      }\n      if (msAbs >= h2) {\n        return Math.round(ms / h2) + \"h\";\n      }\n      if (msAbs >= m) {\n        return Math.round(ms / m) + \"m\";\n      }\n      if (msAbs >= s) {\n        return Math.round(ms / s) + \"s\";\n      }\n      return ms + \"ms\";\n    }\n    function fmtLong(ms) {\n      var msAbs = Math.abs(ms);\n      if (msAbs >= d) {\n        return plural(ms, msAbs, d, \"day\");\n      }\n      if (msAbs >= h2) {\n        return plural(ms, msAbs, h2, \"hour\");\n      }\n      if (msAbs >= m) {\n        return plural(ms, msAbs, m, \"minute\");\n      }\n      if (msAbs >= s) {\n        return plural(ms, msAbs, s, \"second\");\n      }\n      return ms + \" ms\";\n    }\n    function plural(ms, msAbs, n, name) {\n      var isPlural = msAbs >= n * 1.5;\n      return Math.round(ms / n) + \" \" + name + (isPlural ? \"s\" : \"\");\n    }\n  }\n});\n\n// node_modules/debug/src/common.js\nvar require_common = __commonJS({\n  \"node_modules/debug/src/common.js\"(exports, module) {\n    function setup(env) {\n      createDebug.debug = createDebug;\n      createDebug.default = createDebug;\n      createDebug.coerce = coerce2;\n      createDebug.disable = disable;\n      createDebug.enable = enable;\n      createDebug.enabled = enabled;\n      createDebug.humanize = require_ms();\n      createDebug.destroy = destroy;\n      Object.keys(env).forEach((key) => {\n        createDebug[key] = env[key];\n      });\n      createDebug.names = [];\n      createDebug.skips = [];\n      createDebug.formatters = {};\n      function selectColor(namespace) {\n        let hash = 0;\n        for (let i = 0; i < namespace.length; i++) {\n          hash = (hash << 5) - hash + namespace.charCodeAt(i);\n          hash |= 0;\n        }\n        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];\n      }\n      createDebug.selectColor = selectColor;\n      function createDebug(namespace) {\n        let prevTime;\n        let enableOverride = null;\n        let namespacesCache;\n        let enabledCache;\n        function debug2(...args) {\n          if (!debug2.enabled) {\n            return;\n          }\n          const self = debug2;\n          const curr = Number(/* @__PURE__ */ new Date());\n          const ms = curr - (prevTime || curr);\n          self.diff = ms;\n          self.prev = prevTime;\n          self.curr = curr;\n          prevTime = curr;\n          args[0] = createDebug.coerce(args[0]);\n          if (typeof args[0] !== \"string\") {\n            args.unshift(\"%O\");\n          }\n          let index = 0;\n          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {\n            if (match === \"%%\") {\n              return \"%\";\n            }\n            index++;\n            const formatter = createDebug.formatters[format];\n            if (typeof formatter === \"function\") {\n              const val = args[index];\n              match = formatter.call(self, val);\n              args.splice(index, 1);\n              index--;\n            }\n            return match;\n          });\n          createDebug.formatArgs.call(self, args);\n          const logFn = self.log || createDebug.log;\n          logFn.apply(self, args);\n        }\n        debug2.namespace = namespace;\n        debug2.useColors = createDebug.useColors();\n        debug2.color = createDebug.selectColor(namespace);\n        debug2.extend = extend;\n        debug2.destroy = createDebug.destroy;\n        Object.defineProperty(debug2, \"enabled\", {\n          enumerable: true,\n          configurable: false,\n          get: () => {\n            if (enableOverride !== null) {\n              return enableOverride;\n            }\n            if (namespacesCache !== createDebug.namespaces) {\n              namespacesCache = createDebug.namespaces;\n              enabledCache = createDebug.enabled(namespace);\n            }\n            return enabledCache;\n          },\n          set: (v2) => {\n            enableOverride = v2;\n          }\n        });\n        if (typeof createDebug.init === \"function\") {\n          createDebug.init(debug2);\n        }\n        return debug2;\n      }\n      function extend(namespace, delimiter) {\n        const newDebug = createDebug(this.namespace + (typeof delimiter === \"undefined\" ? \":\" : delimiter) + namespace);\n        newDebug.log = this.log;\n        return newDebug;\n      }\n      function enable(namespaces) {\n        createDebug.save(namespaces);\n        createDebug.namespaces = namespaces;\n        createDebug.names = [];\n        createDebug.skips = [];\n        let i;\n        const split = (typeof namespaces === \"string\" ? namespaces : \"\").split(/[\\s,]+/);\n        const len = split.length;\n        for (i = 0; i < len; i++) {\n          if (!split[i]) {\n            continue;\n          }\n          namespaces = split[i].replace(/\\*/g, \".*?\");\n          if (namespaces[0] === \"-\") {\n            createDebug.skips.push(new RegExp(\"^\" + namespaces.slice(1) + \"$\"));\n          } else {\n            createDebug.names.push(new RegExp(\"^\" + namespaces + \"$\"));\n          }\n        }\n      }\n      function disable() {\n        const namespaces = [\n          ...createDebug.names.map(toNamespace),\n          ...createDebug.skips.map(toNamespace).map((namespace) => \"-\" + namespace)\n        ].join(\",\");\n        createDebug.enable(\"\");\n        return namespaces;\n      }\n      function enabled(name) {\n        if (name[name.length - 1] === \"*\") {\n          return true;\n        }\n        let i;\n        let len;\n        for (i = 0, len = createDebug.skips.length; i < len; i++) {\n          if (createDebug.skips[i].test(name)) {\n            return false;\n          }\n        }\n        for (i = 0, len = createDebug.names.length; i < len; i++) {\n          if (createDebug.names[i].test(name)) {\n            return true;\n          }\n        }\n        return false;\n      }\n      function toNamespace(regexp) {\n        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\\.\\*\\?$/, \"*\");\n      }\n      function coerce2(val) {\n        if (val instanceof Error) {\n          return val.stack || val.message;\n        }\n        return val;\n      }\n      function destroy() {\n        console.warn(\"Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.\");\n      }\n      createDebug.enable(createDebug.load());\n      return createDebug;\n    }\n    module.exports = setup;\n  }\n});\n\n// node_modules/debug/src/browser.js\nvar require_browser = __commonJS({\n  \"node_modules/debug/src/browser.js\"(exports, module) {\n    exports.formatArgs = formatArgs;\n    exports.save = save;\n    exports.load = load;\n    exports.useColors = useColors;\n    exports.storage = localstorage();\n    exports.destroy = /* @__PURE__ */ (() => {\n      let warned = false;\n      return () => {\n        if (!warned) {\n          warned = true;\n          console.warn(\"Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.\");\n        }\n      };\n    })();\n    exports.colors = [\n      \"#0000CC\",\n      \"#0000FF\",\n      \"#0033CC\",\n      \"#0033FF\",\n      \"#0066CC\",\n      \"#0066FF\",\n      \"#0099CC\",\n      \"#0099FF\",\n      \"#00CC00\",\n      \"#00CC33\",\n      \"#00CC66\",\n      \"#00CC99\",\n      \"#00CCCC\",\n      \"#00CCFF\",\n      \"#3300CC\",\n      \"#3300FF\",\n      \"#3333CC\",\n      \"#3333FF\",\n      \"#3366CC\",\n      \"#3366FF\",\n      \"#3399CC\",\n      \"#3399FF\",\n      \"#33CC00\",\n      \"#33CC33\",\n      \"#33CC66\",\n      \"#33CC99\",\n      \"#33CCCC\",\n      \"#33CCFF\",\n      \"#6600CC\",\n      \"#6600FF\",\n      \"#6633CC\",\n      \"#6633FF\",\n      \"#66CC00\",\n      \"#66CC33\",\n      \"#9900CC\",\n      \"#9900FF\",\n      \"#9933CC\",\n      \"#9933FF\",\n      \"#99CC00\",\n      \"#99CC33\",\n      \"#CC0000\",\n      \"#CC0033\",\n      \"#CC0066\",\n      \"#CC0099\",\n      \"#CC00CC\",\n      \"#CC00FF\",\n      \"#CC3300\",\n      \"#CC3333\",\n      \"#CC3366\",\n      \"#CC3399\",\n      \"#CC33CC\",\n      \"#CC33FF\",\n      \"#CC6600\",\n      \"#CC6633\",\n      \"#CC9900\",\n      \"#CC9933\",\n      \"#CCCC00\",\n      \"#CCCC33\",\n      \"#FF0000\",\n      \"#FF0033\",\n      \"#FF0066\",\n      \"#FF0099\",\n      \"#FF00CC\",\n      \"#FF00FF\",\n      \"#FF3300\",\n      \"#FF3333\",\n      \"#FF3366\",\n      \"#FF3399\",\n      \"#FF33CC\",\n      \"#FF33FF\",\n      \"#FF6600\",\n      \"#FF6633\",\n      \"#FF9900\",\n      \"#FF9933\",\n      \"#FFCC00\",\n      \"#FFCC33\"\n    ];\n    function useColors() {\n      if (typeof window !== \"undefined\" && window.process && (window.process.type === \"renderer\" || window.process.__nwjs)) {\n        return true;\n      }\n      if (typeof navigator !== \"undefined\" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n        return false;\n      }\n      return typeof document !== \"undefined\" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773\n      typeof window !== \"undefined\" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?\n      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n      typeof navigator !== \"undefined\" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker\n      typeof navigator !== \"undefined\" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/);\n    }\n    function formatArgs(args) {\n      args[0] = (this.useColors ? \"%c\" : \"\") + this.namespace + (this.useColors ? \" %c\" : \" \") + args[0] + (this.useColors ? \"%c \" : \" \") + \"+\" + module.exports.humanize(this.diff);\n      if (!this.useColors) {\n        return;\n      }\n      const c2 = \"color: \" + this.color;\n      args.splice(1, 0, c2, \"color: inherit\");\n      let index = 0;\n      let lastC = 0;\n      args[0].replace(/%[a-zA-Z%]/g, (match) => {\n        if (match === \"%%\") {\n          return;\n        }\n        index++;\n        if (match === \"%c\") {\n          lastC = index;\n        }\n      });\n      args.splice(lastC, 0, c2);\n    }\n    exports.log = console.debug || console.log || (() => {\n    });\n    function save(namespaces) {\n      try {\n        if (namespaces) {\n          exports.storage.setItem(\"debug\", namespaces);\n        } else {\n          exports.storage.removeItem(\"debug\");\n        }\n      } catch (error) {\n      }\n    }\n    function load() {\n      let r3;\n      try {\n        r3 = exports.storage.getItem(\"debug\");\n      } catch (error) {\n      }\n      if (!r3 && typeof process !== \"undefined\" && \"env\" in process) {\n        r3 = process.env.DEBUG;\n      }\n      return r3;\n    }\n    function localstorage() {\n      try {\n        return localStorage;\n      } catch (error) {\n      }\n    }\n    module.exports = require_common()(exports);\n    var { formatters } = module.exports;\n    formatters.j = function(v2) {\n      try {\n        return JSON.stringify(v2);\n      } catch (error) {\n        return \"[UnexpectedJSONParseError]: \" + error.message;\n      }\n    };\n  }\n});\n\n// node_modules/base64-js/index.js\nvar require_base64_js = __commonJS({\n  \"node_modules/base64-js/index.js\"(exports) {\n    \"use strict\";\n    exports.byteLength = byteLength;\n    exports.toByteArray = toByteArray;\n    exports.fromByteArray = fromByteArray;\n    var lookup = [];\n    var revLookup = [];\n    var Arr = typeof Uint8Array !== \"undefined\" ? Uint8Array : Array;\n    var code = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n    for (i = 0, len = code.length; i < len; ++i) {\n      lookup[i] = code[i];\n      revLookup[code.charCodeAt(i)] = i;\n    }\n    var i;\n    var len;\n    revLookup[\"-\".charCodeAt(0)] = 62;\n    revLookup[\"_\".charCodeAt(0)] = 63;\n    function getLens(b64) {\n      var len2 = b64.length;\n      if (len2 % 4 > 0) {\n        throw new Error(\"Invalid string. Length must be a multiple of 4\");\n      }\n      var validLen = b64.indexOf(\"=\");\n      if (validLen === -1)\n        validLen = len2;\n      var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;\n      return [validLen, placeHoldersLen];\n    }\n    function byteLength(b64) {\n      var lens = getLens(b64);\n      var validLen = lens[0];\n      var placeHoldersLen = lens[1];\n      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;\n    }\n    function _byteLength(b64, validLen, placeHoldersLen) {\n      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;\n    }\n    function toByteArray(b64) {\n      var tmp;\n      var lens = getLens(b64);\n      var validLen = lens[0];\n      var placeHoldersLen = lens[1];\n      var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));\n      var curByte = 0;\n      var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;\n      var i2;\n      for (i2 = 0; i2 < len2; i2 += 4) {\n        tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];\n        arr[curByte++] = tmp >> 16 & 255;\n        arr[curByte++] = tmp >> 8 & 255;\n        arr[curByte++] = tmp & 255;\n      }\n      if (placeHoldersLen === 2) {\n        tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;\n        arr[curByte++] = tmp & 255;\n      }\n      if (placeHoldersLen === 1) {\n        tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;\n        arr[curByte++] = tmp >> 8 & 255;\n        arr[curByte++] = tmp & 255;\n      }\n      return arr;\n    }\n    function tripletToBase64(num) {\n      return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];\n    }\n    function encodeChunk(uint8, start, end) {\n      var tmp;\n      var output = [];\n      for (var i2 = start; i2 < end; i2 += 3) {\n        tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);\n        output.push(tripletToBase64(tmp));\n      }\n      return output.join(\"\");\n    }\n    function fromByteArray(uint8) {\n      var tmp;\n      var len2 = uint8.length;\n      var extraBytes = len2 % 3;\n      var parts = [];\n      var maxChunkLength = 16383;\n      for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {\n        parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));\n      }\n      if (extraBytes === 1) {\n        tmp = uint8[len2 - 1];\n        parts.push(\n          lookup[tmp >> 2] + lookup[tmp << 4 & 63] + \"==\"\n        );\n      } else if (extraBytes === 2) {\n        tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];\n        parts.push(\n          lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + \"=\"\n        );\n      }\n      return parts.join(\"\");\n    }\n  }\n});\n\n// node_modules/ieee754/index.js\nvar require_ieee754 = __commonJS({\n  \"node_modules/ieee754/index.js\"(exports) {\n    exports.read = function(buffer, offset, isLE, mLen, nBytes) {\n      var e, m;\n      var eLen = nBytes * 8 - mLen - 1;\n      var eMax = (1 << eLen) - 1;\n      var eBias = eMax >> 1;\n      var nBits = -7;\n      var i = isLE ? nBytes - 1 : 0;\n      var d = isLE ? -1 : 1;\n      var s = buffer[offset + i];\n      i += d;\n      e = s & (1 << -nBits) - 1;\n      s >>= -nBits;\n      nBits += eLen;\n      for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {\n      }\n      m = e & (1 << -nBits) - 1;\n      e >>= -nBits;\n      nBits += mLen;\n      for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {\n      }\n      if (e === 0) {\n        e = 1 - eBias;\n      } else if (e === eMax) {\n        return m ? NaN : (s ? -1 : 1) * Infinity;\n      } else {\n        m = m + Math.pow(2, mLen);\n        e = e - eBias;\n      }\n      return (s ? -1 : 1) * m * Math.pow(2, e - mLen);\n    };\n    exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {\n      var e, m, c2;\n      var eLen = nBytes * 8 - mLen - 1;\n      var eMax = (1 << eLen) - 1;\n      var eBias = eMax >> 1;\n      var rt2 = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;\n      var i = isLE ? 0 : nBytes - 1;\n      var d = isLE ? 1 : -1;\n      var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;\n      value = Math.abs(value);\n      if (isNaN(value) || value === Infinity) {\n        m = isNaN(value) ? 1 : 0;\n        e = eMax;\n      } else {\n        e = Math.floor(Math.log(value) / Math.LN2);\n        if (value * (c2 = Math.pow(2, -e)) < 1) {\n          e--;\n          c2 *= 2;\n        }\n        if (e + eBias >= 1) {\n          value += rt2 / c2;\n        } else {\n          value += rt2 * Math.pow(2, 1 - eBias);\n        }\n        if (value * c2 >= 2) {\n          e++;\n          c2 /= 2;\n        }\n        if (e + eBias >= eMax) {\n          m = 0;\n          e = eMax;\n        } else if (e + eBias >= 1) {\n          m = (value * c2 - 1) * Math.pow(2, mLen);\n          e = e + eBias;\n        } else {\n          m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);\n          e = 0;\n        }\n      }\n      for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {\n      }\n      e = e << mLen | m;\n      eLen += mLen;\n      for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {\n      }\n      buffer[offset + i - d] |= s * 128;\n    };\n  }\n});\n\n// node_modules/buffer/index.js\nvar require_buffer = __commonJS({\n  \"node_modules/buffer/index.js\"(exports) {\n    \"use strict\";\n    var base64 = require_base64_js();\n    var ieee754 = require_ieee754();\n    var customInspectSymbol = typeof Symbol === \"function\" && typeof Symbol[\"for\"] === \"function\" ? Symbol[\"for\"](\"nodejs.util.inspect.custom\") : null;\n    exports.Buffer = Buffer3;\n    exports.SlowBuffer = SlowBuffer;\n    exports.INSPECT_MAX_BYTES = 50;\n    var K_MAX_LENGTH = 2147483647;\n    exports.kMaxLength = K_MAX_LENGTH;\n    Buffer3.TYPED_ARRAY_SUPPORT = typedArraySupport();\n    if (!Buffer3.TYPED_ARRAY_SUPPORT && typeof console !== \"undefined\" && typeof console.error === \"function\") {\n      console.error(\n        \"This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.\"\n      );\n    }\n    function typedArraySupport() {\n      try {\n        const arr = new Uint8Array(1);\n        const proto = { foo: function() {\n          return 42;\n        } };\n        Object.setPrototypeOf(proto, Uint8Array.prototype);\n        Object.setPrototypeOf(arr, proto);\n        return arr.foo() === 42;\n      } catch (e) {\n        return false;\n      }\n    }\n    Object.defineProperty(Buffer3.prototype, \"parent\", {\n      enumerable: true,\n      get: function() {\n        if (!Buffer3.isBuffer(this))\n          return void 0;\n        return this.buffer;\n      }\n    });\n    Object.defineProperty(Buffer3.prototype, \"offset\", {\n      enumerable: true,\n      get: function() {\n        if (!Buffer3.isBuffer(this))\n          return void 0;\n        return this.byteOffset;\n      }\n    });\n    function createBuffer(length) {\n      if (length > K_MAX_LENGTH) {\n        throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"');\n      }\n      const buf = new Uint8Array(length);\n      Object.setPrototypeOf(buf, Buffer3.prototype);\n      return buf;\n    }\n    function Buffer3(arg, encodingOrOffset, length) {\n      if (typeof arg === \"number\") {\n        if (typeof encodingOrOffset === \"string\") {\n          throw new TypeError(\n            'The \"string\" argument must be of type string. Received type number'\n          );\n        }\n        return allocUnsafe(arg);\n      }\n      return from(arg, encodingOrOffset, length);\n    }\n    Buffer3.poolSize = 8192;\n    function from(value, encodingOrOffset, length) {\n      if (typeof value === \"string\") {\n        return fromString(value, encodingOrOffset);\n      }\n      if (ArrayBuffer.isView(value)) {\n        return fromArrayView(value);\n      }\n      if (value == null) {\n        throw new TypeError(\n          \"The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type \" + typeof value\n        );\n      }\n      if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {\n        return fromArrayBuffer(value, encodingOrOffset, length);\n      }\n      if (typeof SharedArrayBuffer !== \"undefined\" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {\n        return fromArrayBuffer(value, encodingOrOffset, length);\n      }\n      if (typeof value === \"number\") {\n        throw new TypeError(\n          'The \"value\" argument must not be of type number. Received type number'\n        );\n      }\n      const valueOf = value.valueOf && value.valueOf();\n      if (valueOf != null && valueOf !== value) {\n        return Buffer3.from(valueOf, encodingOrOffset, length);\n      }\n      const b2 = fromObject(value);\n      if (b2)\n        return b2;\n      if (typeof Symbol !== \"undefined\" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === \"function\") {\n        return Buffer3.from(value[Symbol.toPrimitive](\"string\"), encodingOrOffset, length);\n      }\n      throw new TypeError(\n        \"The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type \" + typeof value\n      );\n    }\n    Buffer3.from = function(value, encodingOrOffset, length) {\n      return from(value, encodingOrOffset, length);\n    };\n    Object.setPrototypeOf(Buffer3.prototype, Uint8Array.prototype);\n    Object.setPrototypeOf(Buffer3, Uint8Array);\n    function assertSize(size) {\n      if (typeof size !== \"number\") {\n        throw new TypeError('\"size\" argument must be of type number');\n      } else if (size < 0) {\n        throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"');\n      }\n    }\n    function alloc(size, fill, encoding) {\n      assertSize(size);\n      if (size <= 0) {\n        return createBuffer(size);\n      }\n      if (fill !== void 0) {\n        return typeof encoding === \"string\" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);\n      }\n      return createBuffer(size);\n    }\n    Buffer3.alloc = function(size, fill, encoding) {\n      return alloc(size, fill, encoding);\n    };\n    function allocUnsafe(size) {\n      assertSize(size);\n      return createBuffer(size < 0 ? 0 : checked(size) | 0);\n    }\n    Buffer3.allocUnsafe = function(size) {\n      return allocUnsafe(size);\n    };\n    Buffer3.allocUnsafeSlow = function(size) {\n      return allocUnsafe(size);\n    };\n    function fromString(string, encoding) {\n      if (typeof encoding !== \"string\" || encoding === \"\") {\n        encoding = \"utf8\";\n      }\n      if (!Buffer3.isEncoding(encoding)) {\n        throw new TypeError(\"Unknown encoding: \" + encoding);\n      }\n      const length = byteLength(string, encoding) | 0;\n      let buf = createBuffer(length);\n      const actual = buf.write(string, encoding);\n      if (actual !== length) {\n        buf = buf.slice(0, actual);\n      }\n      return buf;\n    }\n    function fromArrayLike(array) {\n      const length = array.length < 0 ? 0 : checked(array.length) | 0;\n      const buf = createBuffer(length);\n      for (let i = 0; i < length; i += 1) {\n        buf[i] = array[i] & 255;\n      }\n      return buf;\n    }\n    function fromArrayView(arrayView) {\n      if (isInstance(arrayView, Uint8Array)) {\n        const copy = new Uint8Array(arrayView);\n        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);\n      }\n      return fromArrayLike(arrayView);\n    }\n    function fromArrayBuffer(array, byteOffset, length) {\n      if (byteOffset < 0 || array.byteLength < byteOffset) {\n        throw new RangeError('\"offset\" is outside of buffer bounds');\n      }\n      if (array.byteLength < byteOffset + (length || 0)) {\n        throw new RangeError('\"length\" is outside of buffer bounds');\n      }\n      let buf;\n      if (byteOffset === void 0 && length === void 0) {\n        buf = new Uint8Array(array);\n      } else if (length === void 0) {\n        buf = new Uint8Array(array, byteOffset);\n      } else {\n        buf = new Uint8Array(array, byteOffset, length);\n      }\n      Object.setPrototypeOf(buf, Buffer3.prototype);\n      return buf;\n    }\n    function fromObject(obj) {\n      if (Buffer3.isBuffer(obj)) {\n        const len = checked(obj.length) | 0;\n        const buf = createBuffer(len);\n        if (buf.length === 0) {\n          return buf;\n        }\n        obj.copy(buf, 0, 0, len);\n        return buf;\n      }\n      if (obj.length !== void 0) {\n        if (typeof obj.length !== \"number\" || numberIsNaN(obj.length)) {\n          return createBuffer(0);\n        }\n        return fromArrayLike(obj);\n      }\n      if (obj.type === \"Buffer\" && Array.isArray(obj.data)) {\n        return fromArrayLike(obj.data);\n      }\n    }\n    function checked(length) {\n      if (length >= K_MAX_LENGTH) {\n        throw new RangeError(\"Attempt to allocate Buffer larger than maximum size: 0x\" + K_MAX_LENGTH.toString(16) + \" bytes\");\n      }\n      return length | 0;\n    }\n    function SlowBuffer(length) {\n      if (+length != length) {\n        length = 0;\n      }\n      return Buffer3.alloc(+length);\n    }\n    Buffer3.isBuffer = function isBuffer(b2) {\n      return b2 != null && b2._isBuffer === true && b2 !== Buffer3.prototype;\n    };\n    Buffer3.compare = function compare(a, b2) {\n      if (isInstance(a, Uint8Array))\n        a = Buffer3.from(a, a.offset, a.byteLength);\n      if (isInstance(b2, Uint8Array))\n        b2 = Buffer3.from(b2, b2.offset, b2.byteLength);\n      if (!Buffer3.isBuffer(a) || !Buffer3.isBuffer(b2)) {\n        throw new TypeError(\n          'The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array'\n        );\n      }\n      if (a === b2)\n        return 0;\n      let x2 = a.length;\n      let y = b2.length;\n      for (let i = 0, len = Math.min(x2, y); i < len; ++i) {\n        if (a[i] !== b2[i]) {\n          x2 = a[i];\n          y = b2[i];\n          break;\n        }\n      }\n      if (x2 < y)\n        return -1;\n      if (y < x2)\n        return 1;\n      return 0;\n    };\n    Buffer3.isEncoding = function isEncoding(encoding) {\n      switch (String(encoding).toLowerCase()) {\n        case \"hex\":\n        case \"utf8\":\n        case \"utf-8\":\n        case \"ascii\":\n        case \"latin1\":\n        case \"binary\":\n        case \"base64\":\n        case \"ucs2\":\n        case \"ucs-2\":\n        case \"utf16le\":\n        case \"utf-16le\":\n          return true;\n        default:\n          return false;\n      }\n    };\n    Buffer3.concat = function concat3(list, length) {\n      if (!Array.isArray(list)) {\n        throw new TypeError('\"list\" argument must be an Array of Buffers');\n      }\n      if (list.length === 0) {\n        return Buffer3.alloc(0);\n      }\n      let i;\n      if (length === void 0) {\n        length = 0;\n        for (i = 0; i < list.length; ++i) {\n          length += list[i].length;\n        }\n      }\n      const buffer = Buffer3.allocUnsafe(length);\n      let pos = 0;\n      for (i = 0; i < list.length; ++i) {\n        let buf = list[i];\n        if (isInstance(buf, Uint8Array)) {\n          if (pos + buf.length > buffer.length) {\n            if (!Buffer3.isBuffer(buf))\n              buf = Buffer3.from(buf);\n            buf.copy(buffer, pos);\n          } else {\n            Uint8Array.prototype.set.call(\n              buffer,\n              buf,\n              pos\n            );\n          }\n        } else if (!Buffer3.isBuffer(buf)) {\n          throw new TypeError('\"list\" argument must be an Array of Buffers');\n        } else {\n          buf.copy(buffer, pos);\n        }\n        pos += buf.length;\n      }\n      return buffer;\n    };\n    function byteLength(string, encoding) {\n      if (Buffer3.isBuffer(string)) {\n        return string.length;\n      }\n      if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {\n        return string.byteLength;\n      }\n      if (typeof string !== \"string\") {\n        throw new TypeError(\n          'The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string\n        );\n      }\n      const len = string.length;\n      const mustMatch = arguments.length > 2 && arguments[2] === true;\n      if (!mustMatch && len === 0)\n        return 0;\n      let loweredCase = false;\n      for (; ; ) {\n        switch (encoding) {\n          case \"ascii\":\n          case \"latin1\":\n          case \"binary\":\n            return len;\n          case \"utf8\":\n          case \"utf-8\":\n            return utf8ToBytes(string).length;\n          case \"ucs2\":\n          case \"ucs-2\":\n          case \"utf16le\":\n          case \"utf-16le\":\n            return len * 2;\n          case \"hex\":\n            return len >>> 1;\n          case \"base64\":\n            return base64ToBytes(string).length;\n          default:\n            if (loweredCase) {\n              return mustMatch ? -1 : utf8ToBytes(string).length;\n            }\n            encoding = (\"\" + encoding).toLowerCase();\n            loweredCase = true;\n        }\n      }\n    }\n    Buffer3.byteLength = byteLength;\n    function slowToString(encoding, start, end) {\n      let loweredCase = false;\n      if (start === void 0 || start < 0) {\n        start = 0;\n      }\n      if (start > this.length) {\n        return \"\";\n      }\n      if (end === void 0 || end > this.length) {\n        end = this.length;\n      }\n      if (end <= 0) {\n        return \"\";\n      }\n      end >>>= 0;\n      start >>>= 0;\n      if (end <= start) {\n        return \"\";\n      }\n      if (!encoding)\n        encoding = \"utf8\";\n      while (true) {\n        switch (encoding) {\n          case \"hex\":\n            return hexSlice(this, start, end);\n          case \"utf8\":\n          case \"utf-8\":\n            return utf8Slice(this, start, end);\n          case \"ascii\":\n            return asciiSlice(this, start, end);\n          case \"latin1\":\n          case \"binary\":\n            return latin1Slice(this, start, end);\n          case \"base64\":\n            return base64Slice(this, start, end);\n          case \"ucs2\":\n          case \"ucs-2\":\n          case \"utf16le\":\n          case \"utf-16le\":\n            return utf16leSlice(this, start, end);\n          default:\n            if (loweredCase)\n              throw new TypeError(\"Unknown encoding: \" + encoding);\n            encoding = (encoding + \"\").toLowerCase();\n            loweredCase = true;\n        }\n      }\n    }\n    Buffer3.prototype._isBuffer = true;\n    function swap(b2, n, m) {\n      const i = b2[n];\n      b2[n] = b2[m];\n      b2[m] = i;\n    }\n    Buffer3.prototype.swap16 = function swap16() {\n      const len = this.length;\n      if (len % 2 !== 0) {\n        throw new RangeError(\"Buffer size must be a multiple of 16-bits\");\n      }\n      for (let i = 0; i < len; i += 2) {\n        swap(this, i, i + 1);\n      }\n      return this;\n    };\n    Buffer3.prototype.swap32 = function swap32() {\n      const len = this.length;\n      if (len % 4 !== 0) {\n        throw new RangeError(\"Buffer size must be a multiple of 32-bits\");\n      }\n      for (let i = 0; i < len; i += 4) {\n        swap(this, i, i + 3);\n        swap(this, i + 1, i + 2);\n      }\n      return this;\n    };\n    Buffer3.prototype.swap64 = function swap64() {\n      const len = this.length;\n      if (len % 8 !== 0) {\n        throw new RangeError(\"Buffer size must be a multiple of 64-bits\");\n      }\n      for (let i = 0; i < len; i += 8) {\n        swap(this, i, i + 7);\n        swap(this, i + 1, i + 6);\n        swap(this, i + 2, i + 5);\n        swap(this, i + 3, i + 4);\n      }\n      return this;\n    };\n    Buffer3.prototype.toString = function toString4() {\n      const length = this.length;\n      if (length === 0)\n        return \"\";\n      if (arguments.length === 0)\n        return utf8Slice(this, 0, length);\n      return slowToString.apply(this, arguments);\n    };\n    Buffer3.prototype.toLocaleString = Buffer3.prototype.toString;\n    Buffer3.prototype.equals = function equals3(b2) {\n      if (!Buffer3.isBuffer(b2))\n        throw new TypeError(\"Argument must be a Buffer\");\n      if (this === b2)\n        return true;\n      return Buffer3.compare(this, b2) === 0;\n    };\n    Buffer3.prototype.inspect = function inspect() {\n      let str = \"\";\n      const max3 = exports.INSPECT_MAX_BYTES;\n      str = this.toString(\"hex\", 0, max3).replace(/(.{2})/g, \"$1 \").trim();\n      if (this.length > max3)\n        str += \" ... \";\n      return \"<Buffer \" + str + \">\";\n    };\n    if (customInspectSymbol) {\n      Buffer3.prototype[customInspectSymbol] = Buffer3.prototype.inspect;\n    }\n    Buffer3.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {\n      if (isInstance(target, Uint8Array)) {\n        target = Buffer3.from(target, target.offset, target.byteLength);\n      }\n      if (!Buffer3.isBuffer(target)) {\n        throw new TypeError(\n          'The \"target\" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target\n        );\n      }\n      if (start === void 0) {\n        start = 0;\n      }\n      if (end === void 0) {\n        end = target ? target.length : 0;\n      }\n      if (thisStart === void 0) {\n        thisStart = 0;\n      }\n      if (thisEnd === void 0) {\n        thisEnd = this.length;\n      }\n      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n        throw new RangeError(\"out of range index\");\n      }\n      if (thisStart >= thisEnd && start >= end) {\n        return 0;\n      }\n      if (thisStart >= thisEnd) {\n        return -1;\n      }\n      if (start >= end) {\n        return 1;\n      }\n      start >>>= 0;\n      end >>>= 0;\n      thisStart >>>= 0;\n      thisEnd >>>= 0;\n      if (this === target)\n        return 0;\n      let x2 = thisEnd - thisStart;\n      let y = end - start;\n      const len = Math.min(x2, y);\n      const thisCopy = this.slice(thisStart, thisEnd);\n      const targetCopy = target.slice(start, end);\n      for (let i = 0; i < len; ++i) {\n        if (thisCopy[i] !== targetCopy[i]) {\n          x2 = thisCopy[i];\n          y = targetCopy[i];\n          break;\n        }\n      }\n      if (x2 < y)\n        return -1;\n      if (y < x2)\n        return 1;\n      return 0;\n    };\n    function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {\n      if (buffer.length === 0)\n        return -1;\n      if (typeof byteOffset === \"string\") {\n        encoding = byteOffset;\n        byteOffset = 0;\n      } else if (byteOffset > 2147483647) {\n        byteOffset = 2147483647;\n      } else if (byteOffset < -2147483648) {\n        byteOffset = -2147483648;\n      }\n      byteOffset = +byteOffset;\n      if (numberIsNaN(byteOffset)) {\n        byteOffset = dir ? 0 : buffer.length - 1;\n      }\n      if (byteOffset < 0)\n        byteOffset = buffer.length + byteOffset;\n      if (byteOffset >= buffer.length) {\n        if (dir)\n          return -1;\n        else\n          byteOffset = buffer.length - 1;\n      } else if (byteOffset < 0) {\n        if (dir)\n          byteOffset = 0;\n        else\n          return -1;\n      }\n      if (typeof val === \"string\") {\n        val = Buffer3.from(val, encoding);\n      }\n      if (Buffer3.isBuffer(val)) {\n        if (val.length === 0) {\n          return -1;\n        }\n        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);\n      } else if (typeof val === \"number\") {\n        val = val & 255;\n        if (typeof Uint8Array.prototype.indexOf === \"function\") {\n          if (dir) {\n            return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);\n          } else {\n            return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);\n          }\n        }\n        return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);\n      }\n      throw new TypeError(\"val must be string, number or Buffer\");\n    }\n    function arrayIndexOf(arr, val, byteOffset, encoding, dir) {\n      let indexSize = 1;\n      let arrLength = arr.length;\n      let valLength = val.length;\n      if (encoding !== void 0) {\n        encoding = String(encoding).toLowerCase();\n        if (encoding === \"ucs2\" || encoding === \"ucs-2\" || encoding === \"utf16le\" || encoding === \"utf-16le\") {\n          if (arr.length < 2 || val.length < 2) {\n            return -1;\n          }\n          indexSize = 2;\n          arrLength /= 2;\n          valLength /= 2;\n          byteOffset /= 2;\n        }\n      }\n      function read(buf, i2) {\n        if (indexSize === 1) {\n          return buf[i2];\n        } else {\n          return buf.readUInt16BE(i2 * indexSize);\n        }\n      }\n      let i;\n      if (dir) {\n        let foundIndex = -1;\n        for (i = byteOffset; i < arrLength; i++) {\n          if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n            if (foundIndex === -1)\n              foundIndex = i;\n            if (i - foundIndex + 1 === valLength)\n              return foundIndex * indexSize;\n          } else {\n            if (foundIndex !== -1)\n              i -= i - foundIndex;\n            foundIndex = -1;\n          }\n        }\n      } else {\n        if (byteOffset + valLength > arrLength)\n          byteOffset = arrLength - valLength;\n        for (i = byteOffset; i >= 0; i--) {\n          let found = true;\n          for (let j2 = 0; j2 < valLength; j2++) {\n            if (read(arr, i + j2) !== read(val, j2)) {\n              found = false;\n              break;\n            }\n          }\n          if (found)\n            return i;\n        }\n      }\n      return -1;\n    }\n    Buffer3.prototype.includes = function includes2(val, byteOffset, encoding) {\n      return this.indexOf(val, byteOffset, encoding) !== -1;\n    };\n    Buffer3.prototype.indexOf = function indexOf(val, byteOffset, encoding) {\n      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);\n    };\n    Buffer3.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {\n      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);\n    };\n    function hexWrite(buf, string, offset, length) {\n      offset = Number(offset) || 0;\n      const remaining = buf.length - offset;\n      if (!length) {\n        length = remaining;\n      } else {\n        length = Number(length);\n        if (length > remaining) {\n          length = remaining;\n        }\n      }\n      const strLen = string.length;\n      if (length > strLen / 2) {\n        length = strLen / 2;\n      }\n      let i;\n      for (i = 0; i < length; ++i) {\n        const parsed = parseInt(string.substr(i * 2, 2), 16);\n        if (numberIsNaN(parsed))\n          return i;\n        buf[offset + i] = parsed;\n      }\n      return i;\n    }\n    function utf8Write(buf, string, offset, length) {\n      return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);\n    }\n    function asciiWrite(buf, string, offset, length) {\n      return blitBuffer(asciiToBytes(string), buf, offset, length);\n    }\n    function base64Write(buf, string, offset, length) {\n      return blitBuffer(base64ToBytes(string), buf, offset, length);\n    }\n    function ucs2Write(buf, string, offset, length) {\n      return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);\n    }\n    Buffer3.prototype.write = function write(string, offset, length, encoding) {\n      if (offset === void 0) {\n        encoding = \"utf8\";\n        length = this.length;\n        offset = 0;\n      } else if (length === void 0 && typeof offset === \"string\") {\n        encoding = offset;\n        length = this.length;\n        offset = 0;\n      } else if (isFinite(offset)) {\n        offset = offset >>> 0;\n        if (isFinite(length)) {\n          length = length >>> 0;\n          if (encoding === void 0)\n            encoding = \"utf8\";\n        } else {\n          encoding = length;\n          length = void 0;\n        }\n      } else {\n        throw new Error(\n          \"Buffer.write(string, encoding, offset[, length]) is no longer supported\"\n        );\n      }\n      const remaining = this.length - offset;\n      if (length === void 0 || length > remaining)\n        length = remaining;\n      if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {\n        throw new RangeError(\"Attempt to write outside buffer bounds\");\n      }\n      if (!encoding)\n        encoding = \"utf8\";\n      let loweredCase = false;\n      for (; ; ) {\n        switch (encoding) {\n          case \"hex\":\n            return hexWrite(this, string, offset, length);\n          case \"utf8\":\n          case \"utf-8\":\n            return utf8Write(this, string, offset, length);\n          case \"ascii\":\n          case \"latin1\":\n          case \"binary\":\n            return asciiWrite(this, string, offset, length);\n          case \"base64\":\n            return base64Write(this, string, offset, length);\n          case \"ucs2\":\n          case \"ucs-2\":\n          case \"utf16le\":\n          case \"utf-16le\":\n            return ucs2Write(this, string, offset, length);\n          default:\n            if (loweredCase)\n              throw new TypeError(\"Unknown encoding: \" + encoding);\n            encoding = (\"\" + encoding).toLowerCase();\n            loweredCase = true;\n        }\n      }\n    };\n    Buffer3.prototype.toJSON = function toJSON() {\n      return {\n        type: \"Buffer\",\n        data: Array.prototype.slice.call(this._arr || this, 0)\n      };\n    };\n    function base64Slice(buf, start, end) {\n      if (start === 0 && end === buf.length) {\n        return base64.fromByteArray(buf);\n      } else {\n        return base64.fromByteArray(buf.slice(start, end));\n      }\n    }\n    function utf8Slice(buf, start, end) {\n      end = Math.min(buf.length, end);\n      const res = [];\n      let i = start;\n      while (i < end) {\n        const firstByte = buf[i];\n        let codePoint = null;\n        let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;\n        if (i + bytesPerSequence <= end) {\n          let secondByte, thirdByte, fourthByte, tempCodePoint;\n          switch (bytesPerSequence) {\n            case 1:\n              if (firstByte < 128) {\n                codePoint = firstByte;\n              }\n              break;\n            case 2:\n              secondByte = buf[i + 1];\n              if ((secondByte & 192) === 128) {\n                tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;\n                if (tempCodePoint > 127) {\n                  codePoint = tempCodePoint;\n                }\n              }\n              break;\n            case 3:\n              secondByte = buf[i + 1];\n              thirdByte = buf[i + 2];\n              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {\n                tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;\n                if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {\n                  codePoint = tempCodePoint;\n                }\n              }\n              break;\n            case 4:\n              secondByte = buf[i + 1];\n              thirdByte = buf[i + 2];\n              fourthByte = buf[i + 3];\n              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {\n                tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;\n                if (tempCodePoint > 65535 && tempCodePoint < 1114112) {\n                  codePoint = tempCodePoint;\n                }\n              }\n          }\n        }\n        if (codePoint === null) {\n          codePoint = 65533;\n          bytesPerSequence = 1;\n        } else if (codePoint > 65535) {\n          codePoint -= 65536;\n          res.push(codePoint >>> 10 & 1023 | 55296);\n          codePoint = 56320 | codePoint & 1023;\n        }\n        res.push(codePoint);\n        i += bytesPerSequence;\n      }\n      return decodeCodePointsArray(res);\n    }\n    var MAX_ARGUMENTS_LENGTH = 4096;\n    function decodeCodePointsArray(codePoints) {\n      const len = codePoints.length;\n      if (len <= MAX_ARGUMENTS_LENGTH) {\n        return String.fromCharCode.apply(String, codePoints);\n      }\n      let res = \"\";\n      let i = 0;\n      while (i < len) {\n        res += String.fromCharCode.apply(\n          String,\n          codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n        );\n      }\n      return res;\n    }\n    function asciiSlice(buf, start, end) {\n      let ret = \"\";\n      end = Math.min(buf.length, end);\n      for (let i = start; i < end; ++i) {\n        ret += String.fromCharCode(buf[i] & 127);\n      }\n      return ret;\n    }\n    function latin1Slice(buf, start, end) {\n      let ret = \"\";\n      end = Math.min(buf.length, end);\n      for (let i = start; i < end; ++i) {\n        ret += String.fromCharCode(buf[i]);\n      }\n      return ret;\n    }\n    function hexSlice(buf, start, end) {\n      const len = buf.length;\n      if (!start || start < 0)\n        start = 0;\n      if (!end || end < 0 || end > len)\n        end = len;\n      let out = \"\";\n      for (let i = start; i < end; ++i) {\n        out += hexSliceLookupTable[buf[i]];\n      }\n      return out;\n    }\n    function utf16leSlice(buf, start, end) {\n      const bytes = buf.slice(start, end);\n      let res = \"\";\n      for (let i = 0; i < bytes.length - 1; i += 2) {\n        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);\n      }\n      return res;\n    }\n    Buffer3.prototype.slice = function slice3(start, end) {\n      const len = this.length;\n      start = ~~start;\n      end = end === void 0 ? len : ~~end;\n      if (start < 0) {\n        start += len;\n        if (start < 0)\n          start = 0;\n      } else if (start > len) {\n        start = len;\n      }\n      if (end < 0) {\n        end += len;\n        if (end < 0)\n          end = 0;\n      } else if (end > len) {\n        end = len;\n      }\n      if (end < start)\n        end = start;\n      const newBuf = this.subarray(start, end);\n      Object.setPrototypeOf(newBuf, Buffer3.prototype);\n      return newBuf;\n    };\n    function checkOffset(offset, ext, length) {\n      if (offset % 1 !== 0 || offset < 0)\n        throw new RangeError(\"offset is not uint\");\n      if (offset + ext > length)\n        throw new RangeError(\"Trying to access beyond buffer length\");\n    }\n    Buffer3.prototype.readUintLE = Buffer3.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {\n      offset = offset >>> 0;\n      byteLength2 = byteLength2 >>> 0;\n      if (!noAssert)\n        checkOffset(offset, byteLength2, this.length);\n      let val = this[offset];\n      let mul = 1;\n      let i = 0;\n      while (++i < byteLength2 && (mul *= 256)) {\n        val += this[offset + i] * mul;\n      }\n      return val;\n    };\n    Buffer3.prototype.readUintBE = Buffer3.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {\n      offset = offset >>> 0;\n      byteLength2 = byteLength2 >>> 0;\n      if (!noAssert) {\n        checkOffset(offset, byteLength2, this.length);\n      }\n      let val = this[offset + --byteLength2];\n      let mul = 1;\n      while (byteLength2 > 0 && (mul *= 256)) {\n        val += this[offset + --byteLength2] * mul;\n      }\n      return val;\n    };\n    Buffer3.prototype.readUint8 = Buffer3.prototype.readUInt8 = function readUInt8(offset, noAssert) {\n      offset = offset >>> 0;\n      if (!noAssert)\n        checkOffset(offset, 1, this.length);\n      return this[offset];\n    };\n    Buffer3.prototype.readUint16LE = Buffer3.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {\n      offset = offset >>> 0;\n      if (!noAssert)\n        checkOffset(offset, 2, this.length);\n      return this[offset] | this[offset + 1] << 8;\n    };\n    Buffer3.prototype.readUint16BE = Buffer3.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {\n      offset = offset >>> 0;\n      if (!noAssert)\n        checkOffset(offset, 2, this.length);\n      return this[offset] << 8 | this[offset + 1];\n    };\n    Buffer3.prototype.readUint32LE = Buffer3.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {\n      offset = offset >>> 0;\n      if (!noAssert)\n        checkOffset(offset, 4, this.length);\n      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;\n    };\n    Buffer3.prototype.readUint32BE = Buffer3.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {\n      offset = offset >>> 0;\n      if (!noAssert)\n        checkOffset(offset, 4, this.length);\n      return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);\n    };\n    Buffer3.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {\n      offset = offset >>> 0;\n      validateNumber(offset, \"offset\");\n      const first = this[offset];\n      const last = this[offset + 7];\n      if (first === void 0 || last === void 0) {\n        boundsError(offset, this.length - 8);\n      }\n      const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;\n      const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;\n      return BigInt(lo) + (BigInt(hi) << BigInt(32));\n    });\n    Buffer3.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {\n      offset = offset >>> 0;\n      validateNumber(offset, \"offset\");\n      const first = this[offset];\n      const last = this[offset + 7];\n      if (first === void 0 || last === void 0) {\n        boundsError(offset, this.length - 8);\n      }\n      const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];\n      const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;\n      return (BigInt(hi) << BigInt(32)) + BigInt(lo);\n    });\n    Buffer3.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {\n      offset = offset >>> 0;\n      byteLength2 = byteLength2 >>> 0;\n      if (!noAssert)\n        checkOffset(offset, byteLength2, this.length);\n      let val = this[offset];\n      let mul = 1;\n      let i = 0;\n      while (++i < byteLength2 && (mul *= 256)) {\n        val += this[offset + i] * mul;\n      }\n      mul *= 128;\n      if (val >= mul)\n        val -= Math.pow(2, 8 * byteLength2);\n      return val;\n    };\n    Buffer3.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {\n      offset = offset >>> 0;\n      byteLength2 = byteLength2 >>> 0;\n      if (!noAssert)\n        checkOffset(offset, byteLength2, this.length);\n      let i = byteLength2;\n      let mul = 1;\n      let val = this[offset + --i];\n      while (i > 0 && (mul *= 256)) {\n        val += this[offset + --i] * mul;\n      }\n      mul *= 128;\n      if (val >= mul)\n        val -= Math.pow(2, 8 * byteLength2);\n      return val;\n    };\n    Buffer3.prototype.readInt8 = function readInt8(offset, noAssert) {\n      offset = offset >>> 0;\n      if (!noAssert)\n        checkOffset(offset, 1, this.length);\n      if (!(this[offset] & 128))\n        return this[offset];\n      return (255 - this[offset] + 1) * -1;\n    };\n    Buffer3.prototype.readInt16LE = function readInt16LE(offset, noAssert) {\n      offset = offset >>> 0;\n      if (!noAssert)\n        checkOffset(offset, 2, this.length);\n      const val = this[offset] | this[offset + 1] << 8;\n      return val & 32768 ? val | 4294901760 : val;\n    };\n    Buffer3.prototype.readInt16BE = function readInt16BE(offset, noAssert) {\n      offset = offset >>> 0;\n      if (!noAssert)\n        checkOffset(offset, 2, this.length);\n      const val = this[offset + 1] | this[offset] << 8;\n      return val & 32768 ? val | 4294901760 : val;\n    };\n    Buffer3.prototype.readInt32LE = function readInt32LE(offset, noAssert) {\n      offset = offset >>> 0;\n      if (!noAssert)\n        checkOffset(offset, 4, this.length);\n      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;\n    };\n    Buffer3.prototype.readInt32BE = function readInt32BE(offset, noAssert) {\n      offset = offset >>> 0;\n      if (!noAssert)\n        checkOffset(offset, 4, this.length);\n      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];\n    };\n    Buffer3.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {\n      offset = offset >>> 0;\n      validateNumber(offset, \"offset\");\n      const first = this[offset];\n      const last = this[offset + 7];\n      if (first === void 0 || last === void 0) {\n        boundsError(offset, this.length - 8);\n      }\n      const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);\n      return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);\n    });\n    Buffer3.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {\n      offset = offset >>> 0;\n      validateNumber(offset, \"offset\");\n      const first = this[offset];\n      const last = this[offset + 7];\n      if (first === void 0 || last === void 0) {\n        boundsError(offset, this.length - 8);\n      }\n      const val = (first << 24) + // Overflow\n      this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];\n      return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);\n    });\n    Buffer3.prototype.readFloatLE = function readFloatLE(offset, noAssert) {\n      offset = offset >>> 0;\n      if (!noAssert)\n        checkOffset(offset, 4, this.length);\n      return ieee754.read(this, offset, true, 23, 4);\n    };\n    Buffer3.prototype.readFloatBE = function readFloatBE(offset, noAssert) {\n      offset = offset >>> 0;\n      if (!noAssert)\n        checkOffset(offset, 4, this.length);\n      return ieee754.read(this, offset, false, 23, 4);\n    };\n    Buffer3.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {\n      offset = offset >>> 0;\n      if (!noAssert)\n        checkOffset(offset, 8, this.length);\n      return ieee754.read(this, offset, true, 52, 8);\n    };\n    Buffer3.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {\n      offset = offset >>> 0;\n      if (!noAssert)\n        checkOffset(offset, 8, this.length);\n      return ieee754.read(this, offset, false, 52, 8);\n    };\n    function checkInt(buf, value, offset, ext, max3, min) {\n      if (!Buffer3.isBuffer(buf))\n        throw new TypeError('\"buffer\" argument must be a Buffer instance');\n      if (value > max3 || value < min)\n        throw new RangeError('\"value\" argument is out of bounds');\n      if (offset + ext > buf.length)\n        throw new RangeError(\"Index out of range\");\n    }\n    Buffer3.prototype.writeUintLE = Buffer3.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {\n      value = +value;\n      offset = offset >>> 0;\n      byteLength2 = byteLength2 >>> 0;\n      if (!noAssert) {\n        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;\n        checkInt(this, value, offset, byteLength2, maxBytes, 0);\n      }\n      let mul = 1;\n      let i = 0;\n      this[offset] = value & 255;\n      while (++i < byteLength2 && (mul *= 256)) {\n        this[offset + i] = value / mul & 255;\n      }\n      return offset + byteLength2;\n    };\n    Buffer3.prototype.writeUintBE = Buffer3.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {\n      value = +value;\n      offset = offset >>> 0;\n      byteLength2 = byteLength2 >>> 0;\n      if (!noAssert) {\n        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;\n        checkInt(this, value, offset, byteLength2, maxBytes, 0);\n      }\n      let i = byteLength2 - 1;\n      let mul = 1;\n      this[offset + i] = value & 255;\n      while (--i >= 0 && (mul *= 256)) {\n        this[offset + i] = value / mul & 255;\n      }\n      return offset + byteLength2;\n    };\n    Buffer3.prototype.writeUint8 = Buffer3.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {\n      value = +value;\n      offset = offset >>> 0;\n      if (!noAssert)\n        checkInt(this, value, offset, 1, 255, 0);\n      this[offset] = value & 255;\n      return offset + 1;\n    };\n    Buffer3.prototype.writeUint16LE = Buffer3.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {\n      value = +value;\n      offset = offset >>> 0;\n      if (!noAssert)\n        checkInt(this, value, offset, 2, 65535, 0);\n      this[offset] = value & 255;\n      this[offset + 1] = value >>> 8;\n      return offset + 2;\n    };\n    Buffer3.prototype.writeUint16BE = Buffer3.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {\n      value = +value;\n      offset = offset >>> 0;\n      if (!noAssert)\n        checkInt(this, value, offset, 2, 65535, 0);\n      this[offset] = value >>> 8;\n      this[offset + 1] = value & 255;\n      return offset + 2;\n    };\n    Buffer3.prototype.writeUint32LE = Buffer3.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {\n      value = +value;\n      offset = offset >>> 0;\n      if (!noAssert)\n        checkInt(this, value, offset, 4, 4294967295, 0);\n      this[offset + 3] = value >>> 24;\n      this[offset + 2] = value >>> 16;\n      this[offset + 1] = value >>> 8;\n      this[offset] = value & 255;\n      return offset + 4;\n    };\n    Buffer3.prototype.writeUint32BE = Buffer3.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {\n      value = +value;\n      offset = offset >>> 0;\n      if (!noAssert)\n        checkInt(this, value, offset, 4, 4294967295, 0);\n      this[offset] = value >>> 24;\n      this[offset + 1] = value >>> 16;\n      this[offset + 2] = value >>> 8;\n      this[offset + 3] = value & 255;\n      return offset + 4;\n    };\n    function wrtBigUInt64LE(buf, value, offset, min, max3) {\n      checkIntBI(value, min, max3, buf, offset, 7);\n      let lo = Number(value & BigInt(4294967295));\n      buf[offset++] = lo;\n      lo = lo >> 8;\n      buf[offset++] = lo;\n      lo = lo >> 8;\n      buf[offset++] = lo;\n      lo = lo >> 8;\n      buf[offset++] = lo;\n      let hi = Number(value >> BigInt(32) & BigInt(4294967295));\n      buf[offset++] = hi;\n      hi = hi >> 8;\n      buf[offset++] = hi;\n      hi = hi >> 8;\n      buf[offset++] = hi;\n      hi = hi >> 8;\n      buf[offset++] = hi;\n      return offset;\n    }\n    function wrtBigUInt64BE(buf, value, offset, min, max3) {\n      checkIntBI(value, min, max3, buf, offset, 7);\n      let lo = Number(value & BigInt(4294967295));\n      buf[offset + 7] = lo;\n      lo = lo >> 8;\n      buf[offset + 6] = lo;\n      lo = lo >> 8;\n      buf[offset + 5] = lo;\n      lo = lo >> 8;\n      buf[offset + 4] = lo;\n      let hi = Number(value >> BigInt(32) & BigInt(4294967295));\n      buf[offset + 3] = hi;\n      hi = hi >> 8;\n      buf[offset + 2] = hi;\n      hi = hi >> 8;\n      buf[offset + 1] = hi;\n      hi = hi >> 8;\n      buf[offset] = hi;\n      return offset + 8;\n    }\n    Buffer3.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {\n      return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt(\"0xffffffffffffffff\"));\n    });\n    Buffer3.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {\n      return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt(\"0xffffffffffffffff\"));\n    });\n    Buffer3.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {\n      value = +value;\n      offset = offset >>> 0;\n      if (!noAssert) {\n        const limit = Math.pow(2, 8 * byteLength2 - 1);\n        checkInt(this, value, offset, byteLength2, limit - 1, -limit);\n      }\n      let i = 0;\n      let mul = 1;\n      let sub = 0;\n      this[offset] = value & 255;\n      while (++i < byteLength2 && (mul *= 256)) {\n        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n          sub = 1;\n        }\n        this[offset + i] = (value / mul >> 0) - sub & 255;\n      }\n      return offset + byteLength2;\n    };\n    Buffer3.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {\n      value = +value;\n      offset = offset >>> 0;\n      if (!noAssert) {\n        const limit = Math.pow(2, 8 * byteLength2 - 1);\n        checkInt(this, value, offset, byteLength2, limit - 1, -limit);\n      }\n      let i = byteLength2 - 1;\n      let mul = 1;\n      let sub = 0;\n      this[offset + i] = value & 255;\n      while (--i >= 0 && (mul *= 256)) {\n        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n          sub = 1;\n        }\n        this[offset + i] = (value / mul >> 0) - sub & 255;\n      }\n      return offset + byteLength2;\n    };\n    Buffer3.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {\n      value = +value;\n      offset = offset >>> 0;\n      if (!noAssert)\n        checkInt(this, value, offset, 1, 127, -128);\n      if (value < 0)\n        value = 255 + value + 1;\n      this[offset] = value & 255;\n      return offset + 1;\n    };\n    Buffer3.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {\n      value = +value;\n      offset = offset >>> 0;\n      if (!noAssert)\n        checkInt(this, value, offset, 2, 32767, -32768);\n      this[offset] = value & 255;\n      this[offset + 1] = value >>> 8;\n      return offset + 2;\n    };\n    Buffer3.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {\n      value = +value;\n      offset = offset >>> 0;\n      if (!noAssert)\n        checkInt(this, value, offset, 2, 32767, -32768);\n      this[offset] = value >>> 8;\n      this[offset + 1] = value & 255;\n      return offset + 2;\n    };\n    Buffer3.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {\n      value = +value;\n      offset = offset >>> 0;\n      if (!noAssert)\n        checkInt(this, value, offset, 4, 2147483647, -2147483648);\n      this[offset] = value & 255;\n      this[offset + 1] = value >>> 8;\n      this[offset + 2] = value >>> 16;\n      this[offset + 3] = value >>> 24;\n      return offset + 4;\n    };\n    Buffer3.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {\n      value = +value;\n      offset = offset >>> 0;\n      if (!noAssert)\n        checkInt(this, value, offset, 4, 2147483647, -2147483648);\n      if (value < 0)\n        value = 4294967295 + value + 1;\n      this[offset] = value >>> 24;\n      this[offset + 1] = value >>> 16;\n      this[offset + 2] = value >>> 8;\n      this[offset + 3] = value & 255;\n      return offset + 4;\n    };\n    Buffer3.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {\n      return wrtBigUInt64LE(this, value, offset, -BigInt(\"0x8000000000000000\"), BigInt(\"0x7fffffffffffffff\"));\n    });\n    Buffer3.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {\n      return wrtBigUInt64BE(this, value, offset, -BigInt(\"0x8000000000000000\"), BigInt(\"0x7fffffffffffffff\"));\n    });\n    function checkIEEE754(buf, value, offset, ext, max3, min) {\n      if (offset + ext > buf.length)\n        throw new RangeError(\"Index out of range\");\n      if (offset < 0)\n        throw new RangeError(\"Index out of range\");\n    }\n    function writeFloat(buf, value, offset, littleEndian, noAssert) {\n      value = +value;\n      offset = offset >>> 0;\n      if (!noAssert) {\n        checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);\n      }\n      ieee754.write(buf, value, offset, littleEndian, 23, 4);\n      return offset + 4;\n    }\n    Buffer3.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {\n      return writeFloat(this, value, offset, true, noAssert);\n    };\n    Buffer3.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {\n      return writeFloat(this, value, offset, false, noAssert);\n    };\n    function writeDouble(buf, value, offset, littleEndian, noAssert) {\n      value = +value;\n      offset = offset >>> 0;\n      if (!noAssert) {\n        checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);\n      }\n      ieee754.write(buf, value, offset, littleEndian, 52, 8);\n      return offset + 8;\n    }\n    Buffer3.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {\n      return writeDouble(this, value, offset, true, noAssert);\n    };\n    Buffer3.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {\n      return writeDouble(this, value, offset, false, noAssert);\n    };\n    Buffer3.prototype.copy = function copy(target, targetStart, start, end) {\n      if (!Buffer3.isBuffer(target))\n        throw new TypeError(\"argument should be a Buffer\");\n      if (!start)\n        start = 0;\n      if (!end && end !== 0)\n        end = this.length;\n      if (targetStart >= target.length)\n        targetStart = target.length;\n      if (!targetStart)\n        targetStart = 0;\n      if (end > 0 && end < start)\n        end = start;\n      if (end === start)\n        return 0;\n      if (target.length === 0 || this.length === 0)\n        return 0;\n      if (targetStart < 0) {\n        throw new RangeError(\"targetStart out of bounds\");\n      }\n      if (start < 0 || start >= this.length)\n        throw new RangeError(\"Index out of range\");\n      if (end < 0)\n        throw new RangeError(\"sourceEnd out of bounds\");\n      if (end > this.length)\n        end = this.length;\n      if (target.length - targetStart < end - start) {\n        end = target.length - targetStart + start;\n      }\n      const len = end - start;\n      if (this === target && typeof Uint8Array.prototype.copyWithin === \"function\") {\n        this.copyWithin(targetStart, start, end);\n      } else {\n        Uint8Array.prototype.set.call(\n          target,\n          this.subarray(start, end),\n          targetStart\n        );\n      }\n      return len;\n    };\n    Buffer3.prototype.fill = function fill(val, start, end, encoding) {\n      if (typeof val === \"string\") {\n        if (typeof start === \"string\") {\n          encoding = start;\n          start = 0;\n          end = this.length;\n        } else if (typeof end === \"string\") {\n          encoding = end;\n          end = this.length;\n        }\n        if (encoding !== void 0 && typeof encoding !== \"string\") {\n          throw new TypeError(\"encoding must be a string\");\n        }\n        if (typeof encoding === \"string\" && !Buffer3.isEncoding(encoding)) {\n          throw new TypeError(\"Unknown encoding: \" + encoding);\n        }\n        if (val.length === 1) {\n          const code = val.charCodeAt(0);\n          if (encoding === \"utf8\" && code < 128 || encoding === \"latin1\") {\n            val = code;\n          }\n        }\n      } else if (typeof val === \"number\") {\n        val = val & 255;\n      } else if (typeof val === \"boolean\") {\n        val = Number(val);\n      }\n      if (start < 0 || this.length < start || this.length < end) {\n        throw new RangeError(\"Out of range index\");\n      }\n      if (end <= start) {\n        return this;\n      }\n      start = start >>> 0;\n      end = end === void 0 ? this.length : end >>> 0;\n      if (!val)\n        val = 0;\n      let i;\n      if (typeof val === \"number\") {\n        for (i = start; i < end; ++i) {\n          this[i] = val;\n        }\n      } else {\n        const bytes = Buffer3.isBuffer(val) ? val : Buffer3.from(val, encoding);\n        const len = bytes.length;\n        if (len === 0) {\n          throw new TypeError('The value \"' + val + '\" is invalid for argument \"value\"');\n        }\n        for (i = 0; i < end - start; ++i) {\n          this[i + start] = bytes[i % len];\n        }\n      }\n      return this;\n    };\n    var errors = {};\n    function E3(sym, getMessage, Base) {\n      errors[sym] = class NodeError extends Base {\n        constructor() {\n          super();\n          Object.defineProperty(this, \"message\", {\n            value: getMessage.apply(this, arguments),\n            writable: true,\n            configurable: true\n          });\n          this.name = `${this.name} [${sym}]`;\n          this.stack;\n          delete this.name;\n        }\n        get code() {\n          return sym;\n        }\n        set code(value) {\n          Object.defineProperty(this, \"code\", {\n            configurable: true,\n            enumerable: true,\n            value,\n            writable: true\n          });\n        }\n        toString() {\n          return `${this.name} [${sym}]: ${this.message}`;\n        }\n      };\n    }\n    E3(\n      \"ERR_BUFFER_OUT_OF_BOUNDS\",\n      function(name) {\n        if (name) {\n          return `${name} is outside of buffer bounds`;\n        }\n        return \"Attempt to access memory outside buffer bounds\";\n      },\n      RangeError\n    );\n    E3(\n      \"ERR_INVALID_ARG_TYPE\",\n      function(name, actual) {\n        return `The \"${name}\" argument must be of type number. Received type ${typeof actual}`;\n      },\n      TypeError\n    );\n    E3(\n      \"ERR_OUT_OF_RANGE\",\n      function(str, range, input) {\n        let msg = `The value of \"${str}\" is out of range.`;\n        let received = input;\n        if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {\n          received = addNumericalSeparator(String(input));\n        } else if (typeof input === \"bigint\") {\n          received = String(input);\n          if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {\n            received = addNumericalSeparator(received);\n          }\n          received += \"n\";\n        }\n        msg += ` It must be ${range}. Received ${received}`;\n        return msg;\n      },\n      RangeError\n    );\n    function addNumericalSeparator(val) {\n      let res = \"\";\n      let i = val.length;\n      const start = val[0] === \"-\" ? 1 : 0;\n      for (; i >= start + 4; i -= 3) {\n        res = `_${val.slice(i - 3, i)}${res}`;\n      }\n      return `${val.slice(0, i)}${res}`;\n    }\n    function checkBounds(buf, offset, byteLength2) {\n      validateNumber(offset, \"offset\");\n      if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {\n        boundsError(offset, buf.length - (byteLength2 + 1));\n      }\n    }\n    function checkIntBI(value, min, max3, buf, offset, byteLength2) {\n      if (value > max3 || value < min) {\n        const n = typeof min === \"bigint\" ? \"n\" : \"\";\n        let range;\n        if (byteLength2 > 3) {\n          if (min === 0 || min === BigInt(0)) {\n            range = `>= 0${n} and < 2${n} ** ${(byteLength2 + 1) * 8}${n}`;\n          } else {\n            range = `>= -(2${n} ** ${(byteLength2 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n}`;\n          }\n        } else {\n          range = `>= ${min}${n} and <= ${max3}${n}`;\n        }\n        throw new errors.ERR_OUT_OF_RANGE(\"value\", range, value);\n      }\n      checkBounds(buf, offset, byteLength2);\n    }\n    function validateNumber(value, name) {\n      if (typeof value !== \"number\") {\n        throw new errors.ERR_INVALID_ARG_TYPE(name, \"number\", value);\n      }\n    }\n    function boundsError(value, length, type3) {\n      if (Math.floor(value) !== value) {\n        validateNumber(value, type3);\n        throw new errors.ERR_OUT_OF_RANGE(type3 || \"offset\", \"an integer\", value);\n      }\n      if (length < 0) {\n        throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();\n      }\n      throw new errors.ERR_OUT_OF_RANGE(\n        type3 || \"offset\",\n        `>= ${type3 ? 1 : 0} and <= ${length}`,\n        value\n      );\n    }\n    var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;\n    function base64clean(str) {\n      str = str.split(\"=\")[0];\n      str = str.trim().replace(INVALID_BASE64_RE, \"\");\n      if (str.length < 2)\n        return \"\";\n      while (str.length % 4 !== 0) {\n        str = str + \"=\";\n      }\n      return str;\n    }\n    function utf8ToBytes(string, units) {\n      units = units || Infinity;\n      let codePoint;\n      const length = string.length;\n      let leadSurrogate = null;\n      const bytes = [];\n      for (let i = 0; i < length; ++i) {\n        codePoint = string.charCodeAt(i);\n        if (codePoint > 55295 && codePoint < 57344) {\n          if (!leadSurrogate) {\n            if (codePoint > 56319) {\n              if ((units -= 3) > -1)\n                bytes.push(239, 191, 189);\n              continue;\n            } else if (i + 1 === length) {\n              if ((units -= 3) > -1)\n                bytes.push(239, 191, 189);\n              continue;\n            }\n            leadSurrogate = codePoint;\n            continue;\n          }\n          if (codePoint < 56320) {\n            if ((units -= 3) > -1)\n              bytes.push(239, 191, 189);\n            leadSurrogate = codePoint;\n            continue;\n          }\n          codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;\n        } else if (leadSurrogate) {\n          if ((units -= 3) > -1)\n            bytes.push(239, 191, 189);\n        }\n        leadSurrogate = null;\n        if (codePoint < 128) {\n          if ((units -= 1) < 0)\n            break;\n          bytes.push(codePoint);\n        } else if (codePoint < 2048) {\n          if ((units -= 2) < 0)\n            break;\n          bytes.push(\n            codePoint >> 6 | 192,\n            codePoint & 63 | 128\n          );\n        } else if (codePoint < 65536) {\n          if ((units -= 3) < 0)\n            break;\n          bytes.push(\n            codePoint >> 12 | 224,\n            codePoint >> 6 & 63 | 128,\n            codePoint & 63 | 128\n          );\n        } else if (codePoint < 1114112) {\n          if ((units -= 4) < 0)\n            break;\n          bytes.push(\n            codePoint >> 18 | 240,\n            codePoint >> 12 & 63 | 128,\n            codePoint >> 6 & 63 | 128,\n            codePoint & 63 | 128\n          );\n        } else {\n          throw new Error(\"Invalid code point\");\n        }\n      }\n      return bytes;\n    }\n    function asciiToBytes(str) {\n      const byteArray = [];\n      for (let i = 0; i < str.length; ++i) {\n        byteArray.push(str.charCodeAt(i) & 255);\n      }\n      return byteArray;\n    }\n    function utf16leToBytes(str, units) {\n      let c2, hi, lo;\n      const byteArray = [];\n      for (let i = 0; i < str.length; ++i) {\n        if ((units -= 2) < 0)\n          break;\n        c2 = str.charCodeAt(i);\n        hi = c2 >> 8;\n        lo = c2 % 256;\n        byteArray.push(lo);\n        byteArray.push(hi);\n      }\n      return byteArray;\n    }\n    function base64ToBytes(str) {\n      return base64.toByteArray(base64clean(str));\n    }\n    function blitBuffer(src, dst, offset, length) {\n      let i;\n      for (i = 0; i < length; ++i) {\n        if (i + offset >= dst.length || i >= src.length)\n          break;\n        dst[i + offset] = src[i];\n      }\n      return i;\n    }\n    function isInstance(obj, type3) {\n      return obj instanceof type3 || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type3.name;\n    }\n    function numberIsNaN(obj) {\n      return obj !== obj;\n    }\n    var hexSliceLookupTable = function() {\n      const alphabet = \"0123456789abcdef\";\n      const table = new Array(256);\n      for (let i = 0; i < 16; ++i) {\n        const i16 = i * 16;\n        for (let j2 = 0; j2 < 16; ++j2) {\n          table[i16 + j2] = alphabet[i] + alphabet[j2];\n        }\n      }\n      return table;\n    }();\n    function defineBigIntMethod(fn) {\n      return typeof BigInt === \"undefined\" ? BufferBigIntNotDefined : fn;\n    }\n    function BufferBigIntNotDefined() {\n      throw new Error(\"BigInt not supported\");\n    }\n  }\n});\n\n// node_modules/@permaweb/ao-scheduler-utils/dist/browser.js\nfunction c(r3) {\n  return r3 != null && typeof r3 == \"object\" && r3[\"@@functional/placeholder\"] === true;\n}\nfunction h(r3) {\n  return function t(e) {\n    return arguments.length === 0 || c(e) ? t : r3.apply(this, arguments);\n  };\n}\nfunction u(r3) {\n  return function t(e, o) {\n    switch (arguments.length) {\n      case 0:\n        return t;\n      case 1:\n        return c(e) ? t : h(function(n) {\n          return r3(e, n);\n        });\n      default:\n        return c(e) && c(o) ? t : c(e) ? h(function(n) {\n          return r3(n, o);\n        }) : c(o) ? h(function(n) {\n          return r3(e, n);\n        }) : r3(e, o);\n    }\n  };\n}\nfunction b(r3, t) {\n  switch (r3) {\n    case 0:\n      return function() {\n        return t.apply(this, arguments);\n      };\n    case 1:\n      return function(e) {\n        return t.apply(this, arguments);\n      };\n    case 2:\n      return function(e, o) {\n        return t.apply(this, arguments);\n      };\n    case 3:\n      return function(e, o, n) {\n        return t.apply(this, arguments);\n      };\n    case 4:\n      return function(e, o, n, i) {\n        return t.apply(this, arguments);\n      };\n    case 5:\n      return function(e, o, n, i, a) {\n        return t.apply(this, arguments);\n      };\n    case 6:\n      return function(e, o, n, i, a, f) {\n        return t.apply(this, arguments);\n      };\n    case 7:\n      return function(e, o, n, i, a, f, s) {\n        return t.apply(this, arguments);\n      };\n    case 8:\n      return function(e, o, n, i, a, f, s, l) {\n        return t.apply(this, arguments);\n      };\n    case 9:\n      return function(e, o, n, i, a, f, s, l, _2) {\n        return t.apply(this, arguments);\n      };\n    case 10:\n      return function(e, o, n, i, a, f, s, l, _2, d) {\n        return t.apply(this, arguments);\n      };\n    default:\n      throw new Error(\"First argument to _arity must be a non-negative integer no greater than ten\");\n  }\n}\nfunction J(r3, t, e) {\n  return function() {\n    for (var o = [], n = 0, i = r3, a = 0, f = false; a < t.length || n < arguments.length; ) {\n      var s;\n      a < t.length && (!c(t[a]) || n >= arguments.length) ? s = t[a] : (s = arguments[n], n += 1), o[a] = s, c(s) ? f = true : i -= 1, a += 1;\n    }\n    return !f && i <= 0 ? e.apply(this, o) : b(Math.max(0, i), J(r3, o, e));\n  };\n}\nvar we = u(function(t, e) {\n  return t === 1 ? h(e) : b(t, J(t, [], e));\n});\nvar K = we;\nfunction P(r3) {\n  return function t(e, o, n) {\n    switch (arguments.length) {\n      case 0:\n        return t;\n      case 1:\n        return c(e) ? t : u(function(i, a) {\n          return r3(e, i, a);\n        });\n      case 2:\n        return c(e) && c(o) ? t : c(e) ? u(function(i, a) {\n          return r3(i, o, a);\n        }) : c(o) ? u(function(i, a) {\n          return r3(e, i, a);\n        }) : h(function(i) {\n          return r3(e, o, i);\n        });\n      default:\n        return c(e) && c(o) && c(n) ? t : c(e) && c(o) ? u(function(i, a) {\n          return r3(i, a, n);\n        }) : c(e) && c(n) ? u(function(i, a) {\n          return r3(i, o, a);\n        }) : c(o) && c(n) ? u(function(i, a) {\n          return r3(e, i, a);\n        }) : c(e) ? h(function(i) {\n          return r3(i, o, n);\n        }) : c(o) ? h(function(i) {\n          return r3(e, i, n);\n        }) : c(n) ? h(function(i) {\n          return r3(e, o, i);\n        }) : r3(e, o, n);\n    }\n  };\n}\nvar U = Array.isArray || function(t) {\n  return t != null && t.length >= 0 && Object.prototype.toString.call(t) === \"[object Array]\";\n};\nfunction ct(r3) {\n  return r3 != null && typeof r3[\"@@transducer/step\"] == \"function\";\n}\nfunction D(r3, t, e) {\n  return function() {\n    if (arguments.length === 0)\n      return e();\n    var o = arguments[arguments.length - 1];\n    if (!U(o)) {\n      for (var n = 0; n < r3.length; ) {\n        if (typeof o[r3[n]] == \"function\")\n          return o[r3[n]].apply(o, Array.prototype.slice.call(arguments, 0, -1));\n        n += 1;\n      }\n      if (ct(o)) {\n        var i = t.apply(null, Array.prototype.slice.call(arguments, 0, -1));\n        return i(o);\n      }\n    }\n    return e.apply(this, arguments);\n  };\n}\nfunction pt(r3) {\n  return r3 && r3[\"@@transducer/reduced\"] ? r3 : { \"@@transducer/value\": r3, \"@@transducer/reduced\": true };\n}\nvar F = { init: function() {\n  return this.xf[\"@@transducer/init\"]();\n}, result: function(r3) {\n  return this.xf[\"@@transducer/result\"](r3);\n} };\nfunction Q(r3) {\n  for (var t = [], e; !(e = r3.next()).done; )\n    t.push(e.value);\n  return t;\n}\nfunction Z(r3, t, e) {\n  for (var o = 0, n = e.length; o < n; ) {\n    if (r3(t, e[o]))\n      return true;\n    o += 1;\n  }\n  return false;\n}\nfunction ht(r3) {\n  var t = String(r3).match(/^function (\\w*)/);\n  return t == null ? \"\" : t[1];\n}\nfunction C(r3, t) {\n  return Object.prototype.hasOwnProperty.call(t, r3);\n}\nfunction Se(r3, t) {\n  return r3 === t ? r3 !== 0 || 1 / r3 === 1 / t : r3 !== r3 && t !== t;\n}\nvar tt = typeof Object.is == \"function\" ? Object.is : Se;\nvar Pt = Object.prototype.toString;\nvar ve = function() {\n  return Pt.call(arguments) === \"[object Arguments]\" ? function(t) {\n    return Pt.call(t) === \"[object Arguments]\";\n  } : function(t) {\n    return C(\"callee\", t);\n  };\n}();\nvar Dt = ve;\nvar Oe = !{ toString: null }.propertyIsEnumerable(\"toString\");\nvar Ut = [\"constructor\", \"valueOf\", \"isPrototypeOf\", \"toString\", \"propertyIsEnumerable\", \"hasOwnProperty\", \"toLocaleString\"];\nvar Nt = function() {\n  \"use strict\";\n  return arguments.propertyIsEnumerable(\"length\");\n}();\nvar Ae = function(t, e) {\n  for (var o = 0; o < t.length; ) {\n    if (t[o] === e)\n      return true;\n    o += 1;\n  }\n  return false;\n};\nvar be = typeof Object.keys == \"function\" && !Nt ? h(function(t) {\n  return Object(t) !== t ? [] : Object.keys(t);\n}) : h(function(t) {\n  if (Object(t) !== t)\n    return [];\n  var e, o, n = [], i = Nt && Dt(t);\n  for (e in t)\n    C(e, t) && (!i || e !== \"length\") && (n[n.length] = e);\n  if (Oe)\n    for (o = Ut.length - 1; o >= 0; )\n      e = Ut[o], C(e, t) && !Ae(n, e) && (n[n.length] = e), o -= 1;\n  return n;\n});\nvar O = be;\nvar Te = h(function(t) {\n  return t === null ? \"Null\" : t === void 0 ? \"Undefined\" : Object.prototype.toString.call(t).slice(8, -1);\n});\nvar dt = Te;\nfunction Bt(r3, t, e, o) {\n  var n = Q(r3), i = Q(t);\n  function a(f, s) {\n    return q(f, s, e.slice(), o.slice());\n  }\n  return !Z(function(f, s) {\n    return !Z(a, s, f);\n  }, i, n);\n}\nfunction q(r3, t, e, o) {\n  if (tt(r3, t))\n    return true;\n  var n = dt(r3);\n  if (n !== dt(t))\n    return false;\n  if (typeof r3[\"fantasy-land/equals\"] == \"function\" || typeof t[\"fantasy-land/equals\"] == \"function\")\n    return typeof r3[\"fantasy-land/equals\"] == \"function\" && r3[\"fantasy-land/equals\"](t) && typeof t[\"fantasy-land/equals\"] == \"function\" && t[\"fantasy-land/equals\"](r3);\n  if (typeof r3.equals == \"function\" || typeof t.equals == \"function\")\n    return typeof r3.equals == \"function\" && r3.equals(t) && typeof t.equals == \"function\" && t.equals(r3);\n  switch (n) {\n    case \"Arguments\":\n    case \"Array\":\n    case \"Object\":\n      if (typeof r3.constructor == \"function\" && ht(r3.constructor) === \"Promise\")\n        return r3 === t;\n      break;\n    case \"Boolean\":\n    case \"Number\":\n    case \"String\":\n      if (!(typeof r3 == typeof t && tt(r3.valueOf(), t.valueOf())))\n        return false;\n      break;\n    case \"Date\":\n      if (!tt(r3.valueOf(), t.valueOf()))\n        return false;\n      break;\n    case \"Error\":\n      return r3.name === t.name && r3.message === t.message;\n    case \"RegExp\":\n      if (!(r3.source === t.source && r3.global === t.global && r3.ignoreCase === t.ignoreCase && r3.multiline === t.multiline && r3.sticky === t.sticky && r3.unicode === t.unicode))\n        return false;\n      break;\n  }\n  for (var i = e.length - 1; i >= 0; ) {\n    if (e[i] === r3)\n      return o[i] === t;\n    i -= 1;\n  }\n  switch (n) {\n    case \"Map\":\n      return r3.size !== t.size ? false : Bt(r3.entries(), t.entries(), e.concat([r3]), o.concat([t]));\n    case \"Set\":\n      return r3.size !== t.size ? false : Bt(r3.values(), t.values(), e.concat([r3]), o.concat([t]));\n    case \"Arguments\":\n    case \"Array\":\n    case \"Object\":\n    case \"Boolean\":\n    case \"Number\":\n    case \"String\":\n    case \"Date\":\n    case \"Error\":\n    case \"RegExp\":\n    case \"Int8Array\":\n    case \"Uint8Array\":\n    case \"Uint8ClampedArray\":\n    case \"Int16Array\":\n    case \"Uint16Array\":\n    case \"Int32Array\":\n    case \"Uint32Array\":\n    case \"Float32Array\":\n    case \"Float64Array\":\n    case \"ArrayBuffer\":\n      break;\n    default:\n      return false;\n  }\n  var a = O(r3);\n  if (a.length !== O(t).length)\n    return false;\n  var f = e.concat([r3]), s = o.concat([t]);\n  for (i = a.length - 1; i >= 0; ) {\n    var l = a[i];\n    if (!(C(l, t) && q(t[l], r3[l], f, s)))\n      return false;\n    i -= 1;\n  }\n  return true;\n}\nvar Ee = u(function(t, e) {\n  return q(t, e, [], []);\n});\nvar et = Ee;\nfunction mt(r3, t, e) {\n  var o, n;\n  if (typeof r3.indexOf == \"function\")\n    switch (typeof t) {\n      case \"number\":\n        if (t === 0) {\n          for (o = 1 / t; e < r3.length; ) {\n            if (n = r3[e], n === 0 && 1 / n === o)\n              return e;\n            e += 1;\n          }\n          return -1;\n        } else if (t !== t) {\n          for (; e < r3.length; ) {\n            if (n = r3[e], typeof n == \"number\" && n !== n)\n              return e;\n            e += 1;\n          }\n          return -1;\n        }\n        return r3.indexOf(t, e);\n      case \"string\":\n      case \"boolean\":\n      case \"function\":\n      case \"undefined\":\n        return r3.indexOf(t, e);\n      case \"object\":\n        if (t === null)\n          return r3.indexOf(t, e);\n    }\n  for (; e < r3.length; ) {\n    if (et(r3[e], t))\n      return e;\n    e += 1;\n  }\n  return -1;\n}\nfunction gt(r3, t) {\n  return mt(t, r3, 0) >= 0;\n}\nfunction T(r3, t) {\n  for (var e = 0, o = t.length, n = Array(o); e < o; )\n    n[e] = r3(t[e]), e += 1;\n  return n;\n}\nfunction k(r3) {\n  var t = r3.replace(/\\\\/g, \"\\\\\\\\\").replace(/[\\b]/g, \"\\\\b\").replace(/\\f/g, \"\\\\f\").replace(/\\n/g, \"\\\\n\").replace(/\\r/g, \"\\\\r\").replace(/\\t/g, \"\\\\t\").replace(/\\v/g, \"\\\\v\").replace(/\\0/g, \"\\\\0\");\n  return '\"' + t.replace(/\"/g, '\\\\\"') + '\"';\n}\nvar M = function(t) {\n  return (t < 10 ? \"0\" : \"\") + t;\n};\nvar We = typeof Date.prototype.toISOString == \"function\" ? function(t) {\n  return t.toISOString();\n} : function(t) {\n  return t.getUTCFullYear() + \"-\" + M(t.getUTCMonth() + 1) + \"-\" + M(t.getUTCDate()) + \"T\" + M(t.getUTCHours()) + \":\" + M(t.getUTCMinutes()) + \":\" + M(t.getUTCSeconds()) + \".\" + (t.getUTCMilliseconds() / 1e3).toFixed(3).slice(2, 5) + \"Z\";\n};\nvar qt = We;\nfunction xt(r3) {\n  return function() {\n    return !r3.apply(this, arguments);\n  };\n}\nfunction G(r3, t, e) {\n  for (var o = 0, n = e.length; o < n; )\n    t = r3(t, e[o]), o += 1;\n  return t;\n}\nfunction yt(r3, t) {\n  for (var e = 0, o = t.length, n = []; e < o; )\n    r3(t[e]) && (n[n.length] = t[e]), e += 1;\n  return n;\n}\nfunction _t(r3) {\n  return Object.prototype.toString.call(r3) === \"[object Object]\";\n}\nvar Fe = function() {\n  function r3(t, e) {\n    this.xf = e, this.f = t;\n  }\n  return r3.prototype[\"@@transducer/init\"] = F.init, r3.prototype[\"@@transducer/result\"] = F.result, r3.prototype[\"@@transducer/step\"] = function(t, e) {\n    return this.f(e) ? this.xf[\"@@transducer/step\"](t, e) : t;\n  }, r3;\n}();\nfunction wt(r3) {\n  return function(t) {\n    return new Fe(r3, t);\n  };\n}\nvar Ce = u(D([\"fantasy-land/filter\", \"filter\"], wt, function(r3, t) {\n  return _t(t) ? G(function(e, o) {\n    return r3(t[o]) && (e[o] = t[o]), e;\n  }, {}, O(t)) : yt(r3, t);\n}));\nvar kt = Ce;\nvar Ie = u(function(t, e) {\n  return kt(xt(t), e);\n});\nvar Mt = Ie;\nfunction rt(r3, t) {\n  var e = function(a) {\n    var f = t.concat([r3]);\n    return gt(a, f) ? \"<Circular>\" : rt(a, f);\n  }, o = function(i, a) {\n    return T(function(f) {\n      return k(f) + \": \" + e(i[f]);\n    }, a.slice().sort());\n  };\n  switch (Object.prototype.toString.call(r3)) {\n    case \"[object Arguments]\":\n      return \"(function() { return arguments; }(\" + T(e, r3).join(\", \") + \"))\";\n    case \"[object Array]\":\n      return \"[\" + T(e, r3).concat(o(r3, Mt(function(i) {\n        return /^\\d+$/.test(i);\n      }, O(r3)))).join(\", \") + \"]\";\n    case \"[object Boolean]\":\n      return typeof r3 == \"object\" ? \"new Boolean(\" + e(r3.valueOf()) + \")\" : r3.toString();\n    case \"[object Date]\":\n      return \"new Date(\" + (isNaN(r3.valueOf()) ? e(NaN) : k(qt(r3))) + \")\";\n    case \"[object Map]\":\n      return \"new Map(\" + e(Array.from(r3)) + \")\";\n    case \"[object Null]\":\n      return \"null\";\n    case \"[object Number]\":\n      return typeof r3 == \"object\" ? \"new Number(\" + e(r3.valueOf()) + \")\" : 1 / r3 === -1 / 0 ? \"-0\" : r3.toString(10);\n    case \"[object Set]\":\n      return \"new Set(\" + e(Array.from(r3).sort()) + \")\";\n    case \"[object String]\":\n      return typeof r3 == \"object\" ? \"new String(\" + e(r3.valueOf()) + \")\" : k(r3);\n    case \"[object Undefined]\":\n      return \"undefined\";\n    default:\n      if (typeof r3.toString == \"function\") {\n        var n = r3.toString();\n        if (n !== \"[object Object]\")\n          return n;\n      }\n      return \"{\" + o(r3, O(r3)).join(\", \") + \"}\";\n  }\n}\nvar je = h(function(t) {\n  return rt(t, []);\n});\nvar St = je;\nvar Re = u(function(t, e) {\n  if (t === e)\n    return e;\n  function o(s, l) {\n    if (s > l != l > s)\n      return l > s ? l : s;\n  }\n  var n = o(t, e);\n  if (n !== void 0)\n    return n;\n  var i = o(typeof t, typeof e);\n  if (i !== void 0)\n    return i === typeof t ? t : e;\n  var a = St(t), f = o(a, St(e));\n  return f !== void 0 && f === a ? t : e;\n});\nvar Gt = Re;\nvar Le = function() {\n  function r3(t, e) {\n    this.xf = e, this.f = t;\n  }\n  return r3.prototype[\"@@transducer/init\"] = F.init, r3.prototype[\"@@transducer/result\"] = F.result, r3.prototype[\"@@transducer/step\"] = function(t, e) {\n    return this.xf[\"@@transducer/step\"](t, this.f(e));\n  }, r3;\n}();\nvar ze = function(t) {\n  return function(e) {\n    return new Le(t, e);\n  };\n};\nvar Ht = ze;\nvar Pe = u(D([\"fantasy-land/map\", \"map\"], Ht, function(t, e) {\n  switch (Object.prototype.toString.call(e)) {\n    case \"[object Function]\":\n      return K(e.length, function() {\n        return t.call(this, e.apply(this, arguments));\n      });\n    case \"[object Object]\":\n      return G(function(o, n) {\n        return o[n] = t(e[n]), o;\n      }, {}, O(e));\n    default:\n      return T(t, e);\n  }\n}));\nvar $t = Pe;\nvar ot = Number.isInteger || function(t) {\n  return t << 0 === t;\n};\nfunction H(r3) {\n  return Object.prototype.toString.call(r3) === \"[object String]\";\n}\nvar De = u(function(t, e) {\n  var o = t < 0 ? e.length + t : t;\n  return H(e) ? e.charAt(o) : e[o];\n});\nvar nt = De;\nvar Ue = u(function(t, e) {\n  if (e != null)\n    return ot(t) ? nt(t, e) : e[t];\n});\nvar I = Ue;\nvar Ne = u(function(t, e) {\n  return $t(I(t), e);\n});\nvar Xt = Ne;\nvar Be = h(function(t) {\n  return U(t) ? true : !t || typeof t != \"object\" || H(t) ? false : t.length === 0 ? true : t.length > 0 ? t.hasOwnProperty(0) && t.hasOwnProperty(t.length - 1) : false;\n});\nvar Vt = Be;\nvar Yt = typeof Symbol < \"u\" ? Symbol.iterator : \"@@iterator\";\nfunction vt(r3, t, e) {\n  return function(n, i, a) {\n    if (Vt(a))\n      return r3(n, i, a);\n    if (a == null)\n      return i;\n    if (typeof a[\"fantasy-land/reduce\"] == \"function\")\n      return t(n, i, a, \"fantasy-land/reduce\");\n    if (a[Yt] != null)\n      return e(n, i, a[Yt]());\n    if (typeof a.next == \"function\")\n      return e(n, i, a);\n    if (typeof a.reduce == \"function\")\n      return t(n, i, a, \"reduce\");\n    throw new TypeError(\"reduce: list must be array or iterable\");\n  };\n}\nfunction Ot(r3, t, e) {\n  for (var o = 0, n = e.length; o < n; ) {\n    if (t = r3[\"@@transducer/step\"](t, e[o]), t && t[\"@@transducer/reduced\"]) {\n      t = t[\"@@transducer/value\"];\n      break;\n    }\n    o += 1;\n  }\n  return r3[\"@@transducer/result\"](t);\n}\nvar qe = u(function(t, e) {\n  return b(t.length, function() {\n    return t.apply(e, arguments);\n  });\n});\nvar Jt = qe;\nfunction ke(r3, t, e) {\n  for (var o = e.next(); !o.done; ) {\n    if (t = r3[\"@@transducer/step\"](t, o.value), t && t[\"@@transducer/reduced\"]) {\n      t = t[\"@@transducer/value\"];\n      break;\n    }\n    o = e.next();\n  }\n  return r3[\"@@transducer/result\"](t);\n}\nfunction Me(r3, t, e, o) {\n  return r3[\"@@transducer/result\"](e[o](Jt(r3[\"@@transducer/step\"], r3), t));\n}\nvar Ge = vt(Ot, Me, ke);\nvar Kt = Ge;\nvar He = function() {\n  function r3(t) {\n    this.f = t;\n  }\n  return r3.prototype[\"@@transducer/init\"] = function() {\n    throw new Error(\"init not implemented on XWrap\");\n  }, r3.prototype[\"@@transducer/result\"] = function(t) {\n    return t;\n  }, r3.prototype[\"@@transducer/step\"] = function(t, e) {\n    return this.f(t, e);\n  }, r3;\n}();\nfunction At(r3) {\n  return new He(r3);\n}\nvar $e = P(function(r3, t, e) {\n  return Kt(typeof r3 == \"function\" ? At(r3) : r3, t, e);\n});\nvar it = $e;\nfunction bt(r3, t) {\n  return function() {\n    return t.call(this, r3.apply(this, arguments));\n  };\n}\nfunction $(r3, t) {\n  return function() {\n    var e = arguments.length;\n    if (e === 0)\n      return t();\n    var o = arguments[e - 1];\n    return U(o) || typeof o[r3] != \"function\" ? t.apply(this, arguments) : o[r3].apply(o, Array.prototype.slice.call(arguments, 0, e - 1));\n  };\n}\nvar Xe = P($(\"slice\", function(t, e, o) {\n  return Array.prototype.slice.call(o, t, e);\n}));\nvar Qt = Xe;\nvar Ve = h($(\"tail\", Qt(1, 1 / 0)));\nvar Zt = Ve;\nfunction X() {\n  if (arguments.length === 0)\n    throw new Error(\"pipe requires at least one argument\");\n  return b(arguments[0].length, it(bt, arguments[0], Zt(arguments)));\n}\nvar Ye = u(function(t, e) {\n  return K(it(Gt, 0, Xt(\"length\", e)), function() {\n    var o = arguments, n = this;\n    return t.apply(n, T(function(i) {\n      return i.apply(n, o);\n    }, e));\n  });\n});\nvar te = Ye;\nvar Je = u(function(t, e) {\n  return e == null || e !== e ? t : e;\n});\nvar V = Je;\nvar Ke = function() {\n  function r3(t, e) {\n    this.xf = e, this.f = t, this.found = false;\n  }\n  return r3.prototype[\"@@transducer/init\"] = F.init, r3.prototype[\"@@transducer/result\"] = function(t) {\n    return this.found || (t = this.xf[\"@@transducer/step\"](t, void 0)), this.xf[\"@@transducer/result\"](t);\n  }, r3.prototype[\"@@transducer/step\"] = function(t, e) {\n    return this.f(e) && (this.found = true, t = pt(this.xf[\"@@transducer/step\"](t, e))), t;\n  }, r3;\n}();\nfunction Tt(r3) {\n  return function(t) {\n    return new Ke(r3, t);\n  };\n}\nvar Qe = u(D([\"find\"], Tt, function(t, e) {\n  for (var o = 0, n = e.length; o < n; ) {\n    if (t(e[o]))\n      return e[o];\n    o += 1;\n  }\n}));\nvar Et = Qe;\nvar Ze = h(function(t) {\n  return te(function() {\n    return Array.prototype.slice.call(arguments, 0);\n  }, t);\n});\nvar Wt = Ze;\nvar tr = u(function(t, e) {\n  return t.map(function(o) {\n    for (var n = e, i = 0, a; i < o.length; ) {\n      if (n == null)\n        return;\n      a = o[i], n = ot(a) ? nt(a, n) : n[a], i += 1;\n    }\n    return n;\n  });\n});\nvar ee = tr;\nvar er = u(function(t, e) {\n  return ee([t], e)[0];\n});\nvar at = er;\nvar rr = P(function(t, e, o) {\n  return et(t, I(e, o));\n});\nvar Ft = rr;\nvar E = class extends Error {\n  name = \"InvalidSchedulerLocation\";\n};\nvar st = class extends Error {\n  name = \"SchedulerTagNotFound\";\n};\nvar ft = class extends Error {\n  name = \"TransactionNotFound\";\n};\nvar or = \"Url\";\nvar nr = \"Time-To-Live\";\nvar ir = \"Scheduler\";\nvar Ct = (r3) => X(V([]), Et(Ft(r3, \"name\")), V({}), I(\"value\"));\nvar re = (r3) => X((t) => {\n  if (!t)\n    throw new ft(r3);\n  return t;\n}, I(\"tags\"), V([]));\nfunction oe({ fetch: r3, GRAPHQL_URL: t }) {\n  return async ({ query: e, variables: o }) => r3(t, { method: \"POST\", headers: { \"Content-Type\": \"application/json\" }, body: JSON.stringify({ query: e, variables: o }) }).then((n) => n.json());\n}\nfunction ne({ fetch: r3, GRAPHQL_URL: t }) {\n  let e = oe({ fetch: r3, GRAPHQL_URL: t }), o = It({ fetch: r3, GRAPHQL_URL: t }), n = `\n    query GetTransactions ($transactionIds: [ID!]!) {\n      transactions(ids: $transactionIds) {\n        edges {\n          node {\n            tags {\n              name\n              value\n            }\n          }\n        }\n      }\n    }\n  `;\n  return async (i) => e({ query: n, variables: { transactionIds: [i] } }).then(at([\"data\", \"transactions\", \"edges\", \"0\", \"node\"])).then(re(`Process ${i} was not found on gateway`)).then(Ct(ir)).then((a) => {\n    if (!a)\n      throw new st('No \"Scheduler\" tag found on process');\n    return o(a);\n  });\n}\nfunction It({ fetch: r3, GRAPHQL_URL: t }) {\n  let e = oe({ fetch: r3, GRAPHQL_URL: t }), o = `\n    query GetSchedulerLocation ($owner: String!) {\n      transactions (\n        owners: [$owner]\n        tags: [\n          { name: \"Data-Protocol\", values: [\"ao\"] },\n          { name: \"Type\", values: [\"Scheduler-Location\"] }\n        ]\n        # Only need the most recent Scheduler-Location\n        sort: HEIGHT_DESC\n        first: 1\n      ) {\n        edges {\n          node {\n            tags {\n              name\n              value\n            }\n          }\n        }\n      }\n    }\n  `;\n  return async (n) => e({ query: o, variables: { owner: n } }).then(at([\"data\", \"transactions\", \"edges\", \"0\", \"node\"])).then(re(`Could not find 'Scheduler-Location' owner by wallet ${n}`)).then(Wt([Ct(or), Ct(nr)])).then(([i, a]) => {\n    if (!i)\n      throw new E('No \"Url\" tag found on Scheduler-Location');\n    if (!a)\n      throw new E('No \"Time-To-Live\" tag found on Scheduler-Location');\n    return { url: i, ttl: a, owner: n };\n  });\n}\nvar N = typeof performance == \"object\" && performance && typeof performance.now == \"function\" ? performance : Date;\nvar ae = /* @__PURE__ */ new Set();\nvar jt = typeof process == \"object\" && process ? process : {};\nvar se = (r3, t, e, o) => {\n  typeof jt.emitWarning == \"function\" ? jt.emitWarning(r3, t, e, o) : console.error(`[${e}] ${t}: ${r3}`);\n};\nvar ut = globalThis.AbortController;\nvar ie = globalThis.AbortSignal;\nif (typeof ut > \"u\") {\n  ie = class {\n    onabort;\n    _onabort = [];\n    reason;\n    aborted = false;\n    addEventListener(o, n) {\n      this._onabort.push(n);\n    }\n  }, ut = class {\n    constructor() {\n      t();\n    }\n    signal = new ie();\n    abort(o) {\n      if (!this.signal.aborted) {\n        this.signal.reason = o, this.signal.aborted = true;\n        for (let n of this.signal._onabort)\n          n(o);\n        this.signal.onabort?.(o);\n      }\n    }\n  };\n  let r3 = jt.env?.LRU_CACHE_IGNORE_AC_WARNING !== \"1\", t = () => {\n    r3 && (r3 = false, se(\"AbortController is not defined. If using lru-cache in node 14, load an AbortController polyfill from the `node-abort-controller` package. A minimal polyfill is provided for use by LRUCache.fetch(), but it should not be relied upon in other contexts (eg, passing it to other APIs that use AbortController/AbortSignal might have undesirable effects). You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.\", \"NO_ABORT_CONTROLLER\", \"ENOTSUP\", t));\n  };\n}\nvar sr = (r3) => !ae.has(r3);\nvar ki = Symbol(\"type\");\nvar j = (r3) => r3 && r3 === Math.floor(r3) && r3 > 0 && isFinite(r3);\nvar fe = (r3) => j(r3) ? r3 <= Math.pow(2, 8) ? Uint8Array : r3 <= Math.pow(2, 16) ? Uint16Array : r3 <= Math.pow(2, 32) ? Uint32Array : r3 <= Number.MAX_SAFE_INTEGER ? B : null : null;\nvar B = class extends Array {\n  constructor(t) {\n    super(t), this.fill(0);\n  }\n};\nvar Rt = class r {\n  heap;\n  length;\n  static #f = false;\n  static create(t) {\n    let e = fe(t);\n    if (!e)\n      return [];\n    r.#f = true;\n    let o = new r(t, e);\n    return r.#f = false, o;\n  }\n  constructor(t, e) {\n    if (!r.#f)\n      throw new TypeError(\"instantiate Stack using Stack.create(n)\");\n    this.heap = new e(t), this.length = 0;\n  }\n  push(t) {\n    this.heap[this.length++] = t;\n  }\n  pop() {\n    return this.heap[--this.length];\n  }\n};\nvar lt = class r2 {\n  #f;\n  #c;\n  #m;\n  #g;\n  #F;\n  ttl;\n  ttlResolution;\n  ttlAutopurge;\n  updateAgeOnGet;\n  updateAgeOnHas;\n  allowStale;\n  noDisposeOnSet;\n  noUpdateTTL;\n  maxEntrySize;\n  sizeCalculation;\n  noDeleteOnFetchRejection;\n  noDeleteOnStaleGet;\n  allowStaleOnFetchAbort;\n  allowStaleOnFetchRejection;\n  ignoreFetchAbort;\n  #n;\n  #x;\n  #o;\n  #r;\n  #t;\n  #u;\n  #p;\n  #s;\n  #i;\n  #y;\n  #a;\n  #_;\n  #w;\n  #h;\n  #S;\n  #b;\n  #l;\n  static unsafeExposeInternals(t) {\n    return { starts: t.#w, ttls: t.#h, sizes: t.#_, keyMap: t.#o, keyList: t.#r, valList: t.#t, next: t.#u, prev: t.#p, get head() {\n      return t.#s;\n    }, get tail() {\n      return t.#i;\n    }, free: t.#y, isBackgroundFetch: (e) => t.#e(e), backgroundFetch: (e, o, n, i) => t.#j(e, o, n, i), moveToTail: (e) => t.#W(e), indexes: (e) => t.#v(e), rindexes: (e) => t.#O(e), isStale: (e) => t.#d(e) };\n  }\n  get max() {\n    return this.#f;\n  }\n  get maxSize() {\n    return this.#c;\n  }\n  get calculatedSize() {\n    return this.#x;\n  }\n  get size() {\n    return this.#n;\n  }\n  get fetchMethod() {\n    return this.#F;\n  }\n  get dispose() {\n    return this.#m;\n  }\n  get disposeAfter() {\n    return this.#g;\n  }\n  constructor(t) {\n    let { max: e = 0, ttl: o, ttlResolution: n = 1, ttlAutopurge: i, updateAgeOnGet: a, updateAgeOnHas: f, allowStale: s, dispose: l, disposeAfter: _2, noDisposeOnSet: d, noUpdateTTL: g, maxSize: m = 0, maxEntrySize: L = 0, sizeCalculation: x2, fetchMethod: S, noDeleteOnFetchRejection: p, noDeleteOnStaleGet: w2, allowStaleOnFetchRejection: A, allowStaleOnFetchAbort: y, ignoreFetchAbort: v2 } = t;\n    if (e !== 0 && !j(e))\n      throw new TypeError(\"max option must be a nonnegative integer\");\n    let z3 = e ? fe(e) : Array;\n    if (!z3)\n      throw new Error(\"invalid max value: \" + e);\n    if (this.#f = e, this.#c = m, this.maxEntrySize = L || this.#c, this.sizeCalculation = x2, this.sizeCalculation) {\n      if (!this.#c && !this.maxEntrySize)\n        throw new TypeError(\"cannot set sizeCalculation without setting maxSize or maxEntrySize\");\n      if (typeof this.sizeCalculation != \"function\")\n        throw new TypeError(\"sizeCalculation set to non-function\");\n    }\n    if (S !== void 0 && typeof S != \"function\")\n      throw new TypeError(\"fetchMethod must be a function if specified\");\n    if (this.#F = S, this.#b = !!S, this.#o = /* @__PURE__ */ new Map(), this.#r = new Array(e).fill(void 0), this.#t = new Array(e).fill(void 0), this.#u = new z3(e), this.#p = new z3(e), this.#s = 0, this.#i = 0, this.#y = Rt.create(e), this.#n = 0, this.#x = 0, typeof l == \"function\" && (this.#m = l), typeof _2 == \"function\" ? (this.#g = _2, this.#a = []) : (this.#g = void 0, this.#a = void 0), this.#S = !!this.#m, this.#l = !!this.#g, this.noDisposeOnSet = !!d, this.noUpdateTTL = !!g, this.noDeleteOnFetchRejection = !!p, this.allowStaleOnFetchRejection = !!A, this.allowStaleOnFetchAbort = !!y, this.ignoreFetchAbort = !!v2, this.maxEntrySize !== 0) {\n      if (this.#c !== 0 && !j(this.#c))\n        throw new TypeError(\"maxSize must be a positive integer if specified\");\n      if (!j(this.maxEntrySize))\n        throw new TypeError(\"maxEntrySize must be a positive integer if specified\");\n      this.#U();\n    }\n    if (this.allowStale = !!s, this.noDeleteOnStaleGet = !!w2, this.updateAgeOnGet = !!a, this.updateAgeOnHas = !!f, this.ttlResolution = j(n) || n === 0 ? n : 1, this.ttlAutopurge = !!i, this.ttl = o || 0, this.ttl) {\n      if (!j(this.ttl))\n        throw new TypeError(\"ttl must be a positive integer if specified\");\n      this.#R();\n    }\n    if (this.#f === 0 && this.ttl === 0 && this.#c === 0)\n      throw new TypeError(\"At least one of max, maxSize, or ttl is required\");\n    if (!this.ttlAutopurge && !this.#f && !this.#c) {\n      let W = \"LRU_CACHE_UNBOUNDED\";\n      sr(W) && (ae.add(W), se(\"TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.\", \"UnboundedCacheWarning\", W, r2));\n    }\n  }\n  getRemainingTTL(t) {\n    return this.#o.has(t) ? 1 / 0 : 0;\n  }\n  #R() {\n    let t = new B(this.#f), e = new B(this.#f);\n    this.#h = t, this.#w = e, this.#L = (i, a, f = N.now()) => {\n      if (e[i] = a !== 0 ? f : 0, t[i] = a, a !== 0 && this.ttlAutopurge) {\n        let s = setTimeout(() => {\n          this.#d(i) && this.delete(this.#r[i]);\n        }, a + 1);\n        s.unref && s.unref();\n      }\n    }, this.#T = (i) => {\n      e[i] = t[i] !== 0 ? N.now() : 0;\n    }, this.#A = (i, a) => {\n      if (t[a]) {\n        let f = t[a], s = e[a];\n        if (!f || !s)\n          return;\n        i.ttl = f, i.start = s, i.now = o || n();\n        let l = i.now - s;\n        i.remainingTTL = f - l;\n      }\n    };\n    let o = 0, n = () => {\n      let i = N.now();\n      if (this.ttlResolution > 0) {\n        o = i;\n        let a = setTimeout(() => o = 0, this.ttlResolution);\n        a.unref && a.unref();\n      }\n      return i;\n    };\n    this.getRemainingTTL = (i) => {\n      let a = this.#o.get(i);\n      if (a === void 0)\n        return 0;\n      let f = t[a], s = e[a];\n      if (!f || !s)\n        return 1 / 0;\n      let l = (o || n()) - s;\n      return f - l;\n    }, this.#d = (i) => {\n      let a = e[i], f = t[i];\n      return !!f && !!a && (o || n()) - a > f;\n    };\n  }\n  #T = () => {\n  };\n  #A = () => {\n  };\n  #L = () => {\n  };\n  #d = () => false;\n  #U() {\n    let t = new B(this.#f);\n    this.#x = 0, this.#_ = t, this.#E = (e) => {\n      this.#x -= t[e], t[e] = 0;\n    }, this.#z = (e, o, n, i) => {\n      if (this.#e(o))\n        return 0;\n      if (!j(n))\n        if (i) {\n          if (typeof i != \"function\")\n            throw new TypeError(\"sizeCalculation must be a function\");\n          if (n = i(o, e), !j(n))\n            throw new TypeError(\"sizeCalculation return invalid (expect positive integer)\");\n        } else\n          throw new TypeError(\"invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set.\");\n      return n;\n    }, this.#C = (e, o, n) => {\n      if (t[e] = o, this.#c) {\n        let i = this.#c - t[e];\n        for (; this.#x > i; )\n          this.#I(true);\n      }\n      this.#x += t[e], n && (n.entrySize = o, n.totalCalculatedSize = this.#x);\n    };\n  }\n  #E = (t) => {\n  };\n  #C = (t, e, o) => {\n  };\n  #z = (t, e, o, n) => {\n    if (o || n)\n      throw new TypeError(\"cannot set size without setting maxSize or maxEntrySize on cache\");\n    return 0;\n  };\n  *#v({ allowStale: t = this.allowStale } = {}) {\n    if (this.#n)\n      for (let e = this.#i; !(!this.#P(e) || ((t || !this.#d(e)) && (yield e), e === this.#s)); )\n        e = this.#p[e];\n  }\n  *#O({ allowStale: t = this.allowStale } = {}) {\n    if (this.#n)\n      for (let e = this.#s; !(!this.#P(e) || ((t || !this.#d(e)) && (yield e), e === this.#i)); )\n        e = this.#u[e];\n  }\n  #P(t) {\n    return t !== void 0 && this.#o.get(this.#r[t]) === t;\n  }\n  *entries() {\n    for (let t of this.#v())\n      this.#t[t] !== void 0 && this.#r[t] !== void 0 && !this.#e(this.#t[t]) && (yield [this.#r[t], this.#t[t]]);\n  }\n  *rentries() {\n    for (let t of this.#O())\n      this.#t[t] !== void 0 && this.#r[t] !== void 0 && !this.#e(this.#t[t]) && (yield [this.#r[t], this.#t[t]]);\n  }\n  *keys() {\n    for (let t of this.#v()) {\n      let e = this.#r[t];\n      e !== void 0 && !this.#e(this.#t[t]) && (yield e);\n    }\n  }\n  *rkeys() {\n    for (let t of this.#O()) {\n      let e = this.#r[t];\n      e !== void 0 && !this.#e(this.#t[t]) && (yield e);\n    }\n  }\n  *values() {\n    for (let t of this.#v())\n      this.#t[t] !== void 0 && !this.#e(this.#t[t]) && (yield this.#t[t]);\n  }\n  *rvalues() {\n    for (let t of this.#O())\n      this.#t[t] !== void 0 && !this.#e(this.#t[t]) && (yield this.#t[t]);\n  }\n  [Symbol.iterator]() {\n    return this.entries();\n  }\n  [Symbol.toStringTag] = \"LRUCache\";\n  find(t, e = {}) {\n    for (let o of this.#v()) {\n      let n = this.#t[o], i = this.#e(n) ? n.__staleWhileFetching : n;\n      if (i !== void 0 && t(i, this.#r[o], this))\n        return this.get(this.#r[o], e);\n    }\n  }\n  forEach(t, e = this) {\n    for (let o of this.#v()) {\n      let n = this.#t[o], i = this.#e(n) ? n.__staleWhileFetching : n;\n      i !== void 0 && t.call(e, i, this.#r[o], this);\n    }\n  }\n  rforEach(t, e = this) {\n    for (let o of this.#O()) {\n      let n = this.#t[o], i = this.#e(n) ? n.__staleWhileFetching : n;\n      i !== void 0 && t.call(e, i, this.#r[o], this);\n    }\n  }\n  purgeStale() {\n    let t = false;\n    for (let e of this.#O({ allowStale: true }))\n      this.#d(e) && (this.delete(this.#r[e]), t = true);\n    return t;\n  }\n  info(t) {\n    let e = this.#o.get(t);\n    if (e === void 0)\n      return;\n    let o = this.#t[e], n = this.#e(o) ? o.__staleWhileFetching : o;\n    if (n === void 0)\n      return;\n    let i = { value: n };\n    if (this.#h && this.#w) {\n      let a = this.#h[e], f = this.#w[e];\n      if (a && f) {\n        let s = a - (N.now() - f);\n        i.ttl = s, i.start = Date.now();\n      }\n    }\n    return this.#_ && (i.size = this.#_[e]), i;\n  }\n  dump() {\n    let t = [];\n    for (let e of this.#v({ allowStale: true })) {\n      let o = this.#r[e], n = this.#t[e], i = this.#e(n) ? n.__staleWhileFetching : n;\n      if (i === void 0 || o === void 0)\n        continue;\n      let a = { value: i };\n      if (this.#h && this.#w) {\n        a.ttl = this.#h[e];\n        let f = N.now() - this.#w[e];\n        a.start = Math.floor(Date.now() - f);\n      }\n      this.#_ && (a.size = this.#_[e]), t.unshift([o, a]);\n    }\n    return t;\n  }\n  load(t) {\n    this.clear();\n    for (let [e, o] of t) {\n      if (o.start) {\n        let n = Date.now() - o.start;\n        o.start = N.now() - n;\n      }\n      this.set(e, o.value, o);\n    }\n  }\n  set(t, e, o = {}) {\n    if (e === void 0)\n      return this.delete(t), this;\n    let { ttl: n = this.ttl, start: i, noDisposeOnSet: a = this.noDisposeOnSet, sizeCalculation: f = this.sizeCalculation, status: s } = o, { noUpdateTTL: l = this.noUpdateTTL } = o, _2 = this.#z(t, e, o.size || 0, f);\n    if (this.maxEntrySize && _2 > this.maxEntrySize)\n      return s && (s.set = \"miss\", s.maxEntrySizeExceeded = true), this.delete(t), this;\n    let d = this.#n === 0 ? void 0 : this.#o.get(t);\n    if (d === void 0)\n      d = this.#n === 0 ? this.#i : this.#y.length !== 0 ? this.#y.pop() : this.#n === this.#f ? this.#I(false) : this.#n, this.#r[d] = t, this.#t[d] = e, this.#o.set(t, d), this.#u[this.#i] = d, this.#p[d] = this.#i, this.#i = d, this.#n++, this.#C(d, _2, s), s && (s.set = \"add\"), l = false;\n    else {\n      this.#W(d);\n      let g = this.#t[d];\n      if (e !== g) {\n        if (this.#b && this.#e(g)) {\n          g.__abortController.abort(new Error(\"replaced\"));\n          let { __staleWhileFetching: m } = g;\n          m !== void 0 && !a && (this.#S && this.#m?.(m, t, \"set\"), this.#l && this.#a?.push([m, t, \"set\"]));\n        } else\n          a || (this.#S && this.#m?.(g, t, \"set\"), this.#l && this.#a?.push([g, t, \"set\"]));\n        if (this.#E(d), this.#C(d, _2, s), this.#t[d] = e, s) {\n          s.set = \"replace\";\n          let m = g && this.#e(g) ? g.__staleWhileFetching : g;\n          m !== void 0 && (s.oldValue = m);\n        }\n      } else\n        s && (s.set = \"update\");\n    }\n    if (n !== 0 && !this.#h && this.#R(), this.#h && (l || this.#L(d, n, i), s && this.#A(s, d)), !a && this.#l && this.#a) {\n      let g = this.#a, m;\n      for (; m = g?.shift(); )\n        this.#g?.(...m);\n    }\n    return this;\n  }\n  pop() {\n    try {\n      for (; this.#n; ) {\n        let t = this.#t[this.#s];\n        if (this.#I(true), this.#e(t)) {\n          if (t.__staleWhileFetching)\n            return t.__staleWhileFetching;\n        } else if (t !== void 0)\n          return t;\n      }\n    } finally {\n      if (this.#l && this.#a) {\n        let t = this.#a, e;\n        for (; e = t?.shift(); )\n          this.#g?.(...e);\n      }\n    }\n  }\n  #I(t) {\n    let e = this.#s, o = this.#r[e], n = this.#t[e];\n    return this.#b && this.#e(n) ? n.__abortController.abort(new Error(\"evicted\")) : (this.#S || this.#l) && (this.#S && this.#m?.(n, o, \"evict\"), this.#l && this.#a?.push([n, o, \"evict\"])), this.#E(e), t && (this.#r[e] = void 0, this.#t[e] = void 0, this.#y.push(e)), this.#n === 1 ? (this.#s = this.#i = 0, this.#y.length = 0) : this.#s = this.#u[e], this.#o.delete(o), this.#n--, e;\n  }\n  has(t, e = {}) {\n    let { updateAgeOnHas: o = this.updateAgeOnHas, status: n } = e, i = this.#o.get(t);\n    if (i !== void 0) {\n      let a = this.#t[i];\n      if (this.#e(a) && a.__staleWhileFetching === void 0)\n        return false;\n      if (this.#d(i))\n        n && (n.has = \"stale\", this.#A(n, i));\n      else\n        return o && this.#T(i), n && (n.has = \"hit\", this.#A(n, i)), true;\n    } else\n      n && (n.has = \"miss\");\n    return false;\n  }\n  peek(t, e = {}) {\n    let { allowStale: o = this.allowStale } = e, n = this.#o.get(t);\n    if (n === void 0 || !o && this.#d(n))\n      return;\n    let i = this.#t[n];\n    return this.#e(i) ? i.__staleWhileFetching : i;\n  }\n  #j(t, e, o, n) {\n    let i = e === void 0 ? void 0 : this.#t[e];\n    if (this.#e(i))\n      return i;\n    let a = new ut(), { signal: f } = o;\n    f?.addEventListener(\"abort\", () => a.abort(f.reason), { signal: a.signal });\n    let s = { signal: a.signal, options: o, context: n }, l = (x2, S = false) => {\n      let { aborted: p } = a.signal, w2 = o.ignoreFetchAbort && x2 !== void 0;\n      if (o.status && (p && !S ? (o.status.fetchAborted = true, o.status.fetchError = a.signal.reason, w2 && (o.status.fetchAbortIgnored = true)) : o.status.fetchResolved = true), p && !w2 && !S)\n        return d(a.signal.reason);\n      let A = m;\n      return this.#t[e] === m && (x2 === void 0 ? A.__staleWhileFetching ? this.#t[e] = A.__staleWhileFetching : this.delete(t) : (o.status && (o.status.fetchUpdated = true), this.set(t, x2, s.options))), x2;\n    }, _2 = (x2) => (o.status && (o.status.fetchRejected = true, o.status.fetchError = x2), d(x2)), d = (x2) => {\n      let { aborted: S } = a.signal, p = S && o.allowStaleOnFetchAbort, w2 = p || o.allowStaleOnFetchRejection, A = w2 || o.noDeleteOnFetchRejection, y = m;\n      if (this.#t[e] === m && (!A || y.__staleWhileFetching === void 0 ? this.delete(t) : p || (this.#t[e] = y.__staleWhileFetching)), w2)\n        return o.status && y.__staleWhileFetching !== void 0 && (o.status.returnedStale = true), y.__staleWhileFetching;\n      if (y.__returned === y)\n        throw x2;\n    }, g = (x2, S) => {\n      let p = this.#F?.(t, i, s);\n      p && p instanceof Promise && p.then((w2) => x2(w2 === void 0 ? void 0 : w2), S), a.signal.addEventListener(\"abort\", () => {\n        (!o.ignoreFetchAbort || o.allowStaleOnFetchAbort) && (x2(void 0), o.allowStaleOnFetchAbort && (x2 = (w2) => l(w2, true)));\n      });\n    };\n    o.status && (o.status.fetchDispatched = true);\n    let m = new Promise(g).then(l, _2), L = Object.assign(m, { __abortController: a, __staleWhileFetching: i, __returned: void 0 });\n    return e === void 0 ? (this.set(t, L, { ...s.options, status: void 0 }), e = this.#o.get(t)) : this.#t[e] = L, L;\n  }\n  #e(t) {\n    if (!this.#b)\n      return false;\n    let e = t;\n    return !!e && e instanceof Promise && e.hasOwnProperty(\"__staleWhileFetching\") && e.__abortController instanceof ut;\n  }\n  async fetch(t, e = {}) {\n    let { allowStale: o = this.allowStale, updateAgeOnGet: n = this.updateAgeOnGet, noDeleteOnStaleGet: i = this.noDeleteOnStaleGet, ttl: a = this.ttl, noDisposeOnSet: f = this.noDisposeOnSet, size: s = 0, sizeCalculation: l = this.sizeCalculation, noUpdateTTL: _2 = this.noUpdateTTL, noDeleteOnFetchRejection: d = this.noDeleteOnFetchRejection, allowStaleOnFetchRejection: g = this.allowStaleOnFetchRejection, ignoreFetchAbort: m = this.ignoreFetchAbort, allowStaleOnFetchAbort: L = this.allowStaleOnFetchAbort, context: x2, forceRefresh: S = false, status: p, signal: w2 } = e;\n    if (!this.#b)\n      return p && (p.fetch = \"get\"), this.get(t, { allowStale: o, updateAgeOnGet: n, noDeleteOnStaleGet: i, status: p });\n    let A = { allowStale: o, updateAgeOnGet: n, noDeleteOnStaleGet: i, ttl: a, noDisposeOnSet: f, size: s, sizeCalculation: l, noUpdateTTL: _2, noDeleteOnFetchRejection: d, allowStaleOnFetchRejection: g, allowStaleOnFetchAbort: L, ignoreFetchAbort: m, status: p, signal: w2 }, y = this.#o.get(t);\n    if (y === void 0) {\n      p && (p.fetch = \"miss\");\n      let v2 = this.#j(t, y, A, x2);\n      return v2.__returned = v2;\n    } else {\n      let v2 = this.#t[y];\n      if (this.#e(v2)) {\n        let zt2 = o && v2.__staleWhileFetching !== void 0;\n        return p && (p.fetch = \"inflight\", zt2 && (p.returnedStale = true)), zt2 ? v2.__staleWhileFetching : v2.__returned = v2;\n      }\n      let z3 = this.#d(y);\n      if (!S && !z3)\n        return p && (p.fetch = \"hit\"), this.#W(y), n && this.#T(y), p && this.#A(p, y), v2;\n      let W = this.#j(t, y, A, x2), Lt2 = W.__staleWhileFetching !== void 0 && o;\n      return p && (p.fetch = z3 ? \"stale\" : \"refresh\", Lt2 && z3 && (p.returnedStale = true)), Lt2 ? W.__staleWhileFetching : W.__returned = W;\n    }\n  }\n  get(t, e = {}) {\n    let { allowStale: o = this.allowStale, updateAgeOnGet: n = this.updateAgeOnGet, noDeleteOnStaleGet: i = this.noDeleteOnStaleGet, status: a } = e, f = this.#o.get(t);\n    if (f !== void 0) {\n      let s = this.#t[f], l = this.#e(s);\n      return a && this.#A(a, f), this.#d(f) ? (a && (a.get = \"stale\"), l ? (a && o && s.__staleWhileFetching !== void 0 && (a.returnedStale = true), o ? s.__staleWhileFetching : void 0) : (i || this.delete(t), a && o && (a.returnedStale = true), o ? s : void 0)) : (a && (a.get = \"hit\"), l ? s.__staleWhileFetching : (this.#W(f), n && this.#T(f), s));\n    } else\n      a && (a.get = \"miss\");\n  }\n  #D(t, e) {\n    this.#p[e] = t, this.#u[t] = e;\n  }\n  #W(t) {\n    t !== this.#i && (t === this.#s ? this.#s = this.#u[t] : this.#D(this.#p[t], this.#u[t]), this.#D(this.#i, t), this.#i = t);\n  }\n  delete(t) {\n    let e = false;\n    if (this.#n !== 0) {\n      let o = this.#o.get(t);\n      if (o !== void 0)\n        if (e = true, this.#n === 1)\n          this.clear();\n        else {\n          this.#E(o);\n          let n = this.#t[o];\n          if (this.#e(n) ? n.__abortController.abort(new Error(\"deleted\")) : (this.#S || this.#l) && (this.#S && this.#m?.(n, t, \"delete\"), this.#l && this.#a?.push([n, t, \"delete\"])), this.#o.delete(t), this.#r[o] = void 0, this.#t[o] = void 0, o === this.#i)\n            this.#i = this.#p[o];\n          else if (o === this.#s)\n            this.#s = this.#u[o];\n          else {\n            let i = this.#p[o];\n            this.#u[i] = this.#u[o];\n            let a = this.#u[o];\n            this.#p[a] = this.#p[o];\n          }\n          this.#n--, this.#y.push(o);\n        }\n    }\n    if (this.#l && this.#a?.length) {\n      let o = this.#a, n;\n      for (; n = o?.shift(); )\n        this.#g?.(...n);\n    }\n    return e;\n  }\n  clear() {\n    for (let t of this.#O({ allowStale: true })) {\n      let e = this.#t[t];\n      if (this.#e(e))\n        e.__abortController.abort(new Error(\"deleted\"));\n      else {\n        let o = this.#r[t];\n        this.#S && this.#m?.(e, o, \"delete\"), this.#l && this.#a?.push([e, o, \"delete\"]);\n      }\n    }\n    if (this.#o.clear(), this.#t.fill(void 0), this.#r.fill(void 0), this.#h && this.#w && (this.#h.fill(0), this.#w.fill(0)), this.#_ && this.#_.fill(0), this.#s = 0, this.#i = 0, this.#y.length = 0, this.#x = 0, this.#n = 0, this.#l && this.#a) {\n      let t = this.#a, e;\n      for (; e = t?.shift(); )\n        this.#g?.(...e);\n    }\n  }\n};\nvar R;\nvar Y;\nfunction ue({ size: r3 }) {\n  return R || (Y = r3, R = new lt({ max: r3, maxSize: 1e6 * 5, sizeCalculation: (t) => JSON.stringify(t).length, allowStale: true }), R);\n}\nfunction le({ cache: r3 = R }) {\n  return async (t) => {\n    if (Y)\n      return r3.get(t);\n  };\n}\nfunction ce({ cache: r3 = R }) {\n  return async (t, { url: e, address: o }, n) => {\n    if (Y)\n      return r3.set(t, { url: e, address: o }, { ttl: n });\n  };\n}\nfunction pe({ cache: r3 = R }) {\n  return async (t) => {\n    if (Y)\n      return r3.get(t);\n  };\n}\nfunction he({ cache: r3 = R }) {\n  return async (t, e, o) => {\n    if (Y)\n      return r3.set(t, { url: e, address: t }, { ttl: o });\n  };\n}\nfunction de({ fetch: r3 }) {\n  return async (t, e) => {\n    let o = await r3(`${t}?process-id=${e}`, { method: \"GET\", redirect: \"manual\" });\n    return [301, 302, 307, 308].includes(o.status) ? new URL(o.headers.get(\"Location\")).origin : t;\n  };\n}\nfunction me({ loadProcessScheduler: r3, loadScheduler: t, cache: e, followRedirects: o, checkForRedirect: n }) {\n  return (i, a) => e.getByProcess(i).then(async (f) => f || Promise.resolve().then(async () => {\n    if (a) {\n      let s = await e.getByOwner(a);\n      return s || t(a).then((l) => (e.setByOwner(l.owner, l.url, l.ttl), l));\n    }\n    return r3(i);\n  }).then(async (s) => {\n    let l = s.url;\n    o && (l = await n(s.url, i));\n    let _2 = { url: l, address: s.owner };\n    return await e.setByProcess(i, _2, s.ttl), _2;\n  }));\n}\nfunction ge({ loadScheduler: r3, cache: t }) {\n  return (e) => t.getByOwner(e).then((o) => o ? { url: o.url } : r3(e).then((n) => t.setByOwner(e, n.url, n.ttl).then(() => ({ url: n.url }))).catch((n) => {\n    if (!(n instanceof E))\n      throw n;\n  }));\n}\nfunction xe({ loadScheduler: r3, cache: t }) {\n  return (e) => t.getByOwner(e).then((o) => o ? true : r3(e).then((n) => t.setByOwner(e, n.url, n.ttl)).then(() => true).catch((n) => {\n    if (n instanceof E)\n      return false;\n    throw n;\n  }));\n}\nvar lr = \"https://arweave.net/graphql\";\nfunction ye({ cacheSize: r3 = 100, GRAPHQL_URL: t = lr, followRedirects: e = false } = {}) {\n  let o = ue({ size: r3 }), n = It({ fetch, GRAPHQL_URL: t }), i = { getByProcess: le({ cache: o }), getByOwner: pe({ cache: o }), setByProcess: ce({ cache: o }), setByOwner: he({ cache: o }) }, a = me({ loadProcessScheduler: ne({ fetch, GRAPHQL_URL: t }), loadScheduler: n, cache: i, followRedirects: e, checkForRedirect: de({ fetch }) }), f = xe({ loadScheduler: n, cache: i }), s = ge({ loadScheduler: n, cache: i });\n  return { locate: a, validate: f, raw: s };\n}\nvar cr = globalThis.GRAPHQL_URL || void 0;\nvar pr = globalThis.SCHEDULER_UTILS_CACHE_SIZE || void 0;\nvar hr = globalThis.SCHEDULER_UTILS_FOLLOW_REDIRECTS === \"true\" || void 0;\nvar { locate: ra, validate: oa, raw: na } = ye({ GRAPHQL_URL: cr, cacheSize: pr, followRedirects: hr });\n\n// node_modules/hyper-async/dist/index.js\nvar Async = (fork) => ({\n  fork,\n  toPromise: () => new Promise((resolve, reject3) => fork(reject3, resolve)),\n  map: (fn) => Async((rej, res) => fork(rej, (x2) => res(fn(x2)))),\n  bimap: (f, g) => Async(\n    (rej, res) => fork(\n      (x2) => rej(f(x2)),\n      (x2) => res(g(x2))\n    )\n  ),\n  chain: (fn) => Async((rej, res) => fork(rej, (x2) => fn(x2).fork(rej, res))),\n  bichain: (f, g) => Async(\n    (rej, res) => fork(\n      (x2) => f(x2).fork(rej, res),\n      (x2) => g(x2).fork(rej, res)\n    )\n  ),\n  fold: (f, g) => Async(\n    (rej, res) => fork(\n      (x2) => f(x2).fork(rej, res),\n      (x2) => g(x2).fork(rej, res)\n    )\n  )\n});\nvar of = (x2) => Async((rej, res) => res(x2));\nvar Resolved = (x2) => Async((rej, res) => res(x2));\nvar Rejected = (x2) => Async((rej, res) => rej(x2));\nvar fromPromise = (f) => (...args) => Async(\n  (rej, res) => f(...args).then(res).catch(rej)\n);\n\n// src/client/ao-mu.js\nfunction deployMessageWith({ fetch: fetch2, MU_URL: MU_URL2, logger: _logger }) {\n  const logger = _logger.child(\"deployMessage\");\n  return (args) => {\n    return of(args).chain(\n      fromPromise(({ processId, data, tags, anchor, signer }) => (\n        /**\n         * The processId is the target set on the data item\n         * See https://specs.g8way.io/?tx=xwOgX-MmqN5_-Ny_zNu2A8o-PnTGsoRb_3FrtiMAkuw\n         */\n        signer({ data, tags, target: processId, anchor })\n      ))\n    ).chain(\n      (signedDataItem) => of(signedDataItem).chain(fromPromise(\n        async (signedDataItem2) => fetch2(\n          MU_URL2,\n          {\n            method: \"POST\",\n            headers: {\n              \"Content-Type\": \"application/octet-stream\",\n              Accept: \"application/json\"\n            },\n            redirect: \"follow\",\n            body: signedDataItem2.raw\n          }\n        )\n      )).bichain(\n        (err) => Rejected(new Error(`Error while communicating with MU: ${JSON.stringify(err)}`)),\n        fromPromise(\n          async (res) => {\n            if (res.ok)\n              return res.json();\n            throw new Error(`${res.status}: ${await res.text()}`);\n          }\n        )\n      ).bimap(\n        logger.tap(\"Error encountered when writing message via MU\"),\n        logger.tap(\"Successfully wrote message via MU\")\n      ).map((res) => ({ res, messageId: signedDataItem.id }))\n    ).toPromise();\n  };\n}\nfunction deployProcessWith({ fetch: fetch2, MU_URL: MU_URL2, logger: _logger }) {\n  const logger = _logger.child(\"deployProcess\");\n  return (args) => {\n    return of(args).chain(fromPromise(({ data, tags, signer }) => signer({ data, tags }))).chain(\n      (signedDataItem) => of(signedDataItem).chain(fromPromise(\n        async (signedDataItem2) => fetch2(\n          MU_URL2,\n          {\n            method: \"POST\",\n            headers: {\n              \"Content-Type\": \"application/octet-stream\",\n              Accept: \"application/json\"\n            },\n            redirect: \"follow\",\n            body: signedDataItem2.raw\n          }\n        )\n      )).bichain(\n        (err) => Rejected(new Error(`Error while communicating with MU: ${JSON.stringify(err)}`)),\n        fromPromise(\n          async (res) => {\n            if (res.ok)\n              return res.json();\n            throw new Error(`${res.status}: ${await res.text()}`);\n          }\n        )\n      ).bimap(\n        logger.tap(\"Error encountered when deploying process via MU\"),\n        logger.tap(\"Successfully deployed process via MU\")\n      ).map((res) => ({ res, processId: signedDataItem.id }))\n    ).toPromise();\n  };\n}\nfunction deployMonitorWith({ fetch: fetch2, MU_URL: MU_URL2, logger: _logger }) {\n  const logger = _logger.child(\"deployMonitor\");\n  return (args) => of(args).chain(\n    fromPromise(({ processId, data, tags, anchor, signer }) => (\n      /**\n       * The processId is the target set on the data item\n       */\n      signer({ data, tags, target: processId, anchor })\n    ))\n  ).chain(\n    (signedDataItem) => of(signedDataItem).chain(fromPromise(\n      async (signedDataItem2) => fetch2(\n        MU_URL2 + \"/monitor/\" + args.processId,\n        {\n          method: \"POST\",\n          headers: {\n            \"Content-Type\": \"application/octet-stream\",\n            Accept: \"application/json\"\n          },\n          redirect: \"follow\",\n          body: signedDataItem2.raw\n        }\n      )\n    )).bichain(\n      (err) => Rejected(new Error(`Error while communicating with MU: ${JSON.stringify(err)}`)),\n      fromPromise(\n        async (res) => {\n          if (res.ok)\n            return { ok: true };\n          throw new Error(`${res.status}: ${await res.text()}`);\n        }\n      )\n    ).bimap(\n      logger.tap(\"Error encountered when subscribing to process via MU\"),\n      logger.tap(\"Successfully subscribed to process via MU\")\n    ).map((res) => ({ res, messageId: signedDataItem.id }))\n  ).toPromise();\n}\nfunction deployUnmonitorWith({ fetch: fetch2, MU_URL: MU_URL2, logger: _logger }) {\n  const logger = _logger.child(\"deployUnmonitor\");\n  return (args) => of(args).chain(\n    fromPromise(({ processId, data, tags, anchor, signer }) => (\n      /**\n       * The processId is the target set on the data item\n       */\n      signer({ data, tags, target: processId, anchor })\n    ))\n  ).chain(\n    (signedDataItem) => of(signedDataItem).chain(fromPromise(\n      async (signedDataItem2) => fetch2(\n        MU_URL2 + \"/monitor/\" + args.processId,\n        {\n          method: \"DELETE\",\n          headers: {\n            \"Content-Type\": \"application/octet-stream\",\n            Accept: \"application/json\"\n          },\n          redirect: \"follow\",\n          body: signedDataItem2.raw\n        }\n      )\n    )).bichain(\n      (err) => Rejected(new Error(`Error while communicating with MU: ${JSON.stringify(err)}`)),\n      fromPromise(\n        async (res) => {\n          if (res.ok)\n            return { ok: true };\n          throw new Error(`${res.status}: ${await res.text()}`);\n        }\n      )\n    ).bimap(\n      logger.tap(\"Error encountered when unsubscribing to process via MU\"),\n      logger.tap(\"Successfully unsubscribed to process via MU\")\n    ).map((res) => ({ res, messageId: signedDataItem.id }))\n  ).toPromise();\n}\nfunction deployAssignWith({ fetch: fetch2, MU_URL: MU_URL2, logger: _logger }) {\n  const logger = _logger.child(\"deployAssign\");\n  return (args) => {\n    return of(args).chain(fromPromise(\n      async ({ process: process2, message: message2, baseLayer, exclude }) => fetch2(\n        `${MU_URL2}?process-id=${process2}&assign=${message2}${baseLayer ? \"&base-layer\" : \"\"}${exclude ? \"&exclude=\" + exclude.join(\",\") : \"\"}`,\n        {\n          method: \"POST\",\n          headers: {\n            \"Content-Type\": \"application/octet-stream\",\n            Accept: \"application/json\"\n          }\n        }\n      )\n    )).bichain(\n      (err) => Rejected(new Error(`Error while communicating with MU: ${JSON.stringify(err)}`)),\n      fromPromise(\n        async (res) => {\n          if (res.ok)\n            return res.json();\n          throw new Error(`${res.status}: ${await res.text()}`);\n        }\n      )\n    ).bimap(\n      logger.tap(\"Error encountered when writing assignment via MU\"),\n      logger.tap(\"Successfully wrote assignment via MU\")\n    ).map((res) => ({ res, assignmentId: res.id })).toPromise();\n  };\n}\n\n// src/client/ao-cu.js\nfunction dryrunFetchWith({ fetch: fetch2, CU_URL: CU_URL2, logger }) {\n  return (msg) => of(msg).map(logger.tap(\"posting dryrun request to CU\")).chain(fromPromise((msg2) => fetch2(`${CU_URL2}/dry-run?process-id=${msg2.Target}`, {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\"\n    },\n    redirect: \"follow\",\n    body: JSON.stringify(msg2)\n  }).then((res) => res.json()))).toPromise();\n}\nfunction loadResultWith({ fetch: fetch2, CU_URL: CU_URL2, logger }) {\n  return ({ id, processId }) => {\n    return of(`${CU_URL2}/result/${id}?process-id=${processId}`).map(logger.tap(\"fetching message result from CU\")).chain(fromPromise(\n      async (url) => fetch2(url, {\n        method: \"GET\",\n        headers: {\n          Accept: \"application/json\"\n        },\n        redirect: \"follow\"\n      }).then((res) => res.json())\n    )).toPromise();\n  };\n}\nfunction queryResultsWith({ fetch: fetch2, CU_URL: CU_URL2, logger }) {\n  return ({ process: process2, from, to, sort, limit }) => {\n    const target = new URL(`${CU_URL2}/results/${process2}`);\n    const params = new URLSearchParams(target.search);\n    if (from) {\n      params.append(\"from\", from);\n    }\n    if (to) {\n      params.append(\"to\", to);\n    }\n    if (sort) {\n      params.append(\"sort\", sort);\n    }\n    if (limit) {\n      params.append(\"limit\", limit);\n    }\n    target.search = params;\n    return of(target.toString()).map(logger.tap(\"fetching message result from CU\")).chain(fromPromise(\n      async (url) => fetch2(url, {\n        method: \"GET\",\n        headers: {\n          Accept: \"application/json\"\n        },\n        redirect: \"follow\"\n      }).then((res) => res.json())\n    )).toPromise();\n  };\n}\n\n// src/client/ao-su.js\nvar import_lru_map = __toESM(require_lru_map(), 1);\nvar processMetaCache;\nvar createProcessMetaCache = ({ MAX_SIZE }) => {\n  if (processMetaCache)\n    return processMetaCache;\n  processMetaCache = new import_lru_map.default(MAX_SIZE);\n  return processMetaCache;\n};\nvar loadProcessMetaWith = ({ logger, fetch: fetch2, cache = processMetaCache }) => {\n  return async ({ suUrl, processId }) => {\n    if (cache.has(processId))\n      return cache.get(processId);\n    return fetch2(`${suUrl}/processes/${processId}`, { method: \"GET\", redirect: \"follow\" }).then(async (res) => {\n      if (res.ok)\n        return res.json();\n      logger(\"Error Encountered when fetching process meta from SU '%s' for process '%s'\", suUrl, processId);\n      throw new Error(`Encountered Error fetching scheduled messages from Scheduler Unit: ${res.status}: ${await res.text()}`);\n    }).then((meta) => {\n      logger(\"Caching process meta for process '%s'\", processId);\n      cache.set(processId, { tags: meta.tags });\n      return meta;\n    });\n  };\n};\n\n// node_modules/ramda/es/F.js\nvar F2 = function() {\n  return false;\n};\nvar F_default = F2;\n\n// node_modules/ramda/es/T.js\nvar T2 = function() {\n  return true;\n};\nvar T_default = T2;\n\n// node_modules/ramda/es/__.js\nvar __default = {\n  \"@@functional/placeholder\": true\n};\n\n// node_modules/ramda/es/internal/_isPlaceholder.js\nfunction _isPlaceholder(a) {\n  return a != null && typeof a === \"object\" && a[\"@@functional/placeholder\"] === true;\n}\n\n// node_modules/ramda/es/internal/_curry1.js\nfunction _curry1(fn) {\n  return function f1(a) {\n    if (arguments.length === 0 || _isPlaceholder(a)) {\n      return f1;\n    } else {\n      return fn.apply(this, arguments);\n    }\n  };\n}\n\n// node_modules/ramda/es/internal/_curry2.js\nfunction _curry2(fn) {\n  return function f2(a, b2) {\n    switch (arguments.length) {\n      case 0:\n        return f2;\n      case 1:\n        return _isPlaceholder(a) ? f2 : _curry1(function(_b) {\n          return fn(a, _b);\n        });\n      default:\n        return _isPlaceholder(a) && _isPlaceholder(b2) ? f2 : _isPlaceholder(a) ? _curry1(function(_a) {\n          return fn(_a, b2);\n        }) : _isPlaceholder(b2) ? _curry1(function(_b) {\n          return fn(a, _b);\n        }) : fn(a, b2);\n    }\n  };\n}\n\n// node_modules/ramda/es/internal/_concat.js\nfunction _concat(set1, set2) {\n  set1 = set1 || [];\n  set2 = set2 || [];\n  var idx;\n  var len1 = set1.length;\n  var len2 = set2.length;\n  var result2 = [];\n  idx = 0;\n  while (idx < len1) {\n    result2[result2.length] = set1[idx];\n    idx += 1;\n  }\n  idx = 0;\n  while (idx < len2) {\n    result2[result2.length] = set2[idx];\n    idx += 1;\n  }\n  return result2;\n}\n\n// node_modules/ramda/es/internal/_arity.js\nfunction _arity(n, fn) {\n  switch (n) {\n    case 0:\n      return function() {\n        return fn.apply(this, arguments);\n      };\n    case 1:\n      return function(a0) {\n        return fn.apply(this, arguments);\n      };\n    case 2:\n      return function(a0, a1) {\n        return fn.apply(this, arguments);\n      };\n    case 3:\n      return function(a0, a1, a2) {\n        return fn.apply(this, arguments);\n      };\n    case 4:\n      return function(a0, a1, a2, a3) {\n        return fn.apply(this, arguments);\n      };\n    case 5:\n      return function(a0, a1, a2, a3, a4) {\n        return fn.apply(this, arguments);\n      };\n    case 6:\n      return function(a0, a1, a2, a3, a4, a5) {\n        return fn.apply(this, arguments);\n      };\n    case 7:\n      return function(a0, a1, a2, a3, a4, a5, a6) {\n        return fn.apply(this, arguments);\n      };\n    case 8:\n      return function(a0, a1, a2, a3, a4, a5, a6, a7) {\n        return fn.apply(this, arguments);\n      };\n    case 9:\n      return function(a0, a1, a2, a3, a4, a5, a6, a7, a8) {\n        return fn.apply(this, arguments);\n      };\n    case 10:\n      return function(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) {\n        return fn.apply(this, arguments);\n      };\n    default:\n      throw new Error(\"First argument to _arity must be a non-negative integer no greater than ten\");\n  }\n}\n\n// node_modules/ramda/es/internal/_curryN.js\nfunction _curryN(length, received, fn) {\n  return function() {\n    var combined = [];\n    var argsIdx = 0;\n    var left = length;\n    var combinedIdx = 0;\n    var hasPlaceholder = false;\n    while (combinedIdx < received.length || argsIdx < arguments.length) {\n      var result2;\n      if (combinedIdx < received.length && (!_isPlaceholder(received[combinedIdx]) || argsIdx >= arguments.length)) {\n        result2 = received[combinedIdx];\n      } else {\n        result2 = arguments[argsIdx];\n        argsIdx += 1;\n      }\n      combined[combinedIdx] = result2;\n      if (!_isPlaceholder(result2)) {\n        left -= 1;\n      } else {\n        hasPlaceholder = true;\n      }\n      combinedIdx += 1;\n    }\n    return !hasPlaceholder && left <= 0 ? fn.apply(this, combined) : _arity(Math.max(0, left), _curryN(length, combined, fn));\n  };\n}\n\n// node_modules/ramda/es/curryN.js\nvar curryN = /* @__PURE__ */ _curry2(function curryN2(length, fn) {\n  if (length === 1) {\n    return _curry1(fn);\n  }\n  return _arity(length, _curryN(length, [], fn));\n});\nvar curryN_default = curryN;\n\n// node_modules/ramda/es/internal/_curry3.js\nfunction _curry3(fn) {\n  return function f3(a, b2, c2) {\n    switch (arguments.length) {\n      case 0:\n        return f3;\n      case 1:\n        return _isPlaceholder(a) ? f3 : _curry2(function(_b, _c) {\n          return fn(a, _b, _c);\n        });\n      case 2:\n        return _isPlaceholder(a) && _isPlaceholder(b2) ? f3 : _isPlaceholder(a) ? _curry2(function(_a, _c) {\n          return fn(_a, b2, _c);\n        }) : _isPlaceholder(b2) ? _curry2(function(_b, _c) {\n          return fn(a, _b, _c);\n        }) : _curry1(function(_c) {\n          return fn(a, b2, _c);\n        });\n      default:\n        return _isPlaceholder(a) && _isPlaceholder(b2) && _isPlaceholder(c2) ? f3 : _isPlaceholder(a) && _isPlaceholder(b2) ? _curry2(function(_a, _b) {\n          return fn(_a, _b, c2);\n        }) : _isPlaceholder(a) && _isPlaceholder(c2) ? _curry2(function(_a, _c) {\n          return fn(_a, b2, _c);\n        }) : _isPlaceholder(b2) && _isPlaceholder(c2) ? _curry2(function(_b, _c) {\n          return fn(a, _b, _c);\n        }) : _isPlaceholder(a) ? _curry1(function(_a) {\n          return fn(_a, b2, c2);\n        }) : _isPlaceholder(b2) ? _curry1(function(_b) {\n          return fn(a, _b, c2);\n        }) : _isPlaceholder(c2) ? _curry1(function(_c) {\n          return fn(a, b2, _c);\n        }) : fn(a, b2, c2);\n    }\n  };\n}\n\n// node_modules/ramda/es/internal/_isArray.js\nvar isArray_default = Array.isArray || function _isArray(val) {\n  return val != null && val.length >= 0 && Object.prototype.toString.call(val) === \"[object Array]\";\n};\n\n// node_modules/ramda/es/internal/_isTransformer.js\nfunction _isTransformer(obj) {\n  return obj != null && typeof obj[\"@@transducer/step\"] === \"function\";\n}\n\n// node_modules/ramda/es/internal/_dispatchable.js\nfunction _dispatchable(methodNames, transducerCreator, fn) {\n  return function() {\n    if (arguments.length === 0) {\n      return fn();\n    }\n    var obj = arguments[arguments.length - 1];\n    if (!isArray_default(obj)) {\n      var idx = 0;\n      while (idx < methodNames.length) {\n        if (typeof obj[methodNames[idx]] === \"function\") {\n          return obj[methodNames[idx]].apply(obj, Array.prototype.slice.call(arguments, 0, -1));\n        }\n        idx += 1;\n      }\n      if (_isTransformer(obj)) {\n        var transducer = transducerCreator.apply(null, Array.prototype.slice.call(arguments, 0, -1));\n        return transducer(obj);\n      }\n    }\n    return fn.apply(this, arguments);\n  };\n}\n\n// node_modules/ramda/es/internal/_xfBase.js\nvar xfBase_default = {\n  init: function() {\n    return this.xf[\"@@transducer/init\"]();\n  },\n  result: function(result2) {\n    return this.xf[\"@@transducer/result\"](result2);\n  }\n};\n\n// node_modules/ramda/es/internal/_arrayFromIterator.js\nfunction _arrayFromIterator(iter) {\n  var list = [];\n  var next;\n  while (!(next = iter.next()).done) {\n    list.push(next.value);\n  }\n  return list;\n}\n\n// node_modules/ramda/es/internal/_includesWith.js\nfunction _includesWith(pred, x2, list) {\n  var idx = 0;\n  var len = list.length;\n  while (idx < len) {\n    if (pred(x2, list[idx])) {\n      return true;\n    }\n    idx += 1;\n  }\n  return false;\n}\n\n// node_modules/ramda/es/internal/_functionName.js\nfunction _functionName(f) {\n  var match = String(f).match(/^function (\\w*)/);\n  return match == null ? \"\" : match[1];\n}\n\n// node_modules/ramda/es/internal/_has.js\nfunction _has(prop3, obj) {\n  return Object.prototype.hasOwnProperty.call(obj, prop3);\n}\n\n// node_modules/ramda/es/internal/_objectIs.js\nfunction _objectIs(a, b2) {\n  if (a === b2) {\n    return a !== 0 || 1 / a === 1 / b2;\n  } else {\n    return a !== a && b2 !== b2;\n  }\n}\nvar objectIs_default = typeof Object.is === \"function\" ? Object.is : _objectIs;\n\n// node_modules/ramda/es/internal/_isArguments.js\nvar toString = Object.prototype.toString;\nvar _isArguments = /* @__PURE__ */ function() {\n  return toString.call(arguments) === \"[object Arguments]\" ? function _isArguments2(x2) {\n    return toString.call(x2) === \"[object Arguments]\";\n  } : function _isArguments2(x2) {\n    return _has(\"callee\", x2);\n  };\n}();\nvar isArguments_default = _isArguments;\n\n// node_modules/ramda/es/keys.js\nvar hasEnumBug = !/* @__PURE__ */ {\n  toString: null\n}.propertyIsEnumerable(\"toString\");\nvar nonEnumerableProps = [\"constructor\", \"valueOf\", \"isPrototypeOf\", \"toString\", \"propertyIsEnumerable\", \"hasOwnProperty\", \"toLocaleString\"];\nvar hasArgsEnumBug = /* @__PURE__ */ function() {\n  \"use strict\";\n  return arguments.propertyIsEnumerable(\"length\");\n}();\nvar contains = function contains2(list, item) {\n  var idx = 0;\n  while (idx < list.length) {\n    if (list[idx] === item) {\n      return true;\n    }\n    idx += 1;\n  }\n  return false;\n};\nvar keys = typeof Object.keys === \"function\" && !hasArgsEnumBug ? /* @__PURE__ */ _curry1(function keys2(obj) {\n  return Object(obj) !== obj ? [] : Object.keys(obj);\n}) : /* @__PURE__ */ _curry1(function keys3(obj) {\n  if (Object(obj) !== obj) {\n    return [];\n  }\n  var prop3, nIdx;\n  var ks = [];\n  var checkArgsLength = hasArgsEnumBug && isArguments_default(obj);\n  for (prop3 in obj) {\n    if (_has(prop3, obj) && (!checkArgsLength || prop3 !== \"length\")) {\n      ks[ks.length] = prop3;\n    }\n  }\n  if (hasEnumBug) {\n    nIdx = nonEnumerableProps.length - 1;\n    while (nIdx >= 0) {\n      prop3 = nonEnumerableProps[nIdx];\n      if (_has(prop3, obj) && !contains(ks, prop3)) {\n        ks[ks.length] = prop3;\n      }\n      nIdx -= 1;\n    }\n  }\n  return ks;\n});\nvar keys_default = keys;\n\n// node_modules/ramda/es/type.js\nvar type = /* @__PURE__ */ _curry1(function type2(val) {\n  return val === null ? \"Null\" : val === void 0 ? \"Undefined\" : Object.prototype.toString.call(val).slice(8, -1);\n});\nvar type_default = type;\n\n// node_modules/ramda/es/internal/_equals.js\nfunction _uniqContentEquals(aIterator, bIterator, stackA, stackB) {\n  var a = _arrayFromIterator(aIterator);\n  var b2 = _arrayFromIterator(bIterator);\n  function eq(_a, _b) {\n    return _equals(_a, _b, stackA.slice(), stackB.slice());\n  }\n  return !_includesWith(function(b3, aItem) {\n    return !_includesWith(eq, aItem, b3);\n  }, b2, a);\n}\nfunction _equals(a, b2, stackA, stackB) {\n  if (objectIs_default(a, b2)) {\n    return true;\n  }\n  var typeA = type_default(a);\n  if (typeA !== type_default(b2)) {\n    return false;\n  }\n  if (typeof a[\"fantasy-land/equals\"] === \"function\" || typeof b2[\"fantasy-land/equals\"] === \"function\") {\n    return typeof a[\"fantasy-land/equals\"] === \"function\" && a[\"fantasy-land/equals\"](b2) && typeof b2[\"fantasy-land/equals\"] === \"function\" && b2[\"fantasy-land/equals\"](a);\n  }\n  if (typeof a.equals === \"function\" || typeof b2.equals === \"function\") {\n    return typeof a.equals === \"function\" && a.equals(b2) && typeof b2.equals === \"function\" && b2.equals(a);\n  }\n  switch (typeA) {\n    case \"Arguments\":\n    case \"Array\":\n    case \"Object\":\n      if (typeof a.constructor === \"function\" && _functionName(a.constructor) === \"Promise\") {\n        return a === b2;\n      }\n      break;\n    case \"Boolean\":\n    case \"Number\":\n    case \"String\":\n      if (!(typeof a === typeof b2 && objectIs_default(a.valueOf(), b2.valueOf()))) {\n        return false;\n      }\n      break;\n    case \"Date\":\n      if (!objectIs_default(a.valueOf(), b2.valueOf())) {\n        return false;\n      }\n      break;\n    case \"Error\":\n      return a.name === b2.name && a.message === b2.message;\n    case \"RegExp\":\n      if (!(a.source === b2.source && a.global === b2.global && a.ignoreCase === b2.ignoreCase && a.multiline === b2.multiline && a.sticky === b2.sticky && a.unicode === b2.unicode)) {\n        return false;\n      }\n      break;\n  }\n  var idx = stackA.length - 1;\n  while (idx >= 0) {\n    if (stackA[idx] === a) {\n      return stackB[idx] === b2;\n    }\n    idx -= 1;\n  }\n  switch (typeA) {\n    case \"Map\":\n      if (a.size !== b2.size) {\n        return false;\n      }\n      return _uniqContentEquals(a.entries(), b2.entries(), stackA.concat([a]), stackB.concat([b2]));\n    case \"Set\":\n      if (a.size !== b2.size) {\n        return false;\n      }\n      return _uniqContentEquals(a.values(), b2.values(), stackA.concat([a]), stackB.concat([b2]));\n    case \"Arguments\":\n    case \"Array\":\n    case \"Object\":\n    case \"Boolean\":\n    case \"Number\":\n    case \"String\":\n    case \"Date\":\n    case \"Error\":\n    case \"RegExp\":\n    case \"Int8Array\":\n    case \"Uint8Array\":\n    case \"Uint8ClampedArray\":\n    case \"Int16Array\":\n    case \"Uint16Array\":\n    case \"Int32Array\":\n    case \"Uint32Array\":\n    case \"Float32Array\":\n    case \"Float64Array\":\n    case \"ArrayBuffer\":\n      break;\n    default:\n      return false;\n  }\n  var keysA = keys_default(a);\n  if (keysA.length !== keys_default(b2).length) {\n    return false;\n  }\n  var extendedStackA = stackA.concat([a]);\n  var extendedStackB = stackB.concat([b2]);\n  idx = keysA.length - 1;\n  while (idx >= 0) {\n    var key = keysA[idx];\n    if (!(_has(key, b2) && _equals(b2[key], a[key], extendedStackA, extendedStackB))) {\n      return false;\n    }\n    idx -= 1;\n  }\n  return true;\n}\n\n// node_modules/ramda/es/equals.js\nvar equals = /* @__PURE__ */ _curry2(function equals2(a, b2) {\n  return _equals(a, b2, [], []);\n});\nvar equals_default = equals;\n\n// node_modules/ramda/es/internal/_indexOf.js\nfunction _indexOf(list, a, idx) {\n  var inf, item;\n  if (typeof list.indexOf === \"function\") {\n    switch (typeof a) {\n      case \"number\":\n        if (a === 0) {\n          inf = 1 / a;\n          while (idx < list.length) {\n            item = list[idx];\n            if (item === 0 && 1 / item === inf) {\n              return idx;\n            }\n            idx += 1;\n          }\n          return -1;\n        } else if (a !== a) {\n          while (idx < list.length) {\n            item = list[idx];\n            if (typeof item === \"number\" && item !== item) {\n              return idx;\n            }\n            idx += 1;\n          }\n          return -1;\n        }\n        return list.indexOf(a, idx);\n      case \"string\":\n      case \"boolean\":\n      case \"function\":\n      case \"undefined\":\n        return list.indexOf(a, idx);\n      case \"object\":\n        if (a === null) {\n          return list.indexOf(a, idx);\n        }\n    }\n  }\n  while (idx < list.length) {\n    if (equals_default(list[idx], a)) {\n      return idx;\n    }\n    idx += 1;\n  }\n  return -1;\n}\n\n// node_modules/ramda/es/internal/_includes.js\nfunction _includes(a, list) {\n  return _indexOf(list, a, 0) >= 0;\n}\n\n// node_modules/ramda/es/internal/_map.js\nfunction _map(fn, functor) {\n  var idx = 0;\n  var len = functor.length;\n  var result2 = Array(len);\n  while (idx < len) {\n    result2[idx] = fn(functor[idx]);\n    idx += 1;\n  }\n  return result2;\n}\n\n// node_modules/ramda/es/internal/_quote.js\nfunction _quote(s) {\n  var escaped = s.replace(/\\\\/g, \"\\\\\\\\\").replace(/[\\b]/g, \"\\\\b\").replace(/\\f/g, \"\\\\f\").replace(/\\n/g, \"\\\\n\").replace(/\\r/g, \"\\\\r\").replace(/\\t/g, \"\\\\t\").replace(/\\v/g, \"\\\\v\").replace(/\\0/g, \"\\\\0\");\n  return '\"' + escaped.replace(/\"/g, '\\\\\"') + '\"';\n}\n\n// node_modules/ramda/es/internal/_toISOString.js\nvar pad = function pad2(n) {\n  return (n < 10 ? \"0\" : \"\") + n;\n};\nvar _toISOString = typeof Date.prototype.toISOString === \"function\" ? function _toISOString2(d) {\n  return d.toISOString();\n} : function _toISOString3(d) {\n  return d.getUTCFullYear() + \"-\" + pad(d.getUTCMonth() + 1) + \"-\" + pad(d.getUTCDate()) + \"T\" + pad(d.getUTCHours()) + \":\" + pad(d.getUTCMinutes()) + \":\" + pad(d.getUTCSeconds()) + \".\" + (d.getUTCMilliseconds() / 1e3).toFixed(3).slice(2, 5) + \"Z\";\n};\nvar toISOString_default = _toISOString;\n\n// node_modules/ramda/es/internal/_complement.js\nfunction _complement(f) {\n  return function() {\n    return !f.apply(this, arguments);\n  };\n}\n\n// node_modules/ramda/es/internal/_arrayReduce.js\nfunction _arrayReduce(reducer, acc, list) {\n  var index = 0;\n  var length = list.length;\n  while (index < length) {\n    acc = reducer(acc, list[index]);\n    index += 1;\n  }\n  return acc;\n}\n\n// node_modules/ramda/es/internal/_filter.js\nfunction _filter(fn, list) {\n  var idx = 0;\n  var len = list.length;\n  var result2 = [];\n  while (idx < len) {\n    if (fn(list[idx])) {\n      result2[result2.length] = list[idx];\n    }\n    idx += 1;\n  }\n  return result2;\n}\n\n// node_modules/ramda/es/internal/_isObject.js\nfunction _isObject(x2) {\n  return Object.prototype.toString.call(x2) === \"[object Object]\";\n}\n\n// node_modules/ramda/es/internal/_xfilter.js\nvar XFilter = /* @__PURE__ */ function() {\n  function XFilter2(f, xf) {\n    this.xf = xf;\n    this.f = f;\n  }\n  XFilter2.prototype[\"@@transducer/init\"] = xfBase_default.init;\n  XFilter2.prototype[\"@@transducer/result\"] = xfBase_default.result;\n  XFilter2.prototype[\"@@transducer/step\"] = function(result2, input) {\n    return this.f(input) ? this.xf[\"@@transducer/step\"](result2, input) : result2;\n  };\n  return XFilter2;\n}();\nfunction _xfilter(f) {\n  return function(xf) {\n    return new XFilter(f, xf);\n  };\n}\n\n// node_modules/ramda/es/filter.js\nvar filter = /* @__PURE__ */ _curry2(\n  /* @__PURE__ */ _dispatchable([\"fantasy-land/filter\", \"filter\"], _xfilter, function(pred, filterable) {\n    return _isObject(filterable) ? _arrayReduce(function(acc, key) {\n      if (pred(filterable[key])) {\n        acc[key] = filterable[key];\n      }\n      return acc;\n    }, {}, keys_default(filterable)) : (\n      // else\n      _filter(pred, filterable)\n    );\n  })\n);\nvar filter_default = filter;\n\n// node_modules/ramda/es/reject.js\nvar reject = /* @__PURE__ */ _curry2(function reject2(pred, filterable) {\n  return filter_default(_complement(pred), filterable);\n});\nvar reject_default = reject;\n\n// node_modules/ramda/es/internal/_toString.js\nfunction _toString(x2, seen) {\n  var recur = function recur2(y) {\n    var xs = seen.concat([x2]);\n    return _includes(y, xs) ? \"<Circular>\" : _toString(y, xs);\n  };\n  var mapPairs = function(obj, keys4) {\n    return _map(function(k2) {\n      return _quote(k2) + \": \" + recur(obj[k2]);\n    }, keys4.slice().sort());\n  };\n  switch (Object.prototype.toString.call(x2)) {\n    case \"[object Arguments]\":\n      return \"(function() { return arguments; }(\" + _map(recur, x2).join(\", \") + \"))\";\n    case \"[object Array]\":\n      return \"[\" + _map(recur, x2).concat(mapPairs(x2, reject_default(function(k2) {\n        return /^\\d+$/.test(k2);\n      }, keys_default(x2)))).join(\", \") + \"]\";\n    case \"[object Boolean]\":\n      return typeof x2 === \"object\" ? \"new Boolean(\" + recur(x2.valueOf()) + \")\" : x2.toString();\n    case \"[object Date]\":\n      return \"new Date(\" + (isNaN(x2.valueOf()) ? recur(NaN) : _quote(toISOString_default(x2))) + \")\";\n    case \"[object Map]\":\n      return \"new Map(\" + recur(Array.from(x2)) + \")\";\n    case \"[object Null]\":\n      return \"null\";\n    case \"[object Number]\":\n      return typeof x2 === \"object\" ? \"new Number(\" + recur(x2.valueOf()) + \")\" : 1 / x2 === -Infinity ? \"-0\" : x2.toString(10);\n    case \"[object Set]\":\n      return \"new Set(\" + recur(Array.from(x2).sort()) + \")\";\n    case \"[object String]\":\n      return typeof x2 === \"object\" ? \"new String(\" + recur(x2.valueOf()) + \")\" : _quote(x2);\n    case \"[object Undefined]\":\n      return \"undefined\";\n    default:\n      if (typeof x2.toString === \"function\") {\n        var repr = x2.toString();\n        if (repr !== \"[object Object]\") {\n          return repr;\n        }\n      }\n      return \"{\" + mapPairs(x2, keys_default(x2)).join(\", \") + \"}\";\n  }\n}\n\n// node_modules/ramda/es/toString.js\nvar toString2 = /* @__PURE__ */ _curry1(function toString3(val) {\n  return _toString(val, []);\n});\nvar toString_default = toString2;\n\n// node_modules/ramda/es/max.js\nvar max = /* @__PURE__ */ _curry2(function max2(a, b2) {\n  if (a === b2) {\n    return b2;\n  }\n  function safeMax(x2, y) {\n    if (x2 > y !== y > x2) {\n      return y > x2 ? y : x2;\n    }\n    return void 0;\n  }\n  var maxByValue = safeMax(a, b2);\n  if (maxByValue !== void 0) {\n    return maxByValue;\n  }\n  var maxByType = safeMax(typeof a, typeof b2);\n  if (maxByType !== void 0) {\n    return maxByType === typeof a ? a : b2;\n  }\n  var stringA = toString_default(a);\n  var maxByStringValue = safeMax(stringA, toString_default(b2));\n  if (maxByStringValue !== void 0) {\n    return maxByStringValue === stringA ? a : b2;\n  }\n  return b2;\n});\nvar max_default = max;\n\n// node_modules/ramda/es/internal/_xmap.js\nvar XMap = /* @__PURE__ */ function() {\n  function XMap2(f, xf) {\n    this.xf = xf;\n    this.f = f;\n  }\n  XMap2.prototype[\"@@transducer/init\"] = xfBase_default.init;\n  XMap2.prototype[\"@@transducer/result\"] = xfBase_default.result;\n  XMap2.prototype[\"@@transducer/step\"] = function(result2, input) {\n    return this.xf[\"@@transducer/step\"](result2, this.f(input));\n  };\n  return XMap2;\n}();\nvar _xmap = function _xmap2(f) {\n  return function(xf) {\n    return new XMap(f, xf);\n  };\n};\nvar xmap_default = _xmap;\n\n// node_modules/ramda/es/map.js\nvar map = /* @__PURE__ */ _curry2(\n  /* @__PURE__ */ _dispatchable([\"fantasy-land/map\", \"map\"], xmap_default, function map2(fn, functor) {\n    switch (Object.prototype.toString.call(functor)) {\n      case \"[object Function]\":\n        return curryN_default(functor.length, function() {\n          return fn.call(this, functor.apply(this, arguments));\n        });\n      case \"[object Object]\":\n        return _arrayReduce(function(acc, key) {\n          acc[key] = fn(functor[key]);\n          return acc;\n        }, {}, keys_default(functor));\n      default:\n        return _map(fn, functor);\n    }\n  })\n);\nvar map_default = map;\n\n// node_modules/ramda/es/internal/_isInteger.js\nvar isInteger_default = Number.isInteger || function _isInteger(n) {\n  return n << 0 === n;\n};\n\n// node_modules/ramda/es/internal/_isString.js\nfunction _isString(x2) {\n  return Object.prototype.toString.call(x2) === \"[object String]\";\n}\n\n// node_modules/ramda/es/nth.js\nvar nth = /* @__PURE__ */ _curry2(function nth2(offset, list) {\n  var idx = offset < 0 ? list.length + offset : offset;\n  return _isString(list) ? list.charAt(idx) : list[idx];\n});\nvar nth_default = nth;\n\n// node_modules/ramda/es/prop.js\nvar prop = /* @__PURE__ */ _curry2(function prop2(p, obj) {\n  if (obj == null) {\n    return;\n  }\n  return isInteger_default(p) ? nth_default(p, obj) : obj[p];\n});\nvar prop_default = prop;\n\n// node_modules/ramda/es/pluck.js\nvar pluck = /* @__PURE__ */ _curry2(function pluck2(p, list) {\n  return map_default(prop_default(p), list);\n});\nvar pluck_default = pluck;\n\n// node_modules/ramda/es/internal/_isArrayLike.js\nvar _isArrayLike = /* @__PURE__ */ _curry1(function isArrayLike(x2) {\n  if (isArray_default(x2)) {\n    return true;\n  }\n  if (!x2) {\n    return false;\n  }\n  if (typeof x2 !== \"object\") {\n    return false;\n  }\n  if (_isString(x2)) {\n    return false;\n  }\n  if (x2.length === 0) {\n    return true;\n  }\n  if (x2.length > 0) {\n    return x2.hasOwnProperty(0) && x2.hasOwnProperty(x2.length - 1);\n  }\n  return false;\n});\nvar isArrayLike_default = _isArrayLike;\n\n// node_modules/ramda/es/internal/_createReduce.js\nvar symIterator = typeof Symbol !== \"undefined\" ? Symbol.iterator : \"@@iterator\";\nfunction _createReduce(arrayReduce, methodReduce, iterableReduce) {\n  return function _reduce(xf, acc, list) {\n    if (isArrayLike_default(list)) {\n      return arrayReduce(xf, acc, list);\n    }\n    if (list == null) {\n      return acc;\n    }\n    if (typeof list[\"fantasy-land/reduce\"] === \"function\") {\n      return methodReduce(xf, acc, list, \"fantasy-land/reduce\");\n    }\n    if (list[symIterator] != null) {\n      return iterableReduce(xf, acc, list[symIterator]());\n    }\n    if (typeof list.next === \"function\") {\n      return iterableReduce(xf, acc, list);\n    }\n    if (typeof list.reduce === \"function\") {\n      return methodReduce(xf, acc, list, \"reduce\");\n    }\n    throw new TypeError(\"reduce: list must be array or iterable\");\n  };\n}\n\n// node_modules/ramda/es/internal/_xArrayReduce.js\nfunction _xArrayReduce(xf, acc, list) {\n  var idx = 0;\n  var len = list.length;\n  while (idx < len) {\n    acc = xf[\"@@transducer/step\"](acc, list[idx]);\n    if (acc && acc[\"@@transducer/reduced\"]) {\n      acc = acc[\"@@transducer/value\"];\n      break;\n    }\n    idx += 1;\n  }\n  return xf[\"@@transducer/result\"](acc);\n}\n\n// node_modules/ramda/es/bind.js\nvar bind = /* @__PURE__ */ _curry2(function bind2(fn, thisObj) {\n  return _arity(fn.length, function() {\n    return fn.apply(thisObj, arguments);\n  });\n});\nvar bind_default = bind;\n\n// node_modules/ramda/es/internal/_xReduce.js\nfunction _xIterableReduce(xf, acc, iter) {\n  var step = iter.next();\n  while (!step.done) {\n    acc = xf[\"@@transducer/step\"](acc, step.value);\n    if (acc && acc[\"@@transducer/reduced\"]) {\n      acc = acc[\"@@transducer/value\"];\n      break;\n    }\n    step = iter.next();\n  }\n  return xf[\"@@transducer/result\"](acc);\n}\nfunction _xMethodReduce(xf, acc, obj, methodName) {\n  return xf[\"@@transducer/result\"](obj[methodName](bind_default(xf[\"@@transducer/step\"], xf), acc));\n}\nvar _xReduce = /* @__PURE__ */ _createReduce(_xArrayReduce, _xMethodReduce, _xIterableReduce);\nvar xReduce_default = _xReduce;\n\n// node_modules/ramda/es/internal/_xwrap.js\nvar XWrap = /* @__PURE__ */ function() {\n  function XWrap2(fn) {\n    this.f = fn;\n  }\n  XWrap2.prototype[\"@@transducer/init\"] = function() {\n    throw new Error(\"init not implemented on XWrap\");\n  };\n  XWrap2.prototype[\"@@transducer/result\"] = function(acc) {\n    return acc;\n  };\n  XWrap2.prototype[\"@@transducer/step\"] = function(acc, x2) {\n    return this.f(acc, x2);\n  };\n  return XWrap2;\n}();\nfunction _xwrap(fn) {\n  return new XWrap(fn);\n}\n\n// node_modules/ramda/es/reduce.js\nvar reduce = /* @__PURE__ */ _curry3(function(xf, acc, list) {\n  return xReduce_default(typeof xf === \"function\" ? _xwrap(xf) : xf, acc, list);\n});\nvar reduce_default = reduce;\n\n// node_modules/ramda/es/allPass.js\nvar allPass = /* @__PURE__ */ _curry1(function allPass2(preds) {\n  return curryN_default(reduce_default(max_default, 0, pluck_default(\"length\", preds)), function() {\n    var idx = 0;\n    var len = preds.length;\n    while (idx < len) {\n      if (!preds[idx].apply(this, arguments)) {\n        return false;\n      }\n      idx += 1;\n    }\n    return true;\n  });\n});\nvar allPass_default = allPass;\n\n// node_modules/ramda/es/always.js\nvar always = /* @__PURE__ */ _curry1(function always2(val) {\n  return function() {\n    return val;\n  };\n});\nvar always_default = always;\n\n// node_modules/ramda/es/append.js\nvar append = /* @__PURE__ */ _curry2(function append2(el, list) {\n  return _concat(list, [el]);\n});\nvar append_default = append;\n\n// node_modules/ramda/es/internal/_assoc.js\nfunction _assoc(prop3, val, obj) {\n  if (isInteger_default(prop3) && isArray_default(obj)) {\n    var arr = [].concat(obj);\n    arr[prop3] = val;\n    return arr;\n  }\n  var result2 = {};\n  for (var p in obj) {\n    result2[p] = obj[p];\n  }\n  result2[prop3] = val;\n  return result2;\n}\n\n// node_modules/ramda/es/isNil.js\nvar isNil = /* @__PURE__ */ _curry1(function isNil2(x2) {\n  return x2 == null;\n});\nvar isNil_default = isNil;\n\n// node_modules/ramda/es/assocPath.js\nvar assocPath = /* @__PURE__ */ _curry3(function assocPath2(path3, val, obj) {\n  if (path3.length === 0) {\n    return val;\n  }\n  var idx = path3[0];\n  if (path3.length > 1) {\n    var nextObj = !isNil_default(obj) && _has(idx, obj) && typeof obj[idx] === \"object\" ? obj[idx] : isInteger_default(path3[1]) ? [] : {};\n    val = assocPath2(Array.prototype.slice.call(path3, 1), val, nextObj);\n  }\n  return _assoc(idx, val, obj);\n});\nvar assocPath_default = assocPath;\n\n// node_modules/ramda/es/assoc.js\nvar assoc = /* @__PURE__ */ _curry3(function assoc2(prop3, val, obj) {\n  return assocPath_default([prop3], val, obj);\n});\nvar assoc_default = assoc;\n\n// node_modules/ramda/es/internal/_isFunction.js\nfunction _isFunction(x2) {\n  var type3 = Object.prototype.toString.call(x2);\n  return type3 === \"[object Function]\" || type3 === \"[object AsyncFunction]\" || type3 === \"[object GeneratorFunction]\" || type3 === \"[object AsyncGeneratorFunction]\";\n}\n\n// node_modules/ramda/es/internal/_makeFlat.js\nfunction _makeFlat(recursive) {\n  return function flatt(list) {\n    var value, jlen, j2;\n    var result2 = [];\n    var idx = 0;\n    var ilen = list.length;\n    while (idx < ilen) {\n      if (isArrayLike_default(list[idx])) {\n        value = recursive ? flatt(list[idx]) : list[idx];\n        j2 = 0;\n        jlen = value.length;\n        while (j2 < jlen) {\n          result2[result2.length] = value[j2];\n          j2 += 1;\n        }\n      } else {\n        result2[result2.length] = list[idx];\n      }\n      idx += 1;\n    }\n    return result2;\n  };\n}\n\n// node_modules/ramda/es/internal/_forceReduced.js\nfunction _forceReduced(x2) {\n  return {\n    \"@@transducer/value\": x2,\n    \"@@transducer/reduced\": true\n  };\n}\n\n// node_modules/ramda/es/internal/_flatCat.js\nvar tInit = \"@@transducer/init\";\nvar tStep = \"@@transducer/step\";\nvar tResult = \"@@transducer/result\";\nvar XPreservingReduced = /* @__PURE__ */ function() {\n  function XPreservingReduced2(xf) {\n    this.xf = xf;\n  }\n  XPreservingReduced2.prototype[tInit] = xfBase_default.init;\n  XPreservingReduced2.prototype[tResult] = xfBase_default.result;\n  XPreservingReduced2.prototype[tStep] = function(result2, input) {\n    var ret = this.xf[tStep](result2, input);\n    return ret[\"@@transducer/reduced\"] ? _forceReduced(ret) : ret;\n  };\n  return XPreservingReduced2;\n}();\nvar XFlatCat = /* @__PURE__ */ function() {\n  function XFlatCat2(xf) {\n    this.xf = new XPreservingReduced(xf);\n  }\n  XFlatCat2.prototype[tInit] = xfBase_default.init;\n  XFlatCat2.prototype[tResult] = xfBase_default.result;\n  XFlatCat2.prototype[tStep] = function(result2, input) {\n    return !isArrayLike_default(input) ? _xArrayReduce(this.xf, result2, [input]) : xReduce_default(this.xf, result2, input);\n  };\n  return XFlatCat2;\n}();\nvar _flatCat = function _xcat(xf) {\n  return new XFlatCat(xf);\n};\nvar flatCat_default = _flatCat;\n\n// node_modules/ramda/es/internal/_xchain.js\nfunction _xchain(f) {\n  return function(xf) {\n    return xmap_default(f)(flatCat_default(xf));\n  };\n}\n\n// node_modules/ramda/es/chain.js\nvar chain = /* @__PURE__ */ _curry2(\n  /* @__PURE__ */ _dispatchable([\"fantasy-land/chain\", \"chain\"], _xchain, function chain2(fn, monad) {\n    if (typeof monad === \"function\") {\n      return function(x2) {\n        return fn(monad(x2))(x2);\n      };\n    }\n    return _makeFlat(false)(map_default(fn, monad));\n  })\n);\nvar chain_default = chain;\n\n// node_modules/ramda/es/internal/_pipe.js\nfunction _pipe(f, g) {\n  return function() {\n    return g.call(this, f.apply(this, arguments));\n  };\n}\n\n// node_modules/ramda/es/internal/_checkForMethod.js\nfunction _checkForMethod(methodname, fn) {\n  return function() {\n    var length = arguments.length;\n    if (length === 0) {\n      return fn();\n    }\n    var obj = arguments[length - 1];\n    return isArray_default(obj) || typeof obj[methodname] !== \"function\" ? fn.apply(this, arguments) : obj[methodname].apply(obj, Array.prototype.slice.call(arguments, 0, length - 1));\n  };\n}\n\n// node_modules/ramda/es/slice.js\nvar slice = /* @__PURE__ */ _curry3(\n  /* @__PURE__ */ _checkForMethod(\"slice\", function slice2(fromIndex, toIndex, list) {\n    return Array.prototype.slice.call(list, fromIndex, toIndex);\n  })\n);\nvar slice_default = slice;\n\n// node_modules/ramda/es/tail.js\nvar tail = /* @__PURE__ */ _curry1(\n  /* @__PURE__ */ _checkForMethod(\n    \"tail\",\n    /* @__PURE__ */ slice_default(1, Infinity)\n  )\n);\nvar tail_default = tail;\n\n// node_modules/ramda/es/pipe.js\nfunction pipe() {\n  if (arguments.length === 0) {\n    throw new Error(\"pipe requires at least one argument\");\n  }\n  return _arity(arguments[0].length, reduce_default(_pipe, arguments[0], tail_default(arguments)));\n}\n\n// node_modules/ramda/es/internal/_identity.js\nfunction _identity(x2) {\n  return x2;\n}\n\n// node_modules/ramda/es/identity.js\nvar identity = /* @__PURE__ */ _curry1(_identity);\nvar identity_default = identity;\n\n// node_modules/ramda/es/concat.js\nvar concat = /* @__PURE__ */ _curry2(function concat2(a, b2) {\n  if (isArray_default(a)) {\n    if (isArray_default(b2)) {\n      return a.concat(b2);\n    }\n    throw new TypeError(toString_default(b2) + \" is not an array\");\n  }\n  if (_isString(a)) {\n    if (_isString(b2)) {\n      return a + b2;\n    }\n    throw new TypeError(toString_default(b2) + \" is not a string\");\n  }\n  if (a != null && _isFunction(a[\"fantasy-land/concat\"])) {\n    return a[\"fantasy-land/concat\"](b2);\n  }\n  if (a != null && _isFunction(a.concat)) {\n    return a.concat(b2);\n  }\n  throw new TypeError(toString_default(a) + ' does not have a method named \"concat\" or \"fantasy-land/concat\"');\n});\nvar concat_default = concat;\n\n// node_modules/ramda/es/cond.js\nvar cond = /* @__PURE__ */ _curry1(function cond2(pairs) {\n  var arity = reduce_default(max_default, 0, map_default(function(pair) {\n    return pair[0].length;\n  }, pairs));\n  return _arity(arity, function() {\n    var idx = 0;\n    while (idx < pairs.length) {\n      if (pairs[idx][0].apply(this, arguments)) {\n        return pairs[idx][1].apply(this, arguments);\n      }\n      idx += 1;\n    }\n  });\n});\nvar cond_default = cond;\n\n// node_modules/ramda/es/defaultTo.js\nvar defaultTo = /* @__PURE__ */ _curry2(function defaultTo2(d, v2) {\n  return v2 == null || v2 !== v2 ? d : v2;\n});\nvar defaultTo_default = defaultTo;\n\n// node_modules/ramda/es/hasPath.js\nvar hasPath = /* @__PURE__ */ _curry2(function hasPath2(_path, obj) {\n  if (_path.length === 0 || isNil_default(obj)) {\n    return false;\n  }\n  var val = obj;\n  var idx = 0;\n  while (idx < _path.length) {\n    if (!isNil_default(val) && _has(_path[idx], val)) {\n      val = val[_path[idx]];\n      idx += 1;\n    } else {\n      return false;\n    }\n  }\n  return true;\n});\nvar hasPath_default = hasPath;\n\n// node_modules/ramda/es/has.js\nvar has = /* @__PURE__ */ _curry2(function has2(prop3, obj) {\n  return hasPath_default([prop3], obj);\n});\nvar has_default = has;\n\n// node_modules/ramda/es/ifElse.js\nvar ifElse = /* @__PURE__ */ _curry3(function ifElse2(condition, onTrue, onFalse) {\n  return curryN_default(Math.max(condition.length, onTrue.length, onFalse.length), function _ifElse() {\n    return condition.apply(this, arguments) ? onTrue.apply(this, arguments) : onFalse.apply(this, arguments);\n  });\n});\nvar ifElse_default = ifElse;\n\n// node_modules/ramda/es/includes.js\nvar includes = /* @__PURE__ */ _curry2(_includes);\nvar includes_default = includes;\n\n// node_modules/ramda/es/invoker.js\nvar invoker = /* @__PURE__ */ _curry2(function invoker2(arity, method) {\n  return curryN_default(arity + 1, function() {\n    var target = arguments[arity];\n    if (target != null && _isFunction(target[method])) {\n      return target[method].apply(target, Array.prototype.slice.call(arguments, 0, arity));\n    }\n    throw new TypeError(toString_default(target) + ' does not have a method named \"' + method + '\"');\n  });\n});\nvar invoker_default = invoker;\n\n// node_modules/ramda/es/is.js\nvar is = /* @__PURE__ */ _curry2(function is2(Ctor, val) {\n  return val instanceof Ctor || val != null && (val.constructor === Ctor || Ctor.name === \"Object\" && typeof val === \"object\");\n});\nvar is_default = is;\n\n// node_modules/ramda/es/isNotNil.js\nvar isNotNil = /* @__PURE__ */ _curry1(function isNotNil2(x2) {\n  return !isNil_default(x2);\n});\nvar isNotNil_default = isNotNil;\n\n// node_modules/ramda/es/join.js\nvar join = /* @__PURE__ */ invoker_default(1, \"join\");\nvar join_default = join;\n\n// node_modules/ramda/es/paths.js\nvar paths = /* @__PURE__ */ _curry2(function paths2(pathsArray, obj) {\n  return pathsArray.map(function(paths3) {\n    var val = obj;\n    var idx = 0;\n    var p;\n    while (idx < paths3.length) {\n      if (val == null) {\n        return;\n      }\n      p = paths3[idx];\n      val = isInteger_default(p) ? nth_default(p, val) : val[p];\n      idx += 1;\n    }\n    return val;\n  });\n});\nvar paths_default = paths;\n\n// node_modules/ramda/es/path.js\nvar path = /* @__PURE__ */ _curry2(function path2(pathAr, obj) {\n  return paths_default([pathAr], obj)[0];\n});\nvar path_default = path;\n\n// node_modules/ramda/es/propEq.js\nvar propEq = /* @__PURE__ */ _curry3(function propEq2(val, name, obj) {\n  return equals_default(val, prop_default(name, obj));\n});\nvar propEq_default = propEq;\n\n// node_modules/ramda/es/propOr.js\nvar propOr = /* @__PURE__ */ _curry3(function propOr2(val, p, obj) {\n  return defaultTo_default(val, prop_default(p, obj));\n});\nvar propOr_default = propOr;\n\n// node_modules/ramda/es/internal/_xtap.js\nvar XTap = /* @__PURE__ */ function() {\n  function XTap2(f, xf) {\n    this.xf = xf;\n    this.f = f;\n  }\n  XTap2.prototype[\"@@transducer/init\"] = xfBase_default.init;\n  XTap2.prototype[\"@@transducer/result\"] = xfBase_default.result;\n  XTap2.prototype[\"@@transducer/step\"] = function(result2, input) {\n    this.f(input);\n    return this.xf[\"@@transducer/step\"](result2, input);\n  };\n  return XTap2;\n}();\nfunction _xtap(f) {\n  return function(xf) {\n    return new XTap(f, xf);\n  };\n}\n\n// node_modules/ramda/es/tap.js\nvar tap = /* @__PURE__ */ _curry2(\n  /* @__PURE__ */ _dispatchable([], _xtap, function tap2(fn, x2) {\n    fn(x2);\n    return x2;\n  })\n);\nvar tap_default = tap;\n\n// node_modules/zod/lib/index.mjs\nvar util;\n(function(util2) {\n  util2.assertEqual = (val) => val;\n  function assertIs(_arg) {\n  }\n  util2.assertIs = assertIs;\n  function assertNever(_x) {\n    throw new Error();\n  }\n  util2.assertNever = assertNever;\n  util2.arrayToEnum = (items) => {\n    const obj = {};\n    for (const item of items) {\n      obj[item] = item;\n    }\n    return obj;\n  };\n  util2.getValidEnumValues = (obj) => {\n    const validKeys = util2.objectKeys(obj).filter((k2) => typeof obj[obj[k2]] !== \"number\");\n    const filtered = {};\n    for (const k2 of validKeys) {\n      filtered[k2] = obj[k2];\n    }\n    return util2.objectValues(filtered);\n  };\n  util2.objectValues = (obj) => {\n    return util2.objectKeys(obj).map(function(e) {\n      return obj[e];\n    });\n  };\n  util2.objectKeys = typeof Object.keys === \"function\" ? (obj) => Object.keys(obj) : (object) => {\n    const keys4 = [];\n    for (const key in object) {\n      if (Object.prototype.hasOwnProperty.call(object, key)) {\n        keys4.push(key);\n      }\n    }\n    return keys4;\n  };\n  util2.find = (arr, checker) => {\n    for (const item of arr) {\n      if (checker(item))\n        return item;\n    }\n    return void 0;\n  };\n  util2.isInteger = typeof Number.isInteger === \"function\" ? (val) => Number.isInteger(val) : (val) => typeof val === \"number\" && isFinite(val) && Math.floor(val) === val;\n  function joinValues(array, separator = \" | \") {\n    return array.map((val) => typeof val === \"string\" ? `'${val}'` : val).join(separator);\n  }\n  util2.joinValues = joinValues;\n  util2.jsonStringifyReplacer = (_2, value) => {\n    if (typeof value === \"bigint\") {\n      return value.toString();\n    }\n    return value;\n  };\n})(util || (util = {}));\nvar objectUtil;\n(function(objectUtil2) {\n  objectUtil2.mergeShapes = (first, second) => {\n    return {\n      ...first,\n      ...second\n      // second overwrites first\n    };\n  };\n})(objectUtil || (objectUtil = {}));\nvar ZodParsedType = util.arrayToEnum([\n  \"string\",\n  \"nan\",\n  \"number\",\n  \"integer\",\n  \"float\",\n  \"boolean\",\n  \"date\",\n  \"bigint\",\n  \"symbol\",\n  \"function\",\n  \"undefined\",\n  \"null\",\n  \"array\",\n  \"object\",\n  \"unknown\",\n  \"promise\",\n  \"void\",\n  \"never\",\n  \"map\",\n  \"set\"\n]);\nvar getParsedType = (data) => {\n  const t = typeof data;\n  switch (t) {\n    case \"undefined\":\n      return ZodParsedType.undefined;\n    case \"string\":\n      return ZodParsedType.string;\n    case \"number\":\n      return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;\n    case \"boolean\":\n      return ZodParsedType.boolean;\n    case \"function\":\n      return ZodParsedType.function;\n    case \"bigint\":\n      return ZodParsedType.bigint;\n    case \"symbol\":\n      return ZodParsedType.symbol;\n    case \"object\":\n      if (Array.isArray(data)) {\n        return ZodParsedType.array;\n      }\n      if (data === null) {\n        return ZodParsedType.null;\n      }\n      if (data.then && typeof data.then === \"function\" && data.catch && typeof data.catch === \"function\") {\n        return ZodParsedType.promise;\n      }\n      if (typeof Map !== \"undefined\" && data instanceof Map) {\n        return ZodParsedType.map;\n      }\n      if (typeof Set !== \"undefined\" && data instanceof Set) {\n        return ZodParsedType.set;\n      }\n      if (typeof Date !== \"undefined\" && data instanceof Date) {\n        return ZodParsedType.date;\n      }\n      return ZodParsedType.object;\n    default:\n      return ZodParsedType.unknown;\n  }\n};\nvar ZodIssueCode = util.arrayToEnum([\n  \"invalid_type\",\n  \"invalid_literal\",\n  \"custom\",\n  \"invalid_union\",\n  \"invalid_union_discriminator\",\n  \"invalid_enum_value\",\n  \"unrecognized_keys\",\n  \"invalid_arguments\",\n  \"invalid_return_type\",\n  \"invalid_date\",\n  \"invalid_string\",\n  \"too_small\",\n  \"too_big\",\n  \"invalid_intersection_types\",\n  \"not_multiple_of\",\n  \"not_finite\"\n]);\nvar quotelessJson = (obj) => {\n  const json = JSON.stringify(obj, null, 2);\n  return json.replace(/\"([^\"]+)\":/g, \"$1:\");\n};\nvar ZodError = class extends Error {\n  constructor(issues) {\n    super();\n    this.issues = [];\n    this.addIssue = (sub) => {\n      this.issues = [...this.issues, sub];\n    };\n    this.addIssues = (subs = []) => {\n      this.issues = [...this.issues, ...subs];\n    };\n    const actualProto = new.target.prototype;\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(this, actualProto);\n    } else {\n      this.__proto__ = actualProto;\n    }\n    this.name = \"ZodError\";\n    this.issues = issues;\n  }\n  get errors() {\n    return this.issues;\n  }\n  format(_mapper) {\n    const mapper = _mapper || function(issue) {\n      return issue.message;\n    };\n    const fieldErrors = { _errors: [] };\n    const processError = (error) => {\n      for (const issue of error.issues) {\n        if (issue.code === \"invalid_union\") {\n          issue.unionErrors.map(processError);\n        } else if (issue.code === \"invalid_return_type\") {\n          processError(issue.returnTypeError);\n        } else if (issue.code === \"invalid_arguments\") {\n          processError(issue.argumentsError);\n        } else if (issue.path.length === 0) {\n          fieldErrors._errors.push(mapper(issue));\n        } else {\n          let curr = fieldErrors;\n          let i = 0;\n          while (i < issue.path.length) {\n            const el = issue.path[i];\n            const terminal = i === issue.path.length - 1;\n            if (!terminal) {\n              curr[el] = curr[el] || { _errors: [] };\n            } else {\n              curr[el] = curr[el] || { _errors: [] };\n              curr[el]._errors.push(mapper(issue));\n            }\n            curr = curr[el];\n            i++;\n          }\n        }\n      }\n    };\n    processError(this);\n    return fieldErrors;\n  }\n  toString() {\n    return this.message;\n  }\n  get message() {\n    return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);\n  }\n  get isEmpty() {\n    return this.issues.length === 0;\n  }\n  flatten(mapper = (issue) => issue.message) {\n    const fieldErrors = {};\n    const formErrors = [];\n    for (const sub of this.issues) {\n      if (sub.path.length > 0) {\n        fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];\n        fieldErrors[sub.path[0]].push(mapper(sub));\n      } else {\n        formErrors.push(mapper(sub));\n      }\n    }\n    return { formErrors, fieldErrors };\n  }\n  get formErrors() {\n    return this.flatten();\n  }\n};\nZodError.create = (issues) => {\n  const error = new ZodError(issues);\n  return error;\n};\nvar errorMap = (issue, _ctx) => {\n  let message2;\n  switch (issue.code) {\n    case ZodIssueCode.invalid_type:\n      if (issue.received === ZodParsedType.undefined) {\n        message2 = \"Required\";\n      } else {\n        message2 = `Expected ${issue.expected}, received ${issue.received}`;\n      }\n      break;\n    case ZodIssueCode.invalid_literal:\n      message2 = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;\n      break;\n    case ZodIssueCode.unrecognized_keys:\n      message2 = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, \", \")}`;\n      break;\n    case ZodIssueCode.invalid_union:\n      message2 = `Invalid input`;\n      break;\n    case ZodIssueCode.invalid_union_discriminator:\n      message2 = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;\n      break;\n    case ZodIssueCode.invalid_enum_value:\n      message2 = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;\n      break;\n    case ZodIssueCode.invalid_arguments:\n      message2 = `Invalid function arguments`;\n      break;\n    case ZodIssueCode.invalid_return_type:\n      message2 = `Invalid function return type`;\n      break;\n    case ZodIssueCode.invalid_date:\n      message2 = `Invalid date`;\n      break;\n    case ZodIssueCode.invalid_string:\n      if (typeof issue.validation === \"object\") {\n        if (\"includes\" in issue.validation) {\n          message2 = `Invalid input: must include \"${issue.validation.includes}\"`;\n          if (typeof issue.validation.position === \"number\") {\n            message2 = `${message2} at one or more positions greater than or equal to ${issue.validation.position}`;\n          }\n        } else if (\"startsWith\" in issue.validation) {\n          message2 = `Invalid input: must start with \"${issue.validation.startsWith}\"`;\n        } else if (\"endsWith\" in issue.validation) {\n          message2 = `Invalid input: must end with \"${issue.validation.endsWith}\"`;\n        } else {\n          util.assertNever(issue.validation);\n        }\n      } else if (issue.validation !== \"regex\") {\n        message2 = `Invalid ${issue.validation}`;\n      } else {\n        message2 = \"Invalid\";\n      }\n      break;\n    case ZodIssueCode.too_small:\n      if (issue.type === \"array\")\n        message2 = `Array must contain ${issue.exact ? \"exactly\" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;\n      else if (issue.type === \"string\")\n        message2 = `String must contain ${issue.exact ? \"exactly\" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;\n      else if (issue.type === \"number\")\n        message2 = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;\n      else if (issue.type === \"date\")\n        message2 = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;\n      else\n        message2 = \"Invalid input\";\n      break;\n    case ZodIssueCode.too_big:\n      if (issue.type === \"array\")\n        message2 = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;\n      else if (issue.type === \"string\")\n        message2 = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;\n      else if (issue.type === \"number\")\n        message2 = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;\n      else if (issue.type === \"bigint\")\n        message2 = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;\n      else if (issue.type === \"date\")\n        message2 = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;\n      else\n        message2 = \"Invalid input\";\n      break;\n    case ZodIssueCode.custom:\n      message2 = `Invalid input`;\n      break;\n    case ZodIssueCode.invalid_intersection_types:\n      message2 = `Intersection results could not be merged`;\n      break;\n    case ZodIssueCode.not_multiple_of:\n      message2 = `Number must be a multiple of ${issue.multipleOf}`;\n      break;\n    case ZodIssueCode.not_finite:\n      message2 = \"Number must be finite\";\n      break;\n    default:\n      message2 = _ctx.defaultError;\n      util.assertNever(issue);\n  }\n  return { message: message2 };\n};\nvar overrideErrorMap = errorMap;\nfunction setErrorMap(map3) {\n  overrideErrorMap = map3;\n}\nfunction getErrorMap() {\n  return overrideErrorMap;\n}\nvar makeIssue = (params) => {\n  const { data, path: path3, errorMaps, issueData } = params;\n  const fullPath = [...path3, ...issueData.path || []];\n  const fullIssue = {\n    ...issueData,\n    path: fullPath\n  };\n  let errorMessage = \"\";\n  const maps = errorMaps.filter((m) => !!m).slice().reverse();\n  for (const map3 of maps) {\n    errorMessage = map3(fullIssue, { data, defaultError: errorMessage }).message;\n  }\n  return {\n    ...issueData,\n    path: fullPath,\n    message: issueData.message || errorMessage\n  };\n};\nvar EMPTY_PATH = [];\nfunction addIssueToContext(ctx, issueData) {\n  const issue = makeIssue({\n    issueData,\n    data: ctx.data,\n    path: ctx.path,\n    errorMaps: [\n      ctx.common.contextualErrorMap,\n      ctx.schemaErrorMap,\n      getErrorMap(),\n      errorMap\n      // then global default map\n    ].filter((x2) => !!x2)\n  });\n  ctx.common.issues.push(issue);\n}\nvar ParseStatus = class _ParseStatus {\n  constructor() {\n    this.value = \"valid\";\n  }\n  dirty() {\n    if (this.value === \"valid\")\n      this.value = \"dirty\";\n  }\n  abort() {\n    if (this.value !== \"aborted\")\n      this.value = \"aborted\";\n  }\n  static mergeArray(status, results2) {\n    const arrayValue = [];\n    for (const s of results2) {\n      if (s.status === \"aborted\")\n        return INVALID;\n      if (s.status === \"dirty\")\n        status.dirty();\n      arrayValue.push(s.value);\n    }\n    return { status: status.value, value: arrayValue };\n  }\n  static async mergeObjectAsync(status, pairs) {\n    const syncPairs = [];\n    for (const pair of pairs) {\n      syncPairs.push({\n        key: await pair.key,\n        value: await pair.value\n      });\n    }\n    return _ParseStatus.mergeObjectSync(status, syncPairs);\n  }\n  static mergeObjectSync(status, pairs) {\n    const finalObject = {};\n    for (const pair of pairs) {\n      const { key, value } = pair;\n      if (key.status === \"aborted\")\n        return INVALID;\n      if (value.status === \"aborted\")\n        return INVALID;\n      if (key.status === \"dirty\")\n        status.dirty();\n      if (value.status === \"dirty\")\n        status.dirty();\n      if (key.value !== \"__proto__\" && (typeof value.value !== \"undefined\" || pair.alwaysSet)) {\n        finalObject[key.value] = value.value;\n      }\n    }\n    return { status: status.value, value: finalObject };\n  }\n};\nvar INVALID = Object.freeze({\n  status: \"aborted\"\n});\nvar DIRTY = (value) => ({ status: \"dirty\", value });\nvar OK = (value) => ({ status: \"valid\", value });\nvar isAborted = (x2) => x2.status === \"aborted\";\nvar isDirty = (x2) => x2.status === \"dirty\";\nvar isValid = (x2) => x2.status === \"valid\";\nvar isAsync = (x2) => typeof Promise !== \"undefined\" && x2 instanceof Promise;\nvar errorUtil;\n(function(errorUtil2) {\n  errorUtil2.errToObj = (message2) => typeof message2 === \"string\" ? { message: message2 } : message2 || {};\n  errorUtil2.toString = (message2) => typeof message2 === \"string\" ? message2 : message2 === null || message2 === void 0 ? void 0 : message2.message;\n})(errorUtil || (errorUtil = {}));\nvar ParseInputLazyPath = class {\n  constructor(parent, value, path3, key) {\n    this._cachedPath = [];\n    this.parent = parent;\n    this.data = value;\n    this._path = path3;\n    this._key = key;\n  }\n  get path() {\n    if (!this._cachedPath.length) {\n      if (this._key instanceof Array) {\n        this._cachedPath.push(...this._path, ...this._key);\n      } else {\n        this._cachedPath.push(...this._path, this._key);\n      }\n    }\n    return this._cachedPath;\n  }\n};\nvar handleResult = (ctx, result2) => {\n  if (isValid(result2)) {\n    return { success: true, data: result2.value };\n  } else {\n    if (!ctx.common.issues.length) {\n      throw new Error(\"Validation failed but no issues detected.\");\n    }\n    return {\n      success: false,\n      get error() {\n        if (this._error)\n          return this._error;\n        const error = new ZodError(ctx.common.issues);\n        this._error = error;\n        return this._error;\n      }\n    };\n  }\n};\nfunction processCreateParams(params) {\n  if (!params)\n    return {};\n  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;\n  if (errorMap2 && (invalid_type_error || required_error)) {\n    throw new Error(`Can't use \"invalid_type_error\" or \"required_error\" in conjunction with custom error map.`);\n  }\n  if (errorMap2)\n    return { errorMap: errorMap2, description };\n  const customMap = (iss, ctx) => {\n    if (iss.code !== \"invalid_type\")\n      return { message: ctx.defaultError };\n    if (typeof ctx.data === \"undefined\") {\n      return { message: required_error !== null && required_error !== void 0 ? required_error : ctx.defaultError };\n    }\n    return { message: invalid_type_error !== null && invalid_type_error !== void 0 ? invalid_type_error : ctx.defaultError };\n  };\n  return { errorMap: customMap, description };\n}\nvar ZodType = class {\n  constructor(def) {\n    this.spa = this.safeParseAsync;\n    this._def = def;\n    this.parse = this.parse.bind(this);\n    this.safeParse = this.safeParse.bind(this);\n    this.parseAsync = this.parseAsync.bind(this);\n    this.safeParseAsync = this.safeParseAsync.bind(this);\n    this.spa = this.spa.bind(this);\n    this.refine = this.refine.bind(this);\n    this.refinement = this.refinement.bind(this);\n    this.superRefine = this.superRefine.bind(this);\n    this.optional = this.optional.bind(this);\n    this.nullable = this.nullable.bind(this);\n    this.nullish = this.nullish.bind(this);\n    this.array = this.array.bind(this);\n    this.promise = this.promise.bind(this);\n    this.or = this.or.bind(this);\n    this.and = this.and.bind(this);\n    this.transform = this.transform.bind(this);\n    this.brand = this.brand.bind(this);\n    this.default = this.default.bind(this);\n    this.catch = this.catch.bind(this);\n    this.describe = this.describe.bind(this);\n    this.pipe = this.pipe.bind(this);\n    this.readonly = this.readonly.bind(this);\n    this.isNullable = this.isNullable.bind(this);\n    this.isOptional = this.isOptional.bind(this);\n  }\n  get description() {\n    return this._def.description;\n  }\n  _getType(input) {\n    return getParsedType(input.data);\n  }\n  _getOrReturnCtx(input, ctx) {\n    return ctx || {\n      common: input.parent.common,\n      data: input.data,\n      parsedType: getParsedType(input.data),\n      schemaErrorMap: this._def.errorMap,\n      path: input.path,\n      parent: input.parent\n    };\n  }\n  _processInputParams(input) {\n    return {\n      status: new ParseStatus(),\n      ctx: {\n        common: input.parent.common,\n        data: input.data,\n        parsedType: getParsedType(input.data),\n        schemaErrorMap: this._def.errorMap,\n        path: input.path,\n        parent: input.parent\n      }\n    };\n  }\n  _parseSync(input) {\n    const result2 = this._parse(input);\n    if (isAsync(result2)) {\n      throw new Error(\"Synchronous parse encountered promise.\");\n    }\n    return result2;\n  }\n  _parseAsync(input) {\n    const result2 = this._parse(input);\n    return Promise.resolve(result2);\n  }\n  parse(data, params) {\n    const result2 = this.safeParse(data, params);\n    if (result2.success)\n      return result2.data;\n    throw result2.error;\n  }\n  safeParse(data, params) {\n    var _a;\n    const ctx = {\n      common: {\n        issues: [],\n        async: (_a = params === null || params === void 0 ? void 0 : params.async) !== null && _a !== void 0 ? _a : false,\n        contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap\n      },\n      path: (params === null || params === void 0 ? void 0 : params.path) || [],\n      schemaErrorMap: this._def.errorMap,\n      parent: null,\n      data,\n      parsedType: getParsedType(data)\n    };\n    const result2 = this._parseSync({ data, path: ctx.path, parent: ctx });\n    return handleResult(ctx, result2);\n  }\n  async parseAsync(data, params) {\n    const result2 = await this.safeParseAsync(data, params);\n    if (result2.success)\n      return result2.data;\n    throw result2.error;\n  }\n  async safeParseAsync(data, params) {\n    const ctx = {\n      common: {\n        issues: [],\n        contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,\n        async: true\n      },\n      path: (params === null || params === void 0 ? void 0 : params.path) || [],\n      schemaErrorMap: this._def.errorMap,\n      parent: null,\n      data,\n      parsedType: getParsedType(data)\n    };\n    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });\n    const result2 = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));\n    return handleResult(ctx, result2);\n  }\n  refine(check, message2) {\n    const getIssueProperties = (val) => {\n      if (typeof message2 === \"string\" || typeof message2 === \"undefined\") {\n        return { message: message2 };\n      } else if (typeof message2 === \"function\") {\n        return message2(val);\n      } else {\n        return message2;\n      }\n    };\n    return this._refinement((val, ctx) => {\n      const result2 = check(val);\n      const setError = () => ctx.addIssue({\n        code: ZodIssueCode.custom,\n        ...getIssueProperties(val)\n      });\n      if (typeof Promise !== \"undefined\" && result2 instanceof Promise) {\n        return result2.then((data) => {\n          if (!data) {\n            setError();\n            return false;\n          } else {\n            return true;\n          }\n        });\n      }\n      if (!result2) {\n        setError();\n        return false;\n      } else {\n        return true;\n      }\n    });\n  }\n  refinement(check, refinementData) {\n    return this._refinement((val, ctx) => {\n      if (!check(val)) {\n        ctx.addIssue(typeof refinementData === \"function\" ? refinementData(val, ctx) : refinementData);\n        return false;\n      } else {\n        return true;\n      }\n    });\n  }\n  _refinement(refinement) {\n    return new ZodEffects({\n      schema: this,\n      typeName: ZodFirstPartyTypeKind.ZodEffects,\n      effect: { type: \"refinement\", refinement }\n    });\n  }\n  superRefine(refinement) {\n    return this._refinement(refinement);\n  }\n  optional() {\n    return ZodOptional.create(this, this._def);\n  }\n  nullable() {\n    return ZodNullable.create(this, this._def);\n  }\n  nullish() {\n    return this.nullable().optional();\n  }\n  array() {\n    return ZodArray.create(this, this._def);\n  }\n  promise() {\n    return ZodPromise.create(this, this._def);\n  }\n  or(option) {\n    return ZodUnion.create([this, option], this._def);\n  }\n  and(incoming) {\n    return ZodIntersection.create(this, incoming, this._def);\n  }\n  transform(transform) {\n    return new ZodEffects({\n      ...processCreateParams(this._def),\n      schema: this,\n      typeName: ZodFirstPartyTypeKind.ZodEffects,\n      effect: { type: \"transform\", transform }\n    });\n  }\n  default(def) {\n    const defaultValueFunc = typeof def === \"function\" ? def : () => def;\n    return new ZodDefault({\n      ...processCreateParams(this._def),\n      innerType: this,\n      defaultValue: defaultValueFunc,\n      typeName: ZodFirstPartyTypeKind.ZodDefault\n    });\n  }\n  brand() {\n    return new ZodBranded({\n      typeName: ZodFirstPartyTypeKind.ZodBranded,\n      type: this,\n      ...processCreateParams(this._def)\n    });\n  }\n  catch(def) {\n    const catchValueFunc = typeof def === \"function\" ? def : () => def;\n    return new ZodCatch({\n      ...processCreateParams(this._def),\n      innerType: this,\n      catchValue: catchValueFunc,\n      typeName: ZodFirstPartyTypeKind.ZodCatch\n    });\n  }\n  describe(description) {\n    const This = this.constructor;\n    return new This({\n      ...this._def,\n      description\n    });\n  }\n  pipe(target) {\n    return ZodPipeline.create(this, target);\n  }\n  readonly() {\n    return ZodReadonly.create(this);\n  }\n  isOptional() {\n    return this.safeParse(void 0).success;\n  }\n  isNullable() {\n    return this.safeParse(null).success;\n  }\n};\nvar cuidRegex = /^c[^\\s-]{8,}$/i;\nvar cuid2Regex = /^[a-z][a-z0-9]*$/;\nvar ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/;\nvar uuidRegex = /^[0-9a-fA-F]{8}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{12}$/i;\nvar emailRegex = /^(?!\\.)(?!.*\\.\\.)([A-Z0-9_+-\\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\\-]*\\.)+[A-Z]{2,}$/i;\nvar _emojiRegex = `^(\\\\p{Extended_Pictographic}|\\\\p{Emoji_Component})+$`;\nvar emojiRegex;\nvar ipv4Regex = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/;\nvar ipv6Regex = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;\nvar datetimeRegex = (args) => {\n  if (args.precision) {\n    if (args.offset) {\n      return new RegExp(`^\\\\d{4}-\\\\d{2}-\\\\d{2}T\\\\d{2}:\\\\d{2}:\\\\d{2}\\\\.\\\\d{${args.precision}}(([+-]\\\\d{2}(:?\\\\d{2})?)|Z)$`);\n    } else {\n      return new RegExp(`^\\\\d{4}-\\\\d{2}-\\\\d{2}T\\\\d{2}:\\\\d{2}:\\\\d{2}\\\\.\\\\d{${args.precision}}Z$`);\n    }\n  } else if (args.precision === 0) {\n    if (args.offset) {\n      return new RegExp(`^\\\\d{4}-\\\\d{2}-\\\\d{2}T\\\\d{2}:\\\\d{2}:\\\\d{2}(([+-]\\\\d{2}(:?\\\\d{2})?)|Z)$`);\n    } else {\n      return new RegExp(`^\\\\d{4}-\\\\d{2}-\\\\d{2}T\\\\d{2}:\\\\d{2}:\\\\d{2}Z$`);\n    }\n  } else {\n    if (args.offset) {\n      return new RegExp(`^\\\\d{4}-\\\\d{2}-\\\\d{2}T\\\\d{2}:\\\\d{2}:\\\\d{2}(\\\\.\\\\d+)?(([+-]\\\\d{2}(:?\\\\d{2})?)|Z)$`);\n    } else {\n      return new RegExp(`^\\\\d{4}-\\\\d{2}-\\\\d{2}T\\\\d{2}:\\\\d{2}:\\\\d{2}(\\\\.\\\\d+)?Z$`);\n    }\n  }\n};\nfunction isValidIP(ip, version) {\n  if ((version === \"v4\" || !version) && ipv4Regex.test(ip)) {\n    return true;\n  }\n  if ((version === \"v6\" || !version) && ipv6Regex.test(ip)) {\n    return true;\n  }\n  return false;\n}\nvar ZodString = class _ZodString extends ZodType {\n  _parse(input) {\n    if (this._def.coerce) {\n      input.data = String(input.data);\n    }\n    const parsedType = this._getType(input);\n    if (parsedType !== ZodParsedType.string) {\n      const ctx2 = this._getOrReturnCtx(input);\n      addIssueToContext(\n        ctx2,\n        {\n          code: ZodIssueCode.invalid_type,\n          expected: ZodParsedType.string,\n          received: ctx2.parsedType\n        }\n        //\n      );\n      return INVALID;\n    }\n    const status = new ParseStatus();\n    let ctx = void 0;\n    for (const check of this._def.checks) {\n      if (check.kind === \"min\") {\n        if (input.data.length < check.value) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.too_small,\n            minimum: check.value,\n            type: \"string\",\n            inclusive: true,\n            exact: false,\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"max\") {\n        if (input.data.length > check.value) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.too_big,\n            maximum: check.value,\n            type: \"string\",\n            inclusive: true,\n            exact: false,\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"length\") {\n        const tooBig = input.data.length > check.value;\n        const tooSmall = input.data.length < check.value;\n        if (tooBig || tooSmall) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          if (tooBig) {\n            addIssueToContext(ctx, {\n              code: ZodIssueCode.too_big,\n              maximum: check.value,\n              type: \"string\",\n              inclusive: true,\n              exact: true,\n              message: check.message\n            });\n          } else if (tooSmall) {\n            addIssueToContext(ctx, {\n              code: ZodIssueCode.too_small,\n              minimum: check.value,\n              type: \"string\",\n              inclusive: true,\n              exact: true,\n              message: check.message\n            });\n          }\n          status.dirty();\n        }\n      } else if (check.kind === \"email\") {\n        if (!emailRegex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: \"email\",\n            code: ZodIssueCode.invalid_string,\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"emoji\") {\n        if (!emojiRegex) {\n          emojiRegex = new RegExp(_emojiRegex, \"u\");\n        }\n        if (!emojiRegex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: \"emoji\",\n            code: ZodIssueCode.invalid_string,\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"uuid\") {\n        if (!uuidRegex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: \"uuid\",\n            code: ZodIssueCode.invalid_string,\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"cuid\") {\n        if (!cuidRegex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: \"cuid\",\n            code: ZodIssueCode.invalid_string,\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"cuid2\") {\n        if (!cuid2Regex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: \"cuid2\",\n            code: ZodIssueCode.invalid_string,\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"ulid\") {\n        if (!ulidRegex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: \"ulid\",\n            code: ZodIssueCode.invalid_string,\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"url\") {\n        try {\n          new URL(input.data);\n        } catch (_a) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: \"url\",\n            code: ZodIssueCode.invalid_string,\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"regex\") {\n        check.regex.lastIndex = 0;\n        const testResult = check.regex.test(input.data);\n        if (!testResult) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: \"regex\",\n            code: ZodIssueCode.invalid_string,\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"trim\") {\n        input.data = input.data.trim();\n      } else if (check.kind === \"includes\") {\n        if (!input.data.includes(check.value, check.position)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.invalid_string,\n            validation: { includes: check.value, position: check.position },\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"toLowerCase\") {\n        input.data = input.data.toLowerCase();\n      } else if (check.kind === \"toUpperCase\") {\n        input.data = input.data.toUpperCase();\n      } else if (check.kind === \"startsWith\") {\n        if (!input.data.startsWith(check.value)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.invalid_string,\n            validation: { startsWith: check.value },\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"endsWith\") {\n        if (!input.data.endsWith(check.value)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.invalid_string,\n            validation: { endsWith: check.value },\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"datetime\") {\n        const regex = datetimeRegex(check);\n        if (!regex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.invalid_string,\n            validation: \"datetime\",\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"ip\") {\n        if (!isValidIP(input.data, check.version)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: \"ip\",\n            code: ZodIssueCode.invalid_string,\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else {\n        util.assertNever(check);\n      }\n    }\n    return { status: status.value, value: input.data };\n  }\n  _regex(regex, validation, message2) {\n    return this.refinement((data) => regex.test(data), {\n      validation,\n      code: ZodIssueCode.invalid_string,\n      ...errorUtil.errToObj(message2)\n    });\n  }\n  _addCheck(check) {\n    return new _ZodString({\n      ...this._def,\n      checks: [...this._def.checks, check]\n    });\n  }\n  email(message2) {\n    return this._addCheck({ kind: \"email\", ...errorUtil.errToObj(message2) });\n  }\n  url(message2) {\n    return this._addCheck({ kind: \"url\", ...errorUtil.errToObj(message2) });\n  }\n  emoji(message2) {\n    return this._addCheck({ kind: \"emoji\", ...errorUtil.errToObj(message2) });\n  }\n  uuid(message2) {\n    return this._addCheck({ kind: \"uuid\", ...errorUtil.errToObj(message2) });\n  }\n  cuid(message2) {\n    return this._addCheck({ kind: \"cuid\", ...errorUtil.errToObj(message2) });\n  }\n  cuid2(message2) {\n    return this._addCheck({ kind: \"cuid2\", ...errorUtil.errToObj(message2) });\n  }\n  ulid(message2) {\n    return this._addCheck({ kind: \"ulid\", ...errorUtil.errToObj(message2) });\n  }\n  ip(options) {\n    return this._addCheck({ kind: \"ip\", ...errorUtil.errToObj(options) });\n  }\n  datetime(options) {\n    var _a;\n    if (typeof options === \"string\") {\n      return this._addCheck({\n        kind: \"datetime\",\n        precision: null,\n        offset: false,\n        message: options\n      });\n    }\n    return this._addCheck({\n      kind: \"datetime\",\n      precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === \"undefined\" ? null : options === null || options === void 0 ? void 0 : options.precision,\n      offset: (_a = options === null || options === void 0 ? void 0 : options.offset) !== null && _a !== void 0 ? _a : false,\n      ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)\n    });\n  }\n  regex(regex, message2) {\n    return this._addCheck({\n      kind: \"regex\",\n      regex,\n      ...errorUtil.errToObj(message2)\n    });\n  }\n  includes(value, options) {\n    return this._addCheck({\n      kind: \"includes\",\n      value,\n      position: options === null || options === void 0 ? void 0 : options.position,\n      ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)\n    });\n  }\n  startsWith(value, message2) {\n    return this._addCheck({\n      kind: \"startsWith\",\n      value,\n      ...errorUtil.errToObj(message2)\n    });\n  }\n  endsWith(value, message2) {\n    return this._addCheck({\n      kind: \"endsWith\",\n      value,\n      ...errorUtil.errToObj(message2)\n    });\n  }\n  min(minLength, message2) {\n    return this._addCheck({\n      kind: \"min\",\n      value: minLength,\n      ...errorUtil.errToObj(message2)\n    });\n  }\n  max(maxLength, message2) {\n    return this._addCheck({\n      kind: \"max\",\n      value: maxLength,\n      ...errorUtil.errToObj(message2)\n    });\n  }\n  length(len, message2) {\n    return this._addCheck({\n      kind: \"length\",\n      value: len,\n      ...errorUtil.errToObj(message2)\n    });\n  }\n  /**\n   * @deprecated Use z.string().min(1) instead.\n   * @see {@link ZodString.min}\n   */\n  nonempty(message2) {\n    return this.min(1, errorUtil.errToObj(message2));\n  }\n  trim() {\n    return new _ZodString({\n      ...this._def,\n      checks: [...this._def.checks, { kind: \"trim\" }]\n    });\n  }\n  toLowerCase() {\n    return new _ZodString({\n      ...this._def,\n      checks: [...this._def.checks, { kind: \"toLowerCase\" }]\n    });\n  }\n  toUpperCase() {\n    return new _ZodString({\n      ...this._def,\n      checks: [...this._def.checks, { kind: \"toUpperCase\" }]\n    });\n  }\n  get isDatetime() {\n    return !!this._def.checks.find((ch) => ch.kind === \"datetime\");\n  }\n  get isEmail() {\n    return !!this._def.checks.find((ch) => ch.kind === \"email\");\n  }\n  get isURL() {\n    return !!this._def.checks.find((ch) => ch.kind === \"url\");\n  }\n  get isEmoji() {\n    return !!this._def.checks.find((ch) => ch.kind === \"emoji\");\n  }\n  get isUUID() {\n    return !!this._def.checks.find((ch) => ch.kind === \"uuid\");\n  }\n  get isCUID() {\n    return !!this._def.checks.find((ch) => ch.kind === \"cuid\");\n  }\n  get isCUID2() {\n    return !!this._def.checks.find((ch) => ch.kind === \"cuid2\");\n  }\n  get isULID() {\n    return !!this._def.checks.find((ch) => ch.kind === \"ulid\");\n  }\n  get isIP() {\n    return !!this._def.checks.find((ch) => ch.kind === \"ip\");\n  }\n  get minLength() {\n    let min = null;\n    for (const ch of this._def.checks) {\n      if (ch.kind === \"min\") {\n        if (min === null || ch.value > min)\n          min = ch.value;\n      }\n    }\n    return min;\n  }\n  get maxLength() {\n    let max3 = null;\n    for (const ch of this._def.checks) {\n      if (ch.kind === \"max\") {\n        if (max3 === null || ch.value < max3)\n          max3 = ch.value;\n      }\n    }\n    return max3;\n  }\n};\nZodString.create = (params) => {\n  var _a;\n  return new ZodString({\n    checks: [],\n    typeName: ZodFirstPartyTypeKind.ZodString,\n    coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,\n    ...processCreateParams(params)\n  });\n};\nfunction floatSafeRemainder(val, step) {\n  const valDecCount = (val.toString().split(\".\")[1] || \"\").length;\n  const stepDecCount = (step.toString().split(\".\")[1] || \"\").length;\n  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;\n  const valInt = parseInt(val.toFixed(decCount).replace(\".\", \"\"));\n  const stepInt = parseInt(step.toFixed(decCount).replace(\".\", \"\"));\n  return valInt % stepInt / Math.pow(10, decCount);\n}\nvar ZodNumber = class _ZodNumber extends ZodType {\n  constructor() {\n    super(...arguments);\n    this.min = this.gte;\n    this.max = this.lte;\n    this.step = this.multipleOf;\n  }\n  _parse(input) {\n    if (this._def.coerce) {\n      input.data = Number(input.data);\n    }\n    const parsedType = this._getType(input);\n    if (parsedType !== ZodParsedType.number) {\n      const ctx2 = this._getOrReturnCtx(input);\n      addIssueToContext(ctx2, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.number,\n        received: ctx2.parsedType\n      });\n      return INVALID;\n    }\n    let ctx = void 0;\n    const status = new ParseStatus();\n    for (const check of this._def.checks) {\n      if (check.kind === \"int\") {\n        if (!util.isInteger(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.invalid_type,\n            expected: \"integer\",\n            received: \"float\",\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"min\") {\n        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;\n        if (tooSmall) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.too_small,\n            minimum: check.value,\n            type: \"number\",\n            inclusive: check.inclusive,\n            exact: false,\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"max\") {\n        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;\n        if (tooBig) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.too_big,\n            maximum: check.value,\n            type: \"number\",\n            inclusive: check.inclusive,\n            exact: false,\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"multipleOf\") {\n        if (floatSafeRemainder(input.data, check.value) !== 0) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.not_multiple_of,\n            multipleOf: check.value,\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"finite\") {\n        if (!Number.isFinite(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.not_finite,\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else {\n        util.assertNever(check);\n      }\n    }\n    return { status: status.value, value: input.data };\n  }\n  gte(value, message2) {\n    return this.setLimit(\"min\", value, true, errorUtil.toString(message2));\n  }\n  gt(value, message2) {\n    return this.setLimit(\"min\", value, false, errorUtil.toString(message2));\n  }\n  lte(value, message2) {\n    return this.setLimit(\"max\", value, true, errorUtil.toString(message2));\n  }\n  lt(value, message2) {\n    return this.setLimit(\"max\", value, false, errorUtil.toString(message2));\n  }\n  setLimit(kind, value, inclusive, message2) {\n    return new _ZodNumber({\n      ...this._def,\n      checks: [\n        ...this._def.checks,\n        {\n          kind,\n          value,\n          inclusive,\n          message: errorUtil.toString(message2)\n        }\n      ]\n    });\n  }\n  _addCheck(check) {\n    return new _ZodNumber({\n      ...this._def,\n      checks: [...this._def.checks, check]\n    });\n  }\n  int(message2) {\n    return this._addCheck({\n      kind: \"int\",\n      message: errorUtil.toString(message2)\n    });\n  }\n  positive(message2) {\n    return this._addCheck({\n      kind: \"min\",\n      value: 0,\n      inclusive: false,\n      message: errorUtil.toString(message2)\n    });\n  }\n  negative(message2) {\n    return this._addCheck({\n      kind: \"max\",\n      value: 0,\n      inclusive: false,\n      message: errorUtil.toString(message2)\n    });\n  }\n  nonpositive(message2) {\n    return this._addCheck({\n      kind: \"max\",\n      value: 0,\n      inclusive: true,\n      message: errorUtil.toString(message2)\n    });\n  }\n  nonnegative(message2) {\n    return this._addCheck({\n      kind: \"min\",\n      value: 0,\n      inclusive: true,\n      message: errorUtil.toString(message2)\n    });\n  }\n  multipleOf(value, message2) {\n    return this._addCheck({\n      kind: \"multipleOf\",\n      value,\n      message: errorUtil.toString(message2)\n    });\n  }\n  finite(message2) {\n    return this._addCheck({\n      kind: \"finite\",\n      message: errorUtil.toString(message2)\n    });\n  }\n  safe(message2) {\n    return this._addCheck({\n      kind: \"min\",\n      inclusive: true,\n      value: Number.MIN_SAFE_INTEGER,\n      message: errorUtil.toString(message2)\n    })._addCheck({\n      kind: \"max\",\n      inclusive: true,\n      value: Number.MAX_SAFE_INTEGER,\n      message: errorUtil.toString(message2)\n    });\n  }\n  get minValue() {\n    let min = null;\n    for (const ch of this._def.checks) {\n      if (ch.kind === \"min\") {\n        if (min === null || ch.value > min)\n          min = ch.value;\n      }\n    }\n    return min;\n  }\n  get maxValue() {\n    let max3 = null;\n    for (const ch of this._def.checks) {\n      if (ch.kind === \"max\") {\n        if (max3 === null || ch.value < max3)\n          max3 = ch.value;\n      }\n    }\n    return max3;\n  }\n  get isInt() {\n    return !!this._def.checks.find((ch) => ch.kind === \"int\" || ch.kind === \"multipleOf\" && util.isInteger(ch.value));\n  }\n  get isFinite() {\n    let max3 = null, min = null;\n    for (const ch of this._def.checks) {\n      if (ch.kind === \"finite\" || ch.kind === \"int\" || ch.kind === \"multipleOf\") {\n        return true;\n      } else if (ch.kind === \"min\") {\n        if (min === null || ch.value > min)\n          min = ch.value;\n      } else if (ch.kind === \"max\") {\n        if (max3 === null || ch.value < max3)\n          max3 = ch.value;\n      }\n    }\n    return Number.isFinite(min) && Number.isFinite(max3);\n  }\n};\nZodNumber.create = (params) => {\n  return new ZodNumber({\n    checks: [],\n    typeName: ZodFirstPartyTypeKind.ZodNumber,\n    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,\n    ...processCreateParams(params)\n  });\n};\nvar ZodBigInt = class _ZodBigInt extends ZodType {\n  constructor() {\n    super(...arguments);\n    this.min = this.gte;\n    this.max = this.lte;\n  }\n  _parse(input) {\n    if (this._def.coerce) {\n      input.data = BigInt(input.data);\n    }\n    const parsedType = this._getType(input);\n    if (parsedType !== ZodParsedType.bigint) {\n      const ctx2 = this._getOrReturnCtx(input);\n      addIssueToContext(ctx2, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.bigint,\n        received: ctx2.parsedType\n      });\n      return INVALID;\n    }\n    let ctx = void 0;\n    const status = new ParseStatus();\n    for (const check of this._def.checks) {\n      if (check.kind === \"min\") {\n        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;\n        if (tooSmall) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.too_small,\n            type: \"bigint\",\n            minimum: check.value,\n            inclusive: check.inclusive,\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"max\") {\n        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;\n        if (tooBig) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.too_big,\n            type: \"bigint\",\n            maximum: check.value,\n            inclusive: check.inclusive,\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"multipleOf\") {\n        if (input.data % check.value !== BigInt(0)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.not_multiple_of,\n            multipleOf: check.value,\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else {\n        util.assertNever(check);\n      }\n    }\n    return { status: status.value, value: input.data };\n  }\n  gte(value, message2) {\n    return this.setLimit(\"min\", value, true, errorUtil.toString(message2));\n  }\n  gt(value, message2) {\n    return this.setLimit(\"min\", value, false, errorUtil.toString(message2));\n  }\n  lte(value, message2) {\n    return this.setLimit(\"max\", value, true, errorUtil.toString(message2));\n  }\n  lt(value, message2) {\n    return this.setLimit(\"max\", value, false, errorUtil.toString(message2));\n  }\n  setLimit(kind, value, inclusive, message2) {\n    return new _ZodBigInt({\n      ...this._def,\n      checks: [\n        ...this._def.checks,\n        {\n          kind,\n          value,\n          inclusive,\n          message: errorUtil.toString(message2)\n        }\n      ]\n    });\n  }\n  _addCheck(check) {\n    return new _ZodBigInt({\n      ...this._def,\n      checks: [...this._def.checks, check]\n    });\n  }\n  positive(message2) {\n    return this._addCheck({\n      kind: \"min\",\n      value: BigInt(0),\n      inclusive: false,\n      message: errorUtil.toString(message2)\n    });\n  }\n  negative(message2) {\n    return this._addCheck({\n      kind: \"max\",\n      value: BigInt(0),\n      inclusive: false,\n      message: errorUtil.toString(message2)\n    });\n  }\n  nonpositive(message2) {\n    return this._addCheck({\n      kind: \"max\",\n      value: BigInt(0),\n      inclusive: true,\n      message: errorUtil.toString(message2)\n    });\n  }\n  nonnegative(message2) {\n    return this._addCheck({\n      kind: \"min\",\n      value: BigInt(0),\n      inclusive: true,\n      message: errorUtil.toString(message2)\n    });\n  }\n  multipleOf(value, message2) {\n    return this._addCheck({\n      kind: \"multipleOf\",\n      value,\n      message: errorUtil.toString(message2)\n    });\n  }\n  get minValue() {\n    let min = null;\n    for (const ch of this._def.checks) {\n      if (ch.kind === \"min\") {\n        if (min === null || ch.value > min)\n          min = ch.value;\n      }\n    }\n    return min;\n  }\n  get maxValue() {\n    let max3 = null;\n    for (const ch of this._def.checks) {\n      if (ch.kind === \"max\") {\n        if (max3 === null || ch.value < max3)\n          max3 = ch.value;\n      }\n    }\n    return max3;\n  }\n};\nZodBigInt.create = (params) => {\n  var _a;\n  return new ZodBigInt({\n    checks: [],\n    typeName: ZodFirstPartyTypeKind.ZodBigInt,\n    coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,\n    ...processCreateParams(params)\n  });\n};\nvar ZodBoolean = class extends ZodType {\n  _parse(input) {\n    if (this._def.coerce) {\n      input.data = Boolean(input.data);\n    }\n    const parsedType = this._getType(input);\n    if (parsedType !== ZodParsedType.boolean) {\n      const ctx = this._getOrReturnCtx(input);\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.boolean,\n        received: ctx.parsedType\n      });\n      return INVALID;\n    }\n    return OK(input.data);\n  }\n};\nZodBoolean.create = (params) => {\n  return new ZodBoolean({\n    typeName: ZodFirstPartyTypeKind.ZodBoolean,\n    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,\n    ...processCreateParams(params)\n  });\n};\nvar ZodDate = class _ZodDate extends ZodType {\n  _parse(input) {\n    if (this._def.coerce) {\n      input.data = new Date(input.data);\n    }\n    const parsedType = this._getType(input);\n    if (parsedType !== ZodParsedType.date) {\n      const ctx2 = this._getOrReturnCtx(input);\n      addIssueToContext(ctx2, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.date,\n        received: ctx2.parsedType\n      });\n      return INVALID;\n    }\n    if (isNaN(input.data.getTime())) {\n      const ctx2 = this._getOrReturnCtx(input);\n      addIssueToContext(ctx2, {\n        code: ZodIssueCode.invalid_date\n      });\n      return INVALID;\n    }\n    const status = new ParseStatus();\n    let ctx = void 0;\n    for (const check of this._def.checks) {\n      if (check.kind === \"min\") {\n        if (input.data.getTime() < check.value) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.too_small,\n            message: check.message,\n            inclusive: true,\n            exact: false,\n            minimum: check.value,\n            type: \"date\"\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"max\") {\n        if (input.data.getTime() > check.value) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.too_big,\n            message: check.message,\n            inclusive: true,\n            exact: false,\n            maximum: check.value,\n            type: \"date\"\n          });\n          status.dirty();\n        }\n      } else {\n        util.assertNever(check);\n      }\n    }\n    return {\n      status: status.value,\n      value: new Date(input.data.getTime())\n    };\n  }\n  _addCheck(check) {\n    return new _ZodDate({\n      ...this._def,\n      checks: [...this._def.checks, check]\n    });\n  }\n  min(minDate, message2) {\n    return this._addCheck({\n      kind: \"min\",\n      value: minDate.getTime(),\n      message: errorUtil.toString(message2)\n    });\n  }\n  max(maxDate, message2) {\n    return this._addCheck({\n      kind: \"max\",\n      value: maxDate.getTime(),\n      message: errorUtil.toString(message2)\n    });\n  }\n  get minDate() {\n    let min = null;\n    for (const ch of this._def.checks) {\n      if (ch.kind === \"min\") {\n        if (min === null || ch.value > min)\n          min = ch.value;\n      }\n    }\n    return min != null ? new Date(min) : null;\n  }\n  get maxDate() {\n    let max3 = null;\n    for (const ch of this._def.checks) {\n      if (ch.kind === \"max\") {\n        if (max3 === null || ch.value < max3)\n          max3 = ch.value;\n      }\n    }\n    return max3 != null ? new Date(max3) : null;\n  }\n};\nZodDate.create = (params) => {\n  return new ZodDate({\n    checks: [],\n    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,\n    typeName: ZodFirstPartyTypeKind.ZodDate,\n    ...processCreateParams(params)\n  });\n};\nvar ZodSymbol = class extends ZodType {\n  _parse(input) {\n    const parsedType = this._getType(input);\n    if (parsedType !== ZodParsedType.symbol) {\n      const ctx = this._getOrReturnCtx(input);\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.symbol,\n        received: ctx.parsedType\n      });\n      return INVALID;\n    }\n    return OK(input.data);\n  }\n};\nZodSymbol.create = (params) => {\n  return new ZodSymbol({\n    typeName: ZodFirstPartyTypeKind.ZodSymbol,\n    ...processCreateParams(params)\n  });\n};\nvar ZodUndefined = class extends ZodType {\n  _parse(input) {\n    const parsedType = this._getType(input);\n    if (parsedType !== ZodParsedType.undefined) {\n      const ctx = this._getOrReturnCtx(input);\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.undefined,\n        received: ctx.parsedType\n      });\n      return INVALID;\n    }\n    return OK(input.data);\n  }\n};\nZodUndefined.create = (params) => {\n  return new ZodUndefined({\n    typeName: ZodFirstPartyTypeKind.ZodUndefined,\n    ...processCreateParams(params)\n  });\n};\nvar ZodNull = class extends ZodType {\n  _parse(input) {\n    const parsedType = this._getType(input);\n    if (parsedType !== ZodParsedType.null) {\n      const ctx = this._getOrReturnCtx(input);\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.null,\n        received: ctx.parsedType\n      });\n      return INVALID;\n    }\n    return OK(input.data);\n  }\n};\nZodNull.create = (params) => {\n  return new ZodNull({\n    typeName: ZodFirstPartyTypeKind.ZodNull,\n    ...processCreateParams(params)\n  });\n};\nvar ZodAny = class extends ZodType {\n  constructor() {\n    super(...arguments);\n    this._any = true;\n  }\n  _parse(input) {\n    return OK(input.data);\n  }\n};\nZodAny.create = (params) => {\n  return new ZodAny({\n    typeName: ZodFirstPartyTypeKind.ZodAny,\n    ...processCreateParams(params)\n  });\n};\nvar ZodUnknown = class extends ZodType {\n  constructor() {\n    super(...arguments);\n    this._unknown = true;\n  }\n  _parse(input) {\n    return OK(input.data);\n  }\n};\nZodUnknown.create = (params) => {\n  return new ZodUnknown({\n    typeName: ZodFirstPartyTypeKind.ZodUnknown,\n    ...processCreateParams(params)\n  });\n};\nvar ZodNever = class extends ZodType {\n  _parse(input) {\n    const ctx = this._getOrReturnCtx(input);\n    addIssueToContext(ctx, {\n      code: ZodIssueCode.invalid_type,\n      expected: ZodParsedType.never,\n      received: ctx.parsedType\n    });\n    return INVALID;\n  }\n};\nZodNever.create = (params) => {\n  return new ZodNever({\n    typeName: ZodFirstPartyTypeKind.ZodNever,\n    ...processCreateParams(params)\n  });\n};\nvar ZodVoid = class extends ZodType {\n  _parse(input) {\n    const parsedType = this._getType(input);\n    if (parsedType !== ZodParsedType.undefined) {\n      const ctx = this._getOrReturnCtx(input);\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.void,\n        received: ctx.parsedType\n      });\n      return INVALID;\n    }\n    return OK(input.data);\n  }\n};\nZodVoid.create = (params) => {\n  return new ZodVoid({\n    typeName: ZodFirstPartyTypeKind.ZodVoid,\n    ...processCreateParams(params)\n  });\n};\nvar ZodArray = class _ZodArray extends ZodType {\n  _parse(input) {\n    const { ctx, status } = this._processInputParams(input);\n    const def = this._def;\n    if (ctx.parsedType !== ZodParsedType.array) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.array,\n        received: ctx.parsedType\n      });\n      return INVALID;\n    }\n    if (def.exactLength !== null) {\n      const tooBig = ctx.data.length > def.exactLength.value;\n      const tooSmall = ctx.data.length < def.exactLength.value;\n      if (tooBig || tooSmall) {\n        addIssueToContext(ctx, {\n          code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,\n          minimum: tooSmall ? def.exactLength.value : void 0,\n          maximum: tooBig ? def.exactLength.value : void 0,\n          type: \"array\",\n          inclusive: true,\n          exact: true,\n          message: def.exactLength.message\n        });\n        status.dirty();\n      }\n    }\n    if (def.minLength !== null) {\n      if (ctx.data.length < def.minLength.value) {\n        addIssueToContext(ctx, {\n          code: ZodIssueCode.too_small,\n          minimum: def.minLength.value,\n          type: \"array\",\n          inclusive: true,\n          exact: false,\n          message: def.minLength.message\n        });\n        status.dirty();\n      }\n    }\n    if (def.maxLength !== null) {\n      if (ctx.data.length > def.maxLength.value) {\n        addIssueToContext(ctx, {\n          code: ZodIssueCode.too_big,\n          maximum: def.maxLength.value,\n          type: \"array\",\n          inclusive: true,\n          exact: false,\n          message: def.maxLength.message\n        });\n        status.dirty();\n      }\n    }\n    if (ctx.common.async) {\n      return Promise.all([...ctx.data].map((item, i) => {\n        return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));\n      })).then((result3) => {\n        return ParseStatus.mergeArray(status, result3);\n      });\n    }\n    const result2 = [...ctx.data].map((item, i) => {\n      return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));\n    });\n    return ParseStatus.mergeArray(status, result2);\n  }\n  get element() {\n    return this._def.type;\n  }\n  min(minLength, message2) {\n    return new _ZodArray({\n      ...this._def,\n      minLength: { value: minLength, message: errorUtil.toString(message2) }\n    });\n  }\n  max(maxLength, message2) {\n    return new _ZodArray({\n      ...this._def,\n      maxLength: { value: maxLength, message: errorUtil.toString(message2) }\n    });\n  }\n  length(len, message2) {\n    return new _ZodArray({\n      ...this._def,\n      exactLength: { value: len, message: errorUtil.toString(message2) }\n    });\n  }\n  nonempty(message2) {\n    return this.min(1, message2);\n  }\n};\nZodArray.create = (schema, params) => {\n  return new ZodArray({\n    type: schema,\n    minLength: null,\n    maxLength: null,\n    exactLength: null,\n    typeName: ZodFirstPartyTypeKind.ZodArray,\n    ...processCreateParams(params)\n  });\n};\nfunction deepPartialify(schema) {\n  if (schema instanceof ZodObject) {\n    const newShape = {};\n    for (const key in schema.shape) {\n      const fieldSchema = schema.shape[key];\n      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));\n    }\n    return new ZodObject({\n      ...schema._def,\n      shape: () => newShape\n    });\n  } else if (schema instanceof ZodArray) {\n    return new ZodArray({\n      ...schema._def,\n      type: deepPartialify(schema.element)\n    });\n  } else if (schema instanceof ZodOptional) {\n    return ZodOptional.create(deepPartialify(schema.unwrap()));\n  } else if (schema instanceof ZodNullable) {\n    return ZodNullable.create(deepPartialify(schema.unwrap()));\n  } else if (schema instanceof ZodTuple) {\n    return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));\n  } else {\n    return schema;\n  }\n}\nvar ZodObject = class _ZodObject extends ZodType {\n  constructor() {\n    super(...arguments);\n    this._cached = null;\n    this.nonstrict = this.passthrough;\n    this.augment = this.extend;\n  }\n  _getCached() {\n    if (this._cached !== null)\n      return this._cached;\n    const shape = this._def.shape();\n    const keys4 = util.objectKeys(shape);\n    return this._cached = { shape, keys: keys4 };\n  }\n  _parse(input) {\n    const parsedType = this._getType(input);\n    if (parsedType !== ZodParsedType.object) {\n      const ctx2 = this._getOrReturnCtx(input);\n      addIssueToContext(ctx2, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.object,\n        received: ctx2.parsedType\n      });\n      return INVALID;\n    }\n    const { status, ctx } = this._processInputParams(input);\n    const { shape, keys: shapeKeys } = this._getCached();\n    const extraKeys = [];\n    if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === \"strip\")) {\n      for (const key in ctx.data) {\n        if (!shapeKeys.includes(key)) {\n          extraKeys.push(key);\n        }\n      }\n    }\n    const pairs = [];\n    for (const key of shapeKeys) {\n      const keyValidator = shape[key];\n      const value = ctx.data[key];\n      pairs.push({\n        key: { status: \"valid\", value: key },\n        value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),\n        alwaysSet: key in ctx.data\n      });\n    }\n    if (this._def.catchall instanceof ZodNever) {\n      const unknownKeys = this._def.unknownKeys;\n      if (unknownKeys === \"passthrough\") {\n        for (const key of extraKeys) {\n          pairs.push({\n            key: { status: \"valid\", value: key },\n            value: { status: \"valid\", value: ctx.data[key] }\n          });\n        }\n      } else if (unknownKeys === \"strict\") {\n        if (extraKeys.length > 0) {\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.unrecognized_keys,\n            keys: extraKeys\n          });\n          status.dirty();\n        }\n      } else if (unknownKeys === \"strip\")\n        ;\n      else {\n        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);\n      }\n    } else {\n      const catchall = this._def.catchall;\n      for (const key of extraKeys) {\n        const value = ctx.data[key];\n        pairs.push({\n          key: { status: \"valid\", value: key },\n          value: catchall._parse(\n            new ParseInputLazyPath(ctx, value, ctx.path, key)\n            //, ctx.child(key), value, getParsedType(value)\n          ),\n          alwaysSet: key in ctx.data\n        });\n      }\n    }\n    if (ctx.common.async) {\n      return Promise.resolve().then(async () => {\n        const syncPairs = [];\n        for (const pair of pairs) {\n          const key = await pair.key;\n          syncPairs.push({\n            key,\n            value: await pair.value,\n            alwaysSet: pair.alwaysSet\n          });\n        }\n        return syncPairs;\n      }).then((syncPairs) => {\n        return ParseStatus.mergeObjectSync(status, syncPairs);\n      });\n    } else {\n      return ParseStatus.mergeObjectSync(status, pairs);\n    }\n  }\n  get shape() {\n    return this._def.shape();\n  }\n  strict(message2) {\n    errorUtil.errToObj;\n    return new _ZodObject({\n      ...this._def,\n      unknownKeys: \"strict\",\n      ...message2 !== void 0 ? {\n        errorMap: (issue, ctx) => {\n          var _a, _b, _c, _d;\n          const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;\n          if (issue.code === \"unrecognized_keys\")\n            return {\n              message: (_d = errorUtil.errToObj(message2).message) !== null && _d !== void 0 ? _d : defaultError\n            };\n          return {\n            message: defaultError\n          };\n        }\n      } : {}\n    });\n  }\n  strip() {\n    return new _ZodObject({\n      ...this._def,\n      unknownKeys: \"strip\"\n    });\n  }\n  passthrough() {\n    return new _ZodObject({\n      ...this._def,\n      unknownKeys: \"passthrough\"\n    });\n  }\n  // const AugmentFactory =\n  //   <Def extends ZodObjectDef>(def: Def) =>\n  //   <Augmentation extends ZodRawShape>(\n  //     augmentation: Augmentation\n  //   ): ZodObject<\n  //     extendShape<ReturnType<Def[\"shape\"]>, Augmentation>,\n  //     Def[\"unknownKeys\"],\n  //     Def[\"catchall\"]\n  //   > => {\n  //     return new ZodObject({\n  //       ...def,\n  //       shape: () => ({\n  //         ...def.shape(),\n  //         ...augmentation,\n  //       }),\n  //     }) as any;\n  //   };\n  extend(augmentation) {\n    return new _ZodObject({\n      ...this._def,\n      shape: () => ({\n        ...this._def.shape(),\n        ...augmentation\n      })\n    });\n  }\n  /**\n   * Prior to zod@1.0.12 there was a bug in the\n   * inferred type of merged objects. Please\n   * upgrade if you are experiencing issues.\n   */\n  merge(merging) {\n    const merged = new _ZodObject({\n      unknownKeys: merging._def.unknownKeys,\n      catchall: merging._def.catchall,\n      shape: () => ({\n        ...this._def.shape(),\n        ...merging._def.shape()\n      }),\n      typeName: ZodFirstPartyTypeKind.ZodObject\n    });\n    return merged;\n  }\n  // merge<\n  //   Incoming extends AnyZodObject,\n  //   Augmentation extends Incoming[\"shape\"],\n  //   NewOutput extends {\n  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation\n  //       ? Augmentation[k][\"_output\"]\n  //       : k extends keyof Output\n  //       ? Output[k]\n  //       : never;\n  //   },\n  //   NewInput extends {\n  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation\n  //       ? Augmentation[k][\"_input\"]\n  //       : k extends keyof Input\n  //       ? Input[k]\n  //       : never;\n  //   }\n  // >(\n  //   merging: Incoming\n  // ): ZodObject<\n  //   extendShape<T, ReturnType<Incoming[\"_def\"][\"shape\"]>>,\n  //   Incoming[\"_def\"][\"unknownKeys\"],\n  //   Incoming[\"_def\"][\"catchall\"],\n  //   NewOutput,\n  //   NewInput\n  // > {\n  //   const merged: any = new ZodObject({\n  //     unknownKeys: merging._def.unknownKeys,\n  //     catchall: merging._def.catchall,\n  //     shape: () =>\n  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),\n  //     typeName: ZodFirstPartyTypeKind.ZodObject,\n  //   }) as any;\n  //   return merged;\n  // }\n  setKey(key, schema) {\n    return this.augment({ [key]: schema });\n  }\n  // merge<Incoming extends AnyZodObject>(\n  //   merging: Incoming\n  // ): //ZodObject<T & Incoming[\"_shape\"], UnknownKeys, Catchall> = (merging) => {\n  // ZodObject<\n  //   extendShape<T, ReturnType<Incoming[\"_def\"][\"shape\"]>>,\n  //   Incoming[\"_def\"][\"unknownKeys\"],\n  //   Incoming[\"_def\"][\"catchall\"]\n  // > {\n  //   // const mergedShape = objectUtil.mergeShapes(\n  //   //   this._def.shape(),\n  //   //   merging._def.shape()\n  //   // );\n  //   const merged: any = new ZodObject({\n  //     unknownKeys: merging._def.unknownKeys,\n  //     catchall: merging._def.catchall,\n  //     shape: () =>\n  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),\n  //     typeName: ZodFirstPartyTypeKind.ZodObject,\n  //   }) as any;\n  //   return merged;\n  // }\n  catchall(index) {\n    return new _ZodObject({\n      ...this._def,\n      catchall: index\n    });\n  }\n  pick(mask) {\n    const shape = {};\n    util.objectKeys(mask).forEach((key) => {\n      if (mask[key] && this.shape[key]) {\n        shape[key] = this.shape[key];\n      }\n    });\n    return new _ZodObject({\n      ...this._def,\n      shape: () => shape\n    });\n  }\n  omit(mask) {\n    const shape = {};\n    util.objectKeys(this.shape).forEach((key) => {\n      if (!mask[key]) {\n        shape[key] = this.shape[key];\n      }\n    });\n    return new _ZodObject({\n      ...this._def,\n      shape: () => shape\n    });\n  }\n  /**\n   * @deprecated\n   */\n  deepPartial() {\n    return deepPartialify(this);\n  }\n  partial(mask) {\n    const newShape = {};\n    util.objectKeys(this.shape).forEach((key) => {\n      const fieldSchema = this.shape[key];\n      if (mask && !mask[key]) {\n        newShape[key] = fieldSchema;\n      } else {\n        newShape[key] = fieldSchema.optional();\n      }\n    });\n    return new _ZodObject({\n      ...this._def,\n      shape: () => newShape\n    });\n  }\n  required(mask) {\n    const newShape = {};\n    util.objectKeys(this.shape).forEach((key) => {\n      if (mask && !mask[key]) {\n        newShape[key] = this.shape[key];\n      } else {\n        const fieldSchema = this.shape[key];\n        let newField = fieldSchema;\n        while (newField instanceof ZodOptional) {\n          newField = newField._def.innerType;\n        }\n        newShape[key] = newField;\n      }\n    });\n    return new _ZodObject({\n      ...this._def,\n      shape: () => newShape\n    });\n  }\n  keyof() {\n    return createZodEnum(util.objectKeys(this.shape));\n  }\n};\nZodObject.create = (shape, params) => {\n  return new ZodObject({\n    shape: () => shape,\n    unknownKeys: \"strip\",\n    catchall: ZodNever.create(),\n    typeName: ZodFirstPartyTypeKind.ZodObject,\n    ...processCreateParams(params)\n  });\n};\nZodObject.strictCreate = (shape, params) => {\n  return new ZodObject({\n    shape: () => shape,\n    unknownKeys: \"strict\",\n    catchall: ZodNever.create(),\n    typeName: ZodFirstPartyTypeKind.ZodObject,\n    ...processCreateParams(params)\n  });\n};\nZodObject.lazycreate = (shape, params) => {\n  return new ZodObject({\n    shape,\n    unknownKeys: \"strip\",\n    catchall: ZodNever.create(),\n    typeName: ZodFirstPartyTypeKind.ZodObject,\n    ...processCreateParams(params)\n  });\n};\nvar ZodUnion = class extends ZodType {\n  _parse(input) {\n    const { ctx } = this._processInputParams(input);\n    const options = this._def.options;\n    function handleResults(results2) {\n      for (const result2 of results2) {\n        if (result2.result.status === \"valid\") {\n          return result2.result;\n        }\n      }\n      for (const result2 of results2) {\n        if (result2.result.status === \"dirty\") {\n          ctx.common.issues.push(...result2.ctx.common.issues);\n          return result2.result;\n        }\n      }\n      const unionErrors = results2.map((result2) => new ZodError(result2.ctx.common.issues));\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_union,\n        unionErrors\n      });\n      return INVALID;\n    }\n    if (ctx.common.async) {\n      return Promise.all(options.map(async (option) => {\n        const childCtx = {\n          ...ctx,\n          common: {\n            ...ctx.common,\n            issues: []\n          },\n          parent: null\n        };\n        return {\n          result: await option._parseAsync({\n            data: ctx.data,\n            path: ctx.path,\n            parent: childCtx\n          }),\n          ctx: childCtx\n        };\n      })).then(handleResults);\n    } else {\n      let dirty = void 0;\n      const issues = [];\n      for (const option of options) {\n        const childCtx = {\n          ...ctx,\n          common: {\n            ...ctx.common,\n            issues: []\n          },\n          parent: null\n        };\n        const result2 = option._parseSync({\n          data: ctx.data,\n          path: ctx.path,\n          parent: childCtx\n        });\n        if (result2.status === \"valid\") {\n          return result2;\n        } else if (result2.status === \"dirty\" && !dirty) {\n          dirty = { result: result2, ctx: childCtx };\n        }\n        if (childCtx.common.issues.length) {\n          issues.push(childCtx.common.issues);\n        }\n      }\n      if (dirty) {\n        ctx.common.issues.push(...dirty.ctx.common.issues);\n        return dirty.result;\n      }\n      const unionErrors = issues.map((issues2) => new ZodError(issues2));\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_union,\n        unionErrors\n      });\n      return INVALID;\n    }\n  }\n  get options() {\n    return this._def.options;\n  }\n};\nZodUnion.create = (types, params) => {\n  return new ZodUnion({\n    options: types,\n    typeName: ZodFirstPartyTypeKind.ZodUnion,\n    ...processCreateParams(params)\n  });\n};\nvar getDiscriminator = (type3) => {\n  if (type3 instanceof ZodLazy) {\n    return getDiscriminator(type3.schema);\n  } else if (type3 instanceof ZodEffects) {\n    return getDiscriminator(type3.innerType());\n  } else if (type3 instanceof ZodLiteral) {\n    return [type3.value];\n  } else if (type3 instanceof ZodEnum) {\n    return type3.options;\n  } else if (type3 instanceof ZodNativeEnum) {\n    return Object.keys(type3.enum);\n  } else if (type3 instanceof ZodDefault) {\n    return getDiscriminator(type3._def.innerType);\n  } else if (type3 instanceof ZodUndefined) {\n    return [void 0];\n  } else if (type3 instanceof ZodNull) {\n    return [null];\n  } else {\n    return null;\n  }\n};\nvar ZodDiscriminatedUnion = class _ZodDiscriminatedUnion extends ZodType {\n  _parse(input) {\n    const { ctx } = this._processInputParams(input);\n    if (ctx.parsedType !== ZodParsedType.object) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.object,\n        received: ctx.parsedType\n      });\n      return INVALID;\n    }\n    const discriminator = this.discriminator;\n    const discriminatorValue = ctx.data[discriminator];\n    const option = this.optionsMap.get(discriminatorValue);\n    if (!option) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_union_discriminator,\n        options: Array.from(this.optionsMap.keys()),\n        path: [discriminator]\n      });\n      return INVALID;\n    }\n    if (ctx.common.async) {\n      return option._parseAsync({\n        data: ctx.data,\n        path: ctx.path,\n        parent: ctx\n      });\n    } else {\n      return option._parseSync({\n        data: ctx.data,\n        path: ctx.path,\n        parent: ctx\n      });\n    }\n  }\n  get discriminator() {\n    return this._def.discriminator;\n  }\n  get options() {\n    return this._def.options;\n  }\n  get optionsMap() {\n    return this._def.optionsMap;\n  }\n  /**\n   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.\n   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must\n   * have a different value for each object in the union.\n   * @param discriminator the name of the discriminator property\n   * @param types an array of object schemas\n   * @param params\n   */\n  static create(discriminator, options, params) {\n    const optionsMap = /* @__PURE__ */ new Map();\n    for (const type3 of options) {\n      const discriminatorValues = getDiscriminator(type3.shape[discriminator]);\n      if (!discriminatorValues) {\n        throw new Error(`A discriminator value for key \\`${discriminator}\\` could not be extracted from all schema options`);\n      }\n      for (const value of discriminatorValues) {\n        if (optionsMap.has(value)) {\n          throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);\n        }\n        optionsMap.set(value, type3);\n      }\n    }\n    return new _ZodDiscriminatedUnion({\n      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,\n      discriminator,\n      options,\n      optionsMap,\n      ...processCreateParams(params)\n    });\n  }\n};\nfunction mergeValues(a, b2) {\n  const aType = getParsedType(a);\n  const bType = getParsedType(b2);\n  if (a === b2) {\n    return { valid: true, data: a };\n  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {\n    const bKeys = util.objectKeys(b2);\n    const sharedKeys = util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);\n    const newObj = { ...a, ...b2 };\n    for (const key of sharedKeys) {\n      const sharedValue = mergeValues(a[key], b2[key]);\n      if (!sharedValue.valid) {\n        return { valid: false };\n      }\n      newObj[key] = sharedValue.data;\n    }\n    return { valid: true, data: newObj };\n  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {\n    if (a.length !== b2.length) {\n      return { valid: false };\n    }\n    const newArray = [];\n    for (let index = 0; index < a.length; index++) {\n      const itemA = a[index];\n      const itemB = b2[index];\n      const sharedValue = mergeValues(itemA, itemB);\n      if (!sharedValue.valid) {\n        return { valid: false };\n      }\n      newArray.push(sharedValue.data);\n    }\n    return { valid: true, data: newArray };\n  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b2) {\n    return { valid: true, data: a };\n  } else {\n    return { valid: false };\n  }\n}\nvar ZodIntersection = class extends ZodType {\n  _parse(input) {\n    const { status, ctx } = this._processInputParams(input);\n    const handleParsed = (parsedLeft, parsedRight) => {\n      if (isAborted(parsedLeft) || isAborted(parsedRight)) {\n        return INVALID;\n      }\n      const merged = mergeValues(parsedLeft.value, parsedRight.value);\n      if (!merged.valid) {\n        addIssueToContext(ctx, {\n          code: ZodIssueCode.invalid_intersection_types\n        });\n        return INVALID;\n      }\n      if (isDirty(parsedLeft) || isDirty(parsedRight)) {\n        status.dirty();\n      }\n      return { status: status.value, value: merged.data };\n    };\n    if (ctx.common.async) {\n      return Promise.all([\n        this._def.left._parseAsync({\n          data: ctx.data,\n          path: ctx.path,\n          parent: ctx\n        }),\n        this._def.right._parseAsync({\n          data: ctx.data,\n          path: ctx.path,\n          parent: ctx\n        })\n      ]).then(([left, right]) => handleParsed(left, right));\n    } else {\n      return handleParsed(this._def.left._parseSync({\n        data: ctx.data,\n        path: ctx.path,\n        parent: ctx\n      }), this._def.right._parseSync({\n        data: ctx.data,\n        path: ctx.path,\n        parent: ctx\n      }));\n    }\n  }\n};\nZodIntersection.create = (left, right, params) => {\n  return new ZodIntersection({\n    left,\n    right,\n    typeName: ZodFirstPartyTypeKind.ZodIntersection,\n    ...processCreateParams(params)\n  });\n};\nvar ZodTuple = class _ZodTuple extends ZodType {\n  _parse(input) {\n    const { status, ctx } = this._processInputParams(input);\n    if (ctx.parsedType !== ZodParsedType.array) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.array,\n        received: ctx.parsedType\n      });\n      return INVALID;\n    }\n    if (ctx.data.length < this._def.items.length) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.too_small,\n        minimum: this._def.items.length,\n        inclusive: true,\n        exact: false,\n        type: \"array\"\n      });\n      return INVALID;\n    }\n    const rest = this._def.rest;\n    if (!rest && ctx.data.length > this._def.items.length) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.too_big,\n        maximum: this._def.items.length,\n        inclusive: true,\n        exact: false,\n        type: \"array\"\n      });\n      status.dirty();\n    }\n    const items = [...ctx.data].map((item, itemIndex) => {\n      const schema = this._def.items[itemIndex] || this._def.rest;\n      if (!schema)\n        return null;\n      return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));\n    }).filter((x2) => !!x2);\n    if (ctx.common.async) {\n      return Promise.all(items).then((results2) => {\n        return ParseStatus.mergeArray(status, results2);\n      });\n    } else {\n      return ParseStatus.mergeArray(status, items);\n    }\n  }\n  get items() {\n    return this._def.items;\n  }\n  rest(rest) {\n    return new _ZodTuple({\n      ...this._def,\n      rest\n    });\n  }\n};\nZodTuple.create = (schemas, params) => {\n  if (!Array.isArray(schemas)) {\n    throw new Error(\"You must pass an array of schemas to z.tuple([ ... ])\");\n  }\n  return new ZodTuple({\n    items: schemas,\n    typeName: ZodFirstPartyTypeKind.ZodTuple,\n    rest: null,\n    ...processCreateParams(params)\n  });\n};\nvar ZodRecord = class _ZodRecord extends ZodType {\n  get keySchema() {\n    return this._def.keyType;\n  }\n  get valueSchema() {\n    return this._def.valueType;\n  }\n  _parse(input) {\n    const { status, ctx } = this._processInputParams(input);\n    if (ctx.parsedType !== ZodParsedType.object) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.object,\n        received: ctx.parsedType\n      });\n      return INVALID;\n    }\n    const pairs = [];\n    const keyType = this._def.keyType;\n    const valueType = this._def.valueType;\n    for (const key in ctx.data) {\n      pairs.push({\n        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),\n        value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key))\n      });\n    }\n    if (ctx.common.async) {\n      return ParseStatus.mergeObjectAsync(status, pairs);\n    } else {\n      return ParseStatus.mergeObjectSync(status, pairs);\n    }\n  }\n  get element() {\n    return this._def.valueType;\n  }\n  static create(first, second, third) {\n    if (second instanceof ZodType) {\n      return new _ZodRecord({\n        keyType: first,\n        valueType: second,\n        typeName: ZodFirstPartyTypeKind.ZodRecord,\n        ...processCreateParams(third)\n      });\n    }\n    return new _ZodRecord({\n      keyType: ZodString.create(),\n      valueType: first,\n      typeName: ZodFirstPartyTypeKind.ZodRecord,\n      ...processCreateParams(second)\n    });\n  }\n};\nvar ZodMap = class extends ZodType {\n  get keySchema() {\n    return this._def.keyType;\n  }\n  get valueSchema() {\n    return this._def.valueType;\n  }\n  _parse(input) {\n    const { status, ctx } = this._processInputParams(input);\n    if (ctx.parsedType !== ZodParsedType.map) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.map,\n        received: ctx.parsedType\n      });\n      return INVALID;\n    }\n    const keyType = this._def.keyType;\n    const valueType = this._def.valueType;\n    const pairs = [...ctx.data.entries()].map(([key, value], index) => {\n      return {\n        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, \"key\"])),\n        value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, \"value\"]))\n      };\n    });\n    if (ctx.common.async) {\n      const finalMap = /* @__PURE__ */ new Map();\n      return Promise.resolve().then(async () => {\n        for (const pair of pairs) {\n          const key = await pair.key;\n          const value = await pair.value;\n          if (key.status === \"aborted\" || value.status === \"aborted\") {\n            return INVALID;\n          }\n          if (key.status === \"dirty\" || value.status === \"dirty\") {\n            status.dirty();\n          }\n          finalMap.set(key.value, value.value);\n        }\n        return { status: status.value, value: finalMap };\n      });\n    } else {\n      const finalMap = /* @__PURE__ */ new Map();\n      for (const pair of pairs) {\n        const key = pair.key;\n        const value = pair.value;\n        if (key.status === \"aborted\" || value.status === \"aborted\") {\n          return INVALID;\n        }\n        if (key.status === \"dirty\" || value.status === \"dirty\") {\n          status.dirty();\n        }\n        finalMap.set(key.value, value.value);\n      }\n      return { status: status.value, value: finalMap };\n    }\n  }\n};\nZodMap.create = (keyType, valueType, params) => {\n  return new ZodMap({\n    valueType,\n    keyType,\n    typeName: ZodFirstPartyTypeKind.ZodMap,\n    ...processCreateParams(params)\n  });\n};\nvar ZodSet = class _ZodSet extends ZodType {\n  _parse(input) {\n    const { status, ctx } = this._processInputParams(input);\n    if (ctx.parsedType !== ZodParsedType.set) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.set,\n        received: ctx.parsedType\n      });\n      return INVALID;\n    }\n    const def = this._def;\n    if (def.minSize !== null) {\n      if (ctx.data.size < def.minSize.value) {\n        addIssueToContext(ctx, {\n          code: ZodIssueCode.too_small,\n          minimum: def.minSize.value,\n          type: \"set\",\n          inclusive: true,\n          exact: false,\n          message: def.minSize.message\n        });\n        status.dirty();\n      }\n    }\n    if (def.maxSize !== null) {\n      if (ctx.data.size > def.maxSize.value) {\n        addIssueToContext(ctx, {\n          code: ZodIssueCode.too_big,\n          maximum: def.maxSize.value,\n          type: \"set\",\n          inclusive: true,\n          exact: false,\n          message: def.maxSize.message\n        });\n        status.dirty();\n      }\n    }\n    const valueType = this._def.valueType;\n    function finalizeSet(elements2) {\n      const parsedSet = /* @__PURE__ */ new Set();\n      for (const element of elements2) {\n        if (element.status === \"aborted\")\n          return INVALID;\n        if (element.status === \"dirty\")\n          status.dirty();\n        parsedSet.add(element.value);\n      }\n      return { status: status.value, value: parsedSet };\n    }\n    const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));\n    if (ctx.common.async) {\n      return Promise.all(elements).then((elements2) => finalizeSet(elements2));\n    } else {\n      return finalizeSet(elements);\n    }\n  }\n  min(minSize, message2) {\n    return new _ZodSet({\n      ...this._def,\n      minSize: { value: minSize, message: errorUtil.toString(message2) }\n    });\n  }\n  max(maxSize, message2) {\n    return new _ZodSet({\n      ...this._def,\n      maxSize: { value: maxSize, message: errorUtil.toString(message2) }\n    });\n  }\n  size(size, message2) {\n    return this.min(size, message2).max(size, message2);\n  }\n  nonempty(message2) {\n    return this.min(1, message2);\n  }\n};\nZodSet.create = (valueType, params) => {\n  return new ZodSet({\n    valueType,\n    minSize: null,\n    maxSize: null,\n    typeName: ZodFirstPartyTypeKind.ZodSet,\n    ...processCreateParams(params)\n  });\n};\nvar ZodFunction = class _ZodFunction extends ZodType {\n  constructor() {\n    super(...arguments);\n    this.validate = this.implement;\n  }\n  _parse(input) {\n    const { ctx } = this._processInputParams(input);\n    if (ctx.parsedType !== ZodParsedType.function) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.function,\n        received: ctx.parsedType\n      });\n      return INVALID;\n    }\n    function makeArgsIssue(args, error) {\n      return makeIssue({\n        data: args,\n        path: ctx.path,\n        errorMaps: [\n          ctx.common.contextualErrorMap,\n          ctx.schemaErrorMap,\n          getErrorMap(),\n          errorMap\n        ].filter((x2) => !!x2),\n        issueData: {\n          code: ZodIssueCode.invalid_arguments,\n          argumentsError: error\n        }\n      });\n    }\n    function makeReturnsIssue(returns, error) {\n      return makeIssue({\n        data: returns,\n        path: ctx.path,\n        errorMaps: [\n          ctx.common.contextualErrorMap,\n          ctx.schemaErrorMap,\n          getErrorMap(),\n          errorMap\n        ].filter((x2) => !!x2),\n        issueData: {\n          code: ZodIssueCode.invalid_return_type,\n          returnTypeError: error\n        }\n      });\n    }\n    const params = { errorMap: ctx.common.contextualErrorMap };\n    const fn = ctx.data;\n    if (this._def.returns instanceof ZodPromise) {\n      const me2 = this;\n      return OK(async function(...args) {\n        const error = new ZodError([]);\n        const parsedArgs = await me2._def.args.parseAsync(args, params).catch((e) => {\n          error.addIssue(makeArgsIssue(args, e));\n          throw error;\n        });\n        const result2 = await Reflect.apply(fn, this, parsedArgs);\n        const parsedReturns = await me2._def.returns._def.type.parseAsync(result2, params).catch((e) => {\n          error.addIssue(makeReturnsIssue(result2, e));\n          throw error;\n        });\n        return parsedReturns;\n      });\n    } else {\n      const me2 = this;\n      return OK(function(...args) {\n        const parsedArgs = me2._def.args.safeParse(args, params);\n        if (!parsedArgs.success) {\n          throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);\n        }\n        const result2 = Reflect.apply(fn, this, parsedArgs.data);\n        const parsedReturns = me2._def.returns.safeParse(result2, params);\n        if (!parsedReturns.success) {\n          throw new ZodError([makeReturnsIssue(result2, parsedReturns.error)]);\n        }\n        return parsedReturns.data;\n      });\n    }\n  }\n  parameters() {\n    return this._def.args;\n  }\n  returnType() {\n    return this._def.returns;\n  }\n  args(...items) {\n    return new _ZodFunction({\n      ...this._def,\n      args: ZodTuple.create(items).rest(ZodUnknown.create())\n    });\n  }\n  returns(returnType) {\n    return new _ZodFunction({\n      ...this._def,\n      returns: returnType\n    });\n  }\n  implement(func) {\n    const validatedFunc = this.parse(func);\n    return validatedFunc;\n  }\n  strictImplement(func) {\n    const validatedFunc = this.parse(func);\n    return validatedFunc;\n  }\n  static create(args, returns, params) {\n    return new _ZodFunction({\n      args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),\n      returns: returns || ZodUnknown.create(),\n      typeName: ZodFirstPartyTypeKind.ZodFunction,\n      ...processCreateParams(params)\n    });\n  }\n};\nvar ZodLazy = class extends ZodType {\n  get schema() {\n    return this._def.getter();\n  }\n  _parse(input) {\n    const { ctx } = this._processInputParams(input);\n    const lazySchema = this._def.getter();\n    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });\n  }\n};\nZodLazy.create = (getter, params) => {\n  return new ZodLazy({\n    getter,\n    typeName: ZodFirstPartyTypeKind.ZodLazy,\n    ...processCreateParams(params)\n  });\n};\nvar ZodLiteral = class extends ZodType {\n  _parse(input) {\n    if (input.data !== this._def.value) {\n      const ctx = this._getOrReturnCtx(input);\n      addIssueToContext(ctx, {\n        received: ctx.data,\n        code: ZodIssueCode.invalid_literal,\n        expected: this._def.value\n      });\n      return INVALID;\n    }\n    return { status: \"valid\", value: input.data };\n  }\n  get value() {\n    return this._def.value;\n  }\n};\nZodLiteral.create = (value, params) => {\n  return new ZodLiteral({\n    value,\n    typeName: ZodFirstPartyTypeKind.ZodLiteral,\n    ...processCreateParams(params)\n  });\n};\nfunction createZodEnum(values, params) {\n  return new ZodEnum({\n    values,\n    typeName: ZodFirstPartyTypeKind.ZodEnum,\n    ...processCreateParams(params)\n  });\n}\nvar ZodEnum = class _ZodEnum extends ZodType {\n  _parse(input) {\n    if (typeof input.data !== \"string\") {\n      const ctx = this._getOrReturnCtx(input);\n      const expectedValues = this._def.values;\n      addIssueToContext(ctx, {\n        expected: util.joinValues(expectedValues),\n        received: ctx.parsedType,\n        code: ZodIssueCode.invalid_type\n      });\n      return INVALID;\n    }\n    if (this._def.values.indexOf(input.data) === -1) {\n      const ctx = this._getOrReturnCtx(input);\n      const expectedValues = this._def.values;\n      addIssueToContext(ctx, {\n        received: ctx.data,\n        code: ZodIssueCode.invalid_enum_value,\n        options: expectedValues\n      });\n      return INVALID;\n    }\n    return OK(input.data);\n  }\n  get options() {\n    return this._def.values;\n  }\n  get enum() {\n    const enumValues = {};\n    for (const val of this._def.values) {\n      enumValues[val] = val;\n    }\n    return enumValues;\n  }\n  get Values() {\n    const enumValues = {};\n    for (const val of this._def.values) {\n      enumValues[val] = val;\n    }\n    return enumValues;\n  }\n  get Enum() {\n    const enumValues = {};\n    for (const val of this._def.values) {\n      enumValues[val] = val;\n    }\n    return enumValues;\n  }\n  extract(values) {\n    return _ZodEnum.create(values);\n  }\n  exclude(values) {\n    return _ZodEnum.create(this.options.filter((opt) => !values.includes(opt)));\n  }\n};\nZodEnum.create = createZodEnum;\nvar ZodNativeEnum = class extends ZodType {\n  _parse(input) {\n    const nativeEnumValues = util.getValidEnumValues(this._def.values);\n    const ctx = this._getOrReturnCtx(input);\n    if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {\n      const expectedValues = util.objectValues(nativeEnumValues);\n      addIssueToContext(ctx, {\n        expected: util.joinValues(expectedValues),\n        received: ctx.parsedType,\n        code: ZodIssueCode.invalid_type\n      });\n      return INVALID;\n    }\n    if (nativeEnumValues.indexOf(input.data) === -1) {\n      const expectedValues = util.objectValues(nativeEnumValues);\n      addIssueToContext(ctx, {\n        received: ctx.data,\n        code: ZodIssueCode.invalid_enum_value,\n        options: expectedValues\n      });\n      return INVALID;\n    }\n    return OK(input.data);\n  }\n  get enum() {\n    return this._def.values;\n  }\n};\nZodNativeEnum.create = (values, params) => {\n  return new ZodNativeEnum({\n    values,\n    typeName: ZodFirstPartyTypeKind.ZodNativeEnum,\n    ...processCreateParams(params)\n  });\n};\nvar ZodPromise = class extends ZodType {\n  unwrap() {\n    return this._def.type;\n  }\n  _parse(input) {\n    const { ctx } = this._processInputParams(input);\n    if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.promise,\n        received: ctx.parsedType\n      });\n      return INVALID;\n    }\n    const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);\n    return OK(promisified.then((data) => {\n      return this._def.type.parseAsync(data, {\n        path: ctx.path,\n        errorMap: ctx.common.contextualErrorMap\n      });\n    }));\n  }\n};\nZodPromise.create = (schema, params) => {\n  return new ZodPromise({\n    type: schema,\n    typeName: ZodFirstPartyTypeKind.ZodPromise,\n    ...processCreateParams(params)\n  });\n};\nvar ZodEffects = class extends ZodType {\n  innerType() {\n    return this._def.schema;\n  }\n  sourceType() {\n    return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;\n  }\n  _parse(input) {\n    const { status, ctx } = this._processInputParams(input);\n    const effect = this._def.effect || null;\n    const checkCtx = {\n      addIssue: (arg) => {\n        addIssueToContext(ctx, arg);\n        if (arg.fatal) {\n          status.abort();\n        } else {\n          status.dirty();\n        }\n      },\n      get path() {\n        return ctx.path;\n      }\n    };\n    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);\n    if (effect.type === \"preprocess\") {\n      const processed = effect.transform(ctx.data, checkCtx);\n      if (ctx.common.issues.length) {\n        return {\n          status: \"dirty\",\n          value: ctx.data\n        };\n      }\n      if (ctx.common.async) {\n        return Promise.resolve(processed).then((processed2) => {\n          return this._def.schema._parseAsync({\n            data: processed2,\n            path: ctx.path,\n            parent: ctx\n          });\n        });\n      } else {\n        return this._def.schema._parseSync({\n          data: processed,\n          path: ctx.path,\n          parent: ctx\n        });\n      }\n    }\n    if (effect.type === \"refinement\") {\n      const executeRefinement = (acc) => {\n        const result2 = effect.refinement(acc, checkCtx);\n        if (ctx.common.async) {\n          return Promise.resolve(result2);\n        }\n        if (result2 instanceof Promise) {\n          throw new Error(\"Async refinement encountered during synchronous parse operation. Use .parseAsync instead.\");\n        }\n        return acc;\n      };\n      if (ctx.common.async === false) {\n        const inner = this._def.schema._parseSync({\n          data: ctx.data,\n          path: ctx.path,\n          parent: ctx\n        });\n        if (inner.status === \"aborted\")\n          return INVALID;\n        if (inner.status === \"dirty\")\n          status.dirty();\n        executeRefinement(inner.value);\n        return { status: status.value, value: inner.value };\n      } else {\n        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {\n          if (inner.status === \"aborted\")\n            return INVALID;\n          if (inner.status === \"dirty\")\n            status.dirty();\n          return executeRefinement(inner.value).then(() => {\n            return { status: status.value, value: inner.value };\n          });\n        });\n      }\n    }\n    if (effect.type === \"transform\") {\n      if (ctx.common.async === false) {\n        const base = this._def.schema._parseSync({\n          data: ctx.data,\n          path: ctx.path,\n          parent: ctx\n        });\n        if (!isValid(base))\n          return base;\n        const result2 = effect.transform(base.value, checkCtx);\n        if (result2 instanceof Promise) {\n          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);\n        }\n        return { status: status.value, value: result2 };\n      } else {\n        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {\n          if (!isValid(base))\n            return base;\n          return Promise.resolve(effect.transform(base.value, checkCtx)).then((result2) => ({ status: status.value, value: result2 }));\n        });\n      }\n    }\n    util.assertNever(effect);\n  }\n};\nZodEffects.create = (schema, effect, params) => {\n  return new ZodEffects({\n    schema,\n    typeName: ZodFirstPartyTypeKind.ZodEffects,\n    effect,\n    ...processCreateParams(params)\n  });\n};\nZodEffects.createWithPreprocess = (preprocess, schema, params) => {\n  return new ZodEffects({\n    schema,\n    effect: { type: \"preprocess\", transform: preprocess },\n    typeName: ZodFirstPartyTypeKind.ZodEffects,\n    ...processCreateParams(params)\n  });\n};\nvar ZodOptional = class extends ZodType {\n  _parse(input) {\n    const parsedType = this._getType(input);\n    if (parsedType === ZodParsedType.undefined) {\n      return OK(void 0);\n    }\n    return this._def.innerType._parse(input);\n  }\n  unwrap() {\n    return this._def.innerType;\n  }\n};\nZodOptional.create = (type3, params) => {\n  return new ZodOptional({\n    innerType: type3,\n    typeName: ZodFirstPartyTypeKind.ZodOptional,\n    ...processCreateParams(params)\n  });\n};\nvar ZodNullable = class extends ZodType {\n  _parse(input) {\n    const parsedType = this._getType(input);\n    if (parsedType === ZodParsedType.null) {\n      return OK(null);\n    }\n    return this._def.innerType._parse(input);\n  }\n  unwrap() {\n    return this._def.innerType;\n  }\n};\nZodNullable.create = (type3, params) => {\n  return new ZodNullable({\n    innerType: type3,\n    typeName: ZodFirstPartyTypeKind.ZodNullable,\n    ...processCreateParams(params)\n  });\n};\nvar ZodDefault = class extends ZodType {\n  _parse(input) {\n    const { ctx } = this._processInputParams(input);\n    let data = ctx.data;\n    if (ctx.parsedType === ZodParsedType.undefined) {\n      data = this._def.defaultValue();\n    }\n    return this._def.innerType._parse({\n      data,\n      path: ctx.path,\n      parent: ctx\n    });\n  }\n  removeDefault() {\n    return this._def.innerType;\n  }\n};\nZodDefault.create = (type3, params) => {\n  return new ZodDefault({\n    innerType: type3,\n    typeName: ZodFirstPartyTypeKind.ZodDefault,\n    defaultValue: typeof params.default === \"function\" ? params.default : () => params.default,\n    ...processCreateParams(params)\n  });\n};\nvar ZodCatch = class extends ZodType {\n  _parse(input) {\n    const { ctx } = this._processInputParams(input);\n    const newCtx = {\n      ...ctx,\n      common: {\n        ...ctx.common,\n        issues: []\n      }\n    };\n    const result2 = this._def.innerType._parse({\n      data: newCtx.data,\n      path: newCtx.path,\n      parent: {\n        ...newCtx\n      }\n    });\n    if (isAsync(result2)) {\n      return result2.then((result3) => {\n        return {\n          status: \"valid\",\n          value: result3.status === \"valid\" ? result3.value : this._def.catchValue({\n            get error() {\n              return new ZodError(newCtx.common.issues);\n            },\n            input: newCtx.data\n          })\n        };\n      });\n    } else {\n      return {\n        status: \"valid\",\n        value: result2.status === \"valid\" ? result2.value : this._def.catchValue({\n          get error() {\n            return new ZodError(newCtx.common.issues);\n          },\n          input: newCtx.data\n        })\n      };\n    }\n  }\n  removeCatch() {\n    return this._def.innerType;\n  }\n};\nZodCatch.create = (type3, params) => {\n  return new ZodCatch({\n    innerType: type3,\n    typeName: ZodFirstPartyTypeKind.ZodCatch,\n    catchValue: typeof params.catch === \"function\" ? params.catch : () => params.catch,\n    ...processCreateParams(params)\n  });\n};\nvar ZodNaN = class extends ZodType {\n  _parse(input) {\n    const parsedType = this._getType(input);\n    if (parsedType !== ZodParsedType.nan) {\n      const ctx = this._getOrReturnCtx(input);\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.nan,\n        received: ctx.parsedType\n      });\n      return INVALID;\n    }\n    return { status: \"valid\", value: input.data };\n  }\n};\nZodNaN.create = (params) => {\n  return new ZodNaN({\n    typeName: ZodFirstPartyTypeKind.ZodNaN,\n    ...processCreateParams(params)\n  });\n};\nvar BRAND = Symbol(\"zod_brand\");\nvar ZodBranded = class extends ZodType {\n  _parse(input) {\n    const { ctx } = this._processInputParams(input);\n    const data = ctx.data;\n    return this._def.type._parse({\n      data,\n      path: ctx.path,\n      parent: ctx\n    });\n  }\n  unwrap() {\n    return this._def.type;\n  }\n};\nvar ZodPipeline = class _ZodPipeline extends ZodType {\n  _parse(input) {\n    const { status, ctx } = this._processInputParams(input);\n    if (ctx.common.async) {\n      const handleAsync = async () => {\n        const inResult = await this._def.in._parseAsync({\n          data: ctx.data,\n          path: ctx.path,\n          parent: ctx\n        });\n        if (inResult.status === \"aborted\")\n          return INVALID;\n        if (inResult.status === \"dirty\") {\n          status.dirty();\n          return DIRTY(inResult.value);\n        } else {\n          return this._def.out._parseAsync({\n            data: inResult.value,\n            path: ctx.path,\n            parent: ctx\n          });\n        }\n      };\n      return handleAsync();\n    } else {\n      const inResult = this._def.in._parseSync({\n        data: ctx.data,\n        path: ctx.path,\n        parent: ctx\n      });\n      if (inResult.status === \"aborted\")\n        return INVALID;\n      if (inResult.status === \"dirty\") {\n        status.dirty();\n        return {\n          status: \"dirty\",\n          value: inResult.value\n        };\n      } else {\n        return this._def.out._parseSync({\n          data: inResult.value,\n          path: ctx.path,\n          parent: ctx\n        });\n      }\n    }\n  }\n  static create(a, b2) {\n    return new _ZodPipeline({\n      in: a,\n      out: b2,\n      typeName: ZodFirstPartyTypeKind.ZodPipeline\n    });\n  }\n};\nvar ZodReadonly = class extends ZodType {\n  _parse(input) {\n    const result2 = this._def.innerType._parse(input);\n    if (isValid(result2)) {\n      result2.value = Object.freeze(result2.value);\n    }\n    return result2;\n  }\n};\nZodReadonly.create = (type3, params) => {\n  return new ZodReadonly({\n    innerType: type3,\n    typeName: ZodFirstPartyTypeKind.ZodReadonly,\n    ...processCreateParams(params)\n  });\n};\nvar custom = (check, params = {}, fatal) => {\n  if (check)\n    return ZodAny.create().superRefine((data, ctx) => {\n      var _a, _b;\n      if (!check(data)) {\n        const p = typeof params === \"function\" ? params(data) : typeof params === \"string\" ? { message: params } : params;\n        const _fatal = (_b = (_a = p.fatal) !== null && _a !== void 0 ? _a : fatal) !== null && _b !== void 0 ? _b : true;\n        const p2 = typeof p === \"string\" ? { message: p } : p;\n        ctx.addIssue({ code: \"custom\", ...p2, fatal: _fatal });\n      }\n    });\n  return ZodAny.create();\n};\nvar late = {\n  object: ZodObject.lazycreate\n};\nvar ZodFirstPartyTypeKind;\n(function(ZodFirstPartyTypeKind2) {\n  ZodFirstPartyTypeKind2[\"ZodString\"] = \"ZodString\";\n  ZodFirstPartyTypeKind2[\"ZodNumber\"] = \"ZodNumber\";\n  ZodFirstPartyTypeKind2[\"ZodNaN\"] = \"ZodNaN\";\n  ZodFirstPartyTypeKind2[\"ZodBigInt\"] = \"ZodBigInt\";\n  ZodFirstPartyTypeKind2[\"ZodBoolean\"] = \"ZodBoolean\";\n  ZodFirstPartyTypeKind2[\"ZodDate\"] = \"ZodDate\";\n  ZodFirstPartyTypeKind2[\"ZodSymbol\"] = \"ZodSymbol\";\n  ZodFirstPartyTypeKind2[\"ZodUndefined\"] = \"ZodUndefined\";\n  ZodFirstPartyTypeKind2[\"ZodNull\"] = \"ZodNull\";\n  ZodFirstPartyTypeKind2[\"ZodAny\"] = \"ZodAny\";\n  ZodFirstPartyTypeKind2[\"ZodUnknown\"] = \"ZodUnknown\";\n  ZodFirstPartyTypeKind2[\"ZodNever\"] = \"ZodNever\";\n  ZodFirstPartyTypeKind2[\"ZodVoid\"] = \"ZodVoid\";\n  ZodFirstPartyTypeKind2[\"ZodArray\"] = \"ZodArray\";\n  ZodFirstPartyTypeKind2[\"ZodObject\"] = \"ZodObject\";\n  ZodFirstPartyTypeKind2[\"ZodUnion\"] = \"ZodUnion\";\n  ZodFirstPartyTypeKind2[\"ZodDiscriminatedUnion\"] = \"ZodDiscriminatedUnion\";\n  ZodFirstPartyTypeKind2[\"ZodIntersection\"] = \"ZodIntersection\";\n  ZodFirstPartyTypeKind2[\"ZodTuple\"] = \"ZodTuple\";\n  ZodFirstPartyTypeKind2[\"ZodRecord\"] = \"ZodRecord\";\n  ZodFirstPartyTypeKind2[\"ZodMap\"] = \"ZodMap\";\n  ZodFirstPartyTypeKind2[\"ZodSet\"] = \"ZodSet\";\n  ZodFirstPartyTypeKind2[\"ZodFunction\"] = \"ZodFunction\";\n  ZodFirstPartyTypeKind2[\"ZodLazy\"] = \"ZodLazy\";\n  ZodFirstPartyTypeKind2[\"ZodLiteral\"] = \"ZodLiteral\";\n  ZodFirstPartyTypeKind2[\"ZodEnum\"] = \"ZodEnum\";\n  ZodFirstPartyTypeKind2[\"ZodEffects\"] = \"ZodEffects\";\n  ZodFirstPartyTypeKind2[\"ZodNativeEnum\"] = \"ZodNativeEnum\";\n  ZodFirstPartyTypeKind2[\"ZodOptional\"] = \"ZodOptional\";\n  ZodFirstPartyTypeKind2[\"ZodNullable\"] = \"ZodNullable\";\n  ZodFirstPartyTypeKind2[\"ZodDefault\"] = \"ZodDefault\";\n  ZodFirstPartyTypeKind2[\"ZodCatch\"] = \"ZodCatch\";\n  ZodFirstPartyTypeKind2[\"ZodPromise\"] = \"ZodPromise\";\n  ZodFirstPartyTypeKind2[\"ZodBranded\"] = \"ZodBranded\";\n  ZodFirstPartyTypeKind2[\"ZodPipeline\"] = \"ZodPipeline\";\n  ZodFirstPartyTypeKind2[\"ZodReadonly\"] = \"ZodReadonly\";\n})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));\nvar instanceOfType = (cls, params = {\n  message: `Input not instance of ${cls.name}`\n}) => custom((data) => data instanceof cls, params);\nvar stringType = ZodString.create;\nvar numberType = ZodNumber.create;\nvar nanType = ZodNaN.create;\nvar bigIntType = ZodBigInt.create;\nvar booleanType = ZodBoolean.create;\nvar dateType = ZodDate.create;\nvar symbolType = ZodSymbol.create;\nvar undefinedType = ZodUndefined.create;\nvar nullType = ZodNull.create;\nvar anyType = ZodAny.create;\nvar unknownType = ZodUnknown.create;\nvar neverType = ZodNever.create;\nvar voidType = ZodVoid.create;\nvar arrayType = ZodArray.create;\nvar objectType = ZodObject.create;\nvar strictObjectType = ZodObject.strictCreate;\nvar unionType = ZodUnion.create;\nvar discriminatedUnionType = ZodDiscriminatedUnion.create;\nvar intersectionType = ZodIntersection.create;\nvar tupleType = ZodTuple.create;\nvar recordType = ZodRecord.create;\nvar mapType = ZodMap.create;\nvar setType = ZodSet.create;\nvar functionType = ZodFunction.create;\nvar lazyType = ZodLazy.create;\nvar literalType = ZodLiteral.create;\nvar enumType = ZodEnum.create;\nvar nativeEnumType = ZodNativeEnum.create;\nvar promiseType = ZodPromise.create;\nvar effectsType = ZodEffects.create;\nvar optionalType = ZodOptional.create;\nvar nullableType = ZodNullable.create;\nvar preprocessType = ZodEffects.createWithPreprocess;\nvar pipelineType = ZodPipeline.create;\nvar ostring = () => stringType().optional();\nvar onumber = () => numberType().optional();\nvar oboolean = () => booleanType().optional();\nvar coerce = {\n  string: (arg) => ZodString.create({ ...arg, coerce: true }),\n  number: (arg) => ZodNumber.create({ ...arg, coerce: true }),\n  boolean: (arg) => ZodBoolean.create({\n    ...arg,\n    coerce: true\n  }),\n  bigint: (arg) => ZodBigInt.create({ ...arg, coerce: true }),\n  date: (arg) => ZodDate.create({ ...arg, coerce: true })\n};\nvar NEVER = INVALID;\nvar z = /* @__PURE__ */ Object.freeze({\n  __proto__: null,\n  defaultErrorMap: errorMap,\n  setErrorMap,\n  getErrorMap,\n  makeIssue,\n  EMPTY_PATH,\n  addIssueToContext,\n  ParseStatus,\n  INVALID,\n  DIRTY,\n  OK,\n  isAborted,\n  isDirty,\n  isValid,\n  isAsync,\n  get util() {\n    return util;\n  },\n  get objectUtil() {\n    return objectUtil;\n  },\n  ZodParsedType,\n  getParsedType,\n  ZodType,\n  ZodString,\n  ZodNumber,\n  ZodBigInt,\n  ZodBoolean,\n  ZodDate,\n  ZodSymbol,\n  ZodUndefined,\n  ZodNull,\n  ZodAny,\n  ZodUnknown,\n  ZodNever,\n  ZodVoid,\n  ZodArray,\n  ZodObject,\n  ZodUnion,\n  ZodDiscriminatedUnion,\n  ZodIntersection,\n  ZodTuple,\n  ZodRecord,\n  ZodMap,\n  ZodSet,\n  ZodFunction,\n  ZodLazy,\n  ZodLiteral,\n  ZodEnum,\n  ZodNativeEnum,\n  ZodPromise,\n  ZodEffects,\n  ZodTransformer: ZodEffects,\n  ZodOptional,\n  ZodNullable,\n  ZodDefault,\n  ZodCatch,\n  ZodNaN,\n  BRAND,\n  ZodBranded,\n  ZodPipeline,\n  ZodReadonly,\n  custom,\n  Schema: ZodType,\n  ZodSchema: ZodType,\n  late,\n  get ZodFirstPartyTypeKind() {\n    return ZodFirstPartyTypeKind;\n  },\n  coerce,\n  any: anyType,\n  array: arrayType,\n  bigint: bigIntType,\n  boolean: booleanType,\n  date: dateType,\n  discriminatedUnion: discriminatedUnionType,\n  effect: effectsType,\n  \"enum\": enumType,\n  \"function\": functionType,\n  \"instanceof\": instanceOfType,\n  intersection: intersectionType,\n  lazy: lazyType,\n  literal: literalType,\n  map: mapType,\n  nan: nanType,\n  nativeEnum: nativeEnumType,\n  never: neverType,\n  \"null\": nullType,\n  nullable: nullableType,\n  number: numberType,\n  object: objectType,\n  oboolean,\n  onumber,\n  optional: optionalType,\n  ostring,\n  pipeline: pipelineType,\n  preprocess: preprocessType,\n  promise: promiseType,\n  record: recordType,\n  set: setType,\n  strictObject: strictObjectType,\n  string: stringType,\n  symbol: symbolType,\n  transformer: effectsType,\n  tuple: tupleType,\n  \"undefined\": undefinedType,\n  union: unionType,\n  unknown: unknownType,\n  \"void\": voidType,\n  NEVER,\n  ZodIssueCode,\n  quotelessJson,\n  ZodError\n});\n\n// src/client/gateway.js\nfunction loadTransactionMetaWith({ fetch: fetch2, GRAPHQL_URL: GRAPHQL_URL2, logger }) {\n  const GET_TRANSACTIONS_QUERY = `\n    query GetTransactions ($transactionIds: [ID!]!) {\n      transactions(ids: $transactionIds) {\n        edges {\n          node {\n            owner {\n              address\n            }\n            tags {\n              name\n              value\n            }\n            block {\n              id\n              height\n              timestamp\n            }\n          }\n        }\n      }\n    }`;\n  const transactionConnectionSchema = z.object({\n    data: z.object({\n      transactions: z.object({\n        edges: z.array(z.object({\n          node: z.record(z.any())\n        }))\n      })\n    })\n  });\n  return (id) => of(id).chain(fromPromise(\n    (id2) => fetch2(GRAPHQL_URL2, {\n      method: \"POST\",\n      headers: { \"Content-Type\": \"application/json\" },\n      body: JSON.stringify({\n        query: GET_TRANSACTIONS_QUERY,\n        variables: { transactionIds: [id2] }\n      })\n    }).then(async (res) => {\n      if (res.ok)\n        return res.json();\n      logger('Error Encountered when querying gateway for transaction \"%s\"', id2);\n      throw new Error(`${res.status}: ${await res.text()}`);\n    }).then(transactionConnectionSchema.parse).then(path_default([\"data\", \"transactions\", \"edges\", \"0\", \"node\"]))\n  )).toPromise();\n}\n\n// src/logger.js\nvar import_debug = __toESM(require_browser(), 1);\nvar createLogger = (name = \"@permaweb/aoconnect\") => {\n  const logger = (0, import_debug.default)(name);\n  logger.child = (name2) => createLogger(`${logger.namespace}:${name2}`);\n  logger.tap = (note, ...rest) => tap_default((...args) => logger(note, ...rest, ...args));\n  return logger;\n};\n\n// src/lib/utils.js\nvar joinUrl = ({ url, path: path3 }) => {\n  if (!path3)\n    return url;\n  if (path3.startsWith(\"/\"))\n    return joinUrl({ url, path: path3.slice(1) });\n  url = new URL(url);\n  url.pathname += path3;\n  return url.toString();\n};\nfunction parseTags(rawTags) {\n  return pipe(\n    defaultTo_default([]),\n    reduce_default(\n      (map3, tag) => pipe(\n        // [value, value, ...] || []\n        propOr_default([], tag.name),\n        // [value]\n        append_default(tag.value),\n        // { [name]: [value, value, ...] }\n        assoc_default(tag.name, __default, map3)\n      )(map3),\n      {}\n    ),\n    /**\n    * If the field is only a singly list, then extract the one value.\n    *\n    * Otherwise, keep the value as a list.\n    */\n    map_default((values) => values.length > 1 ? values : values[0])\n  )(rawTags);\n}\nfunction removeTagsByNameMaybeValue(name, value) {\n  return (tags) => reject_default(\n    allPass_default([\n      propEq_default(name, \"name\"),\n      ifElse_default(\n        always_default(value),\n        propEq_default(value, \"value\"),\n        T_default\n      )\n    ]),\n    tags\n  );\n}\nfunction eqOrIncludes(val) {\n  return cond_default([\n    [is_default(String), equals_default(val)],\n    [is_default(Array), includes_default(val)],\n    [T_default, F_default]\n  ]);\n}\nfunction errFrom(err) {\n  let e;\n  if (is_default(ZodError, err)) {\n    e = new Error(mapZodErr(err));\n    e.stack += err.stack;\n  } else if (is_default(Error, err)) {\n    e = err;\n  } else if (has_default(\"message\", err)) {\n    e = new Error(err.message);\n  } else if (is_default(String, err)) {\n    e = new Error(err);\n  } else {\n    e = new Error(\"An error occurred\");\n  }\n  return e;\n}\nfunction mapZodErr(zodErr) {\n  return pipe(\n    (zodErr2) => (\n      /**\n       * Take a ZodError and flatten it's issues into a single depth array\n       */\n      function gatherZodIssues(zodErr3, status, contextCode) {\n        return reduce_default(\n          (issues, issue) => pipe(\n            cond_default([\n              /**\n               * These issue codes indicate nested ZodErrors, so we resursively gather those\n               * See https://github.com/colinhacks/zod/blob/HEAD/ERROR_HANDLING.md#zodissuecode\n               */\n              [\n                equals_default(ZodIssueCode.invalid_arguments),\n                () => gatherZodIssues(issue.argumentsError, 422, \"Invalid Arguments\")\n              ],\n              [\n                equals_default(ZodIssueCode.invalid_return_type),\n                () => gatherZodIssues(issue.returnTypeError, 500, \"Invalid Return\")\n              ],\n              [\n                equals_default(ZodIssueCode.invalid_union),\n                // An array of ZodErrors, so map over and flatten them all\n                () => chain_default((i) => gatherZodIssues(i, 400, \"Invalid Union\"), issue.unionErrors)\n              ],\n              [T_default, () => [{ ...issue, status, contextCode }]]\n            ]),\n            concat_default(issues)\n          )(issue.code),\n          [],\n          zodErr3.issues\n        );\n      }(zodErr2, 400, \"\")\n    ),\n    /**\n     * combine all zod issues into a list of { message, status }\n     * summaries of each issue\n     */\n    (zodIssues) => reduce_default(\n      (acc, zodIssue) => {\n        const { message: message2, path: _path, contextCode: _contextCode } = zodIssue;\n        const path3 = _path[1] || _path[0];\n        const contextCode = _contextCode ? `${_contextCode} ` : \"\";\n        acc.push(`${contextCode}'${path3}': ${message2}.`);\n        return acc;\n      },\n      [],\n      zodIssues\n    ),\n    join_default(\" | \")\n  )(zodErr);\n}\n\n// src/lib/result/verify-input.js\nvar inputSchema = z.object({\n  id: z.string().min(1, { message: \"message is required to be a message id\" }),\n  processId: z.string().min(1, { message: \"process is required to be a process id\" })\n});\nfunction verifyInputWith() {\n  return (ctx) => {\n    return of(ctx).map(inputSchema.parse).map(() => ctx);\n  };\n}\n\n// src/dal.js\nvar tagSchema = z.object({\n  name: z.string(),\n  value: z.string()\n});\nvar dryrunResultSchema = z.function().args(z.object({\n  Id: z.string(),\n  Target: z.string(),\n  Owner: z.string(),\n  Anchor: z.string().optional(),\n  Data: z.any().default(\"1234\"),\n  Tags: z.array(z.object({ name: z.string(), value: z.string() }))\n})).returns(z.promise(z.any()));\nvar loadResultSchema = z.function().args(z.object({\n  id: z.string().min(1, { message: \"message id is required\" }),\n  processId: z.string().min(1, { message: \"process id is required\" })\n})).returns(z.promise(z.any()));\nvar queryResultsSchema = z.function().args(z.object({\n  process: z.string().min(1, { message: \"process id is required\" }),\n  from: z.string().optional(),\n  to: z.string().optional(),\n  sort: z.enum([\"ASC\", \"DESC\"]).default(\"ASC\"),\n  limit: z.number().optional()\n})).returns(z.promise(z.object({\n  edges: z.array(z.object({\n    cursor: z.string(),\n    node: z.object({\n      Output: z.any().optional(),\n      Messages: z.array(z.any()).optional(),\n      Spawns: z.array(z.any()).optional(),\n      Error: z.any().optional()\n    })\n  }))\n})));\nvar deployMessageSchema = z.function().args(z.object({\n  processId: z.string(),\n  data: z.any(),\n  tags: z.array(tagSchema),\n  anchor: z.string().optional(),\n  signer: z.any()\n})).returns(z.promise(\n  z.object({\n    messageId: z.string()\n  }).passthrough()\n));\nvar deployProcessSchema = z.function().args(z.object({\n  data: z.any(),\n  tags: z.array(tagSchema),\n  signer: z.any()\n})).returns(z.promise(\n  z.object({\n    processId: z.string()\n  }).passthrough()\n));\nvar deployAssignSchema = z.function().args(z.object({\n  process: z.string(),\n  message: z.string(),\n  baseLayer: z.boolean().optional(),\n  exclude: z.array(z.string()).optional()\n})).returns(z.promise(\n  z.object({\n    assignmentId: z.string()\n  }).passthrough()\n));\nvar deployMonitorSchema = deployMessageSchema;\nvar loadProcessMetaSchema = z.function().args(z.object({\n  suUrl: z.string().url(),\n  processId: z.string()\n})).returns(z.promise(\n  z.object({\n    tags: z.array(tagSchema)\n  }).passthrough()\n));\nvar locateSchedulerSchema = z.function().args(z.string()).returns(z.promise(\n  z.object({\n    url: z.string()\n  })\n));\nvar validateSchedulerSchema = z.function().args(z.string()).returns(z.promise(z.boolean()));\nvar loadTransactionMetaSchema = z.function().args(z.string()).returns(z.promise(\n  z.object({\n    tags: z.array(tagSchema)\n  }).passthrough()\n));\nvar signerSchema = z.function().args(z.object({\n  data: z.any(),\n  tags: z.array(tagSchema),\n  /**\n   * target must be set with writeMessage,\n   * but not for createProcess\n   */\n  target: z.string().optional(),\n  anchor: z.string().optional()\n})).returns(z.promise(\n  z.object({\n    id: z.string(),\n    raw: z.any()\n  })\n));\n\n// src/lib/result/read.js\nfunction readWith({ loadResult }) {\n  loadResult = fromPromise(loadResultSchema.implement(loadResult));\n  return (ctx) => {\n    return of({ id: ctx.id, processId: ctx.processId }).chain(loadResult);\n  };\n}\n\n// src/lib/result/index.js\nfunction resultWith(env) {\n  const verifyInput = verifyInputWith(env);\n  const read = readWith(env);\n  return ({ message: message2, process: process2 }) => {\n    return of({ id: message2, processId: process2 }).chain(verifyInput).chain(read).map(\n      env.logger.tap(\n        'readResult result for message \"%s\": %O',\n        message2\n      )\n    ).map((result2) => result2).bimap(errFrom, identity_default).toPromise();\n  };\n}\n\n// src/lib/message/upload-message.js\nvar tagSchema2 = z.array(z.object({\n  name: z.string(),\n  value: z.string()\n}));\nfunction buildTagsWith() {\n  return (ctx) => {\n    return of(ctx.tags).map(defaultTo_default([])).map(removeTagsByNameMaybeValue(\"Data-Protocol\", \"ao\")).map(removeTagsByNameMaybeValue(\"Variant\")).map(removeTagsByNameMaybeValue(\"Type\")).map(removeTagsByNameMaybeValue(\"SDK\")).map(concat_default(__default, [\n      { name: \"Data-Protocol\", value: \"ao\" },\n      { name: \"Variant\", value: \"ao.TN.1\" },\n      { name: \"Type\", value: \"Message\" },\n      { name: \"SDK\", value: \"aoconnect\" }\n    ])).map(tagSchema2.parse).map(assoc_default(\"tags\", __default, ctx));\n  };\n}\nfunction buildDataWith({ logger }) {\n  return (ctx) => {\n    return of(ctx).chain(ifElse_default(\n      always_default(ctx.data),\n      /**\n       * data is provided as input, so do nothing\n       */\n      () => Resolved(ctx),\n      /**\n       * Just generate a random value for data\n       */\n      () => Resolved(Math.random().toString().slice(-4)).map(assoc_default(\"data\", __default, ctx)).map(\n        (ctx2) => pipe(\n          prop_default(\"tags\"),\n          removeTagsByNameMaybeValue(\"Content-Type\"),\n          append_default({ name: \"Content-Type\", value: \"text/plain\" }),\n          assoc_default(\"tags\", __default, ctx2)\n        )(ctx2)\n      ).map(logger.tap('added pseudo-random string as message \"data\"'))\n    ));\n  };\n}\nfunction uploadMessageWith(env) {\n  const buildTags = buildTagsWith(env);\n  const buildData = buildDataWith(env);\n  const deployMessage = deployMessageSchema.implement(env.deployMessage);\n  return (ctx) => {\n    return of(ctx).chain(buildTags).chain(buildData).chain(fromPromise(\n      ({ id, data, tags, anchor, signer }) => deployMessage({ processId: id, data, tags, anchor, signer: signerSchema.implement(signer) })\n    )).map((res) => assoc_default(\"messageId\", res.messageId, ctx));\n  };\n}\n\n// src/lib/message/index.js\nfunction messageWith(env) {\n  const uploadMessage = uploadMessageWith(env);\n  return ({ process: process2, data, tags, anchor, signer }) => {\n    return of({ id: process2, data, tags, anchor, signer }).chain(uploadMessage).map((ctx) => ctx.messageId).bimap(errFrom, identity_default).toPromise();\n  };\n}\n\n// src/lib/spawn/verify-inputs.js\nvar checkTag = (name, pred, err) => (tags) => pred(tags[name]) ? Resolved(tags) : Rejected(`Tag '${name}': ${err}`);\nfunction verifyModuleWith({ loadTransactionMeta, logger }) {\n  loadTransactionMeta = fromPromise(loadTransactionMetaSchema.implement(loadTransactionMeta));\n  return (module) => of(module).chain(loadTransactionMeta).map(prop_default(\"tags\")).map(parseTags).chain(checkTag(\"Data-Protocol\", eqOrIncludes(\"ao\"), \"value 'ao' was not found on module\")).chain(checkTag(\"Type\", eqOrIncludes(\"Module\"), \"value 'Module' was not found on module\")).chain(checkTag(\"Module-Format\", isNotNil_default, \"was not found on module\")).chain(checkTag(\"Input-Encoding\", isNotNil_default, \"was not found on module\")).chain(checkTag(\"Output-Encoding\", isNotNil_default, \"was not found on module\")).bimap(\n    logger.tap(\"Verifying module source failed: %s\"),\n    logger.tap(\"Verified module source\")\n  );\n}\nfunction verifySchedulerWith({ logger, validateScheduler }) {\n  validateScheduler = fromPromise(validateSchedulerSchema.implement(validateScheduler));\n  return (scheduler) => of(scheduler).chain(\n    (scheduler2) => validateScheduler(scheduler2).chain((isValid2) => isValid2 ? Resolved(scheduler2) : Rejected(`Valid Scheduler-Location owned by ${scheduler2} not found`))\n  ).bimap(\n    logger.tap(\"Verifying scheduler failed: %s\"),\n    logger.tap(\"Verified scheduler\")\n  );\n}\nfunction verifySignerWith({ logger }) {\n  return (signer) => of(signer).map(logger.tap(\"Checking for signer\")).chain((signer2) => signer2 ? Resolved(signer2) : Rejected(\"signer not found\"));\n}\nfunction verifyInputsWith(env) {\n  const logger = env.logger.child(\"verifyInput\");\n  env = { ...env, logger };\n  const verifyModule = verifyModuleWith(env);\n  const verifyScheduler = verifySchedulerWith(env);\n  const verifySigner = verifySignerWith(env);\n  return (ctx) => {\n    return of(ctx).chain((ctx2) => verifyModule(ctx2.module).map(() => ctx2)).chain((ctx2) => verifyScheduler(ctx2.scheduler)).map(() => ctx).chain((ctx2) => verifySigner(ctx2.signer).map(() => ctx2)).bimap(\n      logger.tap(\"Error when verify input: %s\"),\n      logger.tap(\"Successfully verified inputs\")\n    );\n  };\n}\n\n// src/lib/spawn/upload-process.js\nvar tagSchema3 = z.array(z.object({\n  name: z.string(),\n  value: z.string()\n}));\nfunction buildTagsWith2() {\n  return (ctx) => {\n    return of(ctx).map(prop_default(\"tags\")).map(defaultTo_default([])).map(removeTagsByNameMaybeValue(\"Data-Protocol\", \"ao\")).map(removeTagsByNameMaybeValue(\"Variant\")).map(removeTagsByNameMaybeValue(\"Type\")).map(removeTagsByNameMaybeValue(\"Module\")).map(removeTagsByNameMaybeValue(\"Scheduler\")).map(removeTagsByNameMaybeValue(\"SDK\")).map(concat_default(__default, [\n      { name: \"Data-Protocol\", value: \"ao\" },\n      { name: \"Variant\", value: \"ao.TN.1\" },\n      { name: \"Type\", value: \"Process\" },\n      { name: \"Module\", value: ctx.module },\n      { name: \"Scheduler\", value: ctx.scheduler },\n      { name: \"SDK\", value: \"aoconnect\" }\n    ])).map(tagSchema3.parse).map(assoc_default(\"tags\", __default, ctx));\n  };\n}\nfunction buildDataWith2({ logger }) {\n  return (ctx) => {\n    return of(ctx).chain(ifElse_default(\n      always_default(ctx.data),\n      /**\n       * data is provided as input, so do nothing\n       */\n      () => Resolved(ctx),\n      /**\n       * Just generate a random value for data\n       */\n      () => Resolved(Math.random().toString().slice(-4)).map(assoc_default(\"data\", __default, ctx)).map(\n        (ctx2) => pipe(\n          prop_default(\"tags\"),\n          removeTagsByNameMaybeValue(\"Content-Type\"),\n          append_default({ name: \"Content-Type\", value: \"text/plain\" }),\n          assoc_default(\"tags\", __default, ctx2)\n        )(ctx2)\n      ).map(logger.tap('added pseudo-random string as process \"data\"'))\n    ));\n  };\n}\nfunction uploadProcessWith(env) {\n  const logger = env.logger.child(\"uploadProcess\");\n  env = { ...env, logger };\n  const buildTags = buildTagsWith2(env);\n  const buildData = buildDataWith2(env);\n  const deployProcess = deployProcessSchema.implement(env.deployProcess);\n  return (ctx) => {\n    return of(ctx).chain(buildTags).chain(buildData).chain(fromPromise(\n      ({ data, tags, signer }) => deployProcess({ data, tags, signer: signerSchema.implement(signer) })\n    )).map((res) => assoc_default(\"processId\", res.processId, ctx));\n  };\n}\n\n// src/lib/spawn/index.js\nfunction spawnWith(env) {\n  const verifyInputs = verifyInputsWith(env);\n  const uploadProcess = uploadProcessWith(env);\n  return ({ module, scheduler, signer, tags, data }) => {\n    return of({ module, scheduler, signer, tags, data }).chain(verifyInputs).chain(uploadProcess).map((ctx) => ctx.processId).bimap(errFrom, identity_default).toPromise();\n  };\n}\n\n// src/lib/monitor/upload-monitor.js\nfunction uploadMonitorWith(env) {\n  const deployMonitor = deployMonitorSchema.implement(env.deployMonitor);\n  return (ctx) => {\n    return of(ctx).chain(fromPromise(\n      ({ id, signer }) => deployMonitor({\n        processId: id,\n        signer: signerSchema.implement(signer),\n        /**\n         * No tags or data can be provided right now,\n         *\n         * so just randomize data and set tags to an empty array\n         */\n        data: Math.random().toString().slice(-4),\n        tags: []\n      })\n    )).map((res) => assoc_default(\"monitorId\", res.messageId, ctx));\n  };\n}\n\n// src/lib/monitor/index.js\nfunction monitorWith(env) {\n  const uploadMonitor = uploadMonitorWith(env);\n  return ({ process: process2, signer }) => of({ id: process2, signer }).chain(uploadMonitor).map((ctx) => ctx.monitorId).bimap(errFrom, identity_default).toPromise();\n}\n\n// src/lib/unmonitor/upload-unmonitor.js\nfunction uploadUnmonitorWith(env) {\n  const deployUnmonitor = deployMonitorSchema.implement(env.deployUnmonitor);\n  return (ctx) => {\n    return of(ctx).chain(fromPromise(\n      ({ id, signer }) => deployUnmonitor({\n        processId: id,\n        signer: signerSchema.implement(signer),\n        /**\n         * No tags or data can be provided right now,\n         *\n         * so just randomize data and set tags to an empty array\n         */\n        data: Math.random().toString().slice(-4),\n        tags: []\n      })\n    )).map((res) => assoc_default(\"monitorId\", res.messageId, ctx));\n  };\n}\n\n// src/lib/unmonitor/index.js\nfunction unmonitorWith(env) {\n  const uploadUnmonitor = uploadUnmonitorWith(env);\n  return ({ process: process2, signer }) => of({ id: process2, signer }).chain(uploadUnmonitor).map((ctx) => ctx.monitorId).bimap(errFrom, identity_default).toPromise();\n}\n\n// src/lib/results/verify-input.js\nvar inputSchema2 = z.object({\n  process: z.string().min(1, { message: \"process identifier is required\" }),\n  from: z.string().optional(),\n  to: z.string().optional(),\n  sort: z.enum([\"ASC\", \"DESC\"]).default(\"ASC\"),\n  limit: z.number().optional()\n});\nfunction verifyInputWith2() {\n  return (ctx) => {\n    return of(ctx).map(inputSchema2.parse).map(() => ctx);\n  };\n}\n\n// src/lib/results/query.js\nfunction queryWith({ queryResults }) {\n  queryResults = fromPromise(queryResultsSchema.implement(queryResults));\n  return (ctx) => {\n    return of({ process: ctx.process, from: ctx.from, to: ctx.to, sort: ctx.sort, limit: ctx.limit }).chain(queryResults);\n  };\n}\n\n// src/lib/results/index.js\nfunction resultsWith(env) {\n  const verifyInput = verifyInputWith2(env);\n  const query = queryWith(env);\n  return ({ process: process2, from, to, sort, limit }) => {\n    return of({ process: process2, from, to, sort, limit }).chain(verifyInput).chain(query).map(\n      env.logger.tap(\n        'readResults result for message \"%s\": %O',\n        process2\n      )\n    ).map((result2) => result2).bimap(errFrom, identity_default).toPromise();\n  };\n}\n\n// src/lib/dryrun/verify-input.js\nvar inputSchema3 = z.object({\n  Id: z.string(),\n  Target: z.string(),\n  Owner: z.string(),\n  Anchor: z.string().optional(),\n  Data: z.any().default(\"1234\"),\n  Tags: z.array(z.object({ name: z.string(), value: z.string() }))\n});\nfunction verifyInputWith3() {\n  return (msg) => {\n    return of(msg).map(inputSchema3.parse).map((m) => {\n      m.Tags = m.Tags.concat([\n        { name: \"Data-Protocol\", value: \"ao\" },\n        { name: \"Type\", value: \"Message\" },\n        { name: \"Variant\", value: \"ao.TN.1\" }\n      ]);\n      return m;\n    });\n  };\n}\n\n// src/lib/dryrun/run.js\nfunction runWith({ dryrunFetch }) {\n  return fromPromise(dryrunResultSchema.implement(dryrunFetch));\n}\n\n// src/lib/dryrun/index.js\nfunction dryrunWith(env) {\n  const verifyInput = verifyInputWith3(env);\n  const dryrun2 = runWith(env);\n  return (msg) => of(msg).map(convert).chain(verifyInput).chain(dryrun2).toPromise();\n}\nfunction convert({ process: process2, data, tags, anchor, ...rest }) {\n  return {\n    Id: \"1234\",\n    Owner: \"1234\",\n    ...rest,\n    Target: process2,\n    Data: data || \"1234\",\n    Tags: tags || [],\n    Anchor: anchor || \"0\"\n  };\n}\n\n// src/lib/assign/send-assign.js\nfunction sendAssignWith(env) {\n  const deployAssign = deployAssignSchema.implement(env.deployAssign);\n  return (ctx) => {\n    return of(ctx).chain(fromPromise(\n      ({ process: process2, message: message2, baseLayer, exclude }) => deployAssign({ process: process2, message: message2, baseLayer, exclude })\n    )).map((res) => assoc_default(\"assignmentId\", res.assignmentId, ctx));\n  };\n}\n\n// src/lib/assign/index.js\nfunction assignWith(env) {\n  const sendAssign = sendAssignWith(env);\n  return ({ process: process2, message: message2, baseLayer, exclude }) => {\n    return of({ process: process2, message: message2, baseLayer, exclude }).chain(sendAssign).map((ctx) => ctx.assignmentId).bimap(errFrom, identity_default).toPromise();\n  };\n}\n\n// src/lib/serializeCron/index.js\nfunction serializeCron(cron) {\n  function parseInterval(interval2 = \"\") {\n    if (typeof interval2 !== \"string\")\n      throw new Error(\"Encountered Error serializing cron: invalid interval\");\n    const [value, unit] = interval2.split(\"-\").map((s) => s.trim());\n    if (!value || !unit)\n      throw new Error(\"Encountered Error serializing cron: invalid interval\");\n    if (!parseInt(value) || parseInt(value) < 0)\n      throw new Error(\"Encountered Error serializing cron: invalid interval value\");\n    const singularRegex = /^(millisecond|second|minute|hour|day|month|year|block)$/;\n    const pluralRegex = /^(milliseconds|seconds|minutes|hours|days|months|years|blocks)$/;\n    const unitSingularMatch = unit.match(singularRegex);\n    const unitPluralMatch = unit.match(pluralRegex);\n    if (parseInt(value) > 1 && !unitPluralMatch || parseInt(value) === 1 && !unitSingularMatch)\n      throw new Error(\"Encountered Error serializing cron: invalid interval type\");\n    return `${value}-${unit}`;\n  }\n  function parseTags2(tags2 = []) {\n    return map_default((tag) => {\n      if (!tag.name || !tag.value)\n        throw new Error(\"Encountered Error serializing cron: invalid tag structure\");\n      if (typeof tag.name !== \"string\" || typeof tag.value !== \"string\")\n        throw new Error(\"Encountered Error serializing cron: invalid interval tag types\");\n      return { name: `Cron-Tag-${tag.name}`, value: tag.value };\n    }, tags2);\n  }\n  const interval = parseInterval(cron.interval);\n  const tags = parseTags2(cron.tags);\n  return [{ name: \"Cron-Interval\", value: interval }, ...tags];\n}\n\n// src/index.common.js\nvar DEFAULT_GATEWAY_URL = \"https://arweave.net\";\nvar DEFAULT_MU_URL = \"https://mu.ao-testnet.xyz\";\nvar DEFAULT_CU_URL = \"https://cu.ao-testnet.xyz\";\nfunction connect({\n  GRAPHQL_URL: GRAPHQL_URL2,\n  GATEWAY_URL: GATEWAY_URL2 = DEFAULT_GATEWAY_URL,\n  MU_URL: MU_URL2 = DEFAULT_MU_URL,\n  CU_URL: CU_URL2 = DEFAULT_CU_URL\n} = {}) {\n  const logger = createLogger();\n  if (!GRAPHQL_URL2)\n    GRAPHQL_URL2 = joinUrl({ url: GATEWAY_URL2, path: \"/graphql\" });\n  const { validate } = ye({ cacheSize: 100, GRAPHQL_URL: GRAPHQL_URL2 });\n  const processMetaCache2 = createProcessMetaCache({ MAX_SIZE: 25 });\n  const resultLogger = logger.child(\"result\");\n  const result2 = resultWith({\n    loadResult: loadResultWith({ fetch, CU_URL: CU_URL2, logger: resultLogger }),\n    logger: resultLogger\n  });\n  const messageLogger = logger.child(\"message\");\n  const message2 = messageWith({\n    loadProcessMeta: loadProcessMetaWith({\n      fetch,\n      cache: processMetaCache2,\n      logger: messageLogger\n    }),\n    // locateScheduler: locate,\n    deployMessage: deployMessageWith({ fetch, MU_URL: MU_URL2, logger: messageLogger }),\n    logger: messageLogger\n  });\n  const spawnLogger = logger.child(\"spawn\");\n  const spawn2 = spawnWith({\n    loadTransactionMeta: loadTransactionMetaWith({ fetch, GRAPHQL_URL: GRAPHQL_URL2, logger: spawnLogger }),\n    validateScheduler: validate,\n    deployProcess: deployProcessWith({ fetch, MU_URL: MU_URL2, logger: spawnLogger }),\n    logger: spawnLogger\n  });\n  const monitorLogger = logger.child(\"monitor\");\n  const monitor2 = monitorWith({\n    loadProcessMeta: loadProcessMetaWith({\n      fetch,\n      cache: processMetaCache2,\n      logger: monitorLogger\n    }),\n    // locateScheduler: locate,\n    deployMonitor: deployMonitorWith({ fetch, MU_URL: MU_URL2, logger: monitorLogger }),\n    logger: monitorLogger\n  });\n  const unmonitorLogger = logger.child(\"unmonitor\");\n  const unmonitor2 = unmonitorWith({\n    loadProcessMeta: loadProcessMetaWith({\n      fetch,\n      cache: processMetaCache2,\n      logger: unmonitorLogger\n    }),\n    // locateScheduler: locate,\n    deployUnmonitor: deployUnmonitorWith({ fetch, MU_URL: MU_URL2, logger: unmonitorLogger }),\n    logger: monitorLogger\n  });\n  const resultsLogger = logger.child(\"results\");\n  const results2 = resultsWith({\n    queryResults: queryResultsWith({ fetch, CU_URL: CU_URL2, logger: resultsLogger }),\n    logger: resultsLogger\n  });\n  const dryrunLogger = logger.child(\"dryrun\");\n  const dryrun2 = dryrunWith({\n    dryrunFetch: dryrunFetchWith({ fetch, CU_URL: CU_URL2, logger: dryrunLogger }),\n    logger: dryrunLogger\n  });\n  const assignLogger = logger.child(\"assign\");\n  const assign2 = assignWith({\n    deployAssign: deployAssignWith({\n      fetch,\n      MU_URL: MU_URL2,\n      logger: assignLogger\n    }),\n    logger: messageLogger\n  });\n  return { result: result2, results: results2, message: message2, spawn: spawn2, monitor: monitor2, unmonitor: unmonitor2, dryrun: dryrun2, assign: assign2 };\n}\n\n// src/client/browser/wallet.js\nvar wallet_exports = {};\n__export(wallet_exports, {\n  createDataItemSigner: () => createDataItemSigner\n});\nvar import_buffer = __toESM(require_buffer(), 1);\n\n// node_modules/warp-arbundles/build/web/esm/bundle.js\nvar bundle_exports = {};\n__export(bundle_exports, {\n  AVSCTap: () => $2,\n  ArweaveSigner: () => N2,\n  DataItem: () => _,\n  MAX_TAG_BYTES: () => tt2,\n  MIN_BINARY_SIZE: () => gr,\n  SIG_CONFIG: () => P2,\n  SignatureConfig: () => B2,\n  Signer: () => ot2,\n  createData: () => ge2,\n  default: () => wn,\n  deserializeTags: () => Q2,\n  indexToType: () => wt2,\n  serializeTags: () => dt2,\n  tagsExceedLimit: () => jr,\n  warparbundles: () => dn\n});\nvar xr = Object.create;\nvar it2 = Object.defineProperty;\nvar mr = Object.getOwnPropertyDescriptor;\nvar Br = Object.getOwnPropertyNames;\nvar Er = Object.getPrototypeOf;\nvar br = Object.prototype.hasOwnProperty;\nvar T3 = (e, t) => () => (t || e((t = { exports: {} }).exports, t), t.exports);\nvar Ar = (e, t) => {\n  for (var r3 in t)\n    it2(e, r3, { get: t[r3], enumerable: true });\n};\nvar Tr = (e, t, r3, n) => {\n  if (t && typeof t == \"object\" || typeof t == \"function\")\n    for (let i of Br(t))\n      !br.call(e, i) && i !== r3 && it2(e, i, { get: () => t[i], enumerable: !(n = mr(t, i)) || n.enumerable });\n  return e;\n};\nvar C2 = (e, t, r3) => (r3 = e != null ? xr(Er(e)) : {}, Tr(t || !e || !e.__esModule ? it2(r3, \"default\", { value: e, enumerable: true }) : r3, e));\nvar Rt2 = T3((st2) => {\n  \"use strict\";\n  Object.defineProperty(st2, \"__esModule\", { value: true });\n  function Ir(e) {\n    var t = 4, r3 = e.length, n = r3 % t;\n    if (!n)\n      return e;\n    var i = r3, o = t - n, s = r3 + o, u2 = Buffer.alloc(s);\n    for (u2.write(e); o--; )\n      u2.write(\"=\", i++);\n    return u2.toString();\n  }\n  st2.default = Ir;\n});\nvar Dt2 = T3((ht2) => {\n  \"use strict\";\n  Object.defineProperty(ht2, \"__esModule\", { value: true });\n  var Sr = Rt2();\n  function Ct2(e, t) {\n    return t === void 0 && (t = \"utf8\"), Buffer.isBuffer(e) ? at2(e.toString(\"base64\")) : at2(Buffer.from(e, t).toString(\"base64\"));\n  }\n  function Ur(e, t) {\n    return t === void 0 && (t = \"utf8\"), Buffer.from(ut2(e), \"base64\").toString(t);\n  }\n  function ut2(e) {\n    return e = e.toString(), Sr.default(e).replace(/\\-/g, \"+\").replace(/_/g, \"/\");\n  }\n  function at2(e) {\n    return e.replace(/=/g, \"\").replace(/\\+/g, \"-\").replace(/\\//g, \"_\");\n  }\n  function Fr(e) {\n    return Buffer.from(ut2(e), \"base64\");\n  }\n  var O2 = Ct2;\n  O2.encode = Ct2;\n  O2.decode = Ur;\n  O2.toBase64 = ut2;\n  O2.fromBase64 = at2;\n  O2.toBuffer = Fr;\n  ht2.default = O2;\n});\nvar z2 = T3((me2, V2) => {\n  V2.exports = Dt2().default;\n  V2.exports.default = V2.exports;\n});\nvar ct2 = T3((J2) => {\n  \"use strict\";\n  J2.byteLength = _r;\n  J2.toByteArray = Cr;\n  J2.fromByteArray = Nr;\n  var b2 = [], m = [], Lr = typeof Uint8Array < \"u\" ? Uint8Array : Array, ft2 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n  for (D2 = 0, Pt2 = ft2.length; D2 < Pt2; ++D2)\n    b2[D2] = ft2[D2], m[ft2.charCodeAt(D2)] = D2;\n  var D2, Pt2;\n  m[\"-\".charCodeAt(0)] = 62;\n  m[\"_\".charCodeAt(0)] = 63;\n  function Nt2(e) {\n    var t = e.length;\n    if (t % 4 > 0)\n      throw new Error(\"Invalid string. Length must be a multiple of 4\");\n    var r3 = e.indexOf(\"=\");\n    r3 === -1 && (r3 = t);\n    var n = r3 === t ? 0 : 4 - r3 % 4;\n    return [r3, n];\n  }\n  function _r(e) {\n    var t = Nt2(e), r3 = t[0], n = t[1];\n    return (r3 + n) * 3 / 4 - n;\n  }\n  function Rr(e, t, r3) {\n    return (t + r3) * 3 / 4 - r3;\n  }\n  function Cr(e) {\n    var t, r3 = Nt2(e), n = r3[0], i = r3[1], o = new Lr(Rr(e, n, i)), s = 0, u2 = i > 0 ? n - 4 : n, h2;\n    for (h2 = 0; h2 < u2; h2 += 4)\n      t = m[e.charCodeAt(h2)] << 18 | m[e.charCodeAt(h2 + 1)] << 12 | m[e.charCodeAt(h2 + 2)] << 6 | m[e.charCodeAt(h2 + 3)], o[s++] = t >> 16 & 255, o[s++] = t >> 8 & 255, o[s++] = t & 255;\n    return i === 2 && (t = m[e.charCodeAt(h2)] << 2 | m[e.charCodeAt(h2 + 1)] >> 4, o[s++] = t & 255), i === 1 && (t = m[e.charCodeAt(h2)] << 10 | m[e.charCodeAt(h2 + 1)] << 4 | m[e.charCodeAt(h2 + 2)] >> 2, o[s++] = t >> 8 & 255, o[s++] = t & 255), o;\n  }\n  function Dr(e) {\n    return b2[e >> 18 & 63] + b2[e >> 12 & 63] + b2[e >> 6 & 63] + b2[e & 63];\n  }\n  function Pr(e, t, r3) {\n    for (var n, i = [], o = t; o < r3; o += 3)\n      n = (e[o] << 16 & 16711680) + (e[o + 1] << 8 & 65280) + (e[o + 2] & 255), i.push(Dr(n));\n    return i.join(\"\");\n  }\n  function Nr(e) {\n    for (var t, r3 = e.length, n = r3 % 3, i = [], o = 16383, s = 0, u2 = r3 - n; s < u2; s += o)\n      i.push(Pr(e, s, s + o > u2 ? u2 : s + o));\n    return n === 1 ? (t = e[r3 - 1], i.push(b2[t >> 2] + b2[t << 4 & 63] + \"==\")) : n === 2 && (t = (e[r3 - 2] << 8) + e[r3 - 1], i.push(b2[t >> 10] + b2[t >> 4 & 63] + b2[t << 2 & 63] + \"=\")), i.join(\"\");\n  }\n});\nvar pt2 = T3((g) => {\n  \"use strict\";\n  Object.defineProperty(g, \"__esModule\", { value: true });\n  g.b64UrlDecode = g.b64UrlEncode = g.bufferTob64Url = g.bufferTob64 = g.b64UrlToBuffer = g.stringToB64Url = g.stringToBuffer = g.bufferToString = g.b64UrlToString = g.concatBuffers = void 0;\n  var kt2 = ct2();\n  function kr(e) {\n    let t = 0;\n    for (let i = 0; i < e.length; i++)\n      t += e[i].byteLength;\n    let r3 = new Uint8Array(t), n = 0;\n    r3.set(new Uint8Array(e[0]), n), n += e[0].byteLength;\n    for (let i = 1; i < e.length; i++)\n      r3.set(new Uint8Array(e[i]), n), n += e[i].byteLength;\n    return r3;\n  }\n  g.concatBuffers = kr;\n  function Mr(e) {\n    let t = $t2(e);\n    return Mt2(t);\n  }\n  g.b64UrlToString = Mr;\n  function Mt2(e) {\n    return new TextDecoder(\"utf-8\", { fatal: true }).decode(e);\n  }\n  g.bufferToString = Mt2;\n  function Ot2(e) {\n    return new TextEncoder().encode(e);\n  }\n  g.stringToBuffer = Ot2;\n  function Or(e) {\n    return Ht2(Ot2(e));\n  }\n  g.stringToB64Url = Or;\n  function $t2(e) {\n    return new Uint8Array(kt2.toByteArray(qt2(e)));\n  }\n  g.b64UrlToBuffer = $t2;\n  function Kt2(e) {\n    return kt2.fromByteArray(new Uint8Array(e));\n  }\n  g.bufferTob64 = Kt2;\n  function Ht2(e) {\n    return jt2(Kt2(e));\n  }\n  g.bufferTob64Url = Ht2;\n  function jt2(e) {\n    return e.replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/\\=/g, \"\");\n  }\n  g.b64UrlEncode = jt2;\n  function qt2(e) {\n    e = e.replace(/\\-/g, \"+\").replace(/\\_/g, \"/\");\n    let t;\n    return e.length % 4 == 0 ? t = 0 : t = 4 - e.length % 4, e.concat(\"=\".repeat(t));\n  }\n  g.b64UrlDecode = qt2;\n});\nvar Yt2 = T3((gt2) => {\n  \"use strict\";\n  Object.defineProperty(gt2, \"__esModule\", { value: true });\n  var F3 = pt2(), lt2 = class {\n    keyLength = 4096;\n    publicExponent = 65537;\n    hashAlgorithm = \"sha256\";\n    driver;\n    constructor() {\n      if (!this.detectWebCrypto())\n        throw new Error(\"SubtleCrypto not available!\");\n      this.driver = crypto.subtle;\n    }\n    async generateJWK() {\n      let t = await this.driver.generateKey({ name: \"RSA-PSS\", modulusLength: 4096, publicExponent: new Uint8Array([1, 0, 1]), hash: { name: \"SHA-256\" } }, true, [\"sign\"]), r3 = await this.driver.exportKey(\"jwk\", t.privateKey);\n      return { kty: r3.kty, e: r3.e, n: r3.n, d: r3.d, p: r3.p, q: r3.q, dp: r3.dp, dq: r3.dq, qi: r3.qi };\n    }\n    async sign(t, r3, { saltLength: n } = {}) {\n      let i = await this.driver.sign({ name: \"RSA-PSS\", saltLength: 32 }, await this.jwkToCryptoKey(t), r3);\n      return new Uint8Array(i);\n    }\n    async hash(t, r3 = \"SHA-256\") {\n      let n = await this.driver.digest(r3, t);\n      return new Uint8Array(n);\n    }\n    async verify(t, r3, n) {\n      let i = { kty: \"RSA\", e: \"AQAB\", n: t }, o = await this.jwkToPublicCryptoKey(i), s = await this.driver.digest(\"SHA-256\", r3), u2 = await this.driver.verify({ name: \"RSA-PSS\", saltLength: 0 }, o, n, r3), h2 = await this.driver.verify({ name: \"RSA-PSS\", saltLength: 32 }, o, n, r3), p = await this.driver.verify({ name: \"RSA-PSS\", saltLength: Math.ceil((o.algorithm.modulusLength - 1) / 8) - s.byteLength - 2 }, o, n, r3);\n      return u2 || h2 || p;\n    }\n    async jwkToCryptoKey(t) {\n      return this.driver.importKey(\"jwk\", t, { name: \"RSA-PSS\", hash: { name: \"SHA-256\" } }, false, [\"sign\"]);\n    }\n    async jwkToPublicCryptoKey(t) {\n      return this.driver.importKey(\"jwk\", t, { name: \"RSA-PSS\", hash: { name: \"SHA-256\" } }, false, [\"verify\"]);\n    }\n    detectWebCrypto() {\n      if (typeof crypto > \"u\")\n        return false;\n      let t = crypto?.subtle;\n      return t === void 0 ? false : [\"generateKey\", \"importKey\", \"exportKey\", \"digest\", \"sign\"].every((n) => typeof t[n] == \"function\");\n    }\n    async encrypt(t, r3, n) {\n      let i = await this.driver.importKey(\"raw\", typeof r3 == \"string\" ? F3.stringToBuffer(r3) : r3, { name: \"PBKDF2\", length: 32 }, false, [\"deriveKey\"]), o = await this.driver.deriveKey({ name: \"PBKDF2\", salt: n ? F3.stringToBuffer(n) : F3.stringToBuffer(\"salt\"), iterations: 1e5, hash: \"SHA-256\" }, i, { name: \"AES-CBC\", length: 256 }, false, [\"encrypt\", \"decrypt\"]), s = new Uint8Array(16);\n      crypto.getRandomValues(s);\n      let u2 = await this.driver.encrypt({ name: \"AES-CBC\", iv: s }, o, t);\n      return F3.concatBuffers([s, u2]);\n    }\n    async decrypt(t, r3, n) {\n      let i = await this.driver.importKey(\"raw\", typeof r3 == \"string\" ? F3.stringToBuffer(r3) : r3, { name: \"PBKDF2\", length: 32 }, false, [\"deriveKey\"]), o = await this.driver.deriveKey({ name: \"PBKDF2\", salt: n ? F3.stringToBuffer(n) : F3.stringToBuffer(\"salt\"), iterations: 1e5, hash: \"SHA-256\" }, i, { name: \"AES-CBC\", length: 256 }, false, [\"encrypt\", \"decrypt\"]), s = t.slice(0, 16), u2 = await this.driver.decrypt({ name: \"AES-CBC\", iv: s }, o, t.slice(16));\n      return F3.concatBuffers([u2]);\n    }\n  };\n  gt2.default = lt2;\n});\nvar zt = T3((mt2) => {\n  mt2.read = function(e, t, r3, n, i) {\n    var o, s, u2 = i * 8 - n - 1, h2 = (1 << u2) - 1, p = h2 >> 1, f = -7, c2 = r3 ? i - 1 : 0, U2 = r3 ? -1 : 1, l = e[t + c2];\n    for (c2 += U2, o = l & (1 << -f) - 1, l >>= -f, f += u2; f > 0; o = o * 256 + e[t + c2], c2 += U2, f -= 8)\n      ;\n    for (s = o & (1 << -f) - 1, o >>= -f, f += n; f > 0; s = s * 256 + e[t + c2], c2 += U2, f -= 8)\n      ;\n    if (o === 0)\n      o = 1 - p;\n    else {\n      if (o === h2)\n        return s ? NaN : (l ? -1 : 1) * (1 / 0);\n      s = s + Math.pow(2, n), o = o - p;\n    }\n    return (l ? -1 : 1) * s * Math.pow(2, o - n);\n  };\n  mt2.write = function(e, t, r3, n, i, o) {\n    var s, u2, h2, p = o * 8 - i - 1, f = (1 << p) - 1, c2 = f >> 1, U2 = i === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, l = n ? 0 : o - 1, R2 = n ? 1 : -1, G2 = t < 0 || t === 0 && 1 / t < 0 ? 1 : 0;\n    for (t = Math.abs(t), isNaN(t) || t === 1 / 0 ? (u2 = isNaN(t) ? 1 : 0, s = f) : (s = Math.floor(Math.log(t) / Math.LN2), t * (h2 = Math.pow(2, -s)) < 1 && (s--, h2 *= 2), s + c2 >= 1 ? t += U2 / h2 : t += U2 * Math.pow(2, 1 - c2), t * h2 >= 2 && (s++, h2 /= 2), s + c2 >= f ? (u2 = 0, s = f) : s + c2 >= 1 ? (u2 = (t * h2 - 1) * Math.pow(2, i), s = s + c2) : (u2 = t * Math.pow(2, c2 - 1) * Math.pow(2, i), s = 0)); i >= 8; e[r3 + l] = u2 & 255, l += R2, u2 /= 256, i -= 8)\n      ;\n    for (s = s << i | u2, p += i; p > 0; e[r3 + l] = s & 255, l += R2, s /= 256, p -= 8)\n      ;\n    e[r3 + l - R2] |= G2 * 128;\n  };\n});\nvar nt2 = T3((q2) => {\n  \"use strict\";\n  var Bt2 = ct2(), H2 = zt(), Jt2 = typeof Symbol == \"function\" && typeof Symbol.for == \"function\" ? Symbol.for(\"nodejs.util.inspect.custom\") : null;\n  q2.Buffer = a;\n  q2.SlowBuffer = Vr;\n  q2.INSPECT_MAX_BYTES = 50;\n  var rt2 = 2147483647;\n  q2.kMaxLength = rt2;\n  a.TYPED_ARRAY_SUPPORT = qr();\n  !a.TYPED_ARRAY_SUPPORT && typeof console < \"u\" && typeof console.error == \"function\" && console.error(\"This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.\");\n  function qr() {\n    try {\n      let e = new Uint8Array(1), t = { foo: function() {\n        return 42;\n      } };\n      return Object.setPrototypeOf(t, Uint8Array.prototype), Object.setPrototypeOf(e, t), e.foo() === 42;\n    } catch {\n      return false;\n    }\n  }\n  Object.defineProperty(a.prototype, \"parent\", { enumerable: true, get: function() {\n    if (a.isBuffer(this))\n      return this.buffer;\n  } });\n  Object.defineProperty(a.prototype, \"offset\", { enumerable: true, get: function() {\n    if (a.isBuffer(this))\n      return this.byteOffset;\n  } });\n  function S(e) {\n    if (e > rt2)\n      throw new RangeError('The value \"' + e + '\" is invalid for option \"size\"');\n    let t = new Uint8Array(e);\n    return Object.setPrototypeOf(t, a.prototype), t;\n  }\n  function a(e, t, r3) {\n    if (typeof e == \"number\") {\n      if (typeof t == \"string\")\n        throw new TypeError('The \"string\" argument must be of type string. Received type number');\n      return Tt2(e);\n    }\n    return tr2(e, t, r3);\n  }\n  a.poolSize = 8192;\n  function tr2(e, t, r3) {\n    if (typeof e == \"string\")\n      return Yr(e, t);\n    if (ArrayBuffer.isView(e))\n      return vr(e);\n    if (e == null)\n      throw new TypeError(\"The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type \" + typeof e);\n    if (A(e, ArrayBuffer) || e && A(e.buffer, ArrayBuffer) || typeof SharedArrayBuffer < \"u\" && (A(e, SharedArrayBuffer) || e && A(e.buffer, SharedArrayBuffer)))\n      return bt2(e, t, r3);\n    if (typeof e == \"number\")\n      throw new TypeError('The \"value\" argument must not be of type number. Received type number');\n    let n = e.valueOf && e.valueOf();\n    if (n != null && n !== e)\n      return a.from(n, t, r3);\n    let i = Wr(e);\n    if (i)\n      return i;\n    if (typeof Symbol < \"u\" && Symbol.toPrimitive != null && typeof e[Symbol.toPrimitive] == \"function\")\n      return a.from(e[Symbol.toPrimitive](\"string\"), t, r3);\n    throw new TypeError(\"The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type \" + typeof e);\n  }\n  a.from = function(e, t, r3) {\n    return tr2(e, t, r3);\n  };\n  Object.setPrototypeOf(a.prototype, Uint8Array.prototype);\n  Object.setPrototypeOf(a, Uint8Array);\n  function rr2(e) {\n    if (typeof e != \"number\")\n      throw new TypeError('\"size\" argument must be of type number');\n    if (e < 0)\n      throw new RangeError('The value \"' + e + '\" is invalid for option \"size\"');\n  }\n  function Gr(e, t, r3) {\n    return rr2(e), e <= 0 ? S(e) : t !== void 0 ? typeof r3 == \"string\" ? S(e).fill(t, r3) : S(e).fill(t) : S(e);\n  }\n  a.alloc = function(e, t, r3) {\n    return Gr(e, t, r3);\n  };\n  function Tt2(e) {\n    return rr2(e), S(e < 0 ? 0 : It2(e) | 0);\n  }\n  a.allocUnsafe = function(e) {\n    return Tt2(e);\n  };\n  a.allocUnsafeSlow = function(e) {\n    return Tt2(e);\n  };\n  function Yr(e, t) {\n    if ((typeof t != \"string\" || t === \"\") && (t = \"utf8\"), !a.isEncoding(t))\n      throw new TypeError(\"Unknown encoding: \" + t);\n    let r3 = er2(e, t) | 0, n = S(r3), i = n.write(e, t);\n    return i !== r3 && (n = n.slice(0, i)), n;\n  }\n  function Et2(e) {\n    let t = e.length < 0 ? 0 : It2(e.length) | 0, r3 = S(t);\n    for (let n = 0; n < t; n += 1)\n      r3[n] = e[n] & 255;\n    return r3;\n  }\n  function vr(e) {\n    if (A(e, Uint8Array)) {\n      let t = new Uint8Array(e);\n      return bt2(t.buffer, t.byteOffset, t.byteLength);\n    }\n    return Et2(e);\n  }\n  function bt2(e, t, r3) {\n    if (t < 0 || e.byteLength < t)\n      throw new RangeError('\"offset\" is outside of buffer bounds');\n    if (e.byteLength < t + (r3 || 0))\n      throw new RangeError('\"length\" is outside of buffer bounds');\n    let n;\n    return t === void 0 && r3 === void 0 ? n = new Uint8Array(e) : r3 === void 0 ? n = new Uint8Array(e, t) : n = new Uint8Array(e, t, r3), Object.setPrototypeOf(n, a.prototype), n;\n  }\n  function Wr(e) {\n    if (a.isBuffer(e)) {\n      let t = It2(e.length) | 0, r3 = S(t);\n      return r3.length === 0 || e.copy(r3, 0, 0, t), r3;\n    }\n    if (e.length !== void 0)\n      return typeof e.length != \"number\" || Ut2(e.length) ? S(0) : Et2(e);\n    if (e.type === \"Buffer\" && Array.isArray(e.data))\n      return Et2(e.data);\n  }\n  function It2(e) {\n    if (e >= rt2)\n      throw new RangeError(\"Attempt to allocate Buffer larger than maximum size: 0x\" + rt2.toString(16) + \" bytes\");\n    return e | 0;\n  }\n  function Vr(e) {\n    return +e != e && (e = 0), a.alloc(+e);\n  }\n  a.isBuffer = function(t) {\n    return t != null && t._isBuffer === true && t !== a.prototype;\n  };\n  a.compare = function(t, r3) {\n    if (A(t, Uint8Array) && (t = a.from(t, t.offset, t.byteLength)), A(r3, Uint8Array) && (r3 = a.from(r3, r3.offset, r3.byteLength)), !a.isBuffer(t) || !a.isBuffer(r3))\n      throw new TypeError('The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array');\n    if (t === r3)\n      return 0;\n    let n = t.length, i = r3.length;\n    for (let o = 0, s = Math.min(n, i); o < s; ++o)\n      if (t[o] !== r3[o]) {\n        n = t[o], i = r3[o];\n        break;\n      }\n    return n < i ? -1 : i < n ? 1 : 0;\n  };\n  a.isEncoding = function(t) {\n    switch (String(t).toLowerCase()) {\n      case \"hex\":\n      case \"utf8\":\n      case \"utf-8\":\n      case \"ascii\":\n      case \"latin1\":\n      case \"binary\":\n      case \"base64\":\n      case \"ucs2\":\n      case \"ucs-2\":\n      case \"utf16le\":\n      case \"utf-16le\":\n        return true;\n      default:\n        return false;\n    }\n  };\n  a.concat = function(t, r3) {\n    if (!Array.isArray(t))\n      throw new TypeError('\"list\" argument must be an Array of Buffers');\n    if (t.length === 0)\n      return a.alloc(0);\n    let n;\n    if (r3 === void 0)\n      for (r3 = 0, n = 0; n < t.length; ++n)\n        r3 += t[n].length;\n    let i = a.allocUnsafe(r3), o = 0;\n    for (n = 0; n < t.length; ++n) {\n      let s = t[n];\n      if (A(s, Uint8Array))\n        o + s.length > i.length ? (a.isBuffer(s) || (s = a.from(s)), s.copy(i, o)) : Uint8Array.prototype.set.call(i, s, o);\n      else if (a.isBuffer(s))\n        s.copy(i, o);\n      else\n        throw new TypeError('\"list\" argument must be an Array of Buffers');\n      o += s.length;\n    }\n    return i;\n  };\n  function er2(e, t) {\n    if (a.isBuffer(e))\n      return e.length;\n    if (ArrayBuffer.isView(e) || A(e, ArrayBuffer))\n      return e.byteLength;\n    if (typeof e != \"string\")\n      throw new TypeError('The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof e);\n    let r3 = e.length, n = arguments.length > 2 && arguments[2] === true;\n    if (!n && r3 === 0)\n      return 0;\n    let i = false;\n    for (; ; )\n      switch (t) {\n        case \"ascii\":\n        case \"latin1\":\n        case \"binary\":\n          return r3;\n        case \"utf8\":\n        case \"utf-8\":\n          return At2(e).length;\n        case \"ucs2\":\n        case \"ucs-2\":\n        case \"utf16le\":\n        case \"utf-16le\":\n          return r3 * 2;\n        case \"hex\":\n          return r3 >>> 1;\n        case \"base64\":\n          return cr2(e).length;\n        default:\n          if (i)\n            return n ? -1 : At2(e).length;\n          t = (\"\" + t).toLowerCase(), i = true;\n      }\n  }\n  a.byteLength = er2;\n  function zr(e, t, r3) {\n    let n = false;\n    if ((t === void 0 || t < 0) && (t = 0), t > this.length || ((r3 === void 0 || r3 > this.length) && (r3 = this.length), r3 <= 0) || (r3 >>>= 0, t >>>= 0, r3 <= t))\n      return \"\";\n    for (e || (e = \"utf8\"); ; )\n      switch (e) {\n        case \"hex\":\n          return oe2(this, t, r3);\n        case \"utf8\":\n        case \"utf-8\":\n          return ir2(this, t, r3);\n        case \"ascii\":\n          return ne2(this, t, r3);\n        case \"latin1\":\n        case \"binary\":\n          return ie2(this, t, r3);\n        case \"base64\":\n          return re2(this, t, r3);\n        case \"ucs2\":\n        case \"ucs-2\":\n        case \"utf16le\":\n        case \"utf-16le\":\n          return se2(this, t, r3);\n        default:\n          if (n)\n            throw new TypeError(\"Unknown encoding: \" + e);\n          e = (e + \"\").toLowerCase(), n = true;\n      }\n  }\n  a.prototype._isBuffer = true;\n  function k2(e, t, r3) {\n    let n = e[t];\n    e[t] = e[r3], e[r3] = n;\n  }\n  a.prototype.swap16 = function() {\n    let t = this.length;\n    if (t % 2 !== 0)\n      throw new RangeError(\"Buffer size must be a multiple of 16-bits\");\n    for (let r3 = 0; r3 < t; r3 += 2)\n      k2(this, r3, r3 + 1);\n    return this;\n  };\n  a.prototype.swap32 = function() {\n    let t = this.length;\n    if (t % 4 !== 0)\n      throw new RangeError(\"Buffer size must be a multiple of 32-bits\");\n    for (let r3 = 0; r3 < t; r3 += 4)\n      k2(this, r3, r3 + 3), k2(this, r3 + 1, r3 + 2);\n    return this;\n  };\n  a.prototype.swap64 = function() {\n    let t = this.length;\n    if (t % 8 !== 0)\n      throw new RangeError(\"Buffer size must be a multiple of 64-bits\");\n    for (let r3 = 0; r3 < t; r3 += 8)\n      k2(this, r3, r3 + 7), k2(this, r3 + 1, r3 + 6), k2(this, r3 + 2, r3 + 5), k2(this, r3 + 3, r3 + 4);\n    return this;\n  };\n  a.prototype.toString = function() {\n    let t = this.length;\n    return t === 0 ? \"\" : arguments.length === 0 ? ir2(this, 0, t) : zr.apply(this, arguments);\n  };\n  a.prototype.toLocaleString = a.prototype.toString;\n  a.prototype.equals = function(t) {\n    if (!a.isBuffer(t))\n      throw new TypeError(\"Argument must be a Buffer\");\n    return this === t ? true : a.compare(this, t) === 0;\n  };\n  a.prototype.inspect = function() {\n    let t = \"\", r3 = q2.INSPECT_MAX_BYTES;\n    return t = this.toString(\"hex\", 0, r3).replace(/(.{2})/g, \"$1 \").trim(), this.length > r3 && (t += \" ... \"), \"<Buffer \" + t + \">\";\n  };\n  Jt2 && (a.prototype[Jt2] = a.prototype.inspect);\n  a.prototype.compare = function(t, r3, n, i, o) {\n    if (A(t, Uint8Array) && (t = a.from(t, t.offset, t.byteLength)), !a.isBuffer(t))\n      throw new TypeError('The \"target\" argument must be one of type Buffer or Uint8Array. Received type ' + typeof t);\n    if (r3 === void 0 && (r3 = 0), n === void 0 && (n = t ? t.length : 0), i === void 0 && (i = 0), o === void 0 && (o = this.length), r3 < 0 || n > t.length || i < 0 || o > this.length)\n      throw new RangeError(\"out of range index\");\n    if (i >= o && r3 >= n)\n      return 0;\n    if (i >= o)\n      return -1;\n    if (r3 >= n)\n      return 1;\n    if (r3 >>>= 0, n >>>= 0, i >>>= 0, o >>>= 0, this === t)\n      return 0;\n    let s = o - i, u2 = n - r3, h2 = Math.min(s, u2), p = this.slice(i, o), f = t.slice(r3, n);\n    for (let c2 = 0; c2 < h2; ++c2)\n      if (p[c2] !== f[c2]) {\n        s = p[c2], u2 = f[c2];\n        break;\n      }\n    return s < u2 ? -1 : u2 < s ? 1 : 0;\n  };\n  function nr2(e, t, r3, n, i) {\n    if (e.length === 0)\n      return -1;\n    if (typeof r3 == \"string\" ? (n = r3, r3 = 0) : r3 > 2147483647 ? r3 = 2147483647 : r3 < -2147483648 && (r3 = -2147483648), r3 = +r3, Ut2(r3) && (r3 = i ? 0 : e.length - 1), r3 < 0 && (r3 = e.length + r3), r3 >= e.length) {\n      if (i)\n        return -1;\n      r3 = e.length - 1;\n    } else if (r3 < 0)\n      if (i)\n        r3 = 0;\n      else\n        return -1;\n    if (typeof t == \"string\" && (t = a.from(t, n)), a.isBuffer(t))\n      return t.length === 0 ? -1 : Xt2(e, t, r3, n, i);\n    if (typeof t == \"number\")\n      return t = t & 255, typeof Uint8Array.prototype.indexOf == \"function\" ? i ? Uint8Array.prototype.indexOf.call(e, t, r3) : Uint8Array.prototype.lastIndexOf.call(e, t, r3) : Xt2(e, [t], r3, n, i);\n    throw new TypeError(\"val must be string, number or Buffer\");\n  }\n  function Xt2(e, t, r3, n, i) {\n    let o = 1, s = e.length, u2 = t.length;\n    if (n !== void 0 && (n = String(n).toLowerCase(), n === \"ucs2\" || n === \"ucs-2\" || n === \"utf16le\" || n === \"utf-16le\")) {\n      if (e.length < 2 || t.length < 2)\n        return -1;\n      o = 2, s /= 2, u2 /= 2, r3 /= 2;\n    }\n    function h2(f, c2) {\n      return o === 1 ? f[c2] : f.readUInt16BE(c2 * o);\n    }\n    let p;\n    if (i) {\n      let f = -1;\n      for (p = r3; p < s; p++)\n        if (h2(e, p) === h2(t, f === -1 ? 0 : p - f)) {\n          if (f === -1 && (f = p), p - f + 1 === u2)\n            return f * o;\n        } else\n          f !== -1 && (p -= p - f), f = -1;\n    } else\n      for (r3 + u2 > s && (r3 = s - u2), p = r3; p >= 0; p--) {\n        let f = true;\n        for (let c2 = 0; c2 < u2; c2++)\n          if (h2(e, p + c2) !== h2(t, c2)) {\n            f = false;\n            break;\n          }\n        if (f)\n          return p;\n      }\n    return -1;\n  }\n  a.prototype.includes = function(t, r3, n) {\n    return this.indexOf(t, r3, n) !== -1;\n  };\n  a.prototype.indexOf = function(t, r3, n) {\n    return nr2(this, t, r3, n, true);\n  };\n  a.prototype.lastIndexOf = function(t, r3, n) {\n    return nr2(this, t, r3, n, false);\n  };\n  function Jr(e, t, r3, n) {\n    r3 = Number(r3) || 0;\n    let i = e.length - r3;\n    n ? (n = Number(n), n > i && (n = i)) : n = i;\n    let o = t.length;\n    n > o / 2 && (n = o / 2);\n    let s;\n    for (s = 0; s < n; ++s) {\n      let u2 = parseInt(t.substr(s * 2, 2), 16);\n      if (Ut2(u2))\n        return s;\n      e[r3 + s] = u2;\n    }\n    return s;\n  }\n  function Xr(e, t, r3, n) {\n    return et2(At2(t, e.length - r3), e, r3, n);\n  }\n  function Zr(e, t, r3, n) {\n    return et2(fe2(t), e, r3, n);\n  }\n  function Qr(e, t, r3, n) {\n    return et2(cr2(t), e, r3, n);\n  }\n  function te2(e, t, r3, n) {\n    return et2(ce2(t, e.length - r3), e, r3, n);\n  }\n  a.prototype.write = function(t, r3, n, i) {\n    if (r3 === void 0)\n      i = \"utf8\", n = this.length, r3 = 0;\n    else if (n === void 0 && typeof r3 == \"string\")\n      i = r3, n = this.length, r3 = 0;\n    else if (isFinite(r3))\n      r3 = r3 >>> 0, isFinite(n) ? (n = n >>> 0, i === void 0 && (i = \"utf8\")) : (i = n, n = void 0);\n    else\n      throw new Error(\"Buffer.write(string, encoding, offset[, length]) is no longer supported\");\n    let o = this.length - r3;\n    if ((n === void 0 || n > o) && (n = o), t.length > 0 && (n < 0 || r3 < 0) || r3 > this.length)\n      throw new RangeError(\"Attempt to write outside buffer bounds\");\n    i || (i = \"utf8\");\n    let s = false;\n    for (; ; )\n      switch (i) {\n        case \"hex\":\n          return Jr(this, t, r3, n);\n        case \"utf8\":\n        case \"utf-8\":\n          return Xr(this, t, r3, n);\n        case \"ascii\":\n        case \"latin1\":\n        case \"binary\":\n          return Zr(this, t, r3, n);\n        case \"base64\":\n          return Qr(this, t, r3, n);\n        case \"ucs2\":\n        case \"ucs-2\":\n        case \"utf16le\":\n        case \"utf-16le\":\n          return te2(this, t, r3, n);\n        default:\n          if (s)\n            throw new TypeError(\"Unknown encoding: \" + i);\n          i = (\"\" + i).toLowerCase(), s = true;\n      }\n  };\n  a.prototype.toJSON = function() {\n    return { type: \"Buffer\", data: Array.prototype.slice.call(this._arr || this, 0) };\n  };\n  function re2(e, t, r3) {\n    return t === 0 && r3 === e.length ? Bt2.fromByteArray(e) : Bt2.fromByteArray(e.slice(t, r3));\n  }\n  function ir2(e, t, r3) {\n    r3 = Math.min(e.length, r3);\n    let n = [], i = t;\n    for (; i < r3; ) {\n      let o = e[i], s = null, u2 = o > 239 ? 4 : o > 223 ? 3 : o > 191 ? 2 : 1;\n      if (i + u2 <= r3) {\n        let h2, p, f, c2;\n        switch (u2) {\n          case 1:\n            o < 128 && (s = o);\n            break;\n          case 2:\n            h2 = e[i + 1], (h2 & 192) === 128 && (c2 = (o & 31) << 6 | h2 & 63, c2 > 127 && (s = c2));\n            break;\n          case 3:\n            h2 = e[i + 1], p = e[i + 2], (h2 & 192) === 128 && (p & 192) === 128 && (c2 = (o & 15) << 12 | (h2 & 63) << 6 | p & 63, c2 > 2047 && (c2 < 55296 || c2 > 57343) && (s = c2));\n            break;\n          case 4:\n            h2 = e[i + 1], p = e[i + 2], f = e[i + 3], (h2 & 192) === 128 && (p & 192) === 128 && (f & 192) === 128 && (c2 = (o & 15) << 18 | (h2 & 63) << 12 | (p & 63) << 6 | f & 63, c2 > 65535 && c2 < 1114112 && (s = c2));\n        }\n      }\n      s === null ? (s = 65533, u2 = 1) : s > 65535 && (s -= 65536, n.push(s >>> 10 & 1023 | 55296), s = 56320 | s & 1023), n.push(s), i += u2;\n    }\n    return ee2(n);\n  }\n  var Zt2 = 4096;\n  function ee2(e) {\n    let t = e.length;\n    if (t <= Zt2)\n      return String.fromCharCode.apply(String, e);\n    let r3 = \"\", n = 0;\n    for (; n < t; )\n      r3 += String.fromCharCode.apply(String, e.slice(n, n += Zt2));\n    return r3;\n  }\n  function ne2(e, t, r3) {\n    let n = \"\";\n    r3 = Math.min(e.length, r3);\n    for (let i = t; i < r3; ++i)\n      n += String.fromCharCode(e[i] & 127);\n    return n;\n  }\n  function ie2(e, t, r3) {\n    let n = \"\";\n    r3 = Math.min(e.length, r3);\n    for (let i = t; i < r3; ++i)\n      n += String.fromCharCode(e[i]);\n    return n;\n  }\n  function oe2(e, t, r3) {\n    let n = e.length;\n    (!t || t < 0) && (t = 0), (!r3 || r3 < 0 || r3 > n) && (r3 = n);\n    let i = \"\";\n    for (let o = t; o < r3; ++o)\n      i += pe2[e[o]];\n    return i;\n  }\n  function se2(e, t, r3) {\n    let n = e.slice(t, r3), i = \"\";\n    for (let o = 0; o < n.length - 1; o += 2)\n      i += String.fromCharCode(n[o] + n[o + 1] * 256);\n    return i;\n  }\n  a.prototype.slice = function(t, r3) {\n    let n = this.length;\n    t = ~~t, r3 = r3 === void 0 ? n : ~~r3, t < 0 ? (t += n, t < 0 && (t = 0)) : t > n && (t = n), r3 < 0 ? (r3 += n, r3 < 0 && (r3 = 0)) : r3 > n && (r3 = n), r3 < t && (r3 = t);\n    let i = this.subarray(t, r3);\n    return Object.setPrototypeOf(i, a.prototype), i;\n  };\n  function y(e, t, r3) {\n    if (e % 1 !== 0 || e < 0)\n      throw new RangeError(\"offset is not uint\");\n    if (e + t > r3)\n      throw new RangeError(\"Trying to access beyond buffer length\");\n  }\n  a.prototype.readUintLE = a.prototype.readUIntLE = function(t, r3, n) {\n    t = t >>> 0, r3 = r3 >>> 0, n || y(t, r3, this.length);\n    let i = this[t], o = 1, s = 0;\n    for (; ++s < r3 && (o *= 256); )\n      i += this[t + s] * o;\n    return i;\n  };\n  a.prototype.readUintBE = a.prototype.readUIntBE = function(t, r3, n) {\n    t = t >>> 0, r3 = r3 >>> 0, n || y(t, r3, this.length);\n    let i = this[t + --r3], o = 1;\n    for (; r3 > 0 && (o *= 256); )\n      i += this[t + --r3] * o;\n    return i;\n  };\n  a.prototype.readUint8 = a.prototype.readUInt8 = function(t, r3) {\n    return t = t >>> 0, r3 || y(t, 1, this.length), this[t];\n  };\n  a.prototype.readUint16LE = a.prototype.readUInt16LE = function(t, r3) {\n    return t = t >>> 0, r3 || y(t, 2, this.length), this[t] | this[t + 1] << 8;\n  };\n  a.prototype.readUint16BE = a.prototype.readUInt16BE = function(t, r3) {\n    return t = t >>> 0, r3 || y(t, 2, this.length), this[t] << 8 | this[t + 1];\n  };\n  a.prototype.readUint32LE = a.prototype.readUInt32LE = function(t, r3) {\n    return t = t >>> 0, r3 || y(t, 4, this.length), (this[t] | this[t + 1] << 8 | this[t + 2] << 16) + this[t + 3] * 16777216;\n  };\n  a.prototype.readUint32BE = a.prototype.readUInt32BE = function(t, r3) {\n    return t = t >>> 0, r3 || y(t, 4, this.length), this[t] * 16777216 + (this[t + 1] << 16 | this[t + 2] << 8 | this[t + 3]);\n  };\n  a.prototype.readBigUInt64LE = L(function(t) {\n    t = t >>> 0, j2(t, \"offset\");\n    let r3 = this[t], n = this[t + 7];\n    (r3 === void 0 || n === void 0) && W(t, this.length - 8);\n    let i = r3 + this[++t] * 2 ** 8 + this[++t] * 2 ** 16 + this[++t] * 2 ** 24, o = this[++t] + this[++t] * 2 ** 8 + this[++t] * 2 ** 16 + n * 2 ** 24;\n    return BigInt(i) + (BigInt(o) << BigInt(32));\n  });\n  a.prototype.readBigUInt64BE = L(function(t) {\n    t = t >>> 0, j2(t, \"offset\");\n    let r3 = this[t], n = this[t + 7];\n    (r3 === void 0 || n === void 0) && W(t, this.length - 8);\n    let i = r3 * 2 ** 24 + this[++t] * 2 ** 16 + this[++t] * 2 ** 8 + this[++t], o = this[++t] * 2 ** 24 + this[++t] * 2 ** 16 + this[++t] * 2 ** 8 + n;\n    return (BigInt(i) << BigInt(32)) + BigInt(o);\n  });\n  a.prototype.readIntLE = function(t, r3, n) {\n    t = t >>> 0, r3 = r3 >>> 0, n || y(t, r3, this.length);\n    let i = this[t], o = 1, s = 0;\n    for (; ++s < r3 && (o *= 256); )\n      i += this[t + s] * o;\n    return o *= 128, i >= o && (i -= Math.pow(2, 8 * r3)), i;\n  };\n  a.prototype.readIntBE = function(t, r3, n) {\n    t = t >>> 0, r3 = r3 >>> 0, n || y(t, r3, this.length);\n    let i = r3, o = 1, s = this[t + --i];\n    for (; i > 0 && (o *= 256); )\n      s += this[t + --i] * o;\n    return o *= 128, s >= o && (s -= Math.pow(2, 8 * r3)), s;\n  };\n  a.prototype.readInt8 = function(t, r3) {\n    return t = t >>> 0, r3 || y(t, 1, this.length), this[t] & 128 ? (255 - this[t] + 1) * -1 : this[t];\n  };\n  a.prototype.readInt16LE = function(t, r3) {\n    t = t >>> 0, r3 || y(t, 2, this.length);\n    let n = this[t] | this[t + 1] << 8;\n    return n & 32768 ? n | 4294901760 : n;\n  };\n  a.prototype.readInt16BE = function(t, r3) {\n    t = t >>> 0, r3 || y(t, 2, this.length);\n    let n = this[t + 1] | this[t] << 8;\n    return n & 32768 ? n | 4294901760 : n;\n  };\n  a.prototype.readInt32LE = function(t, r3) {\n    return t = t >>> 0, r3 || y(t, 4, this.length), this[t] | this[t + 1] << 8 | this[t + 2] << 16 | this[t + 3] << 24;\n  };\n  a.prototype.readInt32BE = function(t, r3) {\n    return t = t >>> 0, r3 || y(t, 4, this.length), this[t] << 24 | this[t + 1] << 16 | this[t + 2] << 8 | this[t + 3];\n  };\n  a.prototype.readBigInt64LE = L(function(t) {\n    t = t >>> 0, j2(t, \"offset\");\n    let r3 = this[t], n = this[t + 7];\n    (r3 === void 0 || n === void 0) && W(t, this.length - 8);\n    let i = this[t + 4] + this[t + 5] * 2 ** 8 + this[t + 6] * 2 ** 16 + (n << 24);\n    return (BigInt(i) << BigInt(32)) + BigInt(r3 + this[++t] * 2 ** 8 + this[++t] * 2 ** 16 + this[++t] * 2 ** 24);\n  });\n  a.prototype.readBigInt64BE = L(function(t) {\n    t = t >>> 0, j2(t, \"offset\");\n    let r3 = this[t], n = this[t + 7];\n    (r3 === void 0 || n === void 0) && W(t, this.length - 8);\n    let i = (r3 << 24) + this[++t] * 2 ** 16 + this[++t] * 2 ** 8 + this[++t];\n    return (BigInt(i) << BigInt(32)) + BigInt(this[++t] * 2 ** 24 + this[++t] * 2 ** 16 + this[++t] * 2 ** 8 + n);\n  });\n  a.prototype.readFloatLE = function(t, r3) {\n    return t = t >>> 0, r3 || y(t, 4, this.length), H2.read(this, t, true, 23, 4);\n  };\n  a.prototype.readFloatBE = function(t, r3) {\n    return t = t >>> 0, r3 || y(t, 4, this.length), H2.read(this, t, false, 23, 4);\n  };\n  a.prototype.readDoubleLE = function(t, r3) {\n    return t = t >>> 0, r3 || y(t, 8, this.length), H2.read(this, t, true, 52, 8);\n  };\n  a.prototype.readDoubleBE = function(t, r3) {\n    return t = t >>> 0, r3 || y(t, 8, this.length), H2.read(this, t, false, 52, 8);\n  };\n  function d(e, t, r3, n, i, o) {\n    if (!a.isBuffer(e))\n      throw new TypeError('\"buffer\" argument must be a Buffer instance');\n    if (t > i || t < o)\n      throw new RangeError('\"value\" argument is out of bounds');\n    if (r3 + n > e.length)\n      throw new RangeError(\"Index out of range\");\n  }\n  a.prototype.writeUintLE = a.prototype.writeUIntLE = function(t, r3, n, i) {\n    if (t = +t, r3 = r3 >>> 0, n = n >>> 0, !i) {\n      let u2 = Math.pow(2, 8 * n) - 1;\n      d(this, t, r3, n, u2, 0);\n    }\n    let o = 1, s = 0;\n    for (this[r3] = t & 255; ++s < n && (o *= 256); )\n      this[r3 + s] = t / o & 255;\n    return r3 + n;\n  };\n  a.prototype.writeUintBE = a.prototype.writeUIntBE = function(t, r3, n, i) {\n    if (t = +t, r3 = r3 >>> 0, n = n >>> 0, !i) {\n      let u2 = Math.pow(2, 8 * n) - 1;\n      d(this, t, r3, n, u2, 0);\n    }\n    let o = n - 1, s = 1;\n    for (this[r3 + o] = t & 255; --o >= 0 && (s *= 256); )\n      this[r3 + o] = t / s & 255;\n    return r3 + n;\n  };\n  a.prototype.writeUint8 = a.prototype.writeUInt8 = function(t, r3, n) {\n    return t = +t, r3 = r3 >>> 0, n || d(this, t, r3, 1, 255, 0), this[r3] = t & 255, r3 + 1;\n  };\n  a.prototype.writeUint16LE = a.prototype.writeUInt16LE = function(t, r3, n) {\n    return t = +t, r3 = r3 >>> 0, n || d(this, t, r3, 2, 65535, 0), this[r3] = t & 255, this[r3 + 1] = t >>> 8, r3 + 2;\n  };\n  a.prototype.writeUint16BE = a.prototype.writeUInt16BE = function(t, r3, n) {\n    return t = +t, r3 = r3 >>> 0, n || d(this, t, r3, 2, 65535, 0), this[r3] = t >>> 8, this[r3 + 1] = t & 255, r3 + 2;\n  };\n  a.prototype.writeUint32LE = a.prototype.writeUInt32LE = function(t, r3, n) {\n    return t = +t, r3 = r3 >>> 0, n || d(this, t, r3, 4, 4294967295, 0), this[r3 + 3] = t >>> 24, this[r3 + 2] = t >>> 16, this[r3 + 1] = t >>> 8, this[r3] = t & 255, r3 + 4;\n  };\n  a.prototype.writeUint32BE = a.prototype.writeUInt32BE = function(t, r3, n) {\n    return t = +t, r3 = r3 >>> 0, n || d(this, t, r3, 4, 4294967295, 0), this[r3] = t >>> 24, this[r3 + 1] = t >>> 16, this[r3 + 2] = t >>> 8, this[r3 + 3] = t & 255, r3 + 4;\n  };\n  function or2(e, t, r3, n, i) {\n    fr(t, n, i, e, r3, 7);\n    let o = Number(t & BigInt(4294967295));\n    e[r3++] = o, o = o >> 8, e[r3++] = o, o = o >> 8, e[r3++] = o, o = o >> 8, e[r3++] = o;\n    let s = Number(t >> BigInt(32) & BigInt(4294967295));\n    return e[r3++] = s, s = s >> 8, e[r3++] = s, s = s >> 8, e[r3++] = s, s = s >> 8, e[r3++] = s, r3;\n  }\n  function sr2(e, t, r3, n, i) {\n    fr(t, n, i, e, r3, 7);\n    let o = Number(t & BigInt(4294967295));\n    e[r3 + 7] = o, o = o >> 8, e[r3 + 6] = o, o = o >> 8, e[r3 + 5] = o, o = o >> 8, e[r3 + 4] = o;\n    let s = Number(t >> BigInt(32) & BigInt(4294967295));\n    return e[r3 + 3] = s, s = s >> 8, e[r3 + 2] = s, s = s >> 8, e[r3 + 1] = s, s = s >> 8, e[r3] = s, r3 + 8;\n  }\n  a.prototype.writeBigUInt64LE = L(function(t, r3 = 0) {\n    return or2(this, t, r3, BigInt(0), BigInt(\"0xffffffffffffffff\"));\n  });\n  a.prototype.writeBigUInt64BE = L(function(t, r3 = 0) {\n    return sr2(this, t, r3, BigInt(0), BigInt(\"0xffffffffffffffff\"));\n  });\n  a.prototype.writeIntLE = function(t, r3, n, i) {\n    if (t = +t, r3 = r3 >>> 0, !i) {\n      let h2 = Math.pow(2, 8 * n - 1);\n      d(this, t, r3, n, h2 - 1, -h2);\n    }\n    let o = 0, s = 1, u2 = 0;\n    for (this[r3] = t & 255; ++o < n && (s *= 256); )\n      t < 0 && u2 === 0 && this[r3 + o - 1] !== 0 && (u2 = 1), this[r3 + o] = (t / s >> 0) - u2 & 255;\n    return r3 + n;\n  };\n  a.prototype.writeIntBE = function(t, r3, n, i) {\n    if (t = +t, r3 = r3 >>> 0, !i) {\n      let h2 = Math.pow(2, 8 * n - 1);\n      d(this, t, r3, n, h2 - 1, -h2);\n    }\n    let o = n - 1, s = 1, u2 = 0;\n    for (this[r3 + o] = t & 255; --o >= 0 && (s *= 256); )\n      t < 0 && u2 === 0 && this[r3 + o + 1] !== 0 && (u2 = 1), this[r3 + o] = (t / s >> 0) - u2 & 255;\n    return r3 + n;\n  };\n  a.prototype.writeInt8 = function(t, r3, n) {\n    return t = +t, r3 = r3 >>> 0, n || d(this, t, r3, 1, 127, -128), t < 0 && (t = 255 + t + 1), this[r3] = t & 255, r3 + 1;\n  };\n  a.prototype.writeInt16LE = function(t, r3, n) {\n    return t = +t, r3 = r3 >>> 0, n || d(this, t, r3, 2, 32767, -32768), this[r3] = t & 255, this[r3 + 1] = t >>> 8, r3 + 2;\n  };\n  a.prototype.writeInt16BE = function(t, r3, n) {\n    return t = +t, r3 = r3 >>> 0, n || d(this, t, r3, 2, 32767, -32768), this[r3] = t >>> 8, this[r3 + 1] = t & 255, r3 + 2;\n  };\n  a.prototype.writeInt32LE = function(t, r3, n) {\n    return t = +t, r3 = r3 >>> 0, n || d(this, t, r3, 4, 2147483647, -2147483648), this[r3] = t & 255, this[r3 + 1] = t >>> 8, this[r3 + 2] = t >>> 16, this[r3 + 3] = t >>> 24, r3 + 4;\n  };\n  a.prototype.writeInt32BE = function(t, r3, n) {\n    return t = +t, r3 = r3 >>> 0, n || d(this, t, r3, 4, 2147483647, -2147483648), t < 0 && (t = 4294967295 + t + 1), this[r3] = t >>> 24, this[r3 + 1] = t >>> 16, this[r3 + 2] = t >>> 8, this[r3 + 3] = t & 255, r3 + 4;\n  };\n  a.prototype.writeBigInt64LE = L(function(t, r3 = 0) {\n    return or2(this, t, r3, -BigInt(\"0x8000000000000000\"), BigInt(\"0x7fffffffffffffff\"));\n  });\n  a.prototype.writeBigInt64BE = L(function(t, r3 = 0) {\n    return sr2(this, t, r3, -BigInt(\"0x8000000000000000\"), BigInt(\"0x7fffffffffffffff\"));\n  });\n  function ar(e, t, r3, n, i, o) {\n    if (r3 + n > e.length)\n      throw new RangeError(\"Index out of range\");\n    if (r3 < 0)\n      throw new RangeError(\"Index out of range\");\n  }\n  function ur(e, t, r3, n, i) {\n    return t = +t, r3 = r3 >>> 0, i || ar(e, t, r3, 4, 34028234663852886e22, -34028234663852886e22), H2.write(e, t, r3, n, 23, 4), r3 + 4;\n  }\n  a.prototype.writeFloatLE = function(t, r3, n) {\n    return ur(this, t, r3, true, n);\n  };\n  a.prototype.writeFloatBE = function(t, r3, n) {\n    return ur(this, t, r3, false, n);\n  };\n  function hr2(e, t, r3, n, i) {\n    return t = +t, r3 = r3 >>> 0, i || ar(e, t, r3, 8, 17976931348623157e292, -17976931348623157e292), H2.write(e, t, r3, n, 52, 8), r3 + 8;\n  }\n  a.prototype.writeDoubleLE = function(t, r3, n) {\n    return hr2(this, t, r3, true, n);\n  };\n  a.prototype.writeDoubleBE = function(t, r3, n) {\n    return hr2(this, t, r3, false, n);\n  };\n  a.prototype.copy = function(t, r3, n, i) {\n    if (!a.isBuffer(t))\n      throw new TypeError(\"argument should be a Buffer\");\n    if (n || (n = 0), !i && i !== 0 && (i = this.length), r3 >= t.length && (r3 = t.length), r3 || (r3 = 0), i > 0 && i < n && (i = n), i === n || t.length === 0 || this.length === 0)\n      return 0;\n    if (r3 < 0)\n      throw new RangeError(\"targetStart out of bounds\");\n    if (n < 0 || n >= this.length)\n      throw new RangeError(\"Index out of range\");\n    if (i < 0)\n      throw new RangeError(\"sourceEnd out of bounds\");\n    i > this.length && (i = this.length), t.length - r3 < i - n && (i = t.length - r3 + n);\n    let o = i - n;\n    return this === t && typeof Uint8Array.prototype.copyWithin == \"function\" ? this.copyWithin(r3, n, i) : Uint8Array.prototype.set.call(t, this.subarray(n, i), r3), o;\n  };\n  a.prototype.fill = function(t, r3, n, i) {\n    if (typeof t == \"string\") {\n      if (typeof r3 == \"string\" ? (i = r3, r3 = 0, n = this.length) : typeof n == \"string\" && (i = n, n = this.length), i !== void 0 && typeof i != \"string\")\n        throw new TypeError(\"encoding must be a string\");\n      if (typeof i == \"string\" && !a.isEncoding(i))\n        throw new TypeError(\"Unknown encoding: \" + i);\n      if (t.length === 1) {\n        let s = t.charCodeAt(0);\n        (i === \"utf8\" && s < 128 || i === \"latin1\") && (t = s);\n      }\n    } else\n      typeof t == \"number\" ? t = t & 255 : typeof t == \"boolean\" && (t = Number(t));\n    if (r3 < 0 || this.length < r3 || this.length < n)\n      throw new RangeError(\"Out of range index\");\n    if (n <= r3)\n      return this;\n    r3 = r3 >>> 0, n = n === void 0 ? this.length : n >>> 0, t || (t = 0);\n    let o;\n    if (typeof t == \"number\")\n      for (o = r3; o < n; ++o)\n        this[o] = t;\n    else {\n      let s = a.isBuffer(t) ? t : a.from(t, i), u2 = s.length;\n      if (u2 === 0)\n        throw new TypeError('The value \"' + t + '\" is invalid for argument \"value\"');\n      for (o = 0; o < n - r3; ++o)\n        this[o + r3] = s[o % u2];\n    }\n    return this;\n  };\n  var K2 = {};\n  function St2(e, t, r3) {\n    K2[e] = class extends r3 {\n      constructor() {\n        super(), Object.defineProperty(this, \"message\", { value: t.apply(this, arguments), writable: true, configurable: true }), this.name = `${this.name} [${e}]`, this.stack, delete this.name;\n      }\n      get code() {\n        return e;\n      }\n      set code(i) {\n        Object.defineProperty(this, \"code\", { configurable: true, enumerable: true, value: i, writable: true });\n      }\n      toString() {\n        return `${this.name} [${e}]: ${this.message}`;\n      }\n    };\n  }\n  St2(\"ERR_BUFFER_OUT_OF_BOUNDS\", function(e) {\n    return e ? `${e} is outside of buffer bounds` : \"Attempt to access memory outside buffer bounds\";\n  }, RangeError);\n  St2(\"ERR_INVALID_ARG_TYPE\", function(e, t) {\n    return `The \"${e}\" argument must be of type number. Received type ${typeof t}`;\n  }, TypeError);\n  St2(\"ERR_OUT_OF_RANGE\", function(e, t, r3) {\n    let n = `The value of \"${e}\" is out of range.`, i = r3;\n    return Number.isInteger(r3) && Math.abs(r3) > 2 ** 32 ? i = Qt2(String(r3)) : typeof r3 == \"bigint\" && (i = String(r3), (r3 > BigInt(2) ** BigInt(32) || r3 < -(BigInt(2) ** BigInt(32))) && (i = Qt2(i)), i += \"n\"), n += ` It must be ${t}. Received ${i}`, n;\n  }, RangeError);\n  function Qt2(e) {\n    let t = \"\", r3 = e.length, n = e[0] === \"-\" ? 1 : 0;\n    for (; r3 >= n + 4; r3 -= 3)\n      t = `_${e.slice(r3 - 3, r3)}${t}`;\n    return `${e.slice(0, r3)}${t}`;\n  }\n  function ae2(e, t, r3) {\n    j2(t, \"offset\"), (e[t] === void 0 || e[t + r3] === void 0) && W(t, e.length - (r3 + 1));\n  }\n  function fr(e, t, r3, n, i, o) {\n    if (e > r3 || e < t) {\n      let s = typeof t == \"bigint\" ? \"n\" : \"\", u2;\n      throw o > 3 ? t === 0 || t === BigInt(0) ? u2 = `>= 0${s} and < 2${s} ** ${(o + 1) * 8}${s}` : u2 = `>= -(2${s} ** ${(o + 1) * 8 - 1}${s}) and < 2 ** ${(o + 1) * 8 - 1}${s}` : u2 = `>= ${t}${s} and <= ${r3}${s}`, new K2.ERR_OUT_OF_RANGE(\"value\", u2, e);\n    }\n    ae2(n, i, o);\n  }\n  function j2(e, t) {\n    if (typeof e != \"number\")\n      throw new K2.ERR_INVALID_ARG_TYPE(t, \"number\", e);\n  }\n  function W(e, t, r3) {\n    throw Math.floor(e) !== e ? (j2(e, r3), new K2.ERR_OUT_OF_RANGE(r3 || \"offset\", \"an integer\", e)) : t < 0 ? new K2.ERR_BUFFER_OUT_OF_BOUNDS() : new K2.ERR_OUT_OF_RANGE(r3 || \"offset\", `>= ${r3 ? 1 : 0} and <= ${t}`, e);\n  }\n  var ue2 = /[^+/0-9A-Za-z-_]/g;\n  function he2(e) {\n    if (e = e.split(\"=\")[0], e = e.trim().replace(ue2, \"\"), e.length < 2)\n      return \"\";\n    for (; e.length % 4 !== 0; )\n      e = e + \"=\";\n    return e;\n  }\n  function At2(e, t) {\n    t = t || 1 / 0;\n    let r3, n = e.length, i = null, o = [];\n    for (let s = 0; s < n; ++s) {\n      if (r3 = e.charCodeAt(s), r3 > 55295 && r3 < 57344) {\n        if (!i) {\n          if (r3 > 56319) {\n            (t -= 3) > -1 && o.push(239, 191, 189);\n            continue;\n          } else if (s + 1 === n) {\n            (t -= 3) > -1 && o.push(239, 191, 189);\n            continue;\n          }\n          i = r3;\n          continue;\n        }\n        if (r3 < 56320) {\n          (t -= 3) > -1 && o.push(239, 191, 189), i = r3;\n          continue;\n        }\n        r3 = (i - 55296 << 10 | r3 - 56320) + 65536;\n      } else\n        i && (t -= 3) > -1 && o.push(239, 191, 189);\n      if (i = null, r3 < 128) {\n        if ((t -= 1) < 0)\n          break;\n        o.push(r3);\n      } else if (r3 < 2048) {\n        if ((t -= 2) < 0)\n          break;\n        o.push(r3 >> 6 | 192, r3 & 63 | 128);\n      } else if (r3 < 65536) {\n        if ((t -= 3) < 0)\n          break;\n        o.push(r3 >> 12 | 224, r3 >> 6 & 63 | 128, r3 & 63 | 128);\n      } else if (r3 < 1114112) {\n        if ((t -= 4) < 0)\n          break;\n        o.push(r3 >> 18 | 240, r3 >> 12 & 63 | 128, r3 >> 6 & 63 | 128, r3 & 63 | 128);\n      } else\n        throw new Error(\"Invalid code point\");\n    }\n    return o;\n  }\n  function fe2(e) {\n    let t = [];\n    for (let r3 = 0; r3 < e.length; ++r3)\n      t.push(e.charCodeAt(r3) & 255);\n    return t;\n  }\n  function ce2(e, t) {\n    let r3, n, i, o = [];\n    for (let s = 0; s < e.length && !((t -= 2) < 0); ++s)\n      r3 = e.charCodeAt(s), n = r3 >> 8, i = r3 % 256, o.push(i), o.push(n);\n    return o;\n  }\n  function cr2(e) {\n    return Bt2.toByteArray(he2(e));\n  }\n  function et2(e, t, r3, n) {\n    let i;\n    for (i = 0; i < n && !(i + r3 >= t.length || i >= e.length); ++i)\n      t[i + r3] = e[i];\n    return i;\n  }\n  function A(e, t) {\n    return e instanceof t || e != null && e.constructor != null && e.constructor.name != null && e.constructor.name === t.name;\n  }\n  function Ut2(e) {\n    return e !== e;\n  }\n  var pe2 = function() {\n    let e = \"0123456789abcdef\", t = new Array(256);\n    for (let r3 = 0; r3 < 16; ++r3) {\n      let n = r3 * 16;\n      for (let i = 0; i < 16; ++i)\n        t[n + i] = e[r3] + e[i];\n    }\n    return t;\n  }();\n  function L(e) {\n    return typeof BigInt > \"u\" ? le2 : e;\n  }\n  function le2() {\n    throw new Error(\"BigInt not supported\");\n  }\n});\nvar pr2 = T3((Je2, Ft2) => {\n  typeof window < \"u\" ? (window.global = window, global.fetch = window.fetch, Ft2.exports = { Buffer: nt2().Buffer, Crypto: window.crypto }) : Ft2.exports = { Buffer: nt2().Buffer, Crypto: crypto };\n});\nvar Lt = {};\nAr(Lt, { AVSCTap: () => $2, ArweaveSigner: () => N2, DataItem: () => _, MAX_TAG_BYTES: () => tt2, MIN_BINARY_SIZE: () => gr, SIG_CONFIG: () => P2, SignatureConfig: () => B2, Signer: () => ot2, createData: () => ge2, deserializeTags: () => Q2, indexToType: () => wt2, serializeTags: () => dt2, tagsExceedLimit: () => jr });\nvar ot2 = class {\n  signer;\n  publicKey;\n  signatureType;\n  signatureLength;\n  ownerLength;\n  pem;\n  static verify(t, r3, n, i) {\n    throw new Error(\"You must implement verify method on child\");\n  }\n};\nvar vt2 = C2(z2(), 1);\nvar w = C2(pt2(), 1);\nasync function X2(e) {\n  if (Array.isArray(e)) {\n    let i = (0, w.concatBuffers)([(0, w.stringToBuffer)(\"list\"), (0, w.stringToBuffer)(e.length.toString())]);\n    return await Gt2(e, await x().hash(i, \"SHA-384\"));\n  }\n  let t = e, r3 = (0, w.concatBuffers)([(0, w.stringToBuffer)(\"blob\"), (0, w.stringToBuffer)(t.byteLength.toString())]), n = (0, w.concatBuffers)([await x().hash(r3, \"SHA-384\"), await x().hash(t, \"SHA-384\")]);\n  return await x().hash(n, \"SHA-384\");\n}\nasync function Gt2(e, t) {\n  if (e.length < 1)\n    return t;\n  let r3 = (0, w.concatBuffers)([t, await X2(e[0])]), n = await x().hash(r3, \"SHA-384\");\n  return await Gt2(e.slice(1), n);\n}\nvar Z2 = C2(Yt2(), 1);\nvar $r = Z2.default.default ? Z2.default.default : Z2.default;\nvar yt2 = class extends $r {\n  getPublicKey(t) {\n    throw new Error(\"Unimplemented\");\n  }\n};\nvar Kr;\nfunction x() {\n  return Kr ??= new yt2();\n}\nvar B2;\n(function(e) {\n  e[e.ARWEAVE = 1] = \"ARWEAVE\", e[e.ED25519 = 2] = \"ED25519\", e[e.ETHEREUM = 3] = \"ETHEREUM\", e[e.SOLANA = 4] = \"SOLANA\", e[e.INJECTEDAPTOS = 5] = \"INJECTEDAPTOS\", e[e.MULTIAPTOS = 6] = \"MULTIAPTOS\", e[e.TYPEDETHEREUM = 7] = \"TYPEDETHEREUM\";\n})(B2 || (B2 = {}));\nvar P2 = { [B2.ARWEAVE]: { sigLength: 512, pubLength: 512, sigName: \"arweave\" }, [B2.ED25519]: { sigLength: 64, pubLength: 32, sigName: \"ed25519\" }, [B2.ETHEREUM]: { sigLength: 65, pubLength: 65, sigName: \"ethereum\" }, [B2.SOLANA]: { sigLength: 64, pubLength: 32, sigName: \"solana\" }, [B2.INJECTEDAPTOS]: { sigLength: 64, pubLength: 32, sigName: \"injectedAptos\" }, [B2.MULTIAPTOS]: { sigLength: 64 * 32 + 4, pubLength: 32 * 32 + 1, sigName: \"multiAptos\" }, [B2.TYPEDETHEREUM]: { sigLength: 65, pubLength: 42, sigName: \"typedEthereum\" } };\nvar N2 = class {\n  signatureType = 1;\n  ownerLength = P2[1].pubLength;\n  signatureLength = P2[1].sigLength;\n  jwk;\n  pk;\n  constructor(t) {\n    this.pk = t.n, this.jwk = t;\n  }\n  get publicKey() {\n    return vt2.default.toBuffer(this.pk);\n  }\n  sign(t) {\n    return x().sign(this.jwk, t);\n  }\n  static async verify(t, r3, n) {\n    return await x().verify(t, r3, n);\n  }\n};\nvar wt2 = { 1: N2 };\nvar E2 = C2(z2(), 1);\nasync function v(e) {\n  return X2([(0, w.stringToBuffer)(\"dataitem\"), (0, w.stringToBuffer)(\"1\"), (0, w.stringToBuffer)(e.signatureType.toString()), e.rawOwner, e.rawTarget, e.rawAnchor, e.rawTags, e.rawData]);\n}\nasync function Hr(e, t) {\n  let r3 = await v(e), n = await t.sign(r3), i = await x().hash(n);\n  return { signature: Buffer.from(n), id: Buffer.from(i) };\n}\nasync function Wt2(e, t) {\n  let { signature: r3, id: n } = await Hr(e, t);\n  return e.getRaw().set(r3, 2), n;\n}\nvar $2 = class {\n  buf;\n  pos;\n  constructor(t = Buffer.alloc(tt2), r3 = 0) {\n    this.buf = t, this.pos = r3;\n  }\n  writeTags(t) {\n    if (!Array.isArray(t))\n      throw new Error(\"input must be array\");\n    let r3 = t.length, n;\n    if (r3)\n      for (this.writeLong(r3), n = 0; n < r3; n++) {\n        let i = t[n];\n        if (i?.name === void 0 || i?.value === void 0)\n          throw new Error(`Invalid tag format for ${i}, expected {name:string, value: string}`);\n        this.writeString(i.name), this.writeString(i.value);\n      }\n    this.writeLong(0);\n  }\n  toBuffer() {\n    let t = Buffer.alloc(this.pos);\n    if (this.pos > this.buf.length)\n      throw new Error(`Too many tag bytes (${this.pos} > ${this.buf.length})`);\n    return this.buf.copy(t, 0, 0, this.pos), t;\n  }\n  tagsExceedLimit() {\n    return this.pos > this.buf.length;\n  }\n  writeLong(t) {\n    let r3 = this.buf, n, i;\n    if (t >= -1073741824 && t < 1073741824) {\n      i = t >= 0 ? t << 1 : ~t << 1 | 1;\n      do\n        r3[this.pos] = i & 127, i >>= 7;\n      while (i && (r3[this.pos++] |= 128));\n    } else {\n      n = t >= 0 ? t * 2 : -t * 2 - 1;\n      do\n        r3[this.pos] = n & 127, n /= 128;\n      while (n >= 1 && (r3[this.pos++] |= 128));\n    }\n    this.pos++, this.buf = r3;\n  }\n  writeString(t) {\n    let r3 = Buffer.byteLength(t), n = this.buf;\n    this.writeLong(r3);\n    let i = this.pos;\n    if (this.pos += r3, !(this.pos > n.length)) {\n      if (r3 > 64)\n        this.buf.write(t, this.pos - r3, r3, \"utf8\");\n      else {\n        let o, s, u2, h2;\n        for (o = 0, s = r3; o < s; o++)\n          u2 = t.charCodeAt(o), u2 < 128 ? n[i++] = u2 : u2 < 2048 ? (n[i++] = u2 >> 6 | 192, n[i++] = u2 & 63 | 128) : (u2 & 64512) === 55296 && ((h2 = t.charCodeAt(o + 1)) & 64512) === 56320 ? (u2 = 65536 + ((u2 & 1023) << 10) + (h2 & 1023), o++, n[i++] = u2 >> 18 | 240, n[i++] = u2 >> 12 & 63 | 128, n[i++] = u2 >> 6 & 63 | 128, n[i++] = u2 & 63 | 128) : (n[i++] = u2 >> 12 | 224, n[i++] = u2 >> 6 & 63 | 128, n[i++] = u2 & 63 | 128);\n      }\n      this.buf = n;\n    }\n  }\n  readLong() {\n    let t = 0, r3 = 0, n = this.buf, i, o, s, u2;\n    do\n      i = n[this.pos++], o = i & 128, t |= (i & 127) << r3, r3 += 7;\n    while (o && r3 < 28);\n    if (o) {\n      s = t, u2 = 268435456;\n      do\n        i = n[this.pos++], s += (i & 127) * u2, u2 *= 128;\n      while (i & 128);\n      return (s % 2 ? -(s + 1) : s) / 2;\n    }\n    return t >> 1 ^ -(t & 1);\n  }\n  skipLong() {\n    let t = this.buf;\n    for (; t[this.pos++] & 128; )\n      ;\n  }\n  readTags() {\n    let t = [], r3;\n    for (; r3 = this.readLong(); )\n      for (r3 < 0 && (r3 = -r3, this.skipLong()); r3--; ) {\n        let n = this.readString(), i = this.readString();\n        t.push({ name: n, value: i });\n      }\n    return t;\n  }\n  readString() {\n    let t = this.readLong(), r3 = this.pos, n = this.buf;\n    if (this.pos += t, !(this.pos > n.length))\n      return this.buf.slice(r3, r3 + t).toString();\n  }\n};\nfunction dt2(e) {\n  let t = new $2();\n  return t.writeTags(e), t.toBuffer();\n}\nfunction jr(e) {\n  let t = new $2();\n  return t.writeTags(e), t.tagsExceedLimit();\n}\nfunction Q2(e) {\n  return new $2(e).readTags();\n}\nfunction I2(e) {\n  let t = 0;\n  for (let r3 = e.length - 1; r3 >= 0; r3--)\n    t = t * 256 + e[r3];\n  return t;\n}\nfunction Vt2(e) {\n  if (e > (2 ^ 32 - 1))\n    throw new Error(\"Short too long\");\n  let t = [0, 0];\n  for (let r3 = 0; r3 < t.length; r3++) {\n    let n = e & 255;\n    t[r3] = n, e = (e - n) / 256;\n  }\n  return Uint8Array.from(t);\n}\nfunction xt2(e) {\n  let t = [0, 0, 0, 0, 0, 0, 0, 0];\n  for (let r3 = 0; r3 < t.length; r3++) {\n    let n = e & 255;\n    t[r3] = n, e = (e - n) / 256;\n  }\n  return Uint8Array.from(t);\n}\nvar lr2 = C2(pr2(), 1);\nvar M2 = C2(nt2(), 1);\nvar tt2 = 4096;\nvar gr = 80;\nvar _ = class {\n  binary;\n  _id;\n  constructor(t) {\n    this.binary = t;\n  }\n  static isDataItem(t) {\n    return t.binary !== void 0;\n  }\n  get signatureType() {\n    let t = I2(this.binary.subarray(0, 2));\n    if (B2?.[t] !== void 0)\n      return t;\n    throw new Error(\"Unknown signature type: \" + t);\n  }\n  async isValid() {\n    return _.verify(this.binary);\n  }\n  get id() {\n    return (async () => E2.default.encode(await this.rawId))();\n  }\n  set id(t) {\n    this._id = E2.default.toBuffer(t);\n  }\n  get rawId() {\n    return (async () => M2.Buffer.from(await lr2.Crypto.subtle.digest(\"SHA-256\", this.rawSignature)))();\n  }\n  set rawId(t) {\n    this._id = t;\n  }\n  get rawSignature() {\n    return this.binary.subarray(2, 2 + this.signatureLength);\n  }\n  get signature() {\n    return E2.default.encode(this.rawSignature);\n  }\n  set rawOwner(t) {\n    if (t.byteLength != this.ownerLength)\n      throw new Error(`Expected raw owner (pubkey) to be ${this.ownerLength} bytes, got ${t.byteLength} bytes.`);\n    this.binary.set(t, 2 + this.signatureLength);\n  }\n  get rawOwner() {\n    return this.binary.subarray(2 + this.signatureLength, 2 + this.signatureLength + this.ownerLength);\n  }\n  get signatureLength() {\n    return P2[this.signatureType].sigLength;\n  }\n  get owner() {\n    return E2.default.encode(this.rawOwner);\n  }\n  get ownerLength() {\n    return P2[this.signatureType].pubLength;\n  }\n  get rawTarget() {\n    let t = this.getTargetStart();\n    return this.binary[t] == 1 ? this.binary.subarray(t + 1, t + 33) : M2.Buffer.alloc(0);\n  }\n  get target() {\n    return E2.default.encode(this.rawTarget);\n  }\n  get rawAnchor() {\n    let t = this.getAnchorStart();\n    return this.binary[t] == 1 ? this.binary.subarray(t + 1, t + 33) : M2.Buffer.alloc(0);\n  }\n  get anchor() {\n    return this.rawAnchor.toString();\n  }\n  get rawTags() {\n    let t = this.getTagsStart(), r3 = I2(this.binary.subarray(t + 8, t + 16));\n    return this.binary.subarray(t + 16, t + 16 + r3);\n  }\n  get tags() {\n    let t = this.getTagsStart();\n    if (I2(this.binary.subarray(t, t + 8)) == 0)\n      return [];\n    let n = I2(this.binary.subarray(t + 8, t + 16));\n    return Q2(M2.Buffer.from(this.binary.subarray(t + 16, t + 16 + n)));\n  }\n  get tagsB64Url() {\n    return this.tags.map((r3) => ({ name: E2.default.encode(r3.name), value: E2.default.encode(r3.value) }));\n  }\n  getStartOfData() {\n    let t = this.getTagsStart(), r3 = this.binary.subarray(t + 8, t + 16), n = I2(r3);\n    return t + 16 + n;\n  }\n  get rawData() {\n    let t = this.getTagsStart(), r3 = this.binary.subarray(t + 8, t + 16), n = I2(r3), i = t + 16 + n;\n    return this.binary.subarray(i, this.binary.length);\n  }\n  get data() {\n    return E2.default.encode(this.rawData);\n  }\n  getRaw() {\n    return this.binary;\n  }\n  async sign(t) {\n    return this._id = await Wt2(this, t), this.rawId;\n  }\n  async setSignature(t) {\n    this.binary.set(t, 2), this._id = M2.Buffer.from(await x().hash(t));\n  }\n  isSigned() {\n    return (this._id?.length ?? 0) > 0;\n  }\n  toJSON() {\n    return { signature: this.signature, owner: this.owner, target: this.target, tags: this.tags.map((t) => ({ name: E2.default.encode(t.name), value: E2.default.encode(t.value) })), data: this.data };\n  }\n  static async verify(t) {\n    if (t.byteLength < gr)\n      return false;\n    let r3 = new _(t), n = r3.signatureType, i = r3.getTagsStart(), o = I2(t.subarray(i, i + 8)), s = t.subarray(i + 8, i + 16), u2 = I2(s);\n    if (u2 > tt2)\n      return false;\n    if (o > 0)\n      try {\n        if (Q2(M2.Buffer.from(t.subarray(i + 16, i + 16 + u2))).length !== o)\n          return false;\n      } catch {\n        return false;\n      }\n    let h2 = wt2[n], p = await v(r3);\n    return await h2.verify(r3.rawOwner, p, r3.rawSignature);\n  }\n  async getSignatureData() {\n    return v(this);\n  }\n  getTagsStart() {\n    let t = this.getTargetStart(), r3 = this.binary[t] == 1, n = t + (r3 ? 33 : 1), i = this.binary[n] == 1;\n    return n += i ? 33 : 1, n;\n  }\n  getTargetStart() {\n    return 2 + this.signatureLength + this.ownerLength;\n  }\n  getAnchorStart() {\n    let t = this.getTargetStart() + 1, r3 = this.binary[this.getTargetStart()] == 1;\n    return t += r3 ? 32 : 0, t;\n  }\n};\nvar yr = C2(z2(), 1);\nfunction ge2(e, t, r3) {\n  let n = t.publicKey, i = r3?.target ? yr.default.toBuffer(r3.target) : null, o = 1 + (i?.byteLength ?? 0), s = r3?.anchor ? Buffer.from(r3.anchor) : null, u2 = 1 + (s?.byteLength ?? 0), h2 = (r3?.tags?.length ?? 0) > 0 ? dt2(r3.tags) : null, p = 16 + (h2 ? h2.byteLength : 0), f = Buffer.from(e), c2 = f.byteLength, U2 = 2 + t.signatureLength + t.ownerLength + o + u2 + p + c2, l = Buffer.alloc(U2);\n  if (l.set(Vt2(t.signatureType), 0), l.set(new Uint8Array(t.signatureLength).fill(0), 2), n.byteLength !== t.ownerLength)\n    throw new Error(`Owner must be ${t.ownerLength} bytes, but was incorrectly ${n.byteLength}`);\n  l.set(n, 2 + t.signatureLength);\n  let R2 = 2 + t.signatureLength + t.ownerLength;\n  if (l[R2] = i ? 1 : 0, i) {\n    if (i.byteLength !== 32)\n      throw new Error(`Target must be 32 bytes but was incorrectly ${i.byteLength}`);\n    l.set(i, R2 + 1);\n  }\n  let G2 = R2 + o, Y2 = G2 + 1;\n  if (l[G2] = s ? 1 : 0, s) {\n    if (Y2 += s.byteLength, s.byteLength !== 32)\n      throw new Error(\"Anchor must be 32 bytes\");\n    l.set(s, G2 + 1);\n  }\n  l.set(xt2(r3?.tags?.length ?? 0), Y2);\n  let wr = xt2(h2?.byteLength ?? 0);\n  l.set(wr, Y2 + 8), h2 && l.set(h2, Y2 + 16);\n  let dr = Y2 + p;\n  return l.set(f, dr), new _(l);\n}\nvar _t2 = { ...Lt };\nglobalThis.arbundles ??= _t2;\nvar wn = _t2;\nvar dn = _t2;\n\n// src/client/browser/wallet.js\nif (!globalThis.Buffer)\n  globalThis.Buffer = import_buffer.Buffer;\nvar { DataItem } = bundle_exports;\nfunction createDataItemSigner(arweaveWallet) {\n  const signer = async ({ data, tags, target, anchor, createDataItem = (buf) => new DataItem(buf) }) => {\n    const view = await arweaveWallet.signDataItem({ data, tags, target, anchor });\n    const dataItem = createDataItem(import_buffer.Buffer.from(view));\n    return {\n      id: await dataItem.id,\n      raw: await dataItem.getRaw()\n    };\n  };\n  return signer;\n}\n\n// src/index.browser.js\nvar GATEWAY_URL = globalThis.GATEWAY_URL || void 0;\nvar MU_URL = globalThis.MU_URL || void 0;\nvar CU_URL = globalThis.CU_URL || void 0;\nvar GRAPHQL_URL = globalThis.GRAPHQL_URL || void 0;\nvar { result, results, message, spawn, monitor, unmonitor, dryrun, assign } = connect({ GATEWAY_URL, MU_URL, CU_URL, GRAPHQL_URL });\nvar createDataItemSigner2 = wallet_exports.createDataItemSigner;\n\n/*! Bundled license information:\n\nieee754/index.js:\n  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)\n\nbuffer/index.js:\n  (*!\n   * The buffer module from node.js, for the browser.\n   *\n   * @author   Feross Aboukhadijeh <https://feross.org>\n   * @license  MIT\n   *)\n\nwarp-arbundles/build/web/esm/bundle.js:\n  (*! Bundled license information:\n  \n  ieee754/index.js:\n    (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)\n  \n  buffer/index.js:\n    (*!\n     * The buffer module from node.js, for the browser.\n     *\n     * @author   Feross Aboukhadijeh <https://feross.org>\n     * @license  MIT\n     *)\n  *)\n*/\n\n\n//# sourceURL=webpack://q2/./node_modules/@permaweb/aoconnect/dist/browser.js?");

/***/ }),

/***/ "./node_modules/arweave-wallet-kit/dist/index.es.js":
/*!**********************************************************!*\
  !*** ./node_modules/arweave-wallet-kit/dist/index.es.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ArweaveWalletKit: () => (/* binding */ l2),\n/* harmony export */   ConnectButton: () => (/* binding */ c2),\n/* harmony export */   useActiveAddress: () => (/* binding */ Uo),\n/* harmony export */   useAddresses: () => (/* binding */ Mg),\n/* harmony export */   useApi: () => (/* binding */ i2),\n/* harmony export */   useConnection: () => (/* binding */ Tc),\n/* harmony export */   usePermissions: () => (/* binding */ w1),\n/* harmony export */   useProfileModal: () => (/* binding */ T1),\n/* harmony export */   usePublicKey: () => (/* binding */ o2),\n/* harmony export */   useStrategy: () => (/* binding */ Cg),\n/* harmony export */   useWalletNames: () => (/* binding */ s2)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n\"use client\";\n(function(){\"use strict\";try{if(typeof document<\"u\"){var e=document.createElement(\"style\");e.appendChild(document.createTextNode(\".b1cb9caz{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;font-family:var(--b1cb9caz-0),sans-serif;font-size:.9rem;font-weight:600;color:#fff;background-color:rgb(var(--b1cb9caz-1));border-radius:var(--b1cb9caz-2);padding:.3rem .8rem;text-align:center;border:none;outline:none;text-transform:uppercase;cursor:pointer;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;gap:.4rem;white-space:nowrap;-webkit-tap-highlight-color:transparent;-webkit-transition:all .18s ease-in-out;transition:all .18s ease-in-out}.b1cb9caz:hover:not(:active):not(:disabled){-webkit-transform:translate3d(0px,-1.4px,0px);-ms-transform:translate3d(0px,-1.4px,0px);transform:translate3d(0,-1.4px,0);box-shadow:var(--b1cb9caz-3)}.b1cb9caz:disabled{opacity:.7;cursor:not-allowed}.b1cb9caz svg{font-size:1em;width:1em;height:1em}.w14emrir.b1cb9caz{border-radius:var(--w14emrir-0);text-transform:none;padding:.3rem;background-color:var(--w14emrir-1)}.czh4f0e{line-height:2.6rem;padding:0 .9rem}.pwkn5es{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;background-color:rgb(var(--pwkn5es-0),.2);height:2.6rem;border-radius:var(--pwkn5es-1);padding:0 .3rem 0 .6rem;gap:.25rem}.bdt02oh{padding:0 .5rem}.e3hlv71{font-size:1.5rem!important}.a1jsmwxp{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;border-radius:var(--a1jsmwxp-0);object-fit:cover;width:1.7rem;height:1.7rem;margin-right:.4rem}.as6ir6f{font-size:1rem!important;color:#fff}.av7js2i{position:relative;border-radius:var(--av7js2i-0);width:1.7rem;height:1.7rem;margin-right:.4rem;background:linear-gradient(to right,#4776e6,#8e54e9);background-size:cover}.av7js2i .as6ir6f{position:absolute;top:50%;left:50%;-webkit-transform:translate(-50%,-50%);-ms-transform:translate(-50%,-50%);transform:translate(-50%,-50%)}.bbvkbel{position:fixed;top:0;left:0;right:0;bottom:0;width:100vw;height:100vh;z-index:90000;background-color:#0006}.m1767o4q{height:100vh;left:0;position:fixed;top:0;width:100vw;z-index:100000}.mzdiz37{height:100vh;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center}@media screen and (max-width:720px){.mzdiz37{-webkit-align-items:flex-end;-webkit-box-align:flex-end;-ms-flex-align:flex-end;align-items:flex-end}}.m69h97z{position:relative;left:0;top:100%;z-index:100000;font-family:var(--m69h97z-0),sans-serif;overflow:hidden;-webkit-transition-property:width;transition-property:width}.m69h97z *::selection{background-color:#000000bf;color:#fff}.m69h97z *::-moz-selection{background-color:#000000bf;color:#fff}@media screen and (min-width:1081px){.m69h97z{max-width:28vw}}@media screen and (min-width:721px) and (max-width:1080px){.m69h97z{max-width:50vw}}@media screen and (max-width:720px){.m69h97z{max-width:100vw}}.mh21eb7{-webkit-transition:background-color .23s ease-in-out;transition:background-color .23s ease-in-out;background-color:rgb(var(--mh21eb7-0));border-radius:var(--mh21eb7-1);width:100%}@media screen and (max-width:720px){.mh21eb7{border-bottom-left-radius:0;border-bottom-right-radius:0}}.k17wyawm{position:fixed;font-family:var(--k17wyawm-0),sans-serif;font-size:.8rem;font-weight:500;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:default;text-align:center;margin:0;color:#ffffff80;left:50%;bottom:10px;-webkit-transform:translateX(-50%);-ms-transform:translateX(-50%);transform:translate(-50%)}@media screen and (max-width:720px){.k17wyawm{bottom:unset;top:10px}}.b7jc8fb{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;gap:1.24rem;padding:.75rem 1rem;border-radius:var(--b7jc8fb-0);border-radius:15px;bottom:0;right:1.5rem;left:unset;top:unset;width:auto}@media screen and (max-width:720px){.b7jc8fb{left:1.5rem;gap:1rem}}.typmncv{font-size:1.05rem;font-weight:500;color:rgb(var(--typmncv-0));margin:0}.b14qolsb{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;gap:.6rem}@media screen and (max-width:720px){.b14qolsb{-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column}.b14qolsb .b1cb9caz{width:100%}}.c1jq17m8.b1cb9caz{background-color:transparent;color:rgb(var(--c1jq17m8-0))}.c1jq17m8.b1cb9caz:hover{background-color:rgba(var(--c1jq17m8-1),.05);color:rgb(var(--c1jq17m8-1));box-shadow:none!important}.p1jty3xq{font-size:var(--p1jty3xq-0);color:rgb(var(--p1jty3xq-1));margin:0;font-weight:600;-webkit-transition:color .23s ease-in-out;transition:color .23s ease-in-out}.t1sgzzc0{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;font-family:var(--t1sgzzc0-0),sans-serif;font-size:var(--t1sgzzc0-1);font-weight:600;color:rgb(var(--t1sgzzc0-2));cursor:var(--t1sgzzc0-3);-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;gap:.34rem;margin:0;-webkit-transition:color .23s ease-in-out;transition:color .23s ease-in-out}.tb205ol{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;gap:.1rem}.wzg6vks{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:justify;-webkit-justify-content:space-between;-ms-flex-pack:justify;justify-content:space-between;padding:0 20px}.a1vzc1qt{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;gap:.8rem}.l1rbotc6{width:60%;height:60%;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;object-fit:contain}.acuhj7u{position:relative;width:3.8rem;height:3.8rem;border-radius:var(--acuhj7u-0);background-color:rgb(var(--acuhj7u-1));-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;-webkit-tap-highlight-color:transparent;cursor:var(--acuhj7u-2);-webkit-transition:-webkit-transform .125s ease;-webkit-transition:transform .125s ease;transition:transform .125s ease}.acuhj7u .l1rbotc6{position:absolute;top:50%;left:50%;-webkit-transform:translate(-50%,-50%);-ms-transform:translate(-50%,-50%);transform:translate(-50%,-50%)}.acuhj7u:active{-webkit-transform:scale(var(--acuhj7u-3));-ms-transform:scale(var(--acuhj7u-3));transform:scale(var(--acuhj7u-3))}.a143ijem{-webkit-flex-shrink:1;-ms-flex-negative:1;flex-shrink:1}.wv1c1ab{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:justify;-webkit-justify-content:space-between;-ms-flex-pack:justify;justify-content:space-between;padding:10px 20px;border-top:1px solid rgb(var(--wv1c1ab-0));-webkit-transition:border-color .23s ease-in-out;transition:border-color .23s ease-in-out}.s9sva{color:currentColor;font-size:1em;width:1em;height:1em;-webkit-animation:rotate-s9sva .9s linear infinite;animation:rotate-s9sva .9s linear infinite}@-webkit-keyframes rotate-s9sva{0%{-webkit-transform:rotate(0deg);-ms-transform:rotate(0deg);transform:rotate(0)}to{-webkit-transform:rotate(360deg);-ms-transform:rotate(360deg);transform:rotate(360deg)}}@keyframes rotate-s9sva{0%{-webkit-transform:rotate(0deg);-ms-transform:rotate(0deg);transform:rotate(0)}to{-webkit-transform:rotate(360deg);-ms-transform:rotate(360deg);transform:rotate(360deg)}}.h1mmuqym{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:justify;-webkit-justify-content:space-between;-ms-flex-pack:justify;justify-content:space-between;padding:20px}.c86k5gq{position:relative;width:1.4rem;height:1.4rem;border-radius:100%;background-color:rgb(var(--c86k5gq-0));cursor:pointer;-webkit-tap-highlight-color:transparent;-webkit-transition:opacity .23s ease-in-out,-webkit-transform .125s ease,background-color .23s ease-in-out;-webkit-transition:opacity .23s ease-in-out,transform .125s ease,background-color .23s ease-in-out;transition:opacity .23s ease-in-out,transform .125s ease,background-color .23s ease-in-out}.c86k5gq:hover{-webkit-transform:scale(1.14);-ms-transform:scale(1.14);transform:scale(1.14)}.c86k5gq:active{-webkit-transform:scale(.92);-ms-transform:scale(.92);transform:scale(.92)}.c86k5gq svg{font-size:1.1rem;width:1em;height:1em;position:absolute;top:50%;left:50%;color:rgb(var(--c86k5gq-1));-webkit-transform:translate(-50%,-50%);-ms-transform:translate(-50%,-50%);transform:translate(-50%,-50%)}.a1osnke6{position:relative;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;gap:1.1rem;padding-bottom:1.2rem;max-height:280px;overflow-y:auto}.c15u83h7{position:relative;height:280px}.w5r445t{position:absolute;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;top:45%;left:50%;width:70%;-webkit-transform:translate(-50%,-50%);-ms-transform:translate(-50%,-50%);transform:translate(-50%,-50%)}.w5r445t .acuhj7u{margin-bottom:.65rem}.w5r445t .t1sgzzc0{text-align:center;font-weight:700;margin-bottom:.1rem;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center}.w5r445t .p1jty3xq{text-align:center}.w5r445t .b1cb9caz{margin-top:1rem}.bukrfi8.p1jty3xq{background-color:#fb552b33;color:#fb542b;padding:.44rem;border-radius:var(--bukrfi8-0);margin-top:.6rem}.c13sms3{display:block;margin:0 auto;margin-top:1rem;color:rgb(var(--c13sms3-0));width:1.25rem;height:1.25rem}.b1r2gdr0{font-size:1em;width:1em;height:1em;cursor:pointer;color:#007aff;-webkit-transform:scale(1.75);-ms-transform:scale(1.75);transform:scale(1.75);-webkit-tap-highlight-color:transparent;-webkit-transition:-webkit-transform .125s ease;-webkit-transition:transform .125s ease;transition:transform .125s ease}.b1r2gdr0:hover{-webkit-transform:scale(1.9);-ms-transform:scale(1.9);transform:scale(1.9)}.b1r2gdr0:active{-webkit-transform:scale(1.5);-ms-transform:scale(1.5);transform:scale(1.5)}.p1hjgol5{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;padding:0 20px 20px}.p1hjgol5 .t1sgzzc0,.p1hjgol5 .p1jty3xq{text-align:center}.p1hjgol5 .t1sgzzc0 svg,.p1hjgol5 .p1jty3xq svg{font-size:.85em;width:1em;height:1em;cursor:pointer;-webkit-tap-highlight-color:transparent;-webkit-transition:all .125s ease-in-out;transition:all .125s ease-in-out}.p1hjgol5 .t1sgzzc0 svg:hover,.p1hjgol5 .p1jty3xq svg:hover{opacity:.85}.p1hjgol5 .t1sgzzc0 svg:active,.p1hjgol5 .p1jty3xq svg:active{-webkit-transform:scale(.9);-ms-transform:scale(.9);transform:scale(.9)}.p1hjgol5 .b1cb9caz{margin-top:1.5rem;width:100%;padding:.9rem 0;border-radius:var(--p1hjgol5-0);text-transform:none}.publs4f{position:relative;width:80px;height:80px;border-radius:var(--publs4f-0);margin-bottom:.475rem;background-color:rgb(var(--publs4f-1));background-size:cover;z-index:1;-webkit-var(--publs4f-2);-moz-var(--publs4f-2);-ms-var(--publs4f-2);var(--publs4f-2)}.alzinag{position:absolute;bottom:0;right:0;width:1.45rem;height:1.45rem;border-radius:100%;background-color:rgb(var(--alzinag-0));border:2px solid rgb(var(--alzinag-1))}.alzinag img{position:absolute;top:50%;left:50%;object-fit:contain;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;width:74%;height:74%;border-radius:100%;-webkit-transform:translate(-50%,-50%);-ms-transform:translate(-50%,-50%);transform:translate(-50%,-50%)}.p1qewrlg{position:absolute;font-size:45px;width:1em;height:1em;top:50%;left:50%;color:#fff;-webkit-transform:translate(-50%,-50%);-ms-transform:translate(-50%,-50%);transform:translate(-50%,-50%)}\")),document.head.appendChild(e)}}catch(t){console.error(\"vite-plugin-css-injected-by-js\",t)}})();\nvar Wp = Object.defineProperty;\nvar zp = (t, e, r) => e in t ? Wp(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r;\nvar ot = (t, e, r) => (zp(t, typeof e != \"symbol\" ? e + \"\" : e, r), r), ds = (t, e, r) => {\n  if (!e.has(t))\n    throw TypeError(\"Cannot \" + r);\n};\nvar vt = (t, e, r) => (ds(t, e, \"read from private field\"), r ? r.call(t) : e.get(t)), Cr = (t, e, r) => {\n  if (e.has(t))\n    throw TypeError(\"Cannot add the same private member more than once\");\n  e instanceof WeakSet ? e.add(t) : e.set(t, r);\n}, Or = (t, e, r, n) => (ds(t, e, \"write to private field\"), n ? n.call(t, r) : e.set(t, r), r);\nvar ut = (t, e, r) => (ds(t, e, \"access private method\"), r);\n\n\nconst H0 = () => {\n  for (var t = [], e = [], r = typeof Uint8Array < \"u\" ? Uint8Array : Array, n = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\", i = 0, o = n.length; i < o; ++i)\n    t[i] = n[i], e[n.charCodeAt(i)] = i;\n  e[\"-\".charCodeAt(0)] = 62, e[\"_\".charCodeAt(0)] = 63;\n  function a(h) {\n    var p = h.length;\n    if (p % 4 > 0)\n      throw new Error(\"Invalid string. Length must be a multiple of 4\");\n    var g = h.indexOf(\"=\");\n    g === -1 && (g = p);\n    var _ = g === p ? 0 : 4 - g % 4;\n    return [g, _];\n  }\n  function s(h, p, g) {\n    return (p + g) * 3 / 4 - g;\n  }\n  function l(h) {\n    var p, g = a(h), _ = g[0], T = g[1], A = new r(s(h, _, T)), w = 0, O = T > 0 ? _ - 4 : _, R;\n    for (R = 0; R < O; R += 4)\n      p = e[h.charCodeAt(R)] << 18 | e[h.charCodeAt(R + 1)] << 12 | e[h.charCodeAt(R + 2)] << 6 | e[h.charCodeAt(R + 3)], A[w++] = p >> 16 & 255, A[w++] = p >> 8 & 255, A[w++] = p & 255;\n    return T === 2 && (p = e[h.charCodeAt(R)] << 2 | e[h.charCodeAt(R + 1)] >> 4, A[w++] = p & 255), T === 1 && (p = e[h.charCodeAt(R)] << 10 | e[h.charCodeAt(R + 1)] << 4 | e[h.charCodeAt(R + 2)] >> 2, A[w++] = p >> 8 & 255, A[w++] = p & 255), A;\n  }\n  function u(h) {\n    return t[h >> 18 & 63] + t[h >> 12 & 63] + t[h >> 6 & 63] + t[h & 63];\n  }\n  function c(h, p, g) {\n    for (var _, T = [], A = p; A < g; A += 3)\n      _ = (h[A] << 16 & 16711680) + (h[A + 1] << 8 & 65280) + (h[A + 2] & 255), T.push(u(_));\n    return T.join(\"\");\n  }\n  function f(h) {\n    for (var p, g = h.length, _ = g % 3, T = [], A = 16383, w = 0, O = g - _; w < O; w += A)\n      T.push(c(h, w, w + A > O ? O : w + A));\n    return _ === 1 ? (p = h[g - 1], T.push(t[p >> 2] + t[p << 4 & 63] + \"==\")) : _ === 2 && (p = (h[g - 2] << 8) + h[g - 1], T.push(t[p >> 10] + t[p >> 4 & 63] + t[p << 2 & 63] + \"=\")), T.join(\"\");\n  }\n  return { toByteArray: l, fromByteArray: f };\n};\nfunction Qp(t) {\n  let e = z0(t);\n  return new TextDecoder(\"utf-8\", { fatal: !0 }).decode(e);\n}\nfunction ey(t) {\n  return new TextDecoder(\"utf-8\", { fatal: !0 }).decode(t);\n}\nfunction W0(t) {\n  return new TextEncoder().encode(t);\n}\nfunction ty(t) {\n  return K0(W0(t));\n}\nfunction z0(t) {\n  return new Uint8Array(H0().toByteArray(Y0(t)));\n}\nfunction q0(t) {\n  return H0().fromByteArray(new Uint8Array(t));\n}\nfunction K0(t) {\n  return G0(q0(t));\n}\nfunction G0(t) {\n  return t.replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/\\=/g, \"\");\n}\nfunction Y0(t) {\n  t = t.replace(/\\-/g, \"+\").replace(/\\_/g, \"/\");\n  let e;\n  return t.length % 4 == 0 ? e = 0 : e = 4 - t.length % 4, t.concat(\"=\".repeat(e));\n}\nconst ui = {\n  b64UrlToString: Qp,\n  bufferToString: ey,\n  stringToBuffer: W0,\n  stringToB64Url: ty,\n  b64UrlToBuffer: z0,\n  bufferTob64: q0,\n  bufferTob64Url: K0,\n  b64UrlEncode: G0,\n  b64UrlDecode: Y0\n};\nclass ry {\n  get(e, r) {\n    if (!Object.getOwnPropertyNames(this).includes(e))\n      throw new Error(`Field \"${e}\" is not a property of the Arweave Transaction class.`);\n    return this[e] instanceof Uint8Array ? r && r.decode && r.string ? ui.bufferToString(this[e]) : r && r.decode && !r.string ? this[e] : ui.bufferTob64Url(this[e]) : r && r.decode == !0 ? r && r.string ? ui.b64UrlToString(this[e]) : ui.b64UrlToBuffer(this[e]) : this[e];\n  }\n}\nclass ny extends ry {\n  constructor(e, r, n = !1) {\n    super(), this.name = e, this.value = r;\n  }\n}\nvar ue = typeof globalThis < \"u\" ? globalThis : typeof window < \"u\" ? window : typeof global < \"u\" ? global : typeof self < \"u\" ? self : {};\nfunction iy(t) {\n  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, \"default\") ? t.default : t;\n}\nfunction oy(t) {\n  if (t.__esModule)\n    return t;\n  var e = t.default;\n  if (typeof e == \"function\") {\n    var r = function n() {\n      if (this instanceof n) {\n        var i = [null];\n        i.push.apply(i, arguments);\n        var o = Function.bind.apply(e, i);\n        return new o();\n      }\n      return e.apply(this, arguments);\n    };\n    r.prototype = e.prototype;\n  } else\n    r = {};\n  return Object.defineProperty(r, \"__esModule\", { value: !0 }), Object.keys(t).forEach(function(n) {\n    var i = Object.getOwnPropertyDescriptor(t, n);\n    Object.defineProperty(r, n, i.get ? i : {\n      enumerable: !0,\n      get: function() {\n        return t[n];\n      }\n    });\n  }), r;\n}\nvar ps = {}, ys = {}, ms, Tu;\nfunction Z0() {\n  return Tu || (Tu = 1, ms = function() {\n    if (typeof Symbol != \"function\" || typeof Object.getOwnPropertySymbols != \"function\")\n      return !1;\n    if (typeof Symbol.iterator == \"symbol\")\n      return !0;\n    var e = {}, r = Symbol(\"test\"), n = Object(r);\n    if (typeof r == \"string\" || Object.prototype.toString.call(r) !== \"[object Symbol]\" || Object.prototype.toString.call(n) !== \"[object Symbol]\")\n      return !1;\n    var i = 42;\n    e[r] = i;\n    for (r in e)\n      return !1;\n    if (typeof Object.keys == \"function\" && Object.keys(e).length !== 0 || typeof Object.getOwnPropertyNames == \"function\" && Object.getOwnPropertyNames(e).length !== 0)\n      return !1;\n    var o = Object.getOwnPropertySymbols(e);\n    if (o.length !== 1 || o[0] !== r || !Object.prototype.propertyIsEnumerable.call(e, r))\n      return !1;\n    if (typeof Object.getOwnPropertyDescriptor == \"function\") {\n      var a = Object.getOwnPropertyDescriptor(e, r);\n      if (a.value !== i || a.enumerable !== !0)\n        return !1;\n    }\n    return !0;\n  }), ms;\n}\nvar vs, Eu;\nfunction Mo() {\n  if (Eu)\n    return vs;\n  Eu = 1;\n  var t = Z0();\n  return vs = function() {\n    return t() && !!Symbol.toStringTag;\n  }, vs;\n}\nvar gs, Su;\nfunction sy() {\n  if (Su)\n    return gs;\n  Su = 1;\n  var t = typeof Symbol < \"u\" && Symbol, e = Z0();\n  return gs = function() {\n    return typeof t != \"function\" || typeof Symbol != \"function\" || typeof t(\"foo\") != \"symbol\" || typeof Symbol(\"bar\") != \"symbol\" ? !1 : e();\n  }, gs;\n}\nvar xs, Pu;\nfunction ay() {\n  if (Pu)\n    return xs;\n  Pu = 1;\n  var t = \"Function.prototype.bind called on incompatible \", e = Array.prototype.slice, r = Object.prototype.toString, n = \"[object Function]\";\n  return xs = function(o) {\n    var a = this;\n    if (typeof a != \"function\" || r.call(a) !== n)\n      throw new TypeError(t + a);\n    for (var s = e.call(arguments, 1), l, u = function() {\n      if (this instanceof l) {\n        var g = a.apply(\n          this,\n          s.concat(e.call(arguments))\n        );\n        return Object(g) === g ? g : this;\n      } else\n        return a.apply(\n          o,\n          s.concat(e.call(arguments))\n        );\n    }, c = Math.max(0, a.length - s.length), f = [], h = 0; h < c; h++)\n      f.push(\"$\" + h);\n    if (l = Function(\"binder\", \"return function (\" + f.join(\",\") + \"){ return binder.apply(this,arguments); }\")(u), a.prototype) {\n      var p = function() {\n      };\n      p.prototype = a.prototype, l.prototype = new p(), p.prototype = null;\n    }\n    return l;\n  }, xs;\n}\nvar ws, Cu;\nfunction Xa() {\n  if (Cu)\n    return ws;\n  Cu = 1;\n  var t = ay();\n  return ws = Function.prototype.bind || t, ws;\n}\nvar bs, Ou;\nfunction cy() {\n  if (Ou)\n    return bs;\n  Ou = 1;\n  var t = Xa();\n  return bs = t.call(Function.call, Object.prototype.hasOwnProperty), bs;\n}\nvar _s, Mu;\nfunction Ja() {\n  if (Mu)\n    return _s;\n  Mu = 1;\n  var t, e = SyntaxError, r = Function, n = TypeError, i = function(j) {\n    try {\n      return r('\"use strict\"; return (' + j + \").constructor;\")();\n    } catch {\n    }\n  }, o = Object.getOwnPropertyDescriptor;\n  if (o)\n    try {\n      o({}, \"\");\n    } catch {\n      o = null;\n    }\n  var a = function() {\n    throw new n();\n  }, s = o ? function() {\n    try {\n      return arguments.callee, a;\n    } catch {\n      try {\n        return o(arguments, \"callee\").get;\n      } catch {\n        return a;\n      }\n    }\n  }() : a, l = sy()(), u = Object.getPrototypeOf || function(j) {\n    return j.__proto__;\n  }, c = {}, f = typeof Uint8Array > \"u\" ? t : u(Uint8Array), h = {\n    \"%AggregateError%\": typeof AggregateError > \"u\" ? t : AggregateError,\n    \"%Array%\": Array,\n    \"%ArrayBuffer%\": typeof ArrayBuffer > \"u\" ? t : ArrayBuffer,\n    \"%ArrayIteratorPrototype%\": l ? u([][Symbol.iterator]()) : t,\n    \"%AsyncFromSyncIteratorPrototype%\": t,\n    \"%AsyncFunction%\": c,\n    \"%AsyncGenerator%\": c,\n    \"%AsyncGeneratorFunction%\": c,\n    \"%AsyncIteratorPrototype%\": c,\n    \"%Atomics%\": typeof Atomics > \"u\" ? t : Atomics,\n    \"%BigInt%\": typeof BigInt > \"u\" ? t : BigInt,\n    \"%Boolean%\": Boolean,\n    \"%DataView%\": typeof DataView > \"u\" ? t : DataView,\n    \"%Date%\": Date,\n    \"%decodeURI%\": decodeURI,\n    \"%decodeURIComponent%\": decodeURIComponent,\n    \"%encodeURI%\": encodeURI,\n    \"%encodeURIComponent%\": encodeURIComponent,\n    \"%Error%\": Error,\n    \"%eval%\": eval,\n    // eslint-disable-line no-eval\n    \"%EvalError%\": EvalError,\n    \"%Float32Array%\": typeof Float32Array > \"u\" ? t : Float32Array,\n    \"%Float64Array%\": typeof Float64Array > \"u\" ? t : Float64Array,\n    \"%FinalizationRegistry%\": typeof FinalizationRegistry > \"u\" ? t : FinalizationRegistry,\n    \"%Function%\": r,\n    \"%GeneratorFunction%\": c,\n    \"%Int8Array%\": typeof Int8Array > \"u\" ? t : Int8Array,\n    \"%Int16Array%\": typeof Int16Array > \"u\" ? t : Int16Array,\n    \"%Int32Array%\": typeof Int32Array > \"u\" ? t : Int32Array,\n    \"%isFinite%\": isFinite,\n    \"%isNaN%\": isNaN,\n    \"%IteratorPrototype%\": l ? u(u([][Symbol.iterator]())) : t,\n    \"%JSON%\": typeof JSON == \"object\" ? JSON : t,\n    \"%Map%\": typeof Map > \"u\" ? t : Map,\n    \"%MapIteratorPrototype%\": typeof Map > \"u\" || !l ? t : u((/* @__PURE__ */ new Map())[Symbol.iterator]()),\n    \"%Math%\": Math,\n    \"%Number%\": Number,\n    \"%Object%\": Object,\n    \"%parseFloat%\": parseFloat,\n    \"%parseInt%\": parseInt,\n    \"%Promise%\": typeof Promise > \"u\" ? t : Promise,\n    \"%Proxy%\": typeof Proxy > \"u\" ? t : Proxy,\n    \"%RangeError%\": RangeError,\n    \"%ReferenceError%\": ReferenceError,\n    \"%Reflect%\": typeof Reflect > \"u\" ? t : Reflect,\n    \"%RegExp%\": RegExp,\n    \"%Set%\": typeof Set > \"u\" ? t : Set,\n    \"%SetIteratorPrototype%\": typeof Set > \"u\" || !l ? t : u((/* @__PURE__ */ new Set())[Symbol.iterator]()),\n    \"%SharedArrayBuffer%\": typeof SharedArrayBuffer > \"u\" ? t : SharedArrayBuffer,\n    \"%String%\": String,\n    \"%StringIteratorPrototype%\": l ? u(\"\"[Symbol.iterator]()) : t,\n    \"%Symbol%\": l ? Symbol : t,\n    \"%SyntaxError%\": e,\n    \"%ThrowTypeError%\": s,\n    \"%TypedArray%\": f,\n    \"%TypeError%\": n,\n    \"%Uint8Array%\": typeof Uint8Array > \"u\" ? t : Uint8Array,\n    \"%Uint8ClampedArray%\": typeof Uint8ClampedArray > \"u\" ? t : Uint8ClampedArray,\n    \"%Uint16Array%\": typeof Uint16Array > \"u\" ? t : Uint16Array,\n    \"%Uint32Array%\": typeof Uint32Array > \"u\" ? t : Uint32Array,\n    \"%URIError%\": URIError,\n    \"%WeakMap%\": typeof WeakMap > \"u\" ? t : WeakMap,\n    \"%WeakRef%\": typeof WeakRef > \"u\" ? t : WeakRef,\n    \"%WeakSet%\": typeof WeakSet > \"u\" ? t : WeakSet\n  }, p = function j(P) {\n    var d;\n    if (P === \"%AsyncFunction%\")\n      d = i(\"async function () {}\");\n    else if (P === \"%GeneratorFunction%\")\n      d = i(\"function* () {}\");\n    else if (P === \"%AsyncGeneratorFunction%\")\n      d = i(\"async function* () {}\");\n    else if (P === \"%AsyncGenerator%\") {\n      var x = j(\"%AsyncGeneratorFunction%\");\n      x && (d = x.prototype);\n    } else if (P === \"%AsyncIteratorPrototype%\") {\n      var C = j(\"%AsyncGenerator%\");\n      C && (d = u(C.prototype));\n    }\n    return h[P] = d, d;\n  }, g = {\n    \"%ArrayBufferPrototype%\": [\"ArrayBuffer\", \"prototype\"],\n    \"%ArrayPrototype%\": [\"Array\", \"prototype\"],\n    \"%ArrayProto_entries%\": [\"Array\", \"prototype\", \"entries\"],\n    \"%ArrayProto_forEach%\": [\"Array\", \"prototype\", \"forEach\"],\n    \"%ArrayProto_keys%\": [\"Array\", \"prototype\", \"keys\"],\n    \"%ArrayProto_values%\": [\"Array\", \"prototype\", \"values\"],\n    \"%AsyncFunctionPrototype%\": [\"AsyncFunction\", \"prototype\"],\n    \"%AsyncGenerator%\": [\"AsyncGeneratorFunction\", \"prototype\"],\n    \"%AsyncGeneratorPrototype%\": [\"AsyncGeneratorFunction\", \"prototype\", \"prototype\"],\n    \"%BooleanPrototype%\": [\"Boolean\", \"prototype\"],\n    \"%DataViewPrototype%\": [\"DataView\", \"prototype\"],\n    \"%DatePrototype%\": [\"Date\", \"prototype\"],\n    \"%ErrorPrototype%\": [\"Error\", \"prototype\"],\n    \"%EvalErrorPrototype%\": [\"EvalError\", \"prototype\"],\n    \"%Float32ArrayPrototype%\": [\"Float32Array\", \"prototype\"],\n    \"%Float64ArrayPrototype%\": [\"Float64Array\", \"prototype\"],\n    \"%FunctionPrototype%\": [\"Function\", \"prototype\"],\n    \"%Generator%\": [\"GeneratorFunction\", \"prototype\"],\n    \"%GeneratorPrototype%\": [\"GeneratorFunction\", \"prototype\", \"prototype\"],\n    \"%Int8ArrayPrototype%\": [\"Int8Array\", \"prototype\"],\n    \"%Int16ArrayPrototype%\": [\"Int16Array\", \"prototype\"],\n    \"%Int32ArrayPrototype%\": [\"Int32Array\", \"prototype\"],\n    \"%JSONParse%\": [\"JSON\", \"parse\"],\n    \"%JSONStringify%\": [\"JSON\", \"stringify\"],\n    \"%MapPrototype%\": [\"Map\", \"prototype\"],\n    \"%NumberPrototype%\": [\"Number\", \"prototype\"],\n    \"%ObjectPrototype%\": [\"Object\", \"prototype\"],\n    \"%ObjProto_toString%\": [\"Object\", \"prototype\", \"toString\"],\n    \"%ObjProto_valueOf%\": [\"Object\", \"prototype\", \"valueOf\"],\n    \"%PromisePrototype%\": [\"Promise\", \"prototype\"],\n    \"%PromiseProto_then%\": [\"Promise\", \"prototype\", \"then\"],\n    \"%Promise_all%\": [\"Promise\", \"all\"],\n    \"%Promise_reject%\": [\"Promise\", \"reject\"],\n    \"%Promise_resolve%\": [\"Promise\", \"resolve\"],\n    \"%RangeErrorPrototype%\": [\"RangeError\", \"prototype\"],\n    \"%ReferenceErrorPrototype%\": [\"ReferenceError\", \"prototype\"],\n    \"%RegExpPrototype%\": [\"RegExp\", \"prototype\"],\n    \"%SetPrototype%\": [\"Set\", \"prototype\"],\n    \"%SharedArrayBufferPrototype%\": [\"SharedArrayBuffer\", \"prototype\"],\n    \"%StringPrototype%\": [\"String\", \"prototype\"],\n    \"%SymbolPrototype%\": [\"Symbol\", \"prototype\"],\n    \"%SyntaxErrorPrototype%\": [\"SyntaxError\", \"prototype\"],\n    \"%TypedArrayPrototype%\": [\"TypedArray\", \"prototype\"],\n    \"%TypeErrorPrototype%\": [\"TypeError\", \"prototype\"],\n    \"%Uint8ArrayPrototype%\": [\"Uint8Array\", \"prototype\"],\n    \"%Uint8ClampedArrayPrototype%\": [\"Uint8ClampedArray\", \"prototype\"],\n    \"%Uint16ArrayPrototype%\": [\"Uint16Array\", \"prototype\"],\n    \"%Uint32ArrayPrototype%\": [\"Uint32Array\", \"prototype\"],\n    \"%URIErrorPrototype%\": [\"URIError\", \"prototype\"],\n    \"%WeakMapPrototype%\": [\"WeakMap\", \"prototype\"],\n    \"%WeakSetPrototype%\": [\"WeakSet\", \"prototype\"]\n  }, _ = Xa(), T = cy(), A = _.call(Function.call, Array.prototype.concat), w = _.call(Function.apply, Array.prototype.splice), O = _.call(Function.call, String.prototype.replace), R = _.call(Function.call, String.prototype.slice), $ = _.call(Function.call, RegExp.prototype.exec), U = /[^%.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|%$))/g, W = /\\\\(\\\\)?/g, G = function(P) {\n    var d = R(P, 0, 1), x = R(P, -1);\n    if (d === \"%\" && x !== \"%\")\n      throw new e(\"invalid intrinsic syntax, expected closing `%`\");\n    if (x === \"%\" && d !== \"%\")\n      throw new e(\"invalid intrinsic syntax, expected opening `%`\");\n    var C = [];\n    return O(P, U, function(M, D, z, Y) {\n      C[C.length] = z ? O(Y, W, \"$1\") : D || M;\n    }), C;\n  }, Z = function(P, d) {\n    var x = P, C;\n    if (T(g, x) && (C = g[x], x = \"%\" + C[0] + \"%\"), T(h, x)) {\n      var M = h[x];\n      if (M === c && (M = p(x)), typeof M > \"u\" && !d)\n        throw new n(\"intrinsic \" + P + \" exists, but is not available. Please file an issue!\");\n      return {\n        alias: C,\n        name: x,\n        value: M\n      };\n    }\n    throw new e(\"intrinsic \" + P + \" does not exist!\");\n  };\n  return _s = function(P, d) {\n    if (typeof P != \"string\" || P.length === 0)\n      throw new n(\"intrinsic name must be a non-empty string\");\n    if (arguments.length > 1 && typeof d != \"boolean\")\n      throw new n('\"allowMissing\" argument must be a boolean');\n    if ($(/^%?[^%]*%?$/, P) === null)\n      throw new e(\"`%` may not be present anywhere but at the beginning and end of the intrinsic name\");\n    var x = G(P), C = x.length > 0 ? x[0] : \"\", M = Z(\"%\" + C + \"%\", d), D = M.name, z = M.value, Y = !1, L = M.alias;\n    L && (C = L[0], w(x, A([0, 1], L)));\n    for (var m = 1, E = !0; m < x.length; m += 1) {\n      var B = x[m], V = R(B, 0, 1), I = R(B, -1);\n      if ((V === '\"' || V === \"'\" || V === \"`\" || I === '\"' || I === \"'\" || I === \"`\") && V !== I)\n        throw new e(\"property names with quotes must have matching quotes\");\n      if ((B === \"constructor\" || !E) && (Y = !0), C += \".\" + B, D = \"%\" + C + \"%\", T(h, D))\n        z = h[D];\n      else if (z != null) {\n        if (!(B in z)) {\n          if (!d)\n            throw new n(\"base intrinsic for \" + P + \" exists, but the property is not available.\");\n          return;\n        }\n        if (o && m + 1 >= x.length) {\n          var ne = o(z, B);\n          E = !!ne, E && \"get\" in ne && !(\"originalValue\" in ne.get) ? z = ne.get : z = z[B];\n        } else\n          E = T(z, B), z = z[B];\n        E && !Y && (h[D] = z);\n      }\n    }\n    return z;\n  }, _s;\n}\nvar Ci = {}, uy = {\n  get exports() {\n    return Ci;\n  },\n  set exports(t) {\n    Ci = t;\n  }\n}, ku;\nfunction ly() {\n  return ku || (ku = 1, function(t) {\n    var e = Xa(), r = Ja(), n = r(\"%Function.prototype.apply%\"), i = r(\"%Function.prototype.call%\"), o = r(\"%Reflect.apply%\", !0) || e.call(i, n), a = r(\"%Object.getOwnPropertyDescriptor%\", !0), s = r(\"%Object.defineProperty%\", !0), l = r(\"%Math.max%\");\n    if (s)\n      try {\n        s({}, \"a\", { value: 1 });\n      } catch {\n        s = null;\n      }\n    t.exports = function(f) {\n      var h = o(e, i, arguments);\n      if (a && s) {\n        var p = a(h, \"length\");\n        p.configurable && s(\n          h,\n          \"length\",\n          { value: 1 + l(0, f.length - (arguments.length - 1)) }\n        );\n      }\n      return h;\n    };\n    var u = function() {\n      return o(e, n, arguments);\n    };\n    s ? s(t.exports, \"apply\", { value: u }) : t.exports.apply = u;\n  }(uy)), Ci;\n}\nvar As, Ru;\nfunction Qa() {\n  if (Ru)\n    return As;\n  Ru = 1;\n  var t = Ja(), e = ly(), r = e(t(\"String.prototype.indexOf\"));\n  return As = function(i, o) {\n    var a = t(i, !!o);\n    return typeof a == \"function\" && r(i, \".prototype.\") > -1 ? e(a) : a;\n  }, As;\n}\nvar Ts, Bu;\nfunction fy() {\n  if (Bu)\n    return Ts;\n  Bu = 1;\n  var t = Mo()(), e = Qa(), r = e(\"Object.prototype.toString\"), n = function(s) {\n    return t && s && typeof s == \"object\" && Symbol.toStringTag in s ? !1 : r(s) === \"[object Arguments]\";\n  }, i = function(s) {\n    return n(s) ? !0 : s !== null && typeof s == \"object\" && typeof s.length == \"number\" && s.length >= 0 && r(s) !== \"[object Array]\" && r(s.callee) === \"[object Function]\";\n  }, o = function() {\n    return n(arguments);\n  }();\n  return n.isLegacyArguments = i, Ts = o ? n : i, Ts;\n}\nvar Es, Iu;\nfunction hy() {\n  if (Iu)\n    return Es;\n  Iu = 1;\n  var t = Object.prototype.toString, e = Function.prototype.toString, r = /^\\s*(?:function)?\\*/, n = Mo()(), i = Object.getPrototypeOf, o = function() {\n    if (!n)\n      return !1;\n    try {\n      return Function(\"return function*() {}\")();\n    } catch {\n    }\n  }, a;\n  return Es = function(l) {\n    if (typeof l != \"function\")\n      return !1;\n    if (r.test(e.call(l)))\n      return !0;\n    if (!n) {\n      var u = t.call(l);\n      return u === \"[object GeneratorFunction]\";\n    }\n    if (!i)\n      return !1;\n    if (typeof a > \"u\") {\n      var c = o();\n      a = c ? i(c) : !1;\n    }\n    return i(l) === a;\n  }, Es;\n}\nvar Ss, Du;\nfunction dy() {\n  if (Du)\n    return Ss;\n  Du = 1;\n  var t = Function.prototype.toString, e = typeof Reflect == \"object\" && Reflect !== null && Reflect.apply, r, n;\n  if (typeof e == \"function\" && typeof Object.defineProperty == \"function\")\n    try {\n      r = Object.defineProperty({}, \"length\", {\n        get: function() {\n          throw n;\n        }\n      }), n = {}, e(function() {\n        throw 42;\n      }, null, r);\n    } catch (w) {\n      w !== n && (e = null);\n    }\n  else\n    e = null;\n  var i = /^\\s*class\\b/, o = function(O) {\n    try {\n      var R = t.call(O);\n      return i.test(R);\n    } catch {\n      return !1;\n    }\n  }, a = function(O) {\n    try {\n      return o(O) ? !1 : (t.call(O), !0);\n    } catch {\n      return !1;\n    }\n  }, s = Object.prototype.toString, l = \"[object Object]\", u = \"[object Function]\", c = \"[object GeneratorFunction]\", f = \"[object HTMLAllCollection]\", h = \"[object HTML document.all class]\", p = \"[object HTMLCollection]\", g = typeof Symbol == \"function\" && !!Symbol.toStringTag, _ = !(0 in [,]), T = function() {\n    return !1;\n  };\n  if (typeof document == \"object\") {\n    var A = document.all;\n    s.call(A) === s.call(document.all) && (T = function(O) {\n      if ((_ || !O) && (typeof O > \"u\" || typeof O == \"object\"))\n        try {\n          var R = s.call(O);\n          return (R === f || R === h || R === p || R === l) && O(\"\") == null;\n        } catch {\n        }\n      return !1;\n    });\n  }\n  return Ss = e ? function(O) {\n    if (T(O))\n      return !0;\n    if (!O || typeof O != \"function\" && typeof O != \"object\")\n      return !1;\n    try {\n      e(O, null, r);\n    } catch (R) {\n      if (R !== n)\n        return !1;\n    }\n    return !o(O) && a(O);\n  } : function(O) {\n    if (T(O))\n      return !0;\n    if (!O || typeof O != \"function\" && typeof O != \"object\")\n      return !1;\n    if (g)\n      return a(O);\n    if (o(O))\n      return !1;\n    var R = s.call(O);\n    return R !== u && R !== c && !/^\\[object HTML/.test(R) ? !1 : a(O);\n  }, Ss;\n}\nvar Ps, Nu;\nfunction X0() {\n  if (Nu)\n    return Ps;\n  Nu = 1;\n  var t = dy(), e = Object.prototype.toString, r = Object.prototype.hasOwnProperty, n = function(l, u, c) {\n    for (var f = 0, h = l.length; f < h; f++)\n      r.call(l, f) && (c == null ? u(l[f], f, l) : u.call(c, l[f], f, l));\n  }, i = function(l, u, c) {\n    for (var f = 0, h = l.length; f < h; f++)\n      c == null ? u(l.charAt(f), f, l) : u.call(c, l.charAt(f), f, l);\n  }, o = function(l, u, c) {\n    for (var f in l)\n      r.call(l, f) && (c == null ? u(l[f], f, l) : u.call(c, l[f], f, l));\n  }, a = function(l, u, c) {\n    if (!t(u))\n      throw new TypeError(\"iterator must be a function\");\n    var f;\n    arguments.length >= 3 && (f = c), e.call(l) === \"[object Array]\" ? n(l, u, f) : typeof l == \"string\" ? i(l, u, f) : o(l, u, f);\n  };\n  return Ps = a, Ps;\n}\nvar Cs, Fu;\nfunction J0() {\n  if (Fu)\n    return Cs;\n  Fu = 1;\n  var t = [\n    \"BigInt64Array\",\n    \"BigUint64Array\",\n    \"Float32Array\",\n    \"Float64Array\",\n    \"Int16Array\",\n    \"Int32Array\",\n    \"Int8Array\",\n    \"Uint16Array\",\n    \"Uint32Array\",\n    \"Uint8Array\",\n    \"Uint8ClampedArray\"\n  ], e = typeof globalThis > \"u\" ? ue : globalThis;\n  return Cs = function() {\n    for (var n = [], i = 0; i < t.length; i++)\n      typeof e[t[i]] == \"function\" && (n[n.length] = t[i]);\n    return n;\n  }, Cs;\n}\nvar Os, Lu;\nfunction Q0() {\n  if (Lu)\n    return Os;\n  Lu = 1;\n  var t = Ja(), e = t(\"%Object.getOwnPropertyDescriptor%\", !0);\n  if (e)\n    try {\n      e([], \"length\");\n    } catch {\n      e = null;\n    }\n  return Os = e, Os;\n}\nvar Ms, ju;\nfunction eh() {\n  if (ju)\n    return Ms;\n  ju = 1;\n  var t = X0(), e = J0(), r = Qa(), n = r(\"Object.prototype.toString\"), i = Mo()(), o = Q0(), a = typeof globalThis > \"u\" ? ue : globalThis, s = e(), l = r(\"Array.prototype.indexOf\", !0) || function(g, _) {\n    for (var T = 0; T < g.length; T += 1)\n      if (g[T] === _)\n        return T;\n    return -1;\n  }, u = r(\"String.prototype.slice\"), c = {}, f = Object.getPrototypeOf;\n  i && o && f && t(s, function(p) {\n    var g = new a[p]();\n    if (Symbol.toStringTag in g) {\n      var _ = f(g), T = o(_, Symbol.toStringTag);\n      if (!T) {\n        var A = f(_);\n        T = o(A, Symbol.toStringTag);\n      }\n      c[p] = T.get;\n    }\n  });\n  var h = function(g) {\n    var _ = !1;\n    return t(c, function(T, A) {\n      if (!_)\n        try {\n          _ = T.call(g) === A;\n        } catch {\n        }\n    }), _;\n  };\n  return Ms = function(g) {\n    if (!g || typeof g != \"object\")\n      return !1;\n    if (!i || !(Symbol.toStringTag in g)) {\n      var _ = u(n(g), 8, -1);\n      return l(s, _) > -1;\n    }\n    return o ? h(g) : !1;\n  }, Ms;\n}\nvar ks, Uu;\nfunction py() {\n  if (Uu)\n    return ks;\n  Uu = 1;\n  var t = X0(), e = J0(), r = Qa(), n = Q0(), i = r(\"Object.prototype.toString\"), o = Mo()(), a = typeof globalThis > \"u\" ? ue : globalThis, s = e(), l = r(\"String.prototype.slice\"), u = {}, c = Object.getPrototypeOf;\n  o && n && c && t(s, function(p) {\n    if (typeof a[p] == \"function\") {\n      var g = new a[p]();\n      if (Symbol.toStringTag in g) {\n        var _ = c(g), T = n(_, Symbol.toStringTag);\n        if (!T) {\n          var A = c(_);\n          T = n(A, Symbol.toStringTag);\n        }\n        u[p] = T.get;\n      }\n    }\n  });\n  var f = function(g) {\n    var _ = !1;\n    return t(u, function(T, A) {\n      if (!_)\n        try {\n          var w = T.call(g);\n          w === A && (_ = w);\n        } catch {\n        }\n    }), _;\n  }, h = eh();\n  return ks = function(g) {\n    return h(g) ? !o || !(Symbol.toStringTag in g) ? l(i(g), 8, -1) : f(g) : !1;\n  }, ks;\n}\nvar Vu;\nfunction yy() {\n  return Vu || (Vu = 1, function(t) {\n    var e = fy(), r = hy(), n = py(), i = eh();\n    function o(b) {\n      return b.call.bind(b);\n    }\n    var a = typeof BigInt < \"u\", s = typeof Symbol < \"u\", l = o(Object.prototype.toString), u = o(Number.prototype.valueOf), c = o(String.prototype.valueOf), f = o(Boolean.prototype.valueOf);\n    if (a)\n      var h = o(BigInt.prototype.valueOf);\n    if (s)\n      var p = o(Symbol.prototype.valueOf);\n    function g(b, F) {\n      if (typeof b != \"object\")\n        return !1;\n      try {\n        return F(b), !0;\n      } catch {\n        return !1;\n      }\n    }\n    t.isArgumentsObject = e, t.isGeneratorFunction = r, t.isTypedArray = i;\n    function _(b) {\n      return typeof Promise < \"u\" && b instanceof Promise || b !== null && typeof b == \"object\" && typeof b.then == \"function\" && typeof b.catch == \"function\";\n    }\n    t.isPromise = _;\n    function T(b) {\n      return typeof ArrayBuffer < \"u\" && ArrayBuffer.isView ? ArrayBuffer.isView(b) : i(b) || V(b);\n    }\n    t.isArrayBufferView = T;\n    function A(b) {\n      return n(b) === \"Uint8Array\";\n    }\n    t.isUint8Array = A;\n    function w(b) {\n      return n(b) === \"Uint8ClampedArray\";\n    }\n    t.isUint8ClampedArray = w;\n    function O(b) {\n      return n(b) === \"Uint16Array\";\n    }\n    t.isUint16Array = O;\n    function R(b) {\n      return n(b) === \"Uint32Array\";\n    }\n    t.isUint32Array = R;\n    function $(b) {\n      return n(b) === \"Int8Array\";\n    }\n    t.isInt8Array = $;\n    function U(b) {\n      return n(b) === \"Int16Array\";\n    }\n    t.isInt16Array = U;\n    function W(b) {\n      return n(b) === \"Int32Array\";\n    }\n    t.isInt32Array = W;\n    function G(b) {\n      return n(b) === \"Float32Array\";\n    }\n    t.isFloat32Array = G;\n    function Z(b) {\n      return n(b) === \"Float64Array\";\n    }\n    t.isFloat64Array = Z;\n    function j(b) {\n      return n(b) === \"BigInt64Array\";\n    }\n    t.isBigInt64Array = j;\n    function P(b) {\n      return n(b) === \"BigUint64Array\";\n    }\n    t.isBigUint64Array = P;\n    function d(b) {\n      return l(b) === \"[object Map]\";\n    }\n    d.working = typeof Map < \"u\" && d(/* @__PURE__ */ new Map());\n    function x(b) {\n      return typeof Map > \"u\" ? !1 : d.working ? d(b) : b instanceof Map;\n    }\n    t.isMap = x;\n    function C(b) {\n      return l(b) === \"[object Set]\";\n    }\n    C.working = typeof Set < \"u\" && C(/* @__PURE__ */ new Set());\n    function M(b) {\n      return typeof Set > \"u\" ? !1 : C.working ? C(b) : b instanceof Set;\n    }\n    t.isSet = M;\n    function D(b) {\n      return l(b) === \"[object WeakMap]\";\n    }\n    D.working = typeof WeakMap < \"u\" && D(/* @__PURE__ */ new WeakMap());\n    function z(b) {\n      return typeof WeakMap > \"u\" ? !1 : D.working ? D(b) : b instanceof WeakMap;\n    }\n    t.isWeakMap = z;\n    function Y(b) {\n      return l(b) === \"[object WeakSet]\";\n    }\n    Y.working = typeof WeakSet < \"u\" && Y(/* @__PURE__ */ new WeakSet());\n    function L(b) {\n      return Y(b);\n    }\n    t.isWeakSet = L;\n    function m(b) {\n      return l(b) === \"[object ArrayBuffer]\";\n    }\n    m.working = typeof ArrayBuffer < \"u\" && m(new ArrayBuffer());\n    function E(b) {\n      return typeof ArrayBuffer > \"u\" ? !1 : m.working ? m(b) : b instanceof ArrayBuffer;\n    }\n    t.isArrayBuffer = E;\n    function B(b) {\n      return l(b) === \"[object DataView]\";\n    }\n    B.working = typeof ArrayBuffer < \"u\" && typeof DataView < \"u\" && B(new DataView(new ArrayBuffer(1), 0, 1));\n    function V(b) {\n      return typeof DataView > \"u\" ? !1 : B.working ? B(b) : b instanceof DataView;\n    }\n    t.isDataView = V;\n    var I = typeof SharedArrayBuffer < \"u\" ? SharedArrayBuffer : void 0;\n    function ne(b) {\n      return l(b) === \"[object SharedArrayBuffer]\";\n    }\n    function se(b) {\n      return typeof I > \"u\" ? !1 : (typeof ne.working > \"u\" && (ne.working = ne(new I())), ne.working ? ne(b) : b instanceof I);\n    }\n    t.isSharedArrayBuffer = se;\n    function ce(b) {\n      return l(b) === \"[object AsyncFunction]\";\n    }\n    t.isAsyncFunction = ce;\n    function oe(b) {\n      return l(b) === \"[object Map Iterator]\";\n    }\n    t.isMapIterator = oe;\n    function he(b) {\n      return l(b) === \"[object Set Iterator]\";\n    }\n    t.isSetIterator = he;\n    function k(b) {\n      return l(b) === \"[object Generator]\";\n    }\n    t.isGeneratorObject = k;\n    function H(b) {\n      return l(b) === \"[object WebAssembly.Module]\";\n    }\n    t.isWebAssemblyCompiledModule = H;\n    function N(b) {\n      return g(b, u);\n    }\n    t.isNumberObject = N;\n    function J(b) {\n      return g(b, c);\n    }\n    t.isStringObject = J;\n    function Q(b) {\n      return g(b, f);\n    }\n    t.isBooleanObject = Q;\n    function ee(b) {\n      return a && g(b, h);\n    }\n    t.isBigIntObject = ee;\n    function S(b) {\n      return s && g(b, p);\n    }\n    t.isSymbolObject = S;\n    function y(b) {\n      return N(b) || J(b) || Q(b) || ee(b) || S(b);\n    }\n    t.isBoxedPrimitive = y;\n    function v(b) {\n      return typeof Uint8Array < \"u\" && (E(b) || se(b));\n    }\n    t.isAnyArrayBuffer = v, [\"isProxy\", \"isExternal\", \"isModuleNamespaceObject\"].forEach(function(b) {\n      Object.defineProperty(t, b, {\n        enumerable: !1,\n        value: function() {\n          throw new Error(b + \" is not supported in userland\");\n        }\n      });\n    });\n  }(ys)), ys;\n}\nvar Rs, $u;\nfunction my() {\n  return $u || ($u = 1, Rs = function(e) {\n    return e && typeof e == \"object\" && typeof e.copy == \"function\" && typeof e.fill == \"function\" && typeof e.readUInt8 == \"function\";\n  }), Rs;\n}\nvar Oi = {}, Hu = {\n  get exports() {\n    return Oi;\n  },\n  set exports(t) {\n    Oi = t;\n  }\n}, Wu;\nfunction Tr() {\n  return Wu || (Wu = 1, typeof Object.create == \"function\" ? Hu.exports = function(e, r) {\n    r && (e.super_ = r, e.prototype = Object.create(r.prototype, {\n      constructor: {\n        value: e,\n        enumerable: !1,\n        writable: !0,\n        configurable: !0\n      }\n    }));\n  } : Hu.exports = function(e, r) {\n    if (r) {\n      e.super_ = r;\n      var n = function() {\n      };\n      n.prototype = r.prototype, e.prototype = new n(), e.prototype.constructor = e;\n    }\n  }), Oi;\n}\nvar zu;\nfunction ec() {\n  return zu || (zu = 1, function(t) {\n    var e = Object.getOwnPropertyDescriptors || function(V) {\n      for (var I = Object.keys(V), ne = {}, se = 0; se < I.length; se++)\n        ne[I[se]] = Object.getOwnPropertyDescriptor(V, I[se]);\n      return ne;\n    }, r = /%[sdj%]/g;\n    t.format = function(B) {\n      if (!$(B)) {\n        for (var V = [], I = 0; I < arguments.length; I++)\n          V.push(a(arguments[I]));\n        return V.join(\" \");\n      }\n      for (var I = 1, ne = arguments, se = ne.length, ce = String(B).replace(r, function(he) {\n        if (he === \"%%\")\n          return \"%\";\n        if (I >= se)\n          return he;\n        switch (he) {\n          case \"%s\":\n            return String(ne[I++]);\n          case \"%d\":\n            return Number(ne[I++]);\n          case \"%j\":\n            try {\n              return JSON.stringify(ne[I++]);\n            } catch {\n              return \"[Circular]\";\n            }\n          default:\n            return he;\n        }\n      }), oe = ne[I]; I < se; oe = ne[++I])\n        w(oe) || !Z(oe) ? ce += \" \" + oe : ce += \" \" + a(oe);\n      return ce;\n    }, t.deprecate = function(B, V) {\n      if (typeof process < \"u\" && process.noDeprecation === !0)\n        return B;\n      if (typeof process > \"u\")\n        return function() {\n          return t.deprecate(B, V).apply(this, arguments);\n        };\n      var I = !1;\n      function ne() {\n        if (!I) {\n          if (process.throwDeprecation)\n            throw new Error(V);\n          process.traceDeprecation ? console.trace(V) : console.error(V), I = !0;\n        }\n        return B.apply(this, arguments);\n      }\n      return ne;\n    };\n    var n = {}, i = /^$/;\n    if (process.env.NODE_DEBUG) {\n      var o = process.env.NODE_DEBUG;\n      o = o.replace(/[|\\\\{}()[\\]^$+?.]/g, \"\\\\$&\").replace(/\\*/g, \".*\").replace(/,/g, \"$|^\").toUpperCase(), i = new RegExp(\"^\" + o + \"$\", \"i\");\n    }\n    t.debuglog = function(B) {\n      if (B = B.toUpperCase(), !n[B])\n        if (i.test(B)) {\n          var V = process.pid;\n          n[B] = function() {\n            var I = t.format.apply(t, arguments);\n            console.error(\"%s %d: %s\", B, V, I);\n          };\n        } else\n          n[B] = function() {\n          };\n      return n[B];\n    };\n    function a(B, V) {\n      var I = {\n        seen: [],\n        stylize: l\n      };\n      return arguments.length >= 3 && (I.depth = arguments[2]), arguments.length >= 4 && (I.colors = arguments[3]), A(V) ? I.showHidden = V : V && t._extend(I, V), W(I.showHidden) && (I.showHidden = !1), W(I.depth) && (I.depth = 2), W(I.colors) && (I.colors = !1), W(I.customInspect) && (I.customInspect = !0), I.colors && (I.stylize = s), c(I, B, I.depth);\n    }\n    t.inspect = a, a.colors = {\n      bold: [1, 22],\n      italic: [3, 23],\n      underline: [4, 24],\n      inverse: [7, 27],\n      white: [37, 39],\n      grey: [90, 39],\n      black: [30, 39],\n      blue: [34, 39],\n      cyan: [36, 39],\n      green: [32, 39],\n      magenta: [35, 39],\n      red: [31, 39],\n      yellow: [33, 39]\n    }, a.styles = {\n      special: \"cyan\",\n      number: \"yellow\",\n      boolean: \"yellow\",\n      undefined: \"grey\",\n      null: \"bold\",\n      string: \"green\",\n      date: \"magenta\",\n      // \"name\": intentionally not styling\n      regexp: \"red\"\n    };\n    function s(B, V) {\n      var I = a.styles[V];\n      return I ? \"\\x1B[\" + a.colors[I][0] + \"m\" + B + \"\\x1B[\" + a.colors[I][1] + \"m\" : B;\n    }\n    function l(B, V) {\n      return B;\n    }\n    function u(B) {\n      var V = {};\n      return B.forEach(function(I, ne) {\n        V[I] = !0;\n      }), V;\n    }\n    function c(B, V, I) {\n      if (B.customInspect && V && d(V.inspect) && // Filter out the util module, it's inspect function is special\n      V.inspect !== t.inspect && // Also filter out any prototype objects using the circular check.\n      !(V.constructor && V.constructor.prototype === V)) {\n        var ne = V.inspect(I, B);\n        return $(ne) || (ne = c(B, ne, I)), ne;\n      }\n      var se = f(B, V);\n      if (se)\n        return se;\n      var ce = Object.keys(V), oe = u(ce);\n      if (B.showHidden && (ce = Object.getOwnPropertyNames(V)), P(V) && (ce.indexOf(\"message\") >= 0 || ce.indexOf(\"description\") >= 0))\n        return h(V);\n      if (ce.length === 0) {\n        if (d(V)) {\n          var he = V.name ? \": \" + V.name : \"\";\n          return B.stylize(\"[Function\" + he + \"]\", \"special\");\n        }\n        if (G(V))\n          return B.stylize(RegExp.prototype.toString.call(V), \"regexp\");\n        if (j(V))\n          return B.stylize(Date.prototype.toString.call(V), \"date\");\n        if (P(V))\n          return h(V);\n      }\n      var k = \"\", H = !1, N = [\"{\", \"}\"];\n      if (T(V) && (H = !0, N = [\"[\", \"]\"]), d(V)) {\n        var J = V.name ? \": \" + V.name : \"\";\n        k = \" [Function\" + J + \"]\";\n      }\n      if (G(V) && (k = \" \" + RegExp.prototype.toString.call(V)), j(V) && (k = \" \" + Date.prototype.toUTCString.call(V)), P(V) && (k = \" \" + h(V)), ce.length === 0 && (!H || V.length == 0))\n        return N[0] + k + N[1];\n      if (I < 0)\n        return G(V) ? B.stylize(RegExp.prototype.toString.call(V), \"regexp\") : B.stylize(\"[Object]\", \"special\");\n      B.seen.push(V);\n      var Q;\n      return H ? Q = p(B, V, I, oe, ce) : Q = ce.map(function(ee) {\n        return g(B, V, I, oe, ee, H);\n      }), B.seen.pop(), _(Q, k, N);\n    }\n    function f(B, V) {\n      if (W(V))\n        return B.stylize(\"undefined\", \"undefined\");\n      if ($(V)) {\n        var I = \"'\" + JSON.stringify(V).replace(/^\"|\"$/g, \"\").replace(/'/g, \"\\\\'\").replace(/\\\\\"/g, '\"') + \"'\";\n        return B.stylize(I, \"string\");\n      }\n      if (R(V))\n        return B.stylize(\"\" + V, \"number\");\n      if (A(V))\n        return B.stylize(\"\" + V, \"boolean\");\n      if (w(V))\n        return B.stylize(\"null\", \"null\");\n    }\n    function h(B) {\n      return \"[\" + Error.prototype.toString.call(B) + \"]\";\n    }\n    function p(B, V, I, ne, se) {\n      for (var ce = [], oe = 0, he = V.length; oe < he; ++oe)\n        Y(V, String(oe)) ? ce.push(g(\n          B,\n          V,\n          I,\n          ne,\n          String(oe),\n          !0\n        )) : ce.push(\"\");\n      return se.forEach(function(k) {\n        k.match(/^\\d+$/) || ce.push(g(\n          B,\n          V,\n          I,\n          ne,\n          k,\n          !0\n        ));\n      }), ce;\n    }\n    function g(B, V, I, ne, se, ce) {\n      var oe, he, k;\n      if (k = Object.getOwnPropertyDescriptor(V, se) || { value: V[se] }, k.get ? k.set ? he = B.stylize(\"[Getter/Setter]\", \"special\") : he = B.stylize(\"[Getter]\", \"special\") : k.set && (he = B.stylize(\"[Setter]\", \"special\")), Y(ne, se) || (oe = \"[\" + se + \"]\"), he || (B.seen.indexOf(k.value) < 0 ? (w(I) ? he = c(B, k.value, null) : he = c(B, k.value, I - 1), he.indexOf(`\n`) > -1 && (ce ? he = he.split(`\n`).map(function(H) {\n        return \"  \" + H;\n      }).join(`\n`).slice(2) : he = `\n` + he.split(`\n`).map(function(H) {\n        return \"   \" + H;\n      }).join(`\n`))) : he = B.stylize(\"[Circular]\", \"special\")), W(oe)) {\n        if (ce && se.match(/^\\d+$/))\n          return he;\n        oe = JSON.stringify(\"\" + se), oe.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/) ? (oe = oe.slice(1, -1), oe = B.stylize(oe, \"name\")) : (oe = oe.replace(/'/g, \"\\\\'\").replace(/\\\\\"/g, '\"').replace(/(^\"|\"$)/g, \"'\"), oe = B.stylize(oe, \"string\"));\n      }\n      return oe + \": \" + he;\n    }\n    function _(B, V, I) {\n      var ne = B.reduce(function(se, ce) {\n        return ce.indexOf(`\n`) >= 0, se + ce.replace(/\\u001b\\[\\d\\d?m/g, \"\").length + 1;\n      }, 0);\n      return ne > 60 ? I[0] + (V === \"\" ? \"\" : V + `\n `) + \" \" + B.join(`,\n  `) + \" \" + I[1] : I[0] + V + \" \" + B.join(\", \") + \" \" + I[1];\n    }\n    t.types = yy();\n    function T(B) {\n      return Array.isArray(B);\n    }\n    t.isArray = T;\n    function A(B) {\n      return typeof B == \"boolean\";\n    }\n    t.isBoolean = A;\n    function w(B) {\n      return B === null;\n    }\n    t.isNull = w;\n    function O(B) {\n      return B == null;\n    }\n    t.isNullOrUndefined = O;\n    function R(B) {\n      return typeof B == \"number\";\n    }\n    t.isNumber = R;\n    function $(B) {\n      return typeof B == \"string\";\n    }\n    t.isString = $;\n    function U(B) {\n      return typeof B == \"symbol\";\n    }\n    t.isSymbol = U;\n    function W(B) {\n      return B === void 0;\n    }\n    t.isUndefined = W;\n    function G(B) {\n      return Z(B) && C(B) === \"[object RegExp]\";\n    }\n    t.isRegExp = G, t.types.isRegExp = G;\n    function Z(B) {\n      return typeof B == \"object\" && B !== null;\n    }\n    t.isObject = Z;\n    function j(B) {\n      return Z(B) && C(B) === \"[object Date]\";\n    }\n    t.isDate = j, t.types.isDate = j;\n    function P(B) {\n      return Z(B) && (C(B) === \"[object Error]\" || B instanceof Error);\n    }\n    t.isError = P, t.types.isNativeError = P;\n    function d(B) {\n      return typeof B == \"function\";\n    }\n    t.isFunction = d;\n    function x(B) {\n      return B === null || typeof B == \"boolean\" || typeof B == \"number\" || typeof B == \"string\" || typeof B == \"symbol\" || // ES6 symbol\n      typeof B > \"u\";\n    }\n    t.isPrimitive = x, t.isBuffer = my();\n    function C(B) {\n      return Object.prototype.toString.call(B);\n    }\n    function M(B) {\n      return B < 10 ? \"0\" + B.toString(10) : B.toString(10);\n    }\n    var D = [\n      \"Jan\",\n      \"Feb\",\n      \"Mar\",\n      \"Apr\",\n      \"May\",\n      \"Jun\",\n      \"Jul\",\n      \"Aug\",\n      \"Sep\",\n      \"Oct\",\n      \"Nov\",\n      \"Dec\"\n    ];\n    function z() {\n      var B = new Date(), V = [\n        M(B.getHours()),\n        M(B.getMinutes()),\n        M(B.getSeconds())\n      ].join(\":\");\n      return [B.getDate(), D[B.getMonth()], V].join(\" \");\n    }\n    t.log = function() {\n      console.log(\"%s - %s\", z(), t.format.apply(t, arguments));\n    }, t.inherits = Tr(), t._extend = function(B, V) {\n      if (!V || !Z(V))\n        return B;\n      for (var I = Object.keys(V), ne = I.length; ne--; )\n        B[I[ne]] = V[I[ne]];\n      return B;\n    };\n    function Y(B, V) {\n      return Object.prototype.hasOwnProperty.call(B, V);\n    }\n    var L = typeof Symbol < \"u\" ? Symbol(\"util.promisify.custom\") : void 0;\n    t.promisify = function(V) {\n      if (typeof V != \"function\")\n        throw new TypeError('The \"original\" argument must be of type Function');\n      if (L && V[L]) {\n        var I = V[L];\n        if (typeof I != \"function\")\n          throw new TypeError('The \"util.promisify.custom\" argument must be of type Function');\n        return Object.defineProperty(I, L, {\n          value: I,\n          enumerable: !1,\n          writable: !1,\n          configurable: !0\n        }), I;\n      }\n      function I() {\n        for (var ne, se, ce = new Promise(function(k, H) {\n          ne = k, se = H;\n        }), oe = [], he = 0; he < arguments.length; he++)\n          oe.push(arguments[he]);\n        oe.push(function(k, H) {\n          k ? se(k) : ne(H);\n        });\n        try {\n          V.apply(this, oe);\n        } catch (k) {\n          se(k);\n        }\n        return ce;\n      }\n      return Object.setPrototypeOf(I, Object.getPrototypeOf(V)), L && Object.defineProperty(I, L, {\n        value: I,\n        enumerable: !1,\n        writable: !1,\n        configurable: !0\n      }), Object.defineProperties(\n        I,\n        e(V)\n      );\n    }, t.promisify.custom = L;\n    function m(B, V) {\n      if (!B) {\n        var I = new Error(\"Promise was rejected with a falsy value\");\n        I.reason = B, B = I;\n      }\n      return V(B);\n    }\n    function E(B) {\n      if (typeof B != \"function\")\n        throw new TypeError('The \"original\" argument must be of type Function');\n      function V() {\n        for (var I = [], ne = 0; ne < arguments.length; ne++)\n          I.push(arguments[ne]);\n        var se = I.pop();\n        if (typeof se != \"function\")\n          throw new TypeError(\"The last argument must be of type Function\");\n        var ce = this, oe = function() {\n          return se.apply(ce, arguments);\n        };\n        B.apply(this, I).then(\n          function(he) {\n            process.nextTick(oe.bind(null, null, he));\n          },\n          function(he) {\n            process.nextTick(m.bind(null, he, oe));\n          }\n        );\n      }\n      return Object.setPrototypeOf(V, Object.getPrototypeOf(B)), Object.defineProperties(\n        V,\n        e(B)\n      ), V;\n    }\n    t.callbackify = E;\n  }(ps)), ps;\n}\nvar qu = {};\n/*! *****************************************************************************\nCopyright (C) Microsoft. All rights reserved.\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0\n\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\nMERCHANTABLITY OR NON-INFRINGEMENT.\n\nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\nvar Ku;\nfunction th() {\n  if (Ku)\n    return qu;\n  Ku = 1;\n  var t;\n  return function(e) {\n    (function(r) {\n      var n = typeof ue == \"object\" ? ue : typeof self == \"object\" ? self : typeof this == \"object\" ? this : Function(\"return this;\")(), i = o(e);\n      typeof n.Reflect > \"u\" ? n.Reflect = e : i = o(n.Reflect, i), r(i);\n      function o(a, s) {\n        return function(l, u) {\n          typeof a[l] != \"function\" && Object.defineProperty(a, l, { configurable: !0, writable: !0, value: u }), s && s(l, u);\n        };\n      }\n    })(function(r) {\n      var n = Object.prototype.hasOwnProperty, i = typeof Symbol == \"function\", o = i && typeof Symbol.toPrimitive < \"u\" ? Symbol.toPrimitive : \"@@toPrimitive\", a = i && typeof Symbol.iterator < \"u\" ? Symbol.iterator : \"@@iterator\", s = typeof Object.create == \"function\", l = { __proto__: [] } instanceof Array, u = !s && !l, c = {\n        // create an object in dictionary mode (a.k.a. \"slow\" mode in v8)\n        create: s ? function() {\n          return pe(/* @__PURE__ */ Object.create(null));\n        } : l ? function() {\n          return pe({ __proto__: null });\n        } : function() {\n          return pe({});\n        },\n        has: u ? function(X, ie) {\n          return n.call(X, ie);\n        } : function(X, ie) {\n          return ie in X;\n        },\n        get: u ? function(X, ie) {\n          return n.call(X, ie) ? X[ie] : void 0;\n        } : function(X, ie) {\n          return X[ie];\n        }\n      }, f = Object.getPrototypeOf(Function), h = typeof process == \"object\" && process.env && process.env.REFLECT_METADATA_USE_MAP_POLYFILL === \"true\", p = !h && typeof Map == \"function\" && typeof Map.prototype.entries == \"function\" ? Map : K(), g = !h && typeof Set == \"function\" && typeof Set.prototype.entries == \"function\" ? Set : te(), _ = !h && typeof WeakMap == \"function\" ? WeakMap : de(), T = new _();\n      function A(X, ie, re, ae) {\n        if (B(re)) {\n          if (!H(X))\n            throw new TypeError();\n          if (!J(ie))\n            throw new TypeError();\n          return P(X, ie);\n        } else {\n          if (!H(X))\n            throw new TypeError();\n          if (!ne(ie))\n            throw new TypeError();\n          if (!ne(ae) && !B(ae) && !V(ae))\n            throw new TypeError();\n          return V(ae) && (ae = void 0), re = k(re), d(X, ie, re, ae);\n        }\n      }\n      r(\"decorate\", A);\n      function w(X, ie) {\n        function re(ae, me) {\n          if (!ne(ae))\n            throw new TypeError();\n          if (!B(me) && !Q(me))\n            throw new TypeError();\n          Y(X, ie, ae, me);\n        }\n        return re;\n      }\n      r(\"metadata\", w);\n      function O(X, ie, re, ae) {\n        if (!ne(re))\n          throw new TypeError();\n        return B(ae) || (ae = k(ae)), Y(X, ie, re, ae);\n      }\n      r(\"defineMetadata\", O);\n      function R(X, ie, re) {\n        if (!ne(ie))\n          throw new TypeError();\n        return B(re) || (re = k(re)), C(X, ie, re);\n      }\n      r(\"hasMetadata\", R);\n      function $(X, ie, re) {\n        if (!ne(ie))\n          throw new TypeError();\n        return B(re) || (re = k(re)), M(X, ie, re);\n      }\n      r(\"hasOwnMetadata\", $);\n      function U(X, ie, re) {\n        if (!ne(ie))\n          throw new TypeError();\n        return B(re) || (re = k(re)), D(X, ie, re);\n      }\n      r(\"getMetadata\", U);\n      function W(X, ie, re) {\n        if (!ne(ie))\n          throw new TypeError();\n        return B(re) || (re = k(re)), z(X, ie, re);\n      }\n      r(\"getOwnMetadata\", W);\n      function G(X, ie) {\n        if (!ne(X))\n          throw new TypeError();\n        return B(ie) || (ie = k(ie)), L(X, ie);\n      }\n      r(\"getMetadataKeys\", G);\n      function Z(X, ie) {\n        if (!ne(X))\n          throw new TypeError();\n        return B(ie) || (ie = k(ie)), m(X, ie);\n      }\n      r(\"getOwnMetadataKeys\", Z);\n      function j(X, ie, re) {\n        if (!ne(ie))\n          throw new TypeError();\n        B(re) || (re = k(re));\n        var ae = x(\n          ie,\n          re,\n          /*Create*/\n          !1\n        );\n        if (B(ae) || !ae.delete(X))\n          return !1;\n        if (ae.size > 0)\n          return !0;\n        var me = T.get(ie);\n        return me.delete(re), me.size > 0 || T.delete(ie), !0;\n      }\n      r(\"deleteMetadata\", j);\n      function P(X, ie) {\n        for (var re = X.length - 1; re >= 0; --re) {\n          var ae = X[re], me = ae(ie);\n          if (!B(me) && !V(me)) {\n            if (!J(me))\n              throw new TypeError();\n            ie = me;\n          }\n        }\n        return ie;\n      }\n      function d(X, ie, re, ae) {\n        for (var me = X.length - 1; me >= 0; --me) {\n          var Te = X[me], ve = Te(ie, re, ae);\n          if (!B(ve) && !V(ve)) {\n            if (!ne(ve))\n              throw new TypeError();\n            ae = ve;\n          }\n        }\n        return ae;\n      }\n      function x(X, ie, re) {\n        var ae = T.get(X);\n        if (B(ae)) {\n          if (!re)\n            return;\n          ae = new p(), T.set(X, ae);\n        }\n        var me = ae.get(ie);\n        if (B(me)) {\n          if (!re)\n            return;\n          me = new p(), ae.set(ie, me);\n        }\n        return me;\n      }\n      function C(X, ie, re) {\n        var ae = M(X, ie, re);\n        if (ae)\n          return !0;\n        var me = F(ie);\n        return V(me) ? !1 : C(X, me, re);\n      }\n      function M(X, ie, re) {\n        var ae = x(\n          ie,\n          re,\n          /*Create*/\n          !1\n        );\n        return B(ae) ? !1 : oe(ae.has(X));\n      }\n      function D(X, ie, re) {\n        var ae = M(X, ie, re);\n        if (ae)\n          return z(X, ie, re);\n        var me = F(ie);\n        if (!V(me))\n          return D(X, me, re);\n      }\n      function z(X, ie, re) {\n        var ae = x(\n          ie,\n          re,\n          /*Create*/\n          !1\n        );\n        if (!B(ae))\n          return ae.get(X);\n      }\n      function Y(X, ie, re, ae) {\n        var me = x(\n          re,\n          ae,\n          /*Create*/\n          !0\n        );\n        me.set(X, ie);\n      }\n      function L(X, ie) {\n        var re = m(X, ie), ae = F(X);\n        if (ae === null)\n          return re;\n        var me = L(ae, ie);\n        if (me.length <= 0)\n          return re;\n        if (re.length <= 0)\n          return me;\n        for (var Te = new g(), ve = [], _e = 0, ye = re; _e < ye.length; _e++) {\n          var we = ye[_e], Ae = Te.has(we);\n          Ae || (Te.add(we), ve.push(we));\n        }\n        for (var Pe = 0, Se = me; Pe < Se.length; Pe++) {\n          var we = Se[Pe], Ae = Te.has(we);\n          Ae || (Te.add(we), ve.push(we));\n        }\n        return ve;\n      }\n      function m(X, ie) {\n        var re = [], ae = x(\n          X,\n          ie,\n          /*Create*/\n          !1\n        );\n        if (B(ae))\n          return re;\n        for (var me = ae.keys(), Te = S(me), ve = 0; ; ) {\n          var _e = v(Te);\n          if (!_e)\n            return re.length = ve, re;\n          var ye = y(_e);\n          try {\n            re[ve] = ye;\n          } catch (we) {\n            try {\n              b(Te);\n            } finally {\n              throw we;\n            }\n          }\n          ve++;\n        }\n      }\n      function E(X) {\n        if (X === null)\n          return 1;\n        switch (typeof X) {\n          case \"undefined\":\n            return 0;\n          case \"boolean\":\n            return 2;\n          case \"string\":\n            return 3;\n          case \"symbol\":\n            return 4;\n          case \"number\":\n            return 5;\n          case \"object\":\n            return X === null ? 1 : 6;\n          default:\n            return 6;\n        }\n      }\n      function B(X) {\n        return X === void 0;\n      }\n      function V(X) {\n        return X === null;\n      }\n      function I(X) {\n        return typeof X == \"symbol\";\n      }\n      function ne(X) {\n        return typeof X == \"object\" ? X !== null : typeof X == \"function\";\n      }\n      function se(X, ie) {\n        switch (E(X)) {\n          case 0:\n            return X;\n          case 1:\n            return X;\n          case 2:\n            return X;\n          case 3:\n            return X;\n          case 4:\n            return X;\n          case 5:\n            return X;\n        }\n        var re = ie === 3 ? \"string\" : ie === 5 ? \"number\" : \"default\", ae = ee(X, o);\n        if (ae !== void 0) {\n          var me = ae.call(X, re);\n          if (ne(me))\n            throw new TypeError();\n          return me;\n        }\n        return ce(X, re === \"default\" ? \"number\" : re);\n      }\n      function ce(X, ie) {\n        if (ie === \"string\") {\n          var re = X.toString;\n          if (N(re)) {\n            var ae = re.call(X);\n            if (!ne(ae))\n              return ae;\n          }\n          var me = X.valueOf;\n          if (N(me)) {\n            var ae = me.call(X);\n            if (!ne(ae))\n              return ae;\n          }\n        } else {\n          var me = X.valueOf;\n          if (N(me)) {\n            var ae = me.call(X);\n            if (!ne(ae))\n              return ae;\n          }\n          var Te = X.toString;\n          if (N(Te)) {\n            var ae = Te.call(X);\n            if (!ne(ae))\n              return ae;\n          }\n        }\n        throw new TypeError();\n      }\n      function oe(X) {\n        return !!X;\n      }\n      function he(X) {\n        return \"\" + X;\n      }\n      function k(X) {\n        var ie = se(\n          X,\n          3\n          /* String */\n        );\n        return I(ie) ? ie : he(ie);\n      }\n      function H(X) {\n        return Array.isArray ? Array.isArray(X) : X instanceof Object ? X instanceof Array : Object.prototype.toString.call(X) === \"[object Array]\";\n      }\n      function N(X) {\n        return typeof X == \"function\";\n      }\n      function J(X) {\n        return typeof X == \"function\";\n      }\n      function Q(X) {\n        switch (E(X)) {\n          case 3:\n            return !0;\n          case 4:\n            return !0;\n          default:\n            return !1;\n        }\n      }\n      function ee(X, ie) {\n        var re = X[ie];\n        if (re != null) {\n          if (!N(re))\n            throw new TypeError();\n          return re;\n        }\n      }\n      function S(X) {\n        var ie = ee(X, a);\n        if (!N(ie))\n          throw new TypeError();\n        var re = ie.call(X);\n        if (!ne(re))\n          throw new TypeError();\n        return re;\n      }\n      function y(X) {\n        return X.value;\n      }\n      function v(X) {\n        var ie = X.next();\n        return ie.done ? !1 : ie;\n      }\n      function b(X) {\n        var ie = X.return;\n        ie && ie.call(X);\n      }\n      function F(X) {\n        var ie = Object.getPrototypeOf(X);\n        if (typeof X != \"function\" || X === f || ie !== f)\n          return ie;\n        var re = X.prototype, ae = re && Object.getPrototypeOf(re);\n        if (ae == null || ae === Object.prototype)\n          return ie;\n        var me = ae.constructor;\n        return typeof me != \"function\" || me === X ? ie : me;\n      }\n      function K() {\n        var X = {}, ie = [], re = function() {\n          function ve(_e, ye, we) {\n            this._index = 0, this._keys = _e, this._values = ye, this._selector = we;\n          }\n          return ve.prototype[\"@@iterator\"] = function() {\n            return this;\n          }, ve.prototype[a] = function() {\n            return this;\n          }, ve.prototype.next = function() {\n            var _e = this._index;\n            if (_e >= 0 && _e < this._keys.length) {\n              var ye = this._selector(this._keys[_e], this._values[_e]);\n              return _e + 1 >= this._keys.length ? (this._index = -1, this._keys = ie, this._values = ie) : this._index++, { value: ye, done: !1 };\n            }\n            return { value: void 0, done: !0 };\n          }, ve.prototype.throw = function(_e) {\n            throw this._index >= 0 && (this._index = -1, this._keys = ie, this._values = ie), _e;\n          }, ve.prototype.return = function(_e) {\n            return this._index >= 0 && (this._index = -1, this._keys = ie, this._values = ie), { value: _e, done: !0 };\n          }, ve;\n        }();\n        return function() {\n          function ve() {\n            this._keys = [], this._values = [], this._cacheKey = X, this._cacheIndex = -2;\n          }\n          return Object.defineProperty(ve.prototype, \"size\", {\n            get: function() {\n              return this._keys.length;\n            },\n            enumerable: !0,\n            configurable: !0\n          }), ve.prototype.has = function(_e) {\n            return this._find(\n              _e,\n              /*insert*/\n              !1\n            ) >= 0;\n          }, ve.prototype.get = function(_e) {\n            var ye = this._find(\n              _e,\n              /*insert*/\n              !1\n            );\n            return ye >= 0 ? this._values[ye] : void 0;\n          }, ve.prototype.set = function(_e, ye) {\n            var we = this._find(\n              _e,\n              /*insert*/\n              !0\n            );\n            return this._values[we] = ye, this;\n          }, ve.prototype.delete = function(_e) {\n            var ye = this._find(\n              _e,\n              /*insert*/\n              !1\n            );\n            if (ye >= 0) {\n              for (var we = this._keys.length, Ae = ye + 1; Ae < we; Ae++)\n                this._keys[Ae - 1] = this._keys[Ae], this._values[Ae - 1] = this._values[Ae];\n              return this._keys.length--, this._values.length--, _e === this._cacheKey && (this._cacheKey = X, this._cacheIndex = -2), !0;\n            }\n            return !1;\n          }, ve.prototype.clear = function() {\n            this._keys.length = 0, this._values.length = 0, this._cacheKey = X, this._cacheIndex = -2;\n          }, ve.prototype.keys = function() {\n            return new re(this._keys, this._values, ae);\n          }, ve.prototype.values = function() {\n            return new re(this._keys, this._values, me);\n          }, ve.prototype.entries = function() {\n            return new re(this._keys, this._values, Te);\n          }, ve.prototype[\"@@iterator\"] = function() {\n            return this.entries();\n          }, ve.prototype[a] = function() {\n            return this.entries();\n          }, ve.prototype._find = function(_e, ye) {\n            return this._cacheKey !== _e && (this._cacheIndex = this._keys.indexOf(this._cacheKey = _e)), this._cacheIndex < 0 && ye && (this._cacheIndex = this._keys.length, this._keys.push(_e), this._values.push(void 0)), this._cacheIndex;\n          }, ve;\n        }();\n        function ae(ve, _e) {\n          return ve;\n        }\n        function me(ve, _e) {\n          return _e;\n        }\n        function Te(ve, _e) {\n          return [ve, _e];\n        }\n      }\n      function te() {\n        return function() {\n          function X() {\n            this._map = new p();\n          }\n          return Object.defineProperty(X.prototype, \"size\", {\n            get: function() {\n              return this._map.size;\n            },\n            enumerable: !0,\n            configurable: !0\n          }), X.prototype.has = function(ie) {\n            return this._map.has(ie);\n          }, X.prototype.add = function(ie) {\n            return this._map.set(ie, ie), this;\n          }, X.prototype.delete = function(ie) {\n            return this._map.delete(ie);\n          }, X.prototype.clear = function() {\n            this._map.clear();\n          }, X.prototype.keys = function() {\n            return this._map.keys();\n          }, X.prototype.values = function() {\n            return this._map.values();\n          }, X.prototype.entries = function() {\n            return this._map.entries();\n          }, X.prototype[\"@@iterator\"] = function() {\n            return this.keys();\n          }, X.prototype[a] = function() {\n            return this.keys();\n          }, X;\n        }();\n      }\n      function de() {\n        var X = 16, ie = c.create(), re = ae();\n        return function() {\n          function ye() {\n            this._key = ae();\n          }\n          return ye.prototype.has = function(we) {\n            var Ae = me(\n              we,\n              /*create*/\n              !1\n            );\n            return Ae !== void 0 ? c.has(Ae, this._key) : !1;\n          }, ye.prototype.get = function(we) {\n            var Ae = me(\n              we,\n              /*create*/\n              !1\n            );\n            return Ae !== void 0 ? c.get(Ae, this._key) : void 0;\n          }, ye.prototype.set = function(we, Ae) {\n            var Pe = me(\n              we,\n              /*create*/\n              !0\n            );\n            return Pe[this._key] = Ae, this;\n          }, ye.prototype.delete = function(we) {\n            var Ae = me(\n              we,\n              /*create*/\n              !1\n            );\n            return Ae !== void 0 ? delete Ae[this._key] : !1;\n          }, ye.prototype.clear = function() {\n            this._key = ae();\n          }, ye;\n        }();\n        function ae() {\n          var ye;\n          do\n            ye = \"@@WeakMap@@\" + _e();\n          while (c.has(ie, ye));\n          return ie[ye] = !0, ye;\n        }\n        function me(ye, we) {\n          if (!n.call(ye, re)) {\n            if (!we)\n              return;\n            Object.defineProperty(ye, re, { value: c.create() });\n          }\n          return ye[re];\n        }\n        function Te(ye, we) {\n          for (var Ae = 0; Ae < we; ++Ae)\n            ye[Ae] = Math.random() * 255 | 0;\n          return ye;\n        }\n        function ve(ye) {\n          return typeof Uint8Array == \"function\" ? typeof crypto < \"u\" ? crypto.getRandomValues(new Uint8Array(ye)) : typeof msCrypto < \"u\" ? msCrypto.getRandomValues(new Uint8Array(ye)) : Te(new Uint8Array(ye), ye) : Te(new Array(ye), ye);\n        }\n        function _e() {\n          var ye = ve(X);\n          ye[6] = ye[6] & 79 | 64, ye[8] = ye[8] & 191 | 128;\n          for (var we = \"\", Ae = 0; Ae < X; ++Ae) {\n            var Pe = ye[Ae];\n            (Ae === 4 || Ae === 6 || Ae === 8) && (we += \"-\"), Pe < 16 && (we += \"0\"), we += Pe.toString(16).toLowerCase();\n          }\n          return we;\n        }\n      }\n      function pe(X) {\n        return X.__ = void 0, delete X.__, X;\n      }\n    });\n  }(t || (t = {})), qu;\n}\nlet Jn;\nfunction ko(t) {\n  if (typeof t != \"function\")\n    throw new Error(\"This module should not be used in runtime. Instead, use a transformer during compilation.\");\n}\nconst pa = Symbol(\"assertions\");\nfunction vy(t, e) {\n  let r = e;\n  for (const n of t.slice(1))\n    r = r[n.startsWith(\"[\") ? parseInt(n.replace(\"[\", \"\").replace(\"]\", \"\")) : n];\n  return r;\n}\nfunction gy(t, e, r) {\n  if (t === void 0)\n    return \"validation error\";\n  const n = vy(e, r);\n  try {\n    return t + \", found: \" + ec().inspect(n);\n  } catch {\n  }\n  try {\n    return t + \", found: \" + JSON.stringify(n);\n  } catch {\n  }\n  return t;\n}\nclass tc extends Error {\n  constructor(e, r) {\n    super(gy(e.message, e.path, r)), this.name = \"TypeGuardError\", this.path = e.path, this.reason = e.reason, this.input = r;\n  }\n}\nfunction xy(t, e = {}) {\n  return th(), function(r, n, i) {\n    const o = Reflect.getOwnMetadata(pa, r, n) || [];\n    Reflect.getOwnMetadata(\"design:returntype\", r, n) === Promise ? o[i] = { assertion: t, options: Object.assign({ async: !0 }, e) } : o[i] = { assertion: t, options: e }, Reflect.defineMetadata(pa, o, r, n);\n  };\n}\nfunction wy(t = tc) {\n  return th(), function(e) {\n    for (const r of Object.getOwnPropertyNames(e.prototype)) {\n      const n = Reflect.getOwnMetadata(pa, e.prototype, r);\n      if (n) {\n        const i = e.prototype[r];\n        e.prototype[r] = function(...o) {\n          for (let a = 0; a < n.length; a++) {\n            if (!n[a])\n              continue;\n            const s = n[a].assertion(o[a]);\n            if (s !== null) {\n              const l = new t(s, o[a]);\n              if (n[a].options.async)\n                return Promise.reject(l);\n              throw l;\n            }\n          }\n          return i.apply(this, o);\n        };\n      }\n    }\n  };\n}\nfunction ya(t, e = Jn) {\n  return ko(e), e(t) === null;\n}\nfunction ma(t, e = Jn) {\n  ko(e);\n  const r = e(t);\n  if (r === null)\n    return t;\n  throw new tc(r, t);\n}\nfunction Gu(t = Jn) {\n  return ko(t), (e) => ya(e, t);\n}\nfunction Yu(t = Jn) {\n  return ko(t), (e) => ma(e, t);\n}\nfunction by(t) {\n  Jn = t;\n}\nvar Qr = {\n  is: ya,\n  assertType: ma,\n  createIs: Gu,\n  createAssertType: Yu,\n  equals: ya,\n  createEquals: Gu,\n  assertEquals: ma,\n  createAssertEquals: Yu,\n  AssertType: xy,\n  ValidateClass: wy,\n  TypeGuardError: tc,\n  setDefaultGetErrorObject: by\n}, bn = globalThis && globalThis.__awaiter || function(t, e, r, n) {\n  function i(o) {\n    return o instanceof r ? o : new r(function(a) {\n      a(o);\n    });\n  }\n  return new (r || (r = Promise))(function(o, a) {\n    function s(c) {\n      try {\n        u(n.next(c));\n      } catch (f) {\n        a(f);\n      }\n    }\n    function l(c) {\n      try {\n        u(n.throw(c));\n      } catch (f) {\n        a(f);\n      }\n    }\n    function u(c) {\n      c.done ? o(c.value) : i(c.value).then(s, l);\n    }\n    u((n = n.apply(t, e || [])).next());\n  });\n}, _y = globalThis && globalThis.__rest || function(t, e) {\n  var r = {};\n  for (var n in t)\n    Object.prototype.hasOwnProperty.call(t, n) && e.indexOf(n) < 0 && (r[n] = t[n]);\n  if (t != null && typeof Object.getOwnPropertySymbols == \"function\")\n    for (var i = 0, n = Object.getOwnPropertySymbols(t); i < n.length; i++)\n      e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(t, n[i]) && (r[n[i]] = t[n[i]]);\n  return r;\n};\nfunction Ay(t) {\n  return class extends t {\n    constructor(...r) {\n      super(...r), this.namespaces = {\n        arweaveWallet: {\n          walletName: \"ArConnect\",\n          connect: () => this.address || this.connect(),\n          disconnect: () => this.disconnect(),\n          getActiveAddress: () => this.address,\n          getActivePublicKey: () => this.getPublicKey(),\n          getAllAddresses: () => {\n            throw \"not implemented\";\n          },\n          getWalletNames: () => {\n            throw \"not implemented\";\n          },\n          sign: (n, i) => this.signTransaction(n, i),\n          dispatch: (n, i) => this.dispatch(n, i),\n          encrypt: () => {\n            throw \"not implemented\";\n          },\n          decrypt: (n, i) => this.decrypt(n, i),\n          getPermissions: () => [\"ACCESS_ADDRESS\", \"ACCESS_PUBLIC_KEY\", \"ACCESS_ALL_ADDRESSES\", \"SIGN_TRANSACTION\", \"ENCRYPT\", \"DECRYPT\", \"SIGNATURE\", \"ACCESS_ARWEAVE_CONFIG\", \"DISPATCH\"],\n          getArweaveConfig: () => this.getArweaveConfig()\n        }\n      };\n    }\n    postMessage(r, n, i) {\n      return super.postMessage(r, n, Object.assign(Object.assign({}, i), { protocol: \"arweave\", version: \"1.0.0\" }));\n    }\n    getPublicKey() {\n      return bn(this, void 0, void 0, function* () {\n        const r = yield this.postMessage(\"getPublicKey\");\n        if (!Qr.is(r, (n) => {\n          function i(o) {\n            return typeof o != \"string\" ? {} : null;\n          }\n          return i(n);\n        }))\n          throw \"TypeError\";\n        return r;\n      });\n    }\n    getArweaveConfig() {\n      return bn(this, void 0, void 0, function* () {\n        const r = yield this.postMessage(\"getArweaveConfig\");\n        if (!Qr.is(r, (n) => {\n          function i(A) {\n            return A !== void 0 ? {} : null;\n          }\n          function o(A) {\n            return typeof A != \"string\" ? {} : null;\n          }\n          function a(A) {\n            var w = [i, o];\n            for (const R of w) {\n              var O = R(A);\n              if (!O)\n                return null;\n            }\n            return {};\n          }\n          function s(A) {\n            return typeof A != \"number\" ? {} : null;\n          }\n          function l(A) {\n            var w = [i, o, s];\n            for (const R of w) {\n              var O = R(A);\n              if (!O)\n                return null;\n            }\n            return {};\n          }\n          function u(A) {\n            var w = [i, s];\n            for (const R of w) {\n              var O = R(A);\n              if (!O)\n                return null;\n            }\n            return {};\n          }\n          function c(A) {\n            return A !== !1 ? {} : null;\n          }\n          function f(A) {\n            return A !== !0 ? {} : null;\n          }\n          function h(A) {\n            var w = [i, c, f];\n            for (const R of w) {\n              var O = R(A);\n              if (!O)\n                return null;\n            }\n            return {};\n          }\n          function p(A) {\n            if (typeof A != \"object\" || A === null || Array.isArray(A))\n              return {};\n            if (\"protocol\" in A) {\n              var w = a(A.protocol);\n              if (w)\n                return w;\n            }\n            if (\"host\" in A) {\n              var w = a(A.host);\n              if (w)\n                return w;\n            }\n            if (\"port\" in A) {\n              var w = l(A.port);\n              if (w)\n                return w;\n            }\n            if (\"timeout\" in A) {\n              var w = u(A.timeout);\n              if (w)\n                return w;\n            }\n            if (\"logging\" in A) {\n              var w = h(A.logging);\n              if (w)\n                return w;\n            }\n            return null;\n          }\n          function g() {\n            return null;\n          }\n          function _(A) {\n            if (typeof A != \"object\" || A === null || Array.isArray(A))\n              return {};\n            if (\"logger\" in A) {\n              var w = g(A.logger);\n              if (w)\n                return w;\n            }\n            return null;\n          }\n          function T(A) {\n            var w = [p, _];\n            for (const R of w) {\n              var O = R(A);\n              if (O)\n                return O;\n            }\n            return null;\n          }\n          return T(n);\n        }))\n          throw \"TypeError\";\n        return delete r.logger, r;\n      });\n    }\n    signTransaction(r, n) {\n      var i;\n      return bn(this, void 0, void 0, function* () {\n        const o = _y(r, [\"data\", \"chunks\"]), a = yield this.postMessage(\"signTransaction\", [o, n]);\n        if (!Qr.is(a, (s) => {\n          function l(T) {\n            return typeof T != \"string\" ? {} : null;\n          }\n          function u(T) {\n            return T !== void 0 ? {} : null;\n          }\n          function c(T) {\n            return T !== null ? {} : null;\n          }\n          function f(T) {\n            var A = [u, c, l];\n            for (const O of A) {\n              var w = O(T);\n              if (!w)\n                return null;\n            }\n            return {};\n          }\n          function h(T) {\n            if (typeof T != \"object\" || T === null || Array.isArray(T))\n              return {};\n            if (\"name\" in T) {\n              var A = l(T.name);\n              if (A)\n                return A;\n            } else\n              return {};\n            if (\"value\" in T) {\n              var A = l(T.value);\n              if (A)\n                return A;\n            } else\n              return {};\n            return null;\n          }\n          function p(T) {\n            if (!Array.isArray(T))\n              return {};\n            for (let w = 0; w < T.length; w++) {\n              var A = h(T[w]);\n              if (A)\n                return A;\n            }\n            return null;\n          }\n          function g(T) {\n            var A = [u, c, p];\n            for (const O of A) {\n              var w = O(T);\n              if (!w)\n                return null;\n            }\n            return {};\n          }\n          function _(T) {\n            if (typeof T != \"object\" || T === null || Array.isArray(T))\n              return {};\n            if (\"id\" in T) {\n              var A = l(T.id);\n              if (A)\n                return A;\n            } else\n              return {};\n            if (\"owner\" in T) {\n              var A = f(T.owner);\n              if (A)\n                return A;\n            }\n            if (\"tags\" in T) {\n              var A = g(T.tags);\n              if (A)\n                return A;\n            }\n            if (\"signature\" in T) {\n              var A = l(T.signature);\n              if (A)\n                return A;\n            } else\n              return {};\n            if (\"reward\" in T) {\n              var A = f(T.reward);\n              if (A)\n                return A;\n            }\n            return null;\n          }\n          return _(s);\n        }))\n          throw \"TypeError\";\n        return r.setSignature({\n          id: a.id,\n          owner: a.owner || r.owner,\n          tags: (i = a.tags) === null || i === void 0 ? void 0 : i.map((s) => new ny(s.name, s.value, !0)),\n          signature: a.signature,\n          reward: a.reward || void 0\n        }), r;\n      });\n    }\n    dispatch(r, n) {\n      return bn(this, void 0, void 0, function* () {\n        const i = yield this.postMessage(\"dispatch\", [r, n], { transfer: !0 });\n        if (!Qr.is(i, (o) => {\n          function a(f) {\n            return typeof f != \"string\" ? {} : null;\n          }\n          function s(f) {\n            return f !== \"BASE\" ? {} : null;\n          }\n          function l(f) {\n            return f !== \"BUNDLED\" ? {} : null;\n          }\n          function u(f) {\n            var h = [s, l];\n            for (const g of h) {\n              var p = g(f);\n              if (!p)\n                return null;\n            }\n            return {};\n          }\n          function c(f) {\n            if (typeof f != \"object\" || f === null || Array.isArray(f))\n              return {};\n            if (\"id\" in f) {\n              var h = a(f.id);\n              if (h)\n                return h;\n            }\n            if (\"type\" in f) {\n              var h = u(f.type);\n              if (h)\n                return h;\n            }\n            return null;\n          }\n          return c(o);\n        }))\n          throw \"TypeError\";\n        return i;\n      });\n    }\n    decrypt(r, n) {\n      return bn(this, void 0, void 0, function* () {\n        const i = yield this.postMessage(\"decrypt\", [r, n]);\n        if (!ArrayBuffer.isView(i))\n          throw \"TypeError\";\n        const o = r.constructor;\n        return new o(i.buffer);\n      });\n    }\n  };\n}\nfunction Ty(t) {\n  return { all: t = t || /* @__PURE__ */ new Map(), on: function(e, r) {\n    var n = t.get(e);\n    n ? n.push(r) : t.set(e, [r]);\n  }, off: function(e, r) {\n    var n = t.get(e);\n    n && (r ? n.splice(n.indexOf(r) >>> 0, 1) : t.set(e, []));\n  }, emit: function(e, r) {\n    var n = t.get(e);\n    n && n.slice().map(function(i) {\n      i(r);\n    }), (n = t.get(\"*\")) && n.slice().map(function(i) {\n      i(e, r);\n    });\n  } };\n}\nclass rh {\n  constructor() {\n    this.mittInstance = Ty();\n  }\n  emit(e, r) {\n    this.mittInstance.emit(e, r);\n  }\n  on(e, r) {\n    this.mittInstance.on(e, r);\n  }\n  off(e, r) {\n    this.mittInstance.off(e, r);\n  }\n  once(e, r) {\n    return new Promise((n) => {\n      const i = (o) => {\n        this.off(e, i), n(o), r && r(o);\n      };\n      this.on(e, i);\n    });\n  }\n}\nclass Ey {\n  constructor() {\n    this._promiseController = [];\n  }\n  newMessagePromise(e, r) {\n    e.id = this._promiseController.length;\n    const n = new Promise((i, o) => this._promiseController.push({ resolve: i, reject: o }));\n    return r != null && r.timeout && setTimeout(() => this._promiseController[e.id].reject(\"timeout\"), r.timeout), n;\n  }\n  processResponse(e) {\n    const { id: r, result: n, error: i } = e;\n    if (r != null) {\n      if (typeof r != \"number\" && typeof r != \"string\" || typeof r == \"string\" && isNaN(parseInt(r)))\n        throw \"error\";\n      if (!this._promiseController[+r])\n        throw \"received result to nonexistent request\";\n      return i != null ? this._promiseController[+r].reject(i) : this._promiseController[+r].resolve(n), !0;\n    }\n  }\n}\nconst Zu = \"400\", Xu = \"600\";\nclass Sy extends rh {\n  constructor(e, r) {\n    super(), this._iframe = {}, this._showIframe = !1, this._popup = {}, this._usePopup = !0, this._requirePopup = !1, this._keepPopup = !1, this._promiseController = new Ey(), this._pending = [], this.listener = (i) => {\n      var o, a, s, l, u, c;\n      if (i.source !== this._popup.window && i.source !== ((o = this._iframe) === null || o === void 0 ? void 0 : o.window) || i.origin !== ((a = this._url) === null || a === void 0 ? void 0 : a.origin) || typeof i.data != \"object\")\n        return;\n      const { method: f, params: h, id: p, result: g, error: _, session: T } = i.data;\n      if (console.info(`WalletConnector:${i.source === this._popup.window ? \"popup\" : \"iframe\"}`, i.data), p != null && (this._pending = this._pending.filter((w) => w != p)), this._promiseController.processResponse(i.data) || typeof f != \"string\")\n        return;\n      if (f === \"ready\") {\n        i.source === this._popup.window && ((l = (s = this._popup).resolve) === null || l === void 0 || l.call(s)), i.source === this._iframe.window && ((c = (u = this._iframe).resolve) === null || c === void 0 || c.call(u));\n        return;\n      }\n      if (f === \"change\")\n        return;\n      if (f === \"showIframe\") {\n        if (typeof h != \"boolean\")\n          return;\n        this.showIframe = h;\n      }\n      if (f === \"usePopup\") {\n        if (typeof h != \"boolean\")\n          return;\n        this.setUsePopup(h);\n      }\n      if (f === \"keepPopup\") {\n        if (typeof h != \"boolean\")\n          return;\n        this.setRequirePopup(h);\n      }\n      const A = { method: f, params: h, session: T };\n      if (!Qr.is(A, (w) => {\n        function O(Z) {\n          return typeof Z != \"string\" ? {} : null;\n        }\n        function R() {\n          return null;\n        }\n        function $(Z) {\n          return Z !== void 0 ? {} : null;\n        }\n        function U(Z) {\n          return typeof Z != \"number\" ? {} : null;\n        }\n        function W(Z) {\n          var j = [$, O, U];\n          for (const d of j) {\n            var P = d(Z);\n            if (!P)\n              return null;\n          }\n          return {};\n        }\n        function G(Z) {\n          if (typeof Z != \"object\" || Z === null || Array.isArray(Z))\n            return {};\n          if (\"method\" in Z) {\n            var j = O(Z.method);\n            if (j)\n              return j;\n          } else\n            return {};\n          if (\"params\" in Z) {\n            var j = R(Z.params);\n            if (j)\n              return j;\n          } else\n            return {};\n          if (\"session\" in Z) {\n            var j = W(Z.session);\n            if (j)\n              return j;\n          }\n          return null;\n        }\n        return G(w);\n      }))\n        return console.warn(\"dropped\");\n      this.emit(\"message\", A);\n    }, this._iframeParentNode = r == null ? void 0 : r.iframeParentNode, this._url = e;\n    const n = {\n      origin: window.location.origin,\n      session: Math.random().toString().slice(2)\n    };\n    r != null && r.name && (n.name = r.name), r != null && r.logo && (n.logo = r.logo), this._url.hash = new URLSearchParams(n).toString(), window.addEventListener(\"message\", this.listener);\n  }\n  get url() {\n    var e;\n    return (e = this._url) === null || e === void 0 ? void 0 : e.origin;\n  }\n  get showIframe() {\n    return this._showIframe;\n  }\n  set showIframe(e) {\n    e !== this._showIframe && (this._showIframe = e, this.deliverMessage({ method: \"showIframe\", params: e }), this.emit(\"builtin\", { showIframe: e }), this._iframeNode && (this._iframeParentNode || (this._iframeNode.style.opacity = e ? \"1\" : \"0\", this._iframeNode.style.pointerEvents = e ? \"\" : \"none\", this._iframeNode.style.touchAction = e ? \"\" : \"none\", this._iframeNode.style.zIndex = e ? \"1000000\" : \"-1000000\", this._iframeNode.style.transform = e ? \"\" : \"translate(0, 24px)\", this._iframeNode.style.transition = e ? \"opacity 0.36s cubic-bezier(0.22, 1, 0.36, 1), transform 0.36s cubic-bezier(0.22, 1, 0.36, 1)\" : \"opacity 0.1s ease, transform 0.1s ease, z-index 0s linear 0.1s\")));\n  }\n  get usePopup() {\n    return this._usePopup;\n  }\n  setUsePopup(e) {\n    e !== this._usePopup && (this._usePopup = e, this.emit(\"builtin\", { usePopup: e }));\n  }\n  get requirePopup() {\n    return this._requirePopup;\n  }\n  setRequirePopup(e) {\n    e !== this._requirePopup && (this._requirePopup = e, this.emit(\"builtin\", { requirePopup: e }));\n  }\n  get keepPopup() {\n    return this._keepPopup;\n  }\n  set keepPopup(e) {\n    this._keepPopup = e, this.emit(\"builtin\", { keepPopup: e }), e || this.closePopup(), e && this.openPopup(!0);\n  }\n  destructor(e) {\n    this.closeIframe(), this.closePopup(!0), window.removeEventListener(\"message\", this.listener);\n  }\n  postMessage(e, r) {\n    const n = this._promiseController.newMessagePromise(e, r).finally(() => this.completeRequest());\n    return this.deliverMessage(e), n;\n  }\n  openIframe() {\n    if (this._iframeEl)\n      return;\n    this._iframeNode = document.createElement(\"div\"), this._iframeEl = document.createElement(\"iframe\"), this._iframeEl.src = this._url.toString(), this._iframeEl.allow = \"usb; hid; bluetooth; serial; camera; payment; web-share\", this._iframeEl.style.border = \"none\", this._iframeParentNode || (this._iframeEl.width = Zu, this._iframeEl.height = Xu, this._iframeEl.style.borderRadius = \"8px\", this._iframeEl.style.maxWidth = \"100%\", this._iframeEl.style.maxHeight = \"100%\", this._iframeNode.style.position = \"fixed\", this._iframeNode.style.inset = \"0\", this._iframeNode.style.display = \"flex\", this._iframeNode.style.alignItems = \"center\", this._iframeNode.style.justifyContent = \"center\", this._iframeNode.style.background = \"#00000088\", this._iframeNode.style.opacity = \"0\", this._iframeNode.style.pointerEvents = \"none\", this._iframeNode.style.touchAction = \"none\", this._iframeNode.style.zIndex = \"-1000000\", this._iframeNode.style.transform = \"translate(0, 24px)\", this._iframeNode.style.transition = \"opacity 0.1s ease, transform 0.1s ease, z-index 0s linear 0.1s\"), this._iframeNode.appendChild(this._iframeEl);\n    const e = new Promise((n, i) => this._iframe = { resolve: n, reject: i });\n    this._iframe.promise = e;\n    const r = () => {\n      var n;\n      this._iframeParentNode ? this._iframeParentNode.appendChild(this._iframeNode) : document.body.appendChild(this._iframeNode), this._iframe.window = (n = this._iframeEl) === null || n === void 0 ? void 0 : n.contentWindow;\n    };\n    document.readyState === \"complete\" || document.readyState === \"interactive\" ? r() : document.addEventListener(\"DOMContentLoaded\", r);\n  }\n  closeIframe() {\n    var e, r, n, i;\n    (e = this._iframeEl) === null || e === void 0 || e.setAttribute(\"src\", \"about:blank\"), (r = this._iframeNode) === null || r === void 0 || r.remove(), this._iframeNode = void 0, this._iframeEl = void 0, (i = (n = this._iframe).reject) === null || i === void 0 || i.call(n), this._iframe = {};\n  }\n  openPopup(e) {\n    if (this._popup.window && !this._popup.window.closed) {\n      this._popup.window.focus();\n      return;\n    }\n    if (!this.usePopup && !e)\n      return;\n    window.name = \"parent\";\n    const r = window.open(this._url.toString(), \"_blank\", `location,resizable,scrollbars,width=${Zu},height=${Xu}`), n = new Promise((o, a) => this._popup = { window: r, resolve: o, reject: a });\n    this._popup.promise = n;\n    const i = setInterval(() => {\n      this._popup.window && !this._popup.window.closed || (this.keepPopup && (this.keepPopup = !1), clearInterval(i));\n    }, 200);\n  }\n  closePopup(e) {\n    var r, n, i;\n    !this._popup.window || !((r = this._popup.window) === null || r === void 0) && r.closed || (this.keepPopup || this.requirePopup) && !e || (this._popup.window.location.href = \"about:blank\", this._popup.window.close(), (i = (n = this._popup).reject) === null || i === void 0 || i.call(n), this._popup = {});\n  }\n  completeRequest() {\n    setTimeout(() => {\n      this._pending.length || (this.closePopup(), this.showIframe = !1);\n    }, 100);\n  }\n  deliverMessage(e, r) {\n    var n, i;\n    if (!this._url)\n      throw \"Missing URL\";\n    console.info(\"WalletConnector:post\", e);\n    const o = Object.assign(Object.assign({}, e), { jsonrpc: \"2.0\" });\n    o.id != null && this._pending.push(o.id), this.openIframe(), this._iframe.promise = (n = this._iframe.promise) === null || n === void 0 ? void 0 : n.then(() => {\n      var a;\n      return (a = this._iframe.window) === null || a === void 0 ? void 0 : a.postMessage(o, this._url.origin, r != null && r.transfer ? [o] : void 0);\n    }).catch(() => {\n    }), this.openPopup(), this._popup.promise = (i = this._popup.promise) === null || i === void 0 ? void 0 : i.then(() => {\n      var a;\n      return (a = this._popup.window) === null || a === void 0 ? void 0 : a.postMessage(o, this._url.origin, r != null && r.transfer ? [o] : void 0);\n    }).catch(() => {\n    });\n  }\n}\nfunction Py(t) {\n  return typeof t == \"object\" ? t : (t.includes(\"://\") || (t = \"https://\" + t), new URL(t));\n}\nlet Ju;\nconst Lr = [], In = {}, va = {};\nfunction Cy(t) {\n  t.namespaces && (Lr.find((e) => e === t) || Lr.push(t), Mi());\n}\nfunction Oy(t) {\n  if (!Lr.find((e) => e === t))\n    return Mi();\n  Lr.splice(Lr.indexOf(t), 1);\n  for (const e in t.namespaces)\n    In[e] === t && (window[e] = va[e], delete va[e], delete In[e]);\n  Mi();\n}\nfunction Mi() {\n  for (const t of Lr)\n    for (const e in t.namespaces)\n      In[e] && In[e] !== t || window[e] !== t.namespaces[e] && (va[e] = window[e], window[e] = t.namespaces[e], In[e] = t);\n  window.clearInterval(Ju), Lr.length && (Ju = setInterval(() => Mi(), 1e4));\n}\nconst My = \"Window context missing. If you are using a server side rendering framework, make sure that the connector is excluded. If you want to use the connector outside the browser, use the node version of the module instead\";\nvar Bs = globalThis && globalThis.__awaiter || function(t, e, r, n) {\n  function i(o) {\n    return o instanceof r ? o : new r(function(a) {\n      a(o);\n    });\n  }\n  return new (r || (r = Promise))(function(o, a) {\n    function s(c) {\n      try {\n        u(n.next(c));\n      } catch (f) {\n        a(f);\n      }\n    }\n    function l(c) {\n      try {\n        u(n.throw(c));\n      } catch (f) {\n        a(f);\n      }\n    }\n    function u(c) {\n      c.done ? o(c.value) : i(c.value).then(s, l);\n    }\n    u((n = n.apply(t, e || [])).next());\n  });\n};\nclass kt extends rh {\n  constructor(e, r) {\n    super(), this._session = 0, this._listener = (n) => {\n      const { method: i, params: o, session: a } = n;\n      if (!(a != null && this._session != a) && !(!a && this._session)) {\n        if (i === \"connect\") {\n          if (!Qr.is(o, (s) => {\n            function l(u) {\n              return typeof u != \"string\" ? {} : null;\n            }\n            return l(s);\n          }))\n            return;\n          this.setAddress(o);\n        }\n        i === \"disconnect\" && this.disconnectEvent(!1);\n      }\n    }, this._appInfo = e, this._emitterPassthrough = (n) => {\n      const i = Object.entries(n)[0];\n      this.emit(i[0], i[1]);\n    }, this.on(\"connect\", () => Cy(this)), this.on(\"disconnect\", () => Oy(this)), r && this.setUrl(r);\n  }\n  get address() {\n    return this._address;\n  }\n  setAddress(e) {\n    e && e === this.address || (this._address = e, e != null ? this.emit(\"connect\", e) : this.emit(\"disconnect\", e), this.emit(\"change\", e));\n  }\n  get connected() {\n    return this._address != null;\n  }\n  get url() {\n    var e;\n    return (e = this._bridge) === null || e === void 0 ? void 0 : e.url;\n  }\n  get showIframe() {\n    var e;\n    return ((e = this._bridge) === null || e === void 0 ? void 0 : e.showIframe) || !1;\n  }\n  get usePopup() {\n    var e;\n    return ((e = this._bridge) === null || e === void 0 ? void 0 : e.usePopup) || !1;\n  }\n  get requirePopup() {\n    var e;\n    return ((e = this._bridge) === null || e === void 0 ? void 0 : e.requirePopup) || !1;\n  }\n  get keepPopup() {\n    var e;\n    return ((e = this._bridge) === null || e === void 0 ? void 0 : e.keepPopup) || !1;\n  }\n  set keepPopup(e) {\n    this._bridge && (this._bridge.keepPopup = e);\n  }\n  setUrl(e) {\n    var r;\n    if (!window) {\n      console.error(My);\n      return;\n    }\n    const n = this._bridge, i = Py(e);\n    if (this._url = i, ((r = this._bridge) === null || r === void 0 ? void 0 : r.url) !== i.origin) {\n      if (this.disconnect(), !kt._bridges[i.origin])\n        this._bridge = new Sy(i, this._appInfo), kt._bridges[i.origin] = { bridge: this._bridge, sessions: [] };\n      else {\n        this._bridge = kt._bridges[i.origin].bridge;\n        const o = kt._bridges[i.origin].sessions;\n        for (let a = 0; a <= o.length; a++)\n          if (o.indexOf(a) < 0) {\n            this._session = a;\n            break;\n          }\n      }\n      kt._bridges[i.origin].sessions.push(this._session), this._bridge.on(\"message\", this._listener), this._bridge.on(\"builtin\", this._emitterPassthrough), this._bridge.showIframe !== (n == null ? void 0 : n.showIframe) && this.emit(\"showIframe\", this._bridge.showIframe), this._bridge.usePopup !== (n == null ? void 0 : n.usePopup) && this.emit(\"usePopup\", this._bridge.usePopup), this._bridge.requirePopup !== (n == null ? void 0 : n.requirePopup) && this.emit(\"requirePopup\", this._bridge.requirePopup), this._bridge.keepPopup !== (n == null ? void 0 : n.keepPopup) && this.emit(\"keepPopup\", this._bridge.keepPopup);\n    }\n  }\n  connect(e) {\n    return Bs(this, void 0, void 0, function* () {\n      this._bridge || this._url && this.setUrl(this._url);\n      const r = new Promise((n, i) => {\n        this.once(\"change\", (o) => o ? n(o) : i());\n      }).finally(() => {\n        var n;\n        return (n = this._bridge) === null || n === void 0 ? void 0 : n.completeRequest();\n      });\n      return this._bridge.deliverMessage({ method: \"connect\", params: e }), r;\n    });\n  }\n  disconnect(e) {\n    return Bs(this, void 0, void 0, function* () {\n      return this.disconnectEvent(!0, e);\n    });\n  }\n  disconnectEvent(e, r) {\n    return Bs(this, void 0, void 0, function* () {\n      if (!this._bridge)\n        return;\n      const n = this._bridge, i = this._session, o = n.url;\n      if (this.setAddress(void 0), this._bridge = void 0, this._session = 0, e)\n        try {\n          yield n.postMessage({ method: \"disconnect\", params: [r], session: i });\n        } catch {\n          console.warn(\"disconnect request failed\");\n        }\n      n.off(\"message\", this._listener), n.off(\"builtin\", this._emitterPassthrough), kt._bridges[o].sessions = kt._bridges[o].sessions.filter((a) => a != i), setTimeout(() => {\n        kt._bridges[o].sessions.length || (kt._bridges[o].bridge.destructor(), delete kt._bridges[o]);\n      }, 100);\n    });\n  }\n  postMessage(e, r, n) {\n    return new Promise((i, o) => {\n      if (!this._bridge)\n        return o(\"URL missing\");\n      this.once(\"disconnect\", o), this._bridge.postMessage({ method: e, params: r, session: this._session, protocol: n == null ? void 0 : n.protocol, version: n == null ? void 0 : n.version }, n).then(i).catch(o);\n    });\n  }\n}\nkt._bridges = {};\nconst Qu = Ay(kt);\nfunction nh(t, e) {\n  for (const r of t)\n    if (!e.includes(r))\n      return !1;\n  return !0;\n}\nfunction ih(t, e = 13) {\n  return t.substring(0, e) + \"...\" + t.substring(t.length - e, t.length);\n}\nconst oh = (t) => `${t.r}, ${t.g}, ${t.b}`;\nasync function St(t, e = []) {\n  return window != null && window.arweaveWallet ? await window.arweaveWallet[t](...e) : new Promise(\n    (r, n) => window.addEventListener(\"arweaveWalletLoaded\", async () => {\n      try {\n        r(await window.arweaveWallet[t](...e));\n      } catch (i) {\n        n(i);\n      }\n    })\n  );\n}\nfunction el(t) {\n  return t.map((e) => {\n    try {\n      const r = e.get(\"name\", { decode: !0, string: !0 }), n = e.get(\"value\", { decode: !0, string: !0 });\n      return { name: r, value: n };\n    } catch {\n      return e;\n    }\n  });\n}\nclass rc {\n  constructor() {\n    ot(this, \"id\", \"browserwallet\");\n    ot(this, \"name\", \"Browser Wallet\");\n    ot(this, \"description\", \"Any browser wallet with an injected API\");\n    ot(this, \"theme\", \"121,212,131\");\n    ot(this, \"logo\", \"KKiSlNKc5K59MXzUPz5qjtCLsl6_ckjAOg9MyAzaUs0\");\n  }\n  async isAvailable() {\n    return typeof window > \"u\" || !window ? (console.error(\n      `[Arweave Wallet Kit] \"${this.id}\" strategy is unavailable. Window is undefined`\n    ), !1) : window.arweaveWallet ? !0 : new Promise((e) => {\n      const r = () => e(!0);\n      window.addEventListener(\"arweaveWalletLoaded\", r), setTimeout(() => {\n        window.removeEventListener(\"arweaveWalletLoaded\", r), window.arweaveWallet || console.error(\n          `[Arweave Wallet Kit] \"${this.id}\" strategy is unavailable. window.arweaveWallet is undefined`\n        ), e(!!window.arweaveWallet);\n      }, 7e3);\n    });\n  }\n  async sync() {\n  }\n  async connect(e, r, n) {\n    return await St(\"connect\", [e, r, n]);\n  }\n  async disconnect() {\n    return await St(\"disconnect\");\n  }\n  async getActiveAddress() {\n    return await St(\"getActiveAddress\");\n  }\n  async getAllAddresses() {\n    return await St(\"getAllAddresses\");\n  }\n  async getPermissions() {\n    return await St(\"getPermissions\");\n  }\n  async getWalletNames() {\n    return await St(\"getWalletNames\");\n  }\n  async sign(e, r) {\n    const n = await St(\"sign\", [\n      e,\n      r\n    ]);\n    return e.setSignature({\n      id: n.id,\n      owner: n.owner,\n      reward: n.reward,\n      tags: n.tags,\n      signature: n.signature\n    }), e;\n  }\n  async encrypt(e, r) {\n    return await St(\"encrypt\", [e, r]);\n  }\n  async decrypt(e, r) {\n    return await St(\"decrypt\", [e, r]);\n  }\n  async getArweaveConfig() {\n    return await St(\"getArweaveConfig\");\n  }\n  async signature(e, r) {\n    return await St(\"signature\", [e, r]);\n  }\n  async getActivePublicKey() {\n    return await St(\"getActivePublicKey\");\n  }\n  async addToken(e) {\n    throw new Error(\"Not implemented\");\n  }\n  async dispatch(e) {\n    return await St(\"dispatch\", [e]);\n  }\n  addAddressEvent(e) {\n    const r = (n) => e(n.detail.address);\n    return addEventListener(\"walletSwitch\", r), r;\n  }\n  removeAddressEvent(e) {\n    removeEventListener(\"walletSwitch\", e);\n  }\n}\nvar gr;\nclass ky extends rc {\n  constructor() {\n    super();\n    // @ts-expect-error\n    ot(this, \"id\", \"webwallet\");\n    ot(this, \"name\", \"Arweave.app\");\n    ot(this, \"description\", \"Web based wallet software\");\n    ot(this, \"theme\", \"24, 24, 24\");\n    ot(this, \"logo\", \"qVms-k8Ox-eKFJN5QFvrPQvT9ryqQXaFcYbr-fJbgLY\");\n    ot(this, \"url\", \"https://arweave.app\");\n    Cr(this, gr, new Qu());\n  }\n  async isAvailable() {\n    return !0;\n  }\n  async resumeSession() {\n    vt(this, gr).setUrl(\"arweave.app\"), await vt(this, gr).connect();\n  }\n  async connect(r, n, i) {\n    i && console.warn(\n      \"[Arweave Wallet Kit] Arweave.app does not support custom gateway connection yet.\"\n    ), Or(this, gr, new Qu(n)), await this.resumeSession();\n  }\n  addAddressEvent(r) {\n    return vt(this, gr).on(\"connect\", r), r;\n  }\n  removeAddressEvent(r) {\n    vt(this, gr).off(\"connect\", r);\n  }\n}\ngr = new WeakMap();\nclass Ry extends rc {\n  constructor() {\n    super();\n    // @ts-expect-error\n    ot(this, \"id\", \"arconnect\");\n    ot(this, \"name\", \"ArConnect\");\n    ot(this, \"description\", \"Non-custodial Arweave wallet for your favorite browser\");\n    ot(this, \"theme\", \"171, 154, 255\");\n    ot(this, \"logo\", \"tQUcL4wlNj_NED2VjUGUhfCTJ6pDN9P0e3CbnHo3vUE\");\n    ot(this, \"url\", \"https://arconnect.io\");\n  }\n  async isAvailable() {\n    return await super.isAvailable() ? window.arweaveWallet.walletName === \"ArConnect\" : !1;\n  }\n  async addToken(r) {\n    return await St(\"addToken\", [r]);\n  }\n}\nfunction sh(t, e) {\n  return function() {\n    return t.apply(e, arguments);\n  };\n}\nconst { toString: By } = Object.prototype, { getPrototypeOf: nc } = Object, Ro = ((t) => (e) => {\n  const r = By.call(e);\n  return t[r] || (t[r] = r.slice(8, -1).toLowerCase());\n})(/* @__PURE__ */ Object.create(null)), nr = (t) => (t = t.toLowerCase(), (e) => Ro(e) === t), Bo = (t) => (e) => typeof e === t, { isArray: gn } = Array, $n = Bo(\"undefined\");\nfunction Iy(t) {\n  return t !== null && !$n(t) && t.constructor !== null && !$n(t.constructor) && Vt(t.constructor.isBuffer) && t.constructor.isBuffer(t);\n}\nconst ah = nr(\"ArrayBuffer\");\nfunction Dy(t) {\n  let e;\n  return typeof ArrayBuffer < \"u\" && ArrayBuffer.isView ? e = ArrayBuffer.isView(t) : e = t && t.buffer && ah(t.buffer), e;\n}\nconst Ny = Bo(\"string\"), Vt = Bo(\"function\"), ch = Bo(\"number\"), Io = (t) => t !== null && typeof t == \"object\", Fy = (t) => t === !0 || t === !1, xi = (t) => {\n  if (Ro(t) !== \"object\")\n    return !1;\n  const e = nc(t);\n  return (e === null || e === Object.prototype || Object.getPrototypeOf(e) === null) && !(Symbol.toStringTag in t) && !(Symbol.iterator in t);\n}, Ly = nr(\"Date\"), jy = nr(\"File\"), Uy = nr(\"Blob\"), Vy = nr(\"FileList\"), $y = (t) => Io(t) && Vt(t.pipe), Hy = (t) => {\n  let e;\n  return t && (typeof FormData == \"function\" && t instanceof FormData || Vt(t.append) && ((e = Ro(t)) === \"formdata\" || e === \"object\" && Vt(t.toString) && t.toString() === \"[object FormData]\"));\n}, Wy = nr(\"URLSearchParams\"), zy = (t) => t.trim ? t.trim() : t.replace(/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, \"\");\nfunction Qn(t, e, { allOwnKeys: r = !1 } = {}) {\n  if (t === null || typeof t > \"u\")\n    return;\n  let n, i;\n  if (typeof t != \"object\" && (t = [t]), gn(t))\n    for (n = 0, i = t.length; n < i; n++)\n      e.call(null, t[n], n, t);\n  else {\n    const o = r ? Object.getOwnPropertyNames(t) : Object.keys(t), a = o.length;\n    let s;\n    for (n = 0; n < a; n++)\n      s = o[n], e.call(null, t[s], s, t);\n  }\n}\nfunction uh(t, e) {\n  e = e.toLowerCase();\n  const r = Object.keys(t);\n  let n = r.length, i;\n  for (; n-- > 0; )\n    if (i = r[n], e === i.toLowerCase())\n      return i;\n  return null;\n}\nconst lh = (() => typeof globalThis < \"u\" ? globalThis : typeof self < \"u\" ? self : typeof window < \"u\" ? window : global)(), fh = (t) => !$n(t) && t !== lh;\nfunction ga() {\n  const { caseless: t } = fh(this) && this || {}, e = {}, r = (n, i) => {\n    const o = t && uh(e, i) || i;\n    xi(e[o]) && xi(n) ? e[o] = ga(e[o], n) : xi(n) ? e[o] = ga({}, n) : gn(n) ? e[o] = n.slice() : e[o] = n;\n  };\n  for (let n = 0, i = arguments.length; n < i; n++)\n    arguments[n] && Qn(arguments[n], r);\n  return e;\n}\nconst qy = (t, e, r, { allOwnKeys: n } = {}) => (Qn(e, (i, o) => {\n  r && Vt(i) ? t[o] = sh(i, r) : t[o] = i;\n}, { allOwnKeys: n }), t), Ky = (t) => (t.charCodeAt(0) === 65279 && (t = t.slice(1)), t), Gy = (t, e, r, n) => {\n  t.prototype = Object.create(e.prototype, n), t.prototype.constructor = t, Object.defineProperty(t, \"super\", {\n    value: e.prototype\n  }), r && Object.assign(t.prototype, r);\n}, Yy = (t, e, r, n) => {\n  let i, o, a;\n  const s = {};\n  if (e = e || {}, t == null)\n    return e;\n  do {\n    for (i = Object.getOwnPropertyNames(t), o = i.length; o-- > 0; )\n      a = i[o], (!n || n(a, t, e)) && !s[a] && (e[a] = t[a], s[a] = !0);\n    t = r !== !1 && nc(t);\n  } while (t && (!r || r(t, e)) && t !== Object.prototype);\n  return e;\n}, Zy = (t, e, r) => {\n  t = String(t), (r === void 0 || r > t.length) && (r = t.length), r -= e.length;\n  const n = t.indexOf(e, r);\n  return n !== -1 && n === r;\n}, Xy = (t) => {\n  if (!t)\n    return null;\n  if (gn(t))\n    return t;\n  let e = t.length;\n  if (!ch(e))\n    return null;\n  const r = new Array(e);\n  for (; e-- > 0; )\n    r[e] = t[e];\n  return r;\n}, Jy = ((t) => (e) => t && e instanceof t)(typeof Uint8Array < \"u\" && nc(Uint8Array)), Qy = (t, e) => {\n  const n = (t && t[Symbol.iterator]).call(t);\n  let i;\n  for (; (i = n.next()) && !i.done; ) {\n    const o = i.value;\n    e.call(t, o[0], o[1]);\n  }\n}, em = (t, e) => {\n  let r;\n  const n = [];\n  for (; (r = t.exec(e)) !== null; )\n    n.push(r);\n  return n;\n}, tm = nr(\"HTMLFormElement\"), rm = (t) => t.toLowerCase().replace(\n  /[-_\\s]([a-z\\d])(\\w*)/g,\n  function(r, n, i) {\n    return n.toUpperCase() + i;\n  }\n), tl = (({ hasOwnProperty: t }) => (e, r) => t.call(e, r))(Object.prototype), nm = nr(\"RegExp\"), hh = (t, e) => {\n  const r = Object.getOwnPropertyDescriptors(t), n = {};\n  Qn(r, (i, o) => {\n    e(i, o, t) !== !1 && (n[o] = i);\n  }), Object.defineProperties(t, n);\n}, im = (t) => {\n  hh(t, (e, r) => {\n    if (Vt(t) && [\"arguments\", \"caller\", \"callee\"].indexOf(r) !== -1)\n      return !1;\n    const n = t[r];\n    if (Vt(n)) {\n      if (e.enumerable = !1, \"writable\" in e) {\n        e.writable = !1;\n        return;\n      }\n      e.set || (e.set = () => {\n        throw Error(\"Can not rewrite read-only method '\" + r + \"'\");\n      });\n    }\n  });\n}, om = (t, e) => {\n  const r = {}, n = (i) => {\n    i.forEach((o) => {\n      r[o] = !0;\n    });\n  };\n  return gn(t) ? n(t) : n(String(t).split(e)), r;\n}, sm = () => {\n}, am = (t, e) => (t = +t, Number.isFinite(t) ? t : e), Is = \"abcdefghijklmnopqrstuvwxyz\", rl = \"0123456789\", dh = {\n  DIGIT: rl,\n  ALPHA: Is,\n  ALPHA_DIGIT: Is + Is.toUpperCase() + rl\n}, cm = (t = 16, e = dh.ALPHA_DIGIT) => {\n  let r = \"\";\n  const { length: n } = e;\n  for (; t--; )\n    r += e[Math.random() * n | 0];\n  return r;\n};\nfunction um(t) {\n  return !!(t && Vt(t.append) && t[Symbol.toStringTag] === \"FormData\" && t[Symbol.iterator]);\n}\nconst lm = (t) => {\n  const e = new Array(10), r = (n, i) => {\n    if (Io(n)) {\n      if (e.indexOf(n) >= 0)\n        return;\n      if (!(\"toJSON\" in n)) {\n        e[i] = n;\n        const o = gn(n) ? [] : {};\n        return Qn(n, (a, s) => {\n          const l = r(a, i + 1);\n          !$n(l) && (o[s] = l);\n        }), e[i] = void 0, o;\n      }\n    }\n    return n;\n  };\n  return r(t, 0);\n}, fm = nr(\"AsyncFunction\"), hm = (t) => t && (Io(t) || Vt(t)) && Vt(t.then) && Vt(t.catch), fe = {\n  isArray: gn,\n  isArrayBuffer: ah,\n  isBuffer: Iy,\n  isFormData: Hy,\n  isArrayBufferView: Dy,\n  isString: Ny,\n  isNumber: ch,\n  isBoolean: Fy,\n  isObject: Io,\n  isPlainObject: xi,\n  isUndefined: $n,\n  isDate: Ly,\n  isFile: jy,\n  isBlob: Uy,\n  isRegExp: nm,\n  isFunction: Vt,\n  isStream: $y,\n  isURLSearchParams: Wy,\n  isTypedArray: Jy,\n  isFileList: Vy,\n  forEach: Qn,\n  merge: ga,\n  extend: qy,\n  trim: zy,\n  stripBOM: Ky,\n  inherits: Gy,\n  toFlatObject: Yy,\n  kindOf: Ro,\n  kindOfTest: nr,\n  endsWith: Zy,\n  toArray: Xy,\n  forEachEntry: Qy,\n  matchAll: em,\n  isHTMLForm: tm,\n  hasOwnProperty: tl,\n  hasOwnProp: tl,\n  // an alias to avoid ESLint no-prototype-builtins detection\n  reduceDescriptors: hh,\n  freezeMethods: im,\n  toObjectSet: om,\n  toCamelCase: rm,\n  noop: sm,\n  toFiniteNumber: am,\n  findKey: uh,\n  global: lh,\n  isContextDefined: fh,\n  ALPHABET: dh,\n  generateString: cm,\n  isSpecCompliantForm: um,\n  toJSONObject: lm,\n  isAsyncFn: fm,\n  isThenable: hm\n};\nfunction De(t, e, r, n, i) {\n  Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = t, this.name = \"AxiosError\", e && (this.code = e), r && (this.config = r), n && (this.request = n), i && (this.response = i);\n}\nfe.inherits(De, Error, {\n  toJSON: function() {\n    return {\n      // Standard\n      message: this.message,\n      name: this.name,\n      // Microsoft\n      description: this.description,\n      number: this.number,\n      // Mozilla\n      fileName: this.fileName,\n      lineNumber: this.lineNumber,\n      columnNumber: this.columnNumber,\n      stack: this.stack,\n      // Axios\n      config: fe.toJSONObject(this.config),\n      code: this.code,\n      status: this.response && this.response.status ? this.response.status : null\n    };\n  }\n});\nconst ph = De.prototype, yh = {};\n[\n  \"ERR_BAD_OPTION_VALUE\",\n  \"ERR_BAD_OPTION\",\n  \"ECONNABORTED\",\n  \"ETIMEDOUT\",\n  \"ERR_NETWORK\",\n  \"ERR_FR_TOO_MANY_REDIRECTS\",\n  \"ERR_DEPRECATED\",\n  \"ERR_BAD_RESPONSE\",\n  \"ERR_BAD_REQUEST\",\n  \"ERR_CANCELED\",\n  \"ERR_NOT_SUPPORT\",\n  \"ERR_INVALID_URL\"\n  // eslint-disable-next-line func-names\n].forEach((t) => {\n  yh[t] = { value: t };\n});\nObject.defineProperties(De, yh);\nObject.defineProperty(ph, \"isAxiosError\", { value: !0 });\nDe.from = (t, e, r, n, i, o) => {\n  const a = Object.create(ph);\n  return fe.toFlatObject(t, a, function(l) {\n    return l !== Error.prototype;\n  }, (s) => s !== \"isAxiosError\"), De.call(a, t.message, e, r, n, i), a.cause = t, a.name = t.name, o && Object.assign(a, o), a;\n};\nconst dm = null;\nfunction xa(t) {\n  return fe.isPlainObject(t) || fe.isArray(t);\n}\nfunction mh(t) {\n  return fe.endsWith(t, \"[]\") ? t.slice(0, -2) : t;\n}\nfunction nl(t, e, r) {\n  return t ? t.concat(e).map(function(i, o) {\n    return i = mh(i), !r && o ? \"[\" + i + \"]\" : i;\n  }).join(r ? \".\" : \"\") : e;\n}\nfunction pm(t) {\n  return fe.isArray(t) && !t.some(xa);\n}\nconst ym = fe.toFlatObject(fe, {}, null, function(e) {\n  return /^is[A-Z]/.test(e);\n});\nfunction Do(t, e, r) {\n  if (!fe.isObject(t))\n    throw new TypeError(\"target must be an object\");\n  e = e || new FormData(), r = fe.toFlatObject(r, {\n    metaTokens: !0,\n    dots: !1,\n    indexes: !1\n  }, !1, function(_, T) {\n    return !fe.isUndefined(T[_]);\n  });\n  const n = r.metaTokens, i = r.visitor || c, o = r.dots, a = r.indexes, l = (r.Blob || typeof Blob < \"u\" && Blob) && fe.isSpecCompliantForm(e);\n  if (!fe.isFunction(i))\n    throw new TypeError(\"visitor must be a function\");\n  function u(g) {\n    if (g === null)\n      return \"\";\n    if (fe.isDate(g))\n      return g.toISOString();\n    if (!l && fe.isBlob(g))\n      throw new De(\"Blob is not supported. Use a Buffer instead.\");\n    return fe.isArrayBuffer(g) || fe.isTypedArray(g) ? l && typeof Blob == \"function\" ? new Blob([g]) : Buffer.from(g) : g;\n  }\n  function c(g, _, T) {\n    let A = g;\n    if (g && !T && typeof g == \"object\") {\n      if (fe.endsWith(_, \"{}\"))\n        _ = n ? _ : _.slice(0, -2), g = JSON.stringify(g);\n      else if (fe.isArray(g) && pm(g) || (fe.isFileList(g) || fe.endsWith(_, \"[]\")) && (A = fe.toArray(g)))\n        return _ = mh(_), A.forEach(function(O, R) {\n          !(fe.isUndefined(O) || O === null) && e.append(\n            // eslint-disable-next-line no-nested-ternary\n            a === !0 ? nl([_], R, o) : a === null ? _ : _ + \"[]\",\n            u(O)\n          );\n        }), !1;\n    }\n    return xa(g) ? !0 : (e.append(nl(T, _, o), u(g)), !1);\n  }\n  const f = [], h = Object.assign(ym, {\n    defaultVisitor: c,\n    convertValue: u,\n    isVisitable: xa\n  });\n  function p(g, _) {\n    if (!fe.isUndefined(g)) {\n      if (f.indexOf(g) !== -1)\n        throw Error(\"Circular reference detected in \" + _.join(\".\"));\n      f.push(g), fe.forEach(g, function(A, w) {\n        (!(fe.isUndefined(A) || A === null) && i.call(\n          e,\n          A,\n          fe.isString(w) ? w.trim() : w,\n          _,\n          h\n        )) === !0 && p(A, _ ? _.concat(w) : [w]);\n      }), f.pop();\n    }\n  }\n  if (!fe.isObject(t))\n    throw new TypeError(\"data must be an object\");\n  return p(t), e;\n}\nfunction il(t) {\n  const e = {\n    \"!\": \"%21\",\n    \"'\": \"%27\",\n    \"(\": \"%28\",\n    \")\": \"%29\",\n    \"~\": \"%7E\",\n    \"%20\": \"+\",\n    \"%00\": \"\\0\"\n  };\n  return encodeURIComponent(t).replace(/[!'()~]|%20|%00/g, function(n) {\n    return e[n];\n  });\n}\nfunction ic(t, e) {\n  this._pairs = [], t && Do(t, this, e);\n}\nconst vh = ic.prototype;\nvh.append = function(e, r) {\n  this._pairs.push([e, r]);\n};\nvh.toString = function(e) {\n  const r = e ? function(n) {\n    return e.call(this, n, il);\n  } : il;\n  return this._pairs.map(function(i) {\n    return r(i[0]) + \"=\" + r(i[1]);\n  }, \"\").join(\"&\");\n};\nfunction mm(t) {\n  return encodeURIComponent(t).replace(/%3A/gi, \":\").replace(/%24/g, \"$\").replace(/%2C/gi, \",\").replace(/%20/g, \"+\").replace(/%5B/gi, \"[\").replace(/%5D/gi, \"]\");\n}\nfunction gh(t, e, r) {\n  if (!e)\n    return t;\n  const n = r && r.encode || mm, i = r && r.serialize;\n  let o;\n  if (i ? o = i(e, r) : o = fe.isURLSearchParams(e) ? e.toString() : new ic(e, r).toString(n), o) {\n    const a = t.indexOf(\"#\");\n    a !== -1 && (t = t.slice(0, a)), t += (t.indexOf(\"?\") === -1 ? \"?\" : \"&\") + o;\n  }\n  return t;\n}\nclass vm {\n  constructor() {\n    this.handlers = [];\n  }\n  /**\n   * Add a new interceptor to the stack\n   *\n   * @param {Function} fulfilled The function to handle `then` for a `Promise`\n   * @param {Function} rejected The function to handle `reject` for a `Promise`\n   *\n   * @return {Number} An ID used to remove interceptor later\n   */\n  use(e, r, n) {\n    return this.handlers.push({\n      fulfilled: e,\n      rejected: r,\n      synchronous: n ? n.synchronous : !1,\n      runWhen: n ? n.runWhen : null\n    }), this.handlers.length - 1;\n  }\n  /**\n   * Remove an interceptor from the stack\n   *\n   * @param {Number} id The ID that was returned by `use`\n   *\n   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise\n   */\n  eject(e) {\n    this.handlers[e] && (this.handlers[e] = null);\n  }\n  /**\n   * Clear all interceptors from the stack\n   *\n   * @returns {void}\n   */\n  clear() {\n    this.handlers && (this.handlers = []);\n  }\n  /**\n   * Iterate over all the registered interceptors\n   *\n   * This method is particularly useful for skipping over any\n   * interceptors that may have become `null` calling `eject`.\n   *\n   * @param {Function} fn The function to call for each interceptor\n   *\n   * @returns {void}\n   */\n  forEach(e) {\n    fe.forEach(this.handlers, function(n) {\n      n !== null && e(n);\n    });\n  }\n}\nconst ol = vm, xh = {\n  silentJSONParsing: !0,\n  forcedJSONParsing: !0,\n  clarifyTimeoutError: !1\n}, gm = typeof URLSearchParams < \"u\" ? URLSearchParams : ic, xm = typeof FormData < \"u\" ? FormData : null, wm = typeof Blob < \"u\" ? Blob : null, bm = (() => {\n  let t;\n  return typeof navigator < \"u\" && ((t = navigator.product) === \"ReactNative\" || t === \"NativeScript\" || t === \"NS\") ? !1 : typeof window < \"u\" && typeof document < \"u\";\n})(), _m = (() => typeof WorkerGlobalScope < \"u\" && // eslint-disable-next-line no-undef\nself instanceof WorkerGlobalScope && typeof self.importScripts == \"function\")(), er = {\n  isBrowser: !0,\n  classes: {\n    URLSearchParams: gm,\n    FormData: xm,\n    Blob: wm\n  },\n  isStandardBrowserEnv: bm,\n  isStandardBrowserWebWorkerEnv: _m,\n  protocols: [\"http\", \"https\", \"file\", \"blob\", \"url\", \"data\"]\n};\nfunction Am(t, e) {\n  return Do(t, new er.classes.URLSearchParams(), Object.assign({\n    visitor: function(r, n, i, o) {\n      return er.isNode && fe.isBuffer(r) ? (this.append(n, r.toString(\"base64\")), !1) : o.defaultVisitor.apply(this, arguments);\n    }\n  }, e));\n}\nfunction Tm(t) {\n  return fe.matchAll(/\\w+|\\[(\\w*)]/g, t).map((e) => e[0] === \"[]\" ? \"\" : e[1] || e[0]);\n}\nfunction Em(t) {\n  const e = {}, r = Object.keys(t);\n  let n;\n  const i = r.length;\n  let o;\n  for (n = 0; n < i; n++)\n    o = r[n], e[o] = t[o];\n  return e;\n}\nfunction wh(t) {\n  function e(r, n, i, o) {\n    let a = r[o++];\n    const s = Number.isFinite(+a), l = o >= r.length;\n    return a = !a && fe.isArray(i) ? i.length : a, l ? (fe.hasOwnProp(i, a) ? i[a] = [i[a], n] : i[a] = n, !s) : ((!i[a] || !fe.isObject(i[a])) && (i[a] = []), e(r, n, i[a], o) && fe.isArray(i[a]) && (i[a] = Em(i[a])), !s);\n  }\n  if (fe.isFormData(t) && fe.isFunction(t.entries)) {\n    const r = {};\n    return fe.forEachEntry(t, (n, i) => {\n      e(Tm(n), i, r, 0);\n    }), r;\n  }\n  return null;\n}\nconst Sm = {\n  \"Content-Type\": void 0\n};\nfunction Pm(t, e, r) {\n  if (fe.isString(t))\n    try {\n      return (e || JSON.parse)(t), fe.trim(t);\n    } catch (n) {\n      if (n.name !== \"SyntaxError\")\n        throw n;\n    }\n  return (r || JSON.stringify)(t);\n}\nconst No = {\n  transitional: xh,\n  adapter: [\"xhr\", \"http\"],\n  transformRequest: [function(e, r) {\n    const n = r.getContentType() || \"\", i = n.indexOf(\"application/json\") > -1, o = fe.isObject(e);\n    if (o && fe.isHTMLForm(e) && (e = new FormData(e)), fe.isFormData(e))\n      return i && i ? JSON.stringify(wh(e)) : e;\n    if (fe.isArrayBuffer(e) || fe.isBuffer(e) || fe.isStream(e) || fe.isFile(e) || fe.isBlob(e))\n      return e;\n    if (fe.isArrayBufferView(e))\n      return e.buffer;\n    if (fe.isURLSearchParams(e))\n      return r.setContentType(\"application/x-www-form-urlencoded;charset=utf-8\", !1), e.toString();\n    let s;\n    if (o) {\n      if (n.indexOf(\"application/x-www-form-urlencoded\") > -1)\n        return Am(e, this.formSerializer).toString();\n      if ((s = fe.isFileList(e)) || n.indexOf(\"multipart/form-data\") > -1) {\n        const l = this.env && this.env.FormData;\n        return Do(\n          s ? { \"files[]\": e } : e,\n          l && new l(),\n          this.formSerializer\n        );\n      }\n    }\n    return o || i ? (r.setContentType(\"application/json\", !1), Pm(e)) : e;\n  }],\n  transformResponse: [function(e) {\n    const r = this.transitional || No.transitional, n = r && r.forcedJSONParsing, i = this.responseType === \"json\";\n    if (e && fe.isString(e) && (n && !this.responseType || i)) {\n      const a = !(r && r.silentJSONParsing) && i;\n      try {\n        return JSON.parse(e);\n      } catch (s) {\n        if (a)\n          throw s.name === \"SyntaxError\" ? De.from(s, De.ERR_BAD_RESPONSE, this, null, this.response) : s;\n      }\n    }\n    return e;\n  }],\n  /**\n   * A timeout in milliseconds to abort a request. If set to 0 (default) a\n   * timeout is not created.\n   */\n  timeout: 0,\n  xsrfCookieName: \"XSRF-TOKEN\",\n  xsrfHeaderName: \"X-XSRF-TOKEN\",\n  maxContentLength: -1,\n  maxBodyLength: -1,\n  env: {\n    FormData: er.classes.FormData,\n    Blob: er.classes.Blob\n  },\n  validateStatus: function(e) {\n    return e >= 200 && e < 300;\n  },\n  headers: {\n    common: {\n      Accept: \"application/json, text/plain, */*\"\n    }\n  }\n};\nfe.forEach([\"delete\", \"get\", \"head\"], function(e) {\n  No.headers[e] = {};\n});\nfe.forEach([\"post\", \"put\", \"patch\"], function(e) {\n  No.headers[e] = fe.merge(Sm);\n});\nconst oc = No, Cm = fe.toObjectSet([\n  \"age\",\n  \"authorization\",\n  \"content-length\",\n  \"content-type\",\n  \"etag\",\n  \"expires\",\n  \"from\",\n  \"host\",\n  \"if-modified-since\",\n  \"if-unmodified-since\",\n  \"last-modified\",\n  \"location\",\n  \"max-forwards\",\n  \"proxy-authorization\",\n  \"referer\",\n  \"retry-after\",\n  \"user-agent\"\n]), Om = (t) => {\n  const e = {};\n  let r, n, i;\n  return t && t.split(`\n`).forEach(function(a) {\n    i = a.indexOf(\":\"), r = a.substring(0, i).trim().toLowerCase(), n = a.substring(i + 1).trim(), !(!r || e[r] && Cm[r]) && (r === \"set-cookie\" ? e[r] ? e[r].push(n) : e[r] = [n] : e[r] = e[r] ? e[r] + \", \" + n : n);\n  }), e;\n}, sl = Symbol(\"internals\");\nfunction _n(t) {\n  return t && String(t).trim().toLowerCase();\n}\nfunction wi(t) {\n  return t === !1 || t == null ? t : fe.isArray(t) ? t.map(wi) : String(t);\n}\nfunction Mm(t) {\n  const e = /* @__PURE__ */ Object.create(null), r = /([^\\s,;=]+)\\s*(?:=\\s*([^,;]+))?/g;\n  let n;\n  for (; n = r.exec(t); )\n    e[n[1]] = n[2];\n  return e;\n}\nconst km = (t) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(t.trim());\nfunction Ds(t, e, r, n, i) {\n  if (fe.isFunction(n))\n    return n.call(this, e, r);\n  if (i && (e = r), !!fe.isString(e)) {\n    if (fe.isString(n))\n      return e.indexOf(n) !== -1;\n    if (fe.isRegExp(n))\n      return n.test(e);\n  }\n}\nfunction Rm(t) {\n  return t.trim().toLowerCase().replace(/([a-z\\d])(\\w*)/g, (e, r, n) => r.toUpperCase() + n);\n}\nfunction Bm(t, e) {\n  const r = fe.toCamelCase(\" \" + e);\n  [\"get\", \"set\", \"has\"].forEach((n) => {\n    Object.defineProperty(t, n + r, {\n      value: function(i, o, a) {\n        return this[n].call(this, e, i, o, a);\n      },\n      configurable: !0\n    });\n  });\n}\nclass Fo {\n  constructor(e) {\n    e && this.set(e);\n  }\n  set(e, r, n) {\n    const i = this;\n    function o(s, l, u) {\n      const c = _n(l);\n      if (!c)\n        throw new Error(\"header name must be a non-empty string\");\n      const f = fe.findKey(i, c);\n      (!f || i[f] === void 0 || u === !0 || u === void 0 && i[f] !== !1) && (i[f || l] = wi(s));\n    }\n    const a = (s, l) => fe.forEach(s, (u, c) => o(u, c, l));\n    return fe.isPlainObject(e) || e instanceof this.constructor ? a(e, r) : fe.isString(e) && (e = e.trim()) && !km(e) ? a(Om(e), r) : e != null && o(r, e, n), this;\n  }\n  get(e, r) {\n    if (e = _n(e), e) {\n      const n = fe.findKey(this, e);\n      if (n) {\n        const i = this[n];\n        if (!r)\n          return i;\n        if (r === !0)\n          return Mm(i);\n        if (fe.isFunction(r))\n          return r.call(this, i, n);\n        if (fe.isRegExp(r))\n          return r.exec(i);\n        throw new TypeError(\"parser must be boolean|regexp|function\");\n      }\n    }\n  }\n  has(e, r) {\n    if (e = _n(e), e) {\n      const n = fe.findKey(this, e);\n      return !!(n && this[n] !== void 0 && (!r || Ds(this, this[n], n, r)));\n    }\n    return !1;\n  }\n  delete(e, r) {\n    const n = this;\n    let i = !1;\n    function o(a) {\n      if (a = _n(a), a) {\n        const s = fe.findKey(n, a);\n        s && (!r || Ds(n, n[s], s, r)) && (delete n[s], i = !0);\n      }\n    }\n    return fe.isArray(e) ? e.forEach(o) : o(e), i;\n  }\n  clear(e) {\n    const r = Object.keys(this);\n    let n = r.length, i = !1;\n    for (; n--; ) {\n      const o = r[n];\n      (!e || Ds(this, this[o], o, e, !0)) && (delete this[o], i = !0);\n    }\n    return i;\n  }\n  normalize(e) {\n    const r = this, n = {};\n    return fe.forEach(this, (i, o) => {\n      const a = fe.findKey(n, o);\n      if (a) {\n        r[a] = wi(i), delete r[o];\n        return;\n      }\n      const s = e ? Rm(o) : String(o).trim();\n      s !== o && delete r[o], r[s] = wi(i), n[s] = !0;\n    }), this;\n  }\n  concat(...e) {\n    return this.constructor.concat(this, ...e);\n  }\n  toJSON(e) {\n    const r = /* @__PURE__ */ Object.create(null);\n    return fe.forEach(this, (n, i) => {\n      n != null && n !== !1 && (r[i] = e && fe.isArray(n) ? n.join(\", \") : n);\n    }), r;\n  }\n  [Symbol.iterator]() {\n    return Object.entries(this.toJSON())[Symbol.iterator]();\n  }\n  toString() {\n    return Object.entries(this.toJSON()).map(([e, r]) => e + \": \" + r).join(`\n`);\n  }\n  get [Symbol.toStringTag]() {\n    return \"AxiosHeaders\";\n  }\n  static from(e) {\n    return e instanceof this ? e : new this(e);\n  }\n  static concat(e, ...r) {\n    const n = new this(e);\n    return r.forEach((i) => n.set(i)), n;\n  }\n  static accessor(e) {\n    const n = (this[sl] = this[sl] = {\n      accessors: {}\n    }).accessors, i = this.prototype;\n    function o(a) {\n      const s = _n(a);\n      n[s] || (Bm(i, a), n[s] = !0);\n    }\n    return fe.isArray(e) ? e.forEach(o) : o(e), this;\n  }\n}\nFo.accessor([\"Content-Type\", \"Content-Length\", \"Accept\", \"Accept-Encoding\", \"User-Agent\", \"Authorization\"]);\nfe.freezeMethods(Fo.prototype);\nfe.freezeMethods(Fo);\nconst ur = Fo;\nfunction Ns(t, e) {\n  const r = this || oc, n = e || r, i = ur.from(n.headers);\n  let o = n.data;\n  return fe.forEach(t, function(s) {\n    o = s.call(r, o, i.normalize(), e ? e.status : void 0);\n  }), i.normalize(), o;\n}\nfunction bh(t) {\n  return !!(t && t.__CANCEL__);\n}\nfunction ei(t, e, r) {\n  De.call(this, t ?? \"canceled\", De.ERR_CANCELED, e, r), this.name = \"CanceledError\";\n}\nfe.inherits(ei, De, {\n  __CANCEL__: !0\n});\nfunction Im(t, e, r) {\n  const n = r.config.validateStatus;\n  !r.status || !n || n(r.status) ? t(r) : e(new De(\n    \"Request failed with status code \" + r.status,\n    [De.ERR_BAD_REQUEST, De.ERR_BAD_RESPONSE][Math.floor(r.status / 100) - 4],\n    r.config,\n    r.request,\n    r\n  ));\n}\nconst Dm = er.isStandardBrowserEnv ? function() {\n  return {\n    write: function(r, n, i, o, a, s) {\n      const l = [];\n      l.push(r + \"=\" + encodeURIComponent(n)), fe.isNumber(i) && l.push(\"expires=\" + new Date(i).toGMTString()), fe.isString(o) && l.push(\"path=\" + o), fe.isString(a) && l.push(\"domain=\" + a), s === !0 && l.push(\"secure\"), document.cookie = l.join(\"; \");\n    },\n    read: function(r) {\n      const n = document.cookie.match(new RegExp(\"(^|;\\\\s*)(\" + r + \")=([^;]*)\"));\n      return n ? decodeURIComponent(n[3]) : null;\n    },\n    remove: function(r) {\n      this.write(r, \"\", Date.now() - 864e5);\n    }\n  };\n}() : function() {\n  return {\n    write: function() {\n    },\n    read: function() {\n      return null;\n    },\n    remove: function() {\n    }\n  };\n}();\nfunction Nm(t) {\n  return /^([a-z][a-z\\d+\\-.]*:)?\\/\\//i.test(t);\n}\nfunction Fm(t, e) {\n  return e ? t.replace(/\\/+$/, \"\") + \"/\" + e.replace(/^\\/+/, \"\") : t;\n}\nfunction _h(t, e) {\n  return t && !Nm(e) ? Fm(t, e) : e;\n}\nconst Lm = er.isStandardBrowserEnv ? function() {\n  const e = /(msie|trident)/i.test(navigator.userAgent), r = document.createElement(\"a\");\n  let n;\n  function i(o) {\n    let a = o;\n    return e && (r.setAttribute(\"href\", a), a = r.href), r.setAttribute(\"href\", a), {\n      href: r.href,\n      protocol: r.protocol ? r.protocol.replace(/:$/, \"\") : \"\",\n      host: r.host,\n      search: r.search ? r.search.replace(/^\\?/, \"\") : \"\",\n      hash: r.hash ? r.hash.replace(/^#/, \"\") : \"\",\n      hostname: r.hostname,\n      port: r.port,\n      pathname: r.pathname.charAt(0) === \"/\" ? r.pathname : \"/\" + r.pathname\n    };\n  }\n  return n = i(window.location.href), function(a) {\n    const s = fe.isString(a) ? i(a) : a;\n    return s.protocol === n.protocol && s.host === n.host;\n  };\n}() : function() {\n  return function() {\n    return !0;\n  };\n}();\nfunction jm(t) {\n  const e = /^([-+\\w]{1,25})(:?\\/\\/|:)/.exec(t);\n  return e && e[1] || \"\";\n}\nfunction Um(t, e) {\n  t = t || 10;\n  const r = new Array(t), n = new Array(t);\n  let i = 0, o = 0, a;\n  return e = e !== void 0 ? e : 1e3, function(l) {\n    const u = Date.now(), c = n[o];\n    a || (a = u), r[i] = l, n[i] = u;\n    let f = o, h = 0;\n    for (; f !== i; )\n      h += r[f++], f = f % t;\n    if (i = (i + 1) % t, i === o && (o = (o + 1) % t), u - a < e)\n      return;\n    const p = c && u - c;\n    return p ? Math.round(h * 1e3 / p) : void 0;\n  };\n}\nfunction al(t, e) {\n  let r = 0;\n  const n = Um(50, 250);\n  return (i) => {\n    const o = i.loaded, a = i.lengthComputable ? i.total : void 0, s = o - r, l = n(s), u = o <= a;\n    r = o;\n    const c = {\n      loaded: o,\n      total: a,\n      progress: a ? o / a : void 0,\n      bytes: s,\n      rate: l || void 0,\n      estimated: l && a && u ? (a - o) / l : void 0,\n      event: i\n    };\n    c[e ? \"download\" : \"upload\"] = !0, t(c);\n  };\n}\nconst Vm = typeof XMLHttpRequest < \"u\", $m = Vm && function(t) {\n  return new Promise(function(r, n) {\n    let i = t.data;\n    const o = ur.from(t.headers).normalize(), a = t.responseType;\n    let s;\n    function l() {\n      t.cancelToken && t.cancelToken.unsubscribe(s), t.signal && t.signal.removeEventListener(\"abort\", s);\n    }\n    fe.isFormData(i) && (er.isStandardBrowserEnv || er.isStandardBrowserWebWorkerEnv ? o.setContentType(!1) : o.setContentType(\"multipart/form-data;\", !1));\n    let u = new XMLHttpRequest();\n    if (t.auth) {\n      const p = t.auth.username || \"\", g = t.auth.password ? unescape(encodeURIComponent(t.auth.password)) : \"\";\n      o.set(\"Authorization\", \"Basic \" + btoa(p + \":\" + g));\n    }\n    const c = _h(t.baseURL, t.url);\n    u.open(t.method.toUpperCase(), gh(c, t.params, t.paramsSerializer), !0), u.timeout = t.timeout;\n    function f() {\n      if (!u)\n        return;\n      const p = ur.from(\n        \"getAllResponseHeaders\" in u && u.getAllResponseHeaders()\n      ), _ = {\n        data: !a || a === \"text\" || a === \"json\" ? u.responseText : u.response,\n        status: u.status,\n        statusText: u.statusText,\n        headers: p,\n        config: t,\n        request: u\n      };\n      Im(function(A) {\n        r(A), l();\n      }, function(A) {\n        n(A), l();\n      }, _), u = null;\n    }\n    if (\"onloadend\" in u ? u.onloadend = f : u.onreadystatechange = function() {\n      !u || u.readyState !== 4 || u.status === 0 && !(u.responseURL && u.responseURL.indexOf(\"file:\") === 0) || setTimeout(f);\n    }, u.onabort = function() {\n      u && (n(new De(\"Request aborted\", De.ECONNABORTED, t, u)), u = null);\n    }, u.onerror = function() {\n      n(new De(\"Network Error\", De.ERR_NETWORK, t, u)), u = null;\n    }, u.ontimeout = function() {\n      let g = t.timeout ? \"timeout of \" + t.timeout + \"ms exceeded\" : \"timeout exceeded\";\n      const _ = t.transitional || xh;\n      t.timeoutErrorMessage && (g = t.timeoutErrorMessage), n(new De(\n        g,\n        _.clarifyTimeoutError ? De.ETIMEDOUT : De.ECONNABORTED,\n        t,\n        u\n      )), u = null;\n    }, er.isStandardBrowserEnv) {\n      const p = (t.withCredentials || Lm(c)) && t.xsrfCookieName && Dm.read(t.xsrfCookieName);\n      p && o.set(t.xsrfHeaderName, p);\n    }\n    i === void 0 && o.setContentType(null), \"setRequestHeader\" in u && fe.forEach(o.toJSON(), function(g, _) {\n      u.setRequestHeader(_, g);\n    }), fe.isUndefined(t.withCredentials) || (u.withCredentials = !!t.withCredentials), a && a !== \"json\" && (u.responseType = t.responseType), typeof t.onDownloadProgress == \"function\" && u.addEventListener(\"progress\", al(t.onDownloadProgress, !0)), typeof t.onUploadProgress == \"function\" && u.upload && u.upload.addEventListener(\"progress\", al(t.onUploadProgress)), (t.cancelToken || t.signal) && (s = (p) => {\n      u && (n(!p || p.type ? new ei(null, t, u) : p), u.abort(), u = null);\n    }, t.cancelToken && t.cancelToken.subscribe(s), t.signal && (t.signal.aborted ? s() : t.signal.addEventListener(\"abort\", s)));\n    const h = jm(c);\n    if (h && er.protocols.indexOf(h) === -1) {\n      n(new De(\"Unsupported protocol \" + h + \":\", De.ERR_BAD_REQUEST, t));\n      return;\n    }\n    u.send(i || null);\n  });\n}, bi = {\n  http: dm,\n  xhr: $m\n};\nfe.forEach(bi, (t, e) => {\n  if (t) {\n    try {\n      Object.defineProperty(t, \"name\", { value: e });\n    } catch {\n    }\n    Object.defineProperty(t, \"adapterName\", { value: e });\n  }\n});\nconst Hm = {\n  getAdapter: (t) => {\n    t = fe.isArray(t) ? t : [t];\n    const { length: e } = t;\n    let r, n;\n    for (let i = 0; i < e && (r = t[i], !(n = fe.isString(r) ? bi[r.toLowerCase()] : r)); i++)\n      ;\n    if (!n)\n      throw n === !1 ? new De(\n        `Adapter ${r} is not supported by the environment`,\n        \"ERR_NOT_SUPPORT\"\n      ) : new Error(\n        fe.hasOwnProp(bi, r) ? `Adapter '${r}' is not available in the build` : `Unknown adapter '${r}'`\n      );\n    if (!fe.isFunction(n))\n      throw new TypeError(\"adapter is not a function\");\n    return n;\n  },\n  adapters: bi\n};\nfunction Fs(t) {\n  if (t.cancelToken && t.cancelToken.throwIfRequested(), t.signal && t.signal.aborted)\n    throw new ei(null, t);\n}\nfunction cl(t) {\n  return Fs(t), t.headers = ur.from(t.headers), t.data = Ns.call(\n    t,\n    t.transformRequest\n  ), [\"post\", \"put\", \"patch\"].indexOf(t.method) !== -1 && t.headers.setContentType(\"application/x-www-form-urlencoded\", !1), Hm.getAdapter(t.adapter || oc.adapter)(t).then(function(n) {\n    return Fs(t), n.data = Ns.call(\n      t,\n      t.transformResponse,\n      n\n    ), n.headers = ur.from(n.headers), n;\n  }, function(n) {\n    return bh(n) || (Fs(t), n && n.response && (n.response.data = Ns.call(\n      t,\n      t.transformResponse,\n      n.response\n    ), n.response.headers = ur.from(n.response.headers))), Promise.reject(n);\n  });\n}\nconst ul = (t) => t instanceof ur ? t.toJSON() : t;\nfunction fn(t, e) {\n  e = e || {};\n  const r = {};\n  function n(u, c, f) {\n    return fe.isPlainObject(u) && fe.isPlainObject(c) ? fe.merge.call({ caseless: f }, u, c) : fe.isPlainObject(c) ? fe.merge({}, c) : fe.isArray(c) ? c.slice() : c;\n  }\n  function i(u, c, f) {\n    if (fe.isUndefined(c)) {\n      if (!fe.isUndefined(u))\n        return n(void 0, u, f);\n    } else\n      return n(u, c, f);\n  }\n  function o(u, c) {\n    if (!fe.isUndefined(c))\n      return n(void 0, c);\n  }\n  function a(u, c) {\n    if (fe.isUndefined(c)) {\n      if (!fe.isUndefined(u))\n        return n(void 0, u);\n    } else\n      return n(void 0, c);\n  }\n  function s(u, c, f) {\n    if (f in e)\n      return n(u, c);\n    if (f in t)\n      return n(void 0, u);\n  }\n  const l = {\n    url: o,\n    method: o,\n    data: o,\n    baseURL: a,\n    transformRequest: a,\n    transformResponse: a,\n    paramsSerializer: a,\n    timeout: a,\n    timeoutMessage: a,\n    withCredentials: a,\n    adapter: a,\n    responseType: a,\n    xsrfCookieName: a,\n    xsrfHeaderName: a,\n    onUploadProgress: a,\n    onDownloadProgress: a,\n    decompress: a,\n    maxContentLength: a,\n    maxBodyLength: a,\n    beforeRedirect: a,\n    transport: a,\n    httpAgent: a,\n    httpsAgent: a,\n    cancelToken: a,\n    socketPath: a,\n    responseEncoding: a,\n    validateStatus: s,\n    headers: (u, c) => i(ul(u), ul(c), !0)\n  };\n  return fe.forEach(Object.keys(Object.assign({}, t, e)), function(c) {\n    const f = l[c] || i, h = f(t[c], e[c], c);\n    fe.isUndefined(h) && f !== s || (r[c] = h);\n  }), r;\n}\nconst Ah = \"1.4.0\", sc = {};\n[\"object\", \"boolean\", \"number\", \"function\", \"string\", \"symbol\"].forEach((t, e) => {\n  sc[t] = function(n) {\n    return typeof n === t || \"a\" + (e < 1 ? \"n \" : \" \") + t;\n  };\n});\nconst ll = {};\nsc.transitional = function(e, r, n) {\n  function i(o, a) {\n    return \"[Axios v\" + Ah + \"] Transitional option '\" + o + \"'\" + a + (n ? \". \" + n : \"\");\n  }\n  return (o, a, s) => {\n    if (e === !1)\n      throw new De(\n        i(a, \" has been removed\" + (r ? \" in \" + r : \"\")),\n        De.ERR_DEPRECATED\n      );\n    return r && !ll[a] && (ll[a] = !0, console.warn(\n      i(\n        a,\n        \" has been deprecated since v\" + r + \" and will be removed in the near future\"\n      )\n    )), e ? e(o, a, s) : !0;\n  };\n};\nfunction Wm(t, e, r) {\n  if (typeof t != \"object\")\n    throw new De(\"options must be an object\", De.ERR_BAD_OPTION_VALUE);\n  const n = Object.keys(t);\n  let i = n.length;\n  for (; i-- > 0; ) {\n    const o = n[i], a = e[o];\n    if (a) {\n      const s = t[o], l = s === void 0 || a(s, o, t);\n      if (l !== !0)\n        throw new De(\"option \" + o + \" must be \" + l, De.ERR_BAD_OPTION_VALUE);\n      continue;\n    }\n    if (r !== !0)\n      throw new De(\"Unknown option \" + o, De.ERR_BAD_OPTION);\n  }\n}\nconst wa = {\n  assertOptions: Wm,\n  validators: sc\n}, hr = wa.validators;\nclass ki {\n  constructor(e) {\n    this.defaults = e, this.interceptors = {\n      request: new ol(),\n      response: new ol()\n    };\n  }\n  /**\n   * Dispatch a request\n   *\n   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)\n   * @param {?Object} config\n   *\n   * @returns {Promise} The Promise to be fulfilled\n   */\n  request(e, r) {\n    typeof e == \"string\" ? (r = r || {}, r.url = e) : r = e || {}, r = fn(this.defaults, r);\n    const { transitional: n, paramsSerializer: i, headers: o } = r;\n    n !== void 0 && wa.assertOptions(n, {\n      silentJSONParsing: hr.transitional(hr.boolean),\n      forcedJSONParsing: hr.transitional(hr.boolean),\n      clarifyTimeoutError: hr.transitional(hr.boolean)\n    }, !1), i != null && (fe.isFunction(i) ? r.paramsSerializer = {\n      serialize: i\n    } : wa.assertOptions(i, {\n      encode: hr.function,\n      serialize: hr.function\n    }, !0)), r.method = (r.method || this.defaults.method || \"get\").toLowerCase();\n    let a;\n    a = o && fe.merge(\n      o.common,\n      o[r.method]\n    ), a && fe.forEach(\n      [\"delete\", \"get\", \"head\", \"post\", \"put\", \"patch\", \"common\"],\n      (g) => {\n        delete o[g];\n      }\n    ), r.headers = ur.concat(a, o);\n    const s = [];\n    let l = !0;\n    this.interceptors.request.forEach(function(_) {\n      typeof _.runWhen == \"function\" && _.runWhen(r) === !1 || (l = l && _.synchronous, s.unshift(_.fulfilled, _.rejected));\n    });\n    const u = [];\n    this.interceptors.response.forEach(function(_) {\n      u.push(_.fulfilled, _.rejected);\n    });\n    let c, f = 0, h;\n    if (!l) {\n      const g = [cl.bind(this), void 0];\n      for (g.unshift.apply(g, s), g.push.apply(g, u), h = g.length, c = Promise.resolve(r); f < h; )\n        c = c.then(g[f++], g[f++]);\n      return c;\n    }\n    h = s.length;\n    let p = r;\n    for (f = 0; f < h; ) {\n      const g = s[f++], _ = s[f++];\n      try {\n        p = g(p);\n      } catch (T) {\n        _.call(this, T);\n        break;\n      }\n    }\n    try {\n      c = cl.call(this, p);\n    } catch (g) {\n      return Promise.reject(g);\n    }\n    for (f = 0, h = u.length; f < h; )\n      c = c.then(u[f++], u[f++]);\n    return c;\n  }\n  getUri(e) {\n    e = fn(this.defaults, e);\n    const r = _h(e.baseURL, e.url);\n    return gh(r, e.params, e.paramsSerializer);\n  }\n}\nfe.forEach([\"delete\", \"get\", \"head\", \"options\"], function(e) {\n  ki.prototype[e] = function(r, n) {\n    return this.request(fn(n || {}, {\n      method: e,\n      url: r,\n      data: (n || {}).data\n    }));\n  };\n});\nfe.forEach([\"post\", \"put\", \"patch\"], function(e) {\n  function r(n) {\n    return function(o, a, s) {\n      return this.request(fn(s || {}, {\n        method: e,\n        headers: n ? {\n          \"Content-Type\": \"multipart/form-data\"\n        } : {},\n        url: o,\n        data: a\n      }));\n    };\n  }\n  ki.prototype[e] = r(), ki.prototype[e + \"Form\"] = r(!0);\n});\nconst _i = ki;\nclass ac {\n  constructor(e) {\n    if (typeof e != \"function\")\n      throw new TypeError(\"executor must be a function.\");\n    let r;\n    this.promise = new Promise(function(o) {\n      r = o;\n    });\n    const n = this;\n    this.promise.then((i) => {\n      if (!n._listeners)\n        return;\n      let o = n._listeners.length;\n      for (; o-- > 0; )\n        n._listeners[o](i);\n      n._listeners = null;\n    }), this.promise.then = (i) => {\n      let o;\n      const a = new Promise((s) => {\n        n.subscribe(s), o = s;\n      }).then(i);\n      return a.cancel = function() {\n        n.unsubscribe(o);\n      }, a;\n    }, e(function(o, a, s) {\n      n.reason || (n.reason = new ei(o, a, s), r(n.reason));\n    });\n  }\n  /**\n   * Throws a `CanceledError` if cancellation has been requested.\n   */\n  throwIfRequested() {\n    if (this.reason)\n      throw this.reason;\n  }\n  /**\n   * Subscribe to the cancel signal\n   */\n  subscribe(e) {\n    if (this.reason) {\n      e(this.reason);\n      return;\n    }\n    this._listeners ? this._listeners.push(e) : this._listeners = [e];\n  }\n  /**\n   * Unsubscribe from the cancel signal\n   */\n  unsubscribe(e) {\n    if (!this._listeners)\n      return;\n    const r = this._listeners.indexOf(e);\n    r !== -1 && this._listeners.splice(r, 1);\n  }\n  /**\n   * Returns an object that contains a new `CancelToken` and a function that, when called,\n   * cancels the `CancelToken`.\n   */\n  static source() {\n    let e;\n    return {\n      token: new ac(function(i) {\n        e = i;\n      }),\n      cancel: e\n    };\n  }\n}\nconst zm = ac;\nfunction qm(t) {\n  return function(r) {\n    return t.apply(null, r);\n  };\n}\nfunction Km(t) {\n  return fe.isObject(t) && t.isAxiosError === !0;\n}\nconst ba = {\n  Continue: 100,\n  SwitchingProtocols: 101,\n  Processing: 102,\n  EarlyHints: 103,\n  Ok: 200,\n  Created: 201,\n  Accepted: 202,\n  NonAuthoritativeInformation: 203,\n  NoContent: 204,\n  ResetContent: 205,\n  PartialContent: 206,\n  MultiStatus: 207,\n  AlreadyReported: 208,\n  ImUsed: 226,\n  MultipleChoices: 300,\n  MovedPermanently: 301,\n  Found: 302,\n  SeeOther: 303,\n  NotModified: 304,\n  UseProxy: 305,\n  Unused: 306,\n  TemporaryRedirect: 307,\n  PermanentRedirect: 308,\n  BadRequest: 400,\n  Unauthorized: 401,\n  PaymentRequired: 402,\n  Forbidden: 403,\n  NotFound: 404,\n  MethodNotAllowed: 405,\n  NotAcceptable: 406,\n  ProxyAuthenticationRequired: 407,\n  RequestTimeout: 408,\n  Conflict: 409,\n  Gone: 410,\n  LengthRequired: 411,\n  PreconditionFailed: 412,\n  PayloadTooLarge: 413,\n  UriTooLong: 414,\n  UnsupportedMediaType: 415,\n  RangeNotSatisfiable: 416,\n  ExpectationFailed: 417,\n  ImATeapot: 418,\n  MisdirectedRequest: 421,\n  UnprocessableEntity: 422,\n  Locked: 423,\n  FailedDependency: 424,\n  TooEarly: 425,\n  UpgradeRequired: 426,\n  PreconditionRequired: 428,\n  TooManyRequests: 429,\n  RequestHeaderFieldsTooLarge: 431,\n  UnavailableForLegalReasons: 451,\n  InternalServerError: 500,\n  NotImplemented: 501,\n  BadGateway: 502,\n  ServiceUnavailable: 503,\n  GatewayTimeout: 504,\n  HttpVersionNotSupported: 505,\n  VariantAlsoNegotiates: 506,\n  InsufficientStorage: 507,\n  LoopDetected: 508,\n  NotExtended: 510,\n  NetworkAuthenticationRequired: 511\n};\nObject.entries(ba).forEach(([t, e]) => {\n  ba[e] = t;\n});\nconst Gm = ba;\nfunction Th(t) {\n  const e = new _i(t), r = sh(_i.prototype.request, e);\n  return fe.extend(r, _i.prototype, e, { allOwnKeys: !0 }), fe.extend(r, e, null, { allOwnKeys: !0 }), r.create = function(i) {\n    return Th(fn(t, i));\n  }, r;\n}\nconst pt = Th(oc);\npt.Axios = _i;\npt.CanceledError = ei;\npt.CancelToken = zm;\npt.isCancel = bh;\npt.VERSION = Ah;\npt.toFormData = Do;\npt.AxiosError = De;\npt.Cancel = pt.CanceledError;\npt.all = function(e) {\n  return Promise.all(e);\n};\npt.spread = qm;\npt.isAxiosError = Km;\npt.mergeConfig = fn;\npt.AxiosHeaders = ur;\npt.formToJSON = (t) => wh(fe.isHTMLForm(t) ? new FormData(t) : t);\npt.HttpStatusCode = Gm;\npt.default = pt;\nconst Mt = pt;\nfunction Jt(t, e) {\n  var r = {};\n  for (var n in t)\n    Object.prototype.hasOwnProperty.call(t, n) && e.indexOf(n) < 0 && (r[n] = t[n]);\n  if (t != null && typeof Object.getOwnPropertySymbols == \"function\") {\n    var i = 0;\n    for (n = Object.getOwnPropertySymbols(t); i < n.length; i++)\n      e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(t, n[i]) && (r[n[i]] = t[n[i]]);\n  }\n  return r;\n}\nvar en = typeof globalThis < \"u\" ? globalThis : typeof window < \"u\" ? window : typeof global < \"u\" ? global : typeof self < \"u\" ? self : {};\nfunction cc(t) {\n  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, \"default\") ? t.default : t;\n}\nfunction uc(t, e) {\n  return t(e = { exports: {} }, e.exports), e.exports;\n}\nvar Rr = uc(function(t, e) {\n  Object.defineProperty(e, \"__esModule\", { value: !0 });\n  var r = function() {\n    function n() {\n      var i = this;\n      this.locked = /* @__PURE__ */ new Map(), this.addToLocked = function(o, a) {\n        var s = i.locked.get(o);\n        s === void 0 ? a === void 0 ? i.locked.set(o, []) : i.locked.set(o, [a]) : a !== void 0 && (s.unshift(a), i.locked.set(o, s));\n      }, this.isLocked = function(o) {\n        return i.locked.has(o);\n      }, this.lock = function(o) {\n        return new Promise(function(a, s) {\n          i.isLocked(o) ? i.addToLocked(o, a) : (i.addToLocked(o), a());\n        });\n      }, this.unlock = function(o) {\n        var a = i.locked.get(o);\n        if (a !== void 0 && a.length !== 0) {\n          var s = a.pop();\n          i.locked.set(o, a), s !== void 0 && setTimeout(s, 0);\n        } else\n          i.locked.delete(o);\n      };\n    }\n    return n.getInstance = function() {\n      return n.instance === void 0 && (n.instance = new n()), n.instance;\n    }, n;\n  }();\n  e.default = function() {\n    return r.getInstance();\n  };\n});\ncc(Rr);\nvar Ym = cc(uc(function(t, e) {\n  var r = en && en.__awaiter || function(l, u, c, f) {\n    return new (c || (c = Promise))(function(h, p) {\n      function g(A) {\n        try {\n          T(f.next(A));\n        } catch (w) {\n          p(w);\n        }\n      }\n      function _(A) {\n        try {\n          T(f.throw(A));\n        } catch (w) {\n          p(w);\n        }\n      }\n      function T(A) {\n        A.done ? h(A.value) : new c(function(w) {\n          w(A.value);\n        }).then(g, _);\n      }\n      T((f = f.apply(l, u || [])).next());\n    });\n  }, n = en && en.__generator || function(l, u) {\n    var c, f, h, p, g = { label: 0, sent: function() {\n      if (1 & h[0])\n        throw h[1];\n      return h[1];\n    }, trys: [], ops: [] };\n    return p = { next: _(0), throw: _(1), return: _(2) }, typeof Symbol == \"function\" && (p[Symbol.iterator] = function() {\n      return this;\n    }), p;\n    function _(T) {\n      return function(A) {\n        return function(w) {\n          if (c)\n            throw new TypeError(\"Generator is already executing.\");\n          for (; g; )\n            try {\n              if (c = 1, f && (h = 2 & w[0] ? f.return : w[0] ? f.throw || ((h = f.return) && h.call(f), 0) : f.next) && !(h = h.call(f, w[1])).done)\n                return h;\n              switch (f = 0, h && (w = [2 & w[0], h.value]), w[0]) {\n                case 0:\n                case 1:\n                  h = w;\n                  break;\n                case 4:\n                  return g.label++, { value: w[1], done: !1 };\n                case 5:\n                  g.label++, f = w[1], w = [0];\n                  continue;\n                case 7:\n                  w = g.ops.pop(), g.trys.pop();\n                  continue;\n                default:\n                  if (h = g.trys, !((h = h.length > 0 && h[h.length - 1]) || w[0] !== 6 && w[0] !== 2)) {\n                    g = 0;\n                    continue;\n                  }\n                  if (w[0] === 3 && (!h || w[1] > h[0] && w[1] < h[3])) {\n                    g.label = w[1];\n                    break;\n                  }\n                  if (w[0] === 6 && g.label < h[1]) {\n                    g.label = h[1], h = w;\n                    break;\n                  }\n                  if (h && g.label < h[2]) {\n                    g.label = h[2], g.ops.push(w);\n                    break;\n                  }\n                  h[2] && g.ops.pop(), g.trys.pop();\n                  continue;\n              }\n              w = u.call(l, g);\n            } catch (O) {\n              w = [6, O], f = 0;\n            } finally {\n              c = h = 0;\n            }\n          if (5 & w[0])\n            throw w[1];\n          return { value: w[0] ? w[1] : void 0, done: !0 };\n        }([T, A]);\n      };\n    }\n  };\n  Object.defineProperty(e, \"__esModule\", { value: !0 });\n  var i = \"browser-tabs-lock-key\";\n  function o(l) {\n    return new Promise(function(u) {\n      return setTimeout(u, l);\n    });\n  }\n  function a(l) {\n    for (var u = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghiklmnopqrstuvwxyz\", c = \"\", f = 0; f < l; f++)\n      c += u[Math.floor(Math.random() * u.length)];\n    return c;\n  }\n  var s = function() {\n    function l() {\n      this.acquiredIatSet = /* @__PURE__ */ new Set(), this.id = Date.now().toString() + a(15), this.acquireLock = this.acquireLock.bind(this), this.releaseLock = this.releaseLock.bind(this), this.releaseLock__private__ = this.releaseLock__private__.bind(this), this.waitForSomethingToChange = this.waitForSomethingToChange.bind(this), this.refreshLockWhileAcquired = this.refreshLockWhileAcquired.bind(this), l.waiters === void 0 && (l.waiters = []);\n    }\n    return l.prototype.acquireLock = function(u, c) {\n      return c === void 0 && (c = 5e3), r(this, void 0, void 0, function() {\n        var f, h, p, g, _, T;\n        return n(this, function(A) {\n          switch (A.label) {\n            case 0:\n              f = Date.now() + a(4), h = Date.now() + c, p = i + \"-\" + u, g = window.localStorage, A.label = 1;\n            case 1:\n              return Date.now() < h ? [4, o(30)] : [3, 8];\n            case 2:\n              return A.sent(), g.getItem(p) !== null ? [3, 5] : (_ = this.id + \"-\" + u + \"-\" + f, [4, o(Math.floor(25 * Math.random()))]);\n            case 3:\n              return A.sent(), g.setItem(p, JSON.stringify({ id: this.id, iat: f, timeoutKey: _, timeAcquired: Date.now(), timeRefreshed: Date.now() })), [4, o(30)];\n            case 4:\n              return A.sent(), (T = g.getItem(p)) !== null && (T = JSON.parse(T)).id === this.id && T.iat === f ? (this.acquiredIatSet.add(f), this.refreshLockWhileAcquired(p, f), [2, !0]) : [3, 7];\n            case 5:\n              return l.lockCorrector(), [4, this.waitForSomethingToChange(h)];\n            case 6:\n              A.sent(), A.label = 7;\n            case 7:\n              return f = Date.now() + a(4), [3, 1];\n            case 8:\n              return [2, !1];\n          }\n        });\n      });\n    }, l.prototype.refreshLockWhileAcquired = function(u, c) {\n      return r(this, void 0, void 0, function() {\n        var f = this;\n        return n(this, function(h) {\n          return setTimeout(function() {\n            return r(f, void 0, void 0, function() {\n              var p, g;\n              return n(this, function(_) {\n                switch (_.label) {\n                  case 0:\n                    return [4, Rr.default().lock(c)];\n                  case 1:\n                    return _.sent(), this.acquiredIatSet.has(c) ? (p = window.localStorage, (g = p.getItem(u)) === null ? (Rr.default().unlock(c), [2]) : ((g = JSON.parse(g)).timeRefreshed = Date.now(), p.setItem(u, JSON.stringify(g)), Rr.default().unlock(c), this.refreshLockWhileAcquired(u, c), [2])) : (Rr.default().unlock(c), [2]);\n                }\n              });\n            });\n          }, 1e3), [2];\n        });\n      });\n    }, l.prototype.waitForSomethingToChange = function(u) {\n      return r(this, void 0, void 0, function() {\n        return n(this, function(c) {\n          switch (c.label) {\n            case 0:\n              return [4, new Promise(function(f) {\n                var h = !1, p = Date.now(), g = !1;\n                function _() {\n                  if (g || (window.removeEventListener(\"storage\", _), l.removeFromWaiting(_), clearTimeout(T), g = !0), !h) {\n                    h = !0;\n                    var A = 50 - (Date.now() - p);\n                    A > 0 ? setTimeout(f, A) : f();\n                  }\n                }\n                window.addEventListener(\"storage\", _), l.addToWaiting(_);\n                var T = setTimeout(_, Math.max(0, u - Date.now()));\n              })];\n            case 1:\n              return c.sent(), [2];\n          }\n        });\n      });\n    }, l.addToWaiting = function(u) {\n      this.removeFromWaiting(u), l.waiters !== void 0 && l.waiters.push(u);\n    }, l.removeFromWaiting = function(u) {\n      l.waiters !== void 0 && (l.waiters = l.waiters.filter(function(c) {\n        return c !== u;\n      }));\n    }, l.notifyWaiters = function() {\n      l.waiters !== void 0 && l.waiters.slice().forEach(function(u) {\n        return u();\n      });\n    }, l.prototype.releaseLock = function(u) {\n      return r(this, void 0, void 0, function() {\n        return n(this, function(c) {\n          switch (c.label) {\n            case 0:\n              return [4, this.releaseLock__private__(u)];\n            case 1:\n              return [2, c.sent()];\n          }\n        });\n      });\n    }, l.prototype.releaseLock__private__ = function(u) {\n      return r(this, void 0, void 0, function() {\n        var c, f, h;\n        return n(this, function(p) {\n          switch (p.label) {\n            case 0:\n              return c = window.localStorage, f = i + \"-\" + u, (h = c.getItem(f)) === null ? [2] : (h = JSON.parse(h)).id !== this.id ? [3, 2] : [4, Rr.default().lock(h.iat)];\n            case 1:\n              p.sent(), this.acquiredIatSet.delete(h.iat), c.removeItem(f), Rr.default().unlock(h.iat), l.notifyWaiters(), p.label = 2;\n            case 2:\n              return [2];\n          }\n        });\n      });\n    }, l.lockCorrector = function() {\n      for (var u = Date.now() - 5e3, c = window.localStorage, f = Object.keys(c), h = !1, p = 0; p < f.length; p++) {\n        var g = f[p];\n        if (g.includes(i)) {\n          var _ = c.getItem(g);\n          _ !== null && ((_ = JSON.parse(_)).timeRefreshed === void 0 && _.timeAcquired < u || _.timeRefreshed !== void 0 && _.timeRefreshed < u) && (c.removeItem(g), h = !0);\n        }\n      }\n      h && l.notifyWaiters();\n    }, l.waiters = void 0, l;\n  }();\n  e.default = s;\n}));\nconst Zm = { timeoutInSeconds: 60 }, Eh = { name: \"auth0-spa-js\", version: \"2.0.7\" }, Sh = () => Date.now();\nclass wt extends Error {\n  constructor(e, r) {\n    super(r), this.error = e, this.error_description = r, Object.setPrototypeOf(this, wt.prototype);\n  }\n  static fromPayload({ error: e, error_description: r }) {\n    return new wt(e, r);\n  }\n}\nclass lc extends wt {\n  constructor(e, r, n, i = null) {\n    super(e, r), this.state = n, this.appState = i, Object.setPrototypeOf(this, lc.prototype);\n  }\n}\nclass Hn extends wt {\n  constructor() {\n    super(\"timeout\", \"Timeout\"), Object.setPrototypeOf(this, Hn.prototype);\n  }\n}\nclass fc extends Hn {\n  constructor(e) {\n    super(), this.popup = e, Object.setPrototypeOf(this, fc.prototype);\n  }\n}\nclass hc extends wt {\n  constructor(e) {\n    super(\"cancelled\", \"Popup closed\"), this.popup = e, Object.setPrototypeOf(this, hc.prototype);\n  }\n}\nclass dc extends wt {\n  constructor(e, r, n) {\n    super(e, r), this.mfa_token = n, Object.setPrototypeOf(this, dc.prototype);\n  }\n}\nclass Lo extends wt {\n  constructor(e, r) {\n    super(\"missing_refresh_token\", `Missing Refresh Token (audience: '${fl(e, [\"default\"])}', scope: '${fl(r)}')`), this.audience = e, this.scope = r, Object.setPrototypeOf(this, Lo.prototype);\n  }\n}\nfunction fl(t, e = []) {\n  return t && !e.includes(t) ? t : \"\";\n}\nconst Ai = () => window.crypto, Ls = () => {\n  const t = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_~.\";\n  let e = \"\";\n  return Array.from(Ai().getRandomValues(new Uint8Array(43))).forEach((r) => e += t[r % t.length]), e;\n}, hl = (t) => btoa(t), _a = (t) => {\n  var { clientId: e } = t, r = Jt(t, [\"clientId\"]);\n  return new URLSearchParams(((n) => Object.keys(n).filter((i) => n[i] !== void 0).reduce((i, o) => Object.assign(Object.assign({}, i), { [o]: n[o] }), {}))(Object.assign({ client_id: e }, r))).toString();\n}, dl = (t) => ((e) => decodeURIComponent(atob(e).split(\"\").map((r) => \"%\" + (\"00\" + r.charCodeAt(0).toString(16)).slice(-2)).join(\"\")))(t.replace(/_/g, \"/\").replace(/-/g, \"+\")), Xm = async (t, e) => {\n  const r = await fetch(t, e);\n  return { ok: r.ok, json: await r.json() };\n}, Jm = async (t, e, r) => {\n  const n = new AbortController();\n  let i;\n  return e.signal = n.signal, Promise.race([Xm(t, e), new Promise((o, a) => {\n    i = setTimeout(() => {\n      n.abort(), a(new Error(\"Timeout when executing 'fetch'\"));\n    }, r);\n  })]).finally(() => {\n    clearTimeout(i);\n  });\n}, Qm = async (t, e, r, n, i, o, a) => {\n  return s = { auth: { audience: e, scope: r }, timeout: i, fetchUrl: t, fetchOptions: n, useFormData: a }, l = o, new Promise(function(u, c) {\n    const f = new MessageChannel();\n    f.port1.onmessage = function(h) {\n      h.data.error ? c(new Error(h.data.error)) : u(h.data), f.port1.close();\n    }, l.postMessage(s, [f.port2]);\n  });\n  var s, l;\n}, ev = async (t, e, r, n, i, o, a = 1e4) => i ? Qm(t, e, r, n, a, i, o) : Jm(t, n, a);\nasync function tv(t, e) {\n  var { baseUrl: r, timeout: n, audience: i, scope: o, auth0Client: a, useFormData: s } = t, l = Jt(t, [\"baseUrl\", \"timeout\", \"audience\", \"scope\", \"auth0Client\", \"useFormData\"]);\n  const u = s ? _a(l) : JSON.stringify(l);\n  return await async function(c, f, h, p, g, _, T) {\n    let A, w = null;\n    for (let G = 0; G < 3; G++)\n      try {\n        A = await ev(c, h, p, g, _, T, f), w = null;\n        break;\n      } catch (Z) {\n        w = Z;\n      }\n    if (w)\n      throw w;\n    const O = A.json, { error: R, error_description: $ } = O, U = Jt(O, [\"error\", \"error_description\"]), { ok: W } = A;\n    if (!W) {\n      const G = $ || `HTTP error. Unable to fetch ${c}`;\n      throw R === \"mfa_required\" ? new dc(R, G, U.mfa_token) : R === \"missing_refresh_token\" ? new Lo(h, p) : new wt(R || \"request_error\", G);\n    }\n    return U;\n  }(`${r}/oauth/token`, n, i || \"default\", o, { method: \"POST\", body: u, headers: { \"Content-Type\": s ? \"application/x-www-form-urlencoded\" : \"application/json\", \"Auth0-Client\": btoa(JSON.stringify(a || Eh)) } }, e, s);\n}\nconst li = (...t) => {\n  return (e = t.filter(Boolean).join(\" \").trim().split(/\\s+/), Array.from(new Set(e))).join(\" \");\n  var e;\n};\nclass tr {\n  constructor(e, r = \"@@auth0spajs@@\", n) {\n    this.prefix = r, this.suffix = n, this.clientId = e.clientId, this.scope = e.scope, this.audience = e.audience;\n  }\n  toKey() {\n    return [this.prefix, this.clientId, this.audience, this.scope, this.suffix].filter(Boolean).join(\"::\");\n  }\n  static fromKey(e) {\n    const [r, n, i, o] = e.split(\"::\");\n    return new tr({ clientId: n, scope: o, audience: i }, r);\n  }\n  static fromCacheEntry(e) {\n    const { scope: r, audience: n, client_id: i } = e;\n    return new tr({ scope: r, audience: n, clientId: i });\n  }\n}\nclass rv {\n  set(e, r) {\n    localStorage.setItem(e, JSON.stringify(r));\n  }\n  get(e) {\n    const r = window.localStorage.getItem(e);\n    if (r)\n      try {\n        return JSON.parse(r);\n      } catch {\n        return;\n      }\n  }\n  remove(e) {\n    localStorage.removeItem(e);\n  }\n  allKeys() {\n    return Object.keys(window.localStorage).filter((e) => e.startsWith(\"@@auth0spajs@@\"));\n  }\n}\nclass Ph {\n  constructor() {\n    this.enclosedCache = function() {\n      let e = {};\n      return { set(r, n) {\n        e[r] = n;\n      }, get(r) {\n        const n = e[r];\n        if (n)\n          return n;\n      }, remove(r) {\n        delete e[r];\n      }, allKeys: () => Object.keys(e) };\n    }();\n  }\n}\nclass nv {\n  constructor(e, r, n) {\n    this.cache = e, this.keyManifest = r, this.nowProvider = n || Sh;\n  }\n  async setIdToken(e, r, n) {\n    var i;\n    const o = this.getIdTokenCacheKey(e);\n    await this.cache.set(o, { id_token: r, decodedToken: n }), await ((i = this.keyManifest) === null || i === void 0 ? void 0 : i.add(o));\n  }\n  async getIdToken(e) {\n    const r = await this.cache.get(this.getIdTokenCacheKey(e.clientId));\n    if (!r && e.scope && e.audience) {\n      const n = await this.get(e);\n      return !n || !n.id_token || !n.decodedToken ? void 0 : { id_token: n.id_token, decodedToken: n.decodedToken };\n    }\n    if (r)\n      return { id_token: r.id_token, decodedToken: r.decodedToken };\n  }\n  async get(e, r = 0) {\n    var n;\n    let i = await this.cache.get(e.toKey());\n    if (!i) {\n      const s = await this.getCacheKeys();\n      if (!s)\n        return;\n      const l = this.matchExistingCacheKey(e, s);\n      l && (i = await this.cache.get(l));\n    }\n    if (!i)\n      return;\n    const o = await this.nowProvider(), a = Math.floor(o / 1e3);\n    return i.expiresAt - r < a ? i.body.refresh_token ? (i.body = { refresh_token: i.body.refresh_token }, await this.cache.set(e.toKey(), i), i.body) : (await this.cache.remove(e.toKey()), void await ((n = this.keyManifest) === null || n === void 0 ? void 0 : n.remove(e.toKey()))) : i.body;\n  }\n  async set(e) {\n    var r;\n    const n = new tr({ clientId: e.client_id, scope: e.scope, audience: e.audience }), i = await this.wrapCacheEntry(e);\n    await this.cache.set(n.toKey(), i), await ((r = this.keyManifest) === null || r === void 0 ? void 0 : r.add(n.toKey()));\n  }\n  async clear(e) {\n    var r;\n    const n = await this.getCacheKeys();\n    n && (await n.filter((i) => !e || i.includes(e)).reduce(async (i, o) => {\n      await i, await this.cache.remove(o);\n    }, Promise.resolve()), await ((r = this.keyManifest) === null || r === void 0 ? void 0 : r.clear()));\n  }\n  async wrapCacheEntry(e) {\n    const r = await this.nowProvider();\n    return { body: e, expiresAt: Math.floor(r / 1e3) + e.expires_in };\n  }\n  async getCacheKeys() {\n    var e;\n    return this.keyManifest ? (e = await this.keyManifest.get()) === null || e === void 0 ? void 0 : e.keys : this.cache.allKeys ? this.cache.allKeys() : void 0;\n  }\n  getIdTokenCacheKey(e) {\n    return new tr({ clientId: e }, \"@@auth0spajs@@\", \"@@user@@\").toKey();\n  }\n  matchExistingCacheKey(e, r) {\n    return r.filter((n) => {\n      var i;\n      const o = tr.fromKey(n), a = new Set(o.scope && o.scope.split(\" \")), s = ((i = e.scope) === null || i === void 0 ? void 0 : i.split(\" \")) || [], l = o.scope && s.reduce((u, c) => u && a.has(c), !0);\n      return o.prefix === \"@@auth0spajs@@\" && o.clientId === e.clientId && o.audience === e.audience && l;\n    })[0];\n  }\n}\nclass iv {\n  constructor(e, r, n) {\n    this.storage = e, this.clientId = r, this.cookieDomain = n, this.storageKey = `a0.spajs.txs.${this.clientId}`, this.transaction = this.storage.get(this.storageKey);\n  }\n  create(e) {\n    this.transaction = e, this.storage.save(this.storageKey, e, { daysUntilExpire: 1, cookieDomain: this.cookieDomain });\n  }\n  get() {\n    return this.transaction;\n  }\n  remove() {\n    delete this.transaction, this.storage.remove(this.storageKey, { cookieDomain: this.cookieDomain });\n  }\n}\nconst An = (t) => typeof t == \"number\", ov = [\"iss\", \"aud\", \"exp\", \"nbf\", \"iat\", \"jti\", \"azp\", \"nonce\", \"auth_time\", \"at_hash\", \"c_hash\", \"acr\", \"amr\", \"sub_jwk\", \"cnf\", \"sip_from_tag\", \"sip_date\", \"sip_callid\", \"sip_cseq_num\", \"sip_via_branch\", \"orig\", \"dest\", \"mky\", \"events\", \"toe\", \"txn\", \"rph\", \"sid\", \"vot\", \"vtm\"], sv = (t) => {\n  if (!t.id_token)\n    throw new Error(\"ID token is required but missing\");\n  const e = ((o) => {\n    const a = o.split(\".\"), [s, l, u] = a;\n    if (a.length !== 3 || !s || !l || !u)\n      throw new Error(\"ID token could not be decoded\");\n    const c = JSON.parse(dl(l)), f = { __raw: o }, h = {};\n    return Object.keys(c).forEach((p) => {\n      f[p] = c[p], ov.includes(p) || (h[p] = c[p]);\n    }), { encoded: { header: s, payload: l, signature: u }, header: JSON.parse(dl(s)), claims: f, user: h };\n  })(t.id_token);\n  if (!e.claims.iss)\n    throw new Error(\"Issuer (iss) claim must be a string present in the ID token\");\n  if (e.claims.iss !== t.iss)\n    throw new Error(`Issuer (iss) claim mismatch in the ID token; expected \"${t.iss}\", found \"${e.claims.iss}\"`);\n  if (!e.user.sub)\n    throw new Error(\"Subject (sub) claim must be a string present in the ID token\");\n  if (e.header.alg !== \"RS256\")\n    throw new Error(`Signature algorithm of \"${e.header.alg}\" is not supported. Expected the ID token to be signed with \"RS256\".`);\n  if (!e.claims.aud || typeof e.claims.aud != \"string\" && !Array.isArray(e.claims.aud))\n    throw new Error(\"Audience (aud) claim must be a string or array of strings present in the ID token\");\n  if (Array.isArray(e.claims.aud)) {\n    if (!e.claims.aud.includes(t.aud))\n      throw new Error(`Audience (aud) claim mismatch in the ID token; expected \"${t.aud}\" but was not one of \"${e.claims.aud.join(\", \")}\"`);\n    if (e.claims.aud.length > 1) {\n      if (!e.claims.azp)\n        throw new Error(\"Authorized Party (azp) claim must be a string present in the ID token when Audience (aud) claim has multiple values\");\n      if (e.claims.azp !== t.aud)\n        throw new Error(`Authorized Party (azp) claim mismatch in the ID token; expected \"${t.aud}\", found \"${e.claims.azp}\"`);\n    }\n  } else if (e.claims.aud !== t.aud)\n    throw new Error(`Audience (aud) claim mismatch in the ID token; expected \"${t.aud}\" but found \"${e.claims.aud}\"`);\n  if (t.nonce) {\n    if (!e.claims.nonce)\n      throw new Error(\"Nonce (nonce) claim must be a string present in the ID token\");\n    if (e.claims.nonce !== t.nonce)\n      throw new Error(`Nonce (nonce) claim mismatch in the ID token; expected \"${t.nonce}\", found \"${e.claims.nonce}\"`);\n  }\n  if (t.max_age && !An(e.claims.auth_time))\n    throw new Error(\"Authentication Time (auth_time) claim must be a number present in the ID token when Max Age (max_age) is specified\");\n  if (e.claims.exp == null || !An(e.claims.exp))\n    throw new Error(\"Expiration Time (exp) claim must be a number present in the ID token\");\n  if (!An(e.claims.iat))\n    throw new Error(\"Issued At (iat) claim must be a number present in the ID token\");\n  const r = t.leeway || 60, n = new Date(t.now || Date.now()), i = new Date(0);\n  if (i.setUTCSeconds(e.claims.exp + r), n > i)\n    throw new Error(`Expiration Time (exp) claim error in the ID token; current time (${n}) is after expiration time (${i})`);\n  if (e.claims.nbf != null && An(e.claims.nbf)) {\n    const o = new Date(0);\n    if (o.setUTCSeconds(e.claims.nbf - r), n < o)\n      throw new Error(`Not Before time (nbf) claim in the ID token indicates that this token can't be used just yet. Current time (${n}) is before ${o}`);\n  }\n  if (e.claims.auth_time != null && An(e.claims.auth_time)) {\n    const o = new Date(0);\n    if (o.setUTCSeconds(parseInt(e.claims.auth_time) + t.max_age + r), n > o)\n      throw new Error(`Authentication Time (auth_time) claim in the ID token indicates that too much time has passed since the last end-user authentication. Current time (${n}) is after last auth at ${o}`);\n  }\n  if (t.organizationId) {\n    if (!e.claims.org_id)\n      throw new Error(\"Organization ID (org_id) claim must be a string present in the ID token\");\n    if (t.organizationId !== e.claims.org_id)\n      throw new Error(`Organization ID (org_id) claim mismatch in the ID token; expected \"${t.organizationId}\", found \"${e.claims.org_id}\"`);\n  }\n  return e;\n};\nvar Ir = uc(function(t, e) {\n  var r = en && en.__assign || function() {\n    return r = Object.assign || function(l) {\n      for (var u, c = 1, f = arguments.length; c < f; c++)\n        for (var h in u = arguments[c])\n          Object.prototype.hasOwnProperty.call(u, h) && (l[h] = u[h]);\n      return l;\n    }, r.apply(this, arguments);\n  };\n  function n(l, u) {\n    if (!u)\n      return \"\";\n    var c = \"; \" + l;\n    return u === !0 ? c : c + \"=\" + u;\n  }\n  function i(l, u, c) {\n    return encodeURIComponent(l).replace(/%(23|24|26|2B|5E|60|7C)/g, decodeURIComponent).replace(/\\(/g, \"%28\").replace(/\\)/g, \"%29\") + \"=\" + encodeURIComponent(u).replace(/%(23|24|26|2B|3A|3C|3E|3D|2F|3F|40|5B|5D|5E|60|7B|7D|7C)/g, decodeURIComponent) + function(f) {\n      if (typeof f.expires == \"number\") {\n        var h = new Date();\n        h.setMilliseconds(h.getMilliseconds() + 864e5 * f.expires), f.expires = h;\n      }\n      return n(\"Expires\", f.expires ? f.expires.toUTCString() : \"\") + n(\"Domain\", f.domain) + n(\"Path\", f.path) + n(\"Secure\", f.secure) + n(\"SameSite\", f.sameSite);\n    }(c);\n  }\n  function o(l) {\n    for (var u = {}, c = l ? l.split(\"; \") : [], f = /(%[\\dA-F]{2})+/gi, h = 0; h < c.length; h++) {\n      var p = c[h].split(\"=\"), g = p.slice(1).join(\"=\");\n      g.charAt(0) === '\"' && (g = g.slice(1, -1));\n      try {\n        u[p[0].replace(f, decodeURIComponent)] = g.replace(f, decodeURIComponent);\n      } catch {\n      }\n    }\n    return u;\n  }\n  function a() {\n    return o(document.cookie);\n  }\n  function s(l, u, c) {\n    document.cookie = i(l, u, r({ path: \"/\" }, c));\n  }\n  e.__esModule = !0, e.encode = i, e.parse = o, e.getAll = a, e.get = function(l) {\n    return a()[l];\n  }, e.set = s, e.remove = function(l, u) {\n    s(l, \"\", r(r({}, u), { expires: -1 }));\n  };\n});\ncc(Ir), Ir.encode, Ir.parse, Ir.getAll;\nvar av = Ir.get, Ch = Ir.set, Oh = Ir.remove;\nconst Xr = { get(t) {\n  const e = av(t);\n  if (e !== void 0)\n    return JSON.parse(e);\n}, save(t, e, r) {\n  let n = {};\n  window.location.protocol === \"https:\" && (n = { secure: !0, sameSite: \"none\" }), r != null && r.daysUntilExpire && (n.expires = r.daysUntilExpire), r != null && r.cookieDomain && (n.domain = r.cookieDomain), Ch(t, JSON.stringify(e), n);\n}, remove(t, e) {\n  let r = {};\n  e != null && e.cookieDomain && (r.domain = e.cookieDomain), Oh(t, r);\n} }, cv = { get(t) {\n  return Xr.get(t) || Xr.get(`_legacy_${t}`);\n}, save(t, e, r) {\n  let n = {};\n  window.location.protocol === \"https:\" && (n = { secure: !0 }), r != null && r.daysUntilExpire && (n.expires = r.daysUntilExpire), r != null && r.cookieDomain && (n.domain = r.cookieDomain), Ch(`_legacy_${t}`, JSON.stringify(e), n), Xr.save(t, e, r);\n}, remove(t, e) {\n  let r = {};\n  e != null && e.cookieDomain && (r.domain = e.cookieDomain), Oh(t, r), Xr.remove(t, e), Xr.remove(`_legacy_${t}`, e);\n} }, uv = { get(t) {\n  if (typeof sessionStorage > \"u\")\n    return;\n  const e = sessionStorage.getItem(t);\n  return e != null ? JSON.parse(e) : void 0;\n}, save(t, e) {\n  sessionStorage.setItem(t, JSON.stringify(e));\n}, remove(t) {\n  sessionStorage.removeItem(t);\n} };\nfunction lv(t, e, r) {\n  var n = e === void 0 ? null : e, i = function(l, u) {\n    var c = atob(l);\n    if (u) {\n      for (var f = new Uint8Array(c.length), h = 0, p = c.length; h < p; ++h)\n        f[h] = c.charCodeAt(h);\n      return String.fromCharCode.apply(null, new Uint16Array(f.buffer));\n    }\n    return c;\n  }(t, r !== void 0 && r), o = i.indexOf(`\n`, 10) + 1, a = i.substring(o) + (n ? \"//# sourceMappingURL=\" + n : \"\"), s = new Blob([a], { type: \"application/javascript\" });\n  return URL.createObjectURL(s);\n}\nvar pl, yl, ml, js, fv = (pl = \"Lyogcm9sbHVwLXBsdWdpbi13ZWItd29ya2VyLWxvYWRlciAqLwohZnVuY3Rpb24oKXsidXNlIHN0cmljdCI7Y2xhc3MgZSBleHRlbmRzIEVycm9ye2NvbnN0cnVjdG9yKHQscil7c3VwZXIociksdGhpcy5lcnJvcj10LHRoaXMuZXJyb3JfZGVzY3JpcHRpb249cixPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcyxlLnByb3RvdHlwZSl9c3RhdGljIGZyb21QYXlsb2FkKHtlcnJvcjp0LGVycm9yX2Rlc2NyaXB0aW9uOnJ9KXtyZXR1cm4gbmV3IGUodCxyKX19Y2xhc3MgdCBleHRlbmRzIGV7Y29uc3RydWN0b3IoZSxzKXtzdXBlcigibWlzc2luZ19yZWZyZXNoX3Rva2VuIixgTWlzc2luZyBSZWZyZXNoIFRva2VuIChhdWRpZW5jZTogJyR7cihlLFsiZGVmYXVsdCJdKX0nLCBzY29wZTogJyR7cihzKX0nKWApLHRoaXMuYXVkaWVuY2U9ZSx0aGlzLnNjb3BlPXMsT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsdC5wcm90b3R5cGUpfX1mdW5jdGlvbiByKGUsdD1bXSl7cmV0dXJuIGUmJiF0LmluY2x1ZGVzKGUpP2U6IiJ9Y29uc3Qgcz1lPT57dmFye2NsaWVudElkOnR9PWUscj1mdW5jdGlvbihlLHQpe3ZhciByPXt9O2Zvcih2YXIgcyBpbiBlKU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLHMpJiZ0LmluZGV4T2Yocyk8MCYmKHJbc109ZVtzXSk7aWYobnVsbCE9ZSYmImZ1bmN0aW9uIj09dHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpe3ZhciBvPTA7Zm9yKHM9T2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTtvPHMubGVuZ3RoO28rKyl0LmluZGV4T2Yoc1tvXSk8MCYmT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKGUsc1tvXSkmJihyW3Nbb11dPWVbc1tvXV0pfXJldHVybiByfShlLFsiY2xpZW50SWQiXSk7cmV0dXJuIG5ldyBVUkxTZWFyY2hQYXJhbXMoKGU9Pk9iamVjdC5rZXlzKGUpLmZpbHRlcigodD0+dm9pZCAwIT09ZVt0XSkpLnJlZHVjZSgoKHQscik9Pk9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSx0KSx7W3JdOmVbcl19KSkse30pKShPYmplY3QuYXNzaWduKHtjbGllbnRfaWQ6dH0scikpKS50b1N0cmluZygpfTtsZXQgbz17fTtjb25zdCBuPShlLHQpPT5gJHtlfXwke3R9YDthZGRFdmVudExpc3RlbmVyKCJtZXNzYWdlIiwoYXN5bmMoe2RhdGE6e3RpbWVvdXQ6ZSxhdXRoOnIsZmV0Y2hVcmw6aSxmZXRjaE9wdGlvbnM6Yyx1c2VGb3JtRGF0YTphfSxwb3J0czpbZl19KT0+e2xldCBwO2NvbnN0e2F1ZGllbmNlOmwsc2NvcGU6dX09cnx8e307dHJ5e2NvbnN0IHI9YT8oZT0+e2NvbnN0IHQ9bmV3IFVSTFNlYXJjaFBhcmFtcyhlKSxyPXt9O3JldHVybiB0LmZvckVhY2goKChlLHQpPT57clt0XT1lfSkpLHJ9KShjLmJvZHkpOkpTT04ucGFyc2UoYy5ib2R5KTtpZighci5yZWZyZXNoX3Rva2VuJiYicmVmcmVzaF90b2tlbiI9PT1yLmdyYW50X3R5cGUpe2NvbnN0IGU9KChlLHQpPT5vW24oZSx0KV0pKGwsdSk7aWYoIWUpdGhyb3cgbmV3IHQobCx1KTtjLmJvZHk9YT9zKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxyKSx7cmVmcmVzaF90b2tlbjplfSkpOkpTT04uc3RyaW5naWZ5KE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxyKSx7cmVmcmVzaF90b2tlbjplfSkpfWxldCBkLGc7ImZ1bmN0aW9uIj09dHlwZW9mIEFib3J0Q29udHJvbGxlciYmKGQ9bmV3IEFib3J0Q29udHJvbGxlcixjLnNpZ25hbD1kLnNpZ25hbCk7dHJ5e2c9YXdhaXQgUHJvbWlzZS5yYWNlKFsoaD1lLG5ldyBQcm9taXNlKChlPT5zZXRUaW1lb3V0KGUsaCkpKSksZmV0Y2goaSxPYmplY3QuYXNzaWduKHt9LGMpKV0pfWNhdGNoKGUpe3JldHVybiB2b2lkIGYucG9zdE1lc3NhZ2Uoe2Vycm9yOmUubWVzc2FnZX0pfWlmKCFnKXJldHVybiBkJiZkLmFib3J0KCksdm9pZCBmLnBvc3RNZXNzYWdlKHtlcnJvcjoiVGltZW91dCB3aGVuIGV4ZWN1dGluZyAnZmV0Y2gnIn0pO3A9YXdhaXQgZy5qc29uKCkscC5yZWZyZXNoX3Rva2VuPygoKGUsdCxyKT0+e29bbih0LHIpXT1lfSkocC5yZWZyZXNoX3Rva2VuLGwsdSksZGVsZXRlIHAucmVmcmVzaF90b2tlbik6KChlLHQpPT57ZGVsZXRlIG9bbihlLHQpXX0pKGwsdSksZi5wb3N0TWVzc2FnZSh7b2s6Zy5vayxqc29uOnB9KX1jYXRjaChlKXtmLnBvc3RNZXNzYWdlKHtvazohMSxqc29uOntlcnJvcjplLmVycm9yLGVycm9yX2Rlc2NyaXB0aW9uOmUubWVzc2FnZX19KX12YXIgaH0pKX0oKTsKCg==\", yl = null, ml = !1, function(t) {\n  return js = js || lv(pl, yl, ml), new Worker(js, t);\n});\nconst Us = {};\nclass hv {\n  constructor(e, r) {\n    this.cache = e, this.clientId = r, this.manifestKey = this.createManifestKeyFrom(this.clientId);\n  }\n  async add(e) {\n    var r;\n    const n = new Set(((r = await this.cache.get(this.manifestKey)) === null || r === void 0 ? void 0 : r.keys) || []);\n    n.add(e), await this.cache.set(this.manifestKey, { keys: [...n] });\n  }\n  async remove(e) {\n    const r = await this.cache.get(this.manifestKey);\n    if (r) {\n      const n = new Set(r.keys);\n      return n.delete(e), n.size > 0 ? await this.cache.set(this.manifestKey, { keys: [...n] }) : await this.cache.remove(this.manifestKey);\n    }\n  }\n  get() {\n    return this.cache.get(this.manifestKey);\n  }\n  clear() {\n    return this.cache.remove(this.manifestKey);\n  }\n  createManifestKeyFrom(e) {\n    return `@@auth0spajs@@::${e}`;\n  }\n}\nconst dv = { memory: () => new Ph().enclosedCache, localstorage: () => new rv() }, vl = (t) => dv[t], gl = (t) => {\n  const { openUrl: e, onRedirect: r } = t, n = Jt(t, [\"openUrl\", \"onRedirect\"]);\n  return Object.assign(Object.assign({}, n), { openUrl: e === !1 || e ? e : r });\n}, Vs = new Ym();\nclass pv {\n  constructor(e) {\n    let r, n;\n    if (this.userCache = new Ph().enclosedCache, this.defaultOptions = { authorizationParams: { scope: \"openid profile email\" }, useRefreshTokensFallback: !1, useFormData: !0 }, this._releaseLockOnPageHide = async () => {\n      await Vs.releaseLock(\"auth0.lock.getTokenSilently\"), window.removeEventListener(\"pagehide\", this._releaseLockOnPageHide);\n    }, this.options = Object.assign(Object.assign(Object.assign({}, this.defaultOptions), e), { authorizationParams: Object.assign(Object.assign({}, this.defaultOptions.authorizationParams), e.authorizationParams) }), typeof window < \"u\" && (() => {\n      if (!Ai())\n        throw new Error(\"For security reasons, `window.crypto` is required to run `auth0-spa-js`.\");\n      if (Ai().subtle === void 0)\n        throw new Error(`\n      auth0-spa-js must run on a secure origin. See https://github.com/auth0/auth0-spa-js/blob/master/FAQ.md#why-do-i-get-auth0-spa-js-must-run-on-a-secure-origin for more information.\n    `);\n    })(), e.cache && e.cacheLocation && console.warn(\"Both `cache` and `cacheLocation` options have been specified in the Auth0Client configuration; ignoring `cacheLocation` and using `cache`.\"), e.cache)\n      n = e.cache;\n    else {\n      if (r = e.cacheLocation || \"memory\", !vl(r))\n        throw new Error(`Invalid cache location \"${r}\"`);\n      n = vl(r)();\n    }\n    this.httpTimeoutMs = e.httpTimeoutInSeconds ? 1e3 * e.httpTimeoutInSeconds : 1e4, this.cookieStorage = e.legacySameSiteCookie === !1 ? Xr : cv, this.orgHintCookieName = `auth0.${this.options.clientId}.organization_hint`, this.isAuthenticatedCookieName = ((a) => `auth0.${a}.is.authenticated`)(this.options.clientId), this.sessionCheckExpiryDays = e.sessionCheckExpiryDays || 1;\n    const i = e.useCookiesForTransactions ? this.cookieStorage : uv;\n    var o;\n    this.scope = li(\"openid\", this.options.authorizationParams.scope, this.options.useRefreshTokens ? \"offline_access\" : \"\"), this.transactionManager = new iv(i, this.options.clientId, this.options.cookieDomain), this.nowProvider = this.options.nowProvider || Sh, this.cacheManager = new nv(n, n.allKeys ? void 0 : new hv(n, this.options.clientId), this.nowProvider), this.domainUrl = (o = this.options.domain, /^https?:\\/\\//.test(o) ? o : `https://${o}`), this.tokenIssuer = ((a, s) => a ? a.startsWith(\"https://\") ? a : `https://${a}/` : `${s}/`)(this.options.issuer, this.domainUrl), typeof window < \"u\" && window.Worker && this.options.useRefreshTokens && r === \"memory\" && (this.worker = new fv());\n  }\n  _url(e) {\n    const r = encodeURIComponent(btoa(JSON.stringify(this.options.auth0Client || Eh)));\n    return `${this.domainUrl}${e}&auth0Client=${r}`;\n  }\n  _authorizeUrl(e) {\n    return this._url(`/authorize?${_a(e)}`);\n  }\n  async _verifyIdToken(e, r, n) {\n    const i = await this.nowProvider();\n    return sv({ iss: this.tokenIssuer, aud: this.options.clientId, id_token: e, nonce: r, organizationId: n, leeway: this.options.leeway, max_age: (o = this.options.authorizationParams.max_age, typeof o != \"string\" ? o : parseInt(o, 10) || void 0), now: i });\n    var o;\n  }\n  _processOrgIdHint(e) {\n    e ? this.cookieStorage.save(this.orgHintCookieName, e, { daysUntilExpire: this.sessionCheckExpiryDays, cookieDomain: this.options.cookieDomain }) : this.cookieStorage.remove(this.orgHintCookieName, { cookieDomain: this.options.cookieDomain });\n  }\n  async _prepareAuthorizeUrl(e, r, n) {\n    const i = hl(Ls()), o = hl(Ls()), a = Ls(), s = ((c) => {\n      const f = new Uint8Array(c);\n      return ((h) => {\n        const p = { \"+\": \"-\", \"/\": \"_\", \"=\": \"\" };\n        return h.replace(/[+/=]/g, (g) => p[g]);\n      })(window.btoa(String.fromCharCode(...Array.from(f))));\n    })(await (async (c) => await Ai().subtle.digest({ name: \"SHA-256\" }, new TextEncoder().encode(c)))(a)), l = ((c, f, h, p, g, _, T, A) => Object.assign(Object.assign(Object.assign({ client_id: c.clientId }, c.authorizationParams), h), { scope: li(f, h.scope), response_type: \"code\", response_mode: A || \"query\", state: p, nonce: g, redirect_uri: T || c.authorizationParams.redirect_uri, code_challenge: _, code_challenge_method: \"S256\" }))(this.options, this.scope, e, i, o, s, e.redirect_uri || this.options.authorizationParams.redirect_uri || n, r == null ? void 0 : r.response_mode), u = this._authorizeUrl(l);\n    return { nonce: o, code_verifier: a, scope: l.scope, audience: l.audience || \"default\", redirect_uri: l.redirect_uri, state: i, url: u };\n  }\n  async loginWithPopup(e, r) {\n    var n;\n    if (e = e || {}, !(r = r || {}).popup && (r.popup = ((s) => {\n      const l = window.screenX + (window.innerWidth - 400) / 2, u = window.screenY + (window.innerHeight - 600) / 2;\n      return window.open(s, \"auth0:authorize:popup\", `left=${l},top=${u},width=400,height=600,resizable,scrollbars=yes,status=1`);\n    })(\"\"), !r.popup))\n      throw new Error(\"Unable to open a popup for loginWithPopup - window.open returned `null`\");\n    const i = await this._prepareAuthorizeUrl(e.authorizationParams || {}, { response_mode: \"web_message\" }, window.location.origin);\n    r.popup.location.href = i.url;\n    const o = await ((s) => new Promise((l, u) => {\n      let c;\n      const f = setInterval(() => {\n        s.popup && s.popup.closed && (clearInterval(f), clearTimeout(h), window.removeEventListener(\"message\", c, !1), u(new hc(s.popup)));\n      }, 1e3), h = setTimeout(() => {\n        clearInterval(f), u(new fc(s.popup)), window.removeEventListener(\"message\", c, !1);\n      }, 1e3 * (s.timeoutInSeconds || 60));\n      c = function(p) {\n        if (p.data && p.data.type === \"authorization_response\") {\n          if (clearTimeout(h), clearInterval(f), window.removeEventListener(\"message\", c, !1), s.popup.close(), p.data.response.error)\n            return u(wt.fromPayload(p.data.response));\n          l(p.data.response);\n        }\n      }, window.addEventListener(\"message\", c);\n    }))(Object.assign(Object.assign({}, r), { timeoutInSeconds: r.timeoutInSeconds || this.options.authorizeTimeoutInSeconds || 60 }));\n    if (i.state !== o.state)\n      throw new wt(\"state_mismatch\", \"Invalid state\");\n    const a = ((n = e.authorizationParams) === null || n === void 0 ? void 0 : n.organization) || this.options.authorizationParams.organization;\n    await this._requestToken({ audience: i.audience, scope: i.scope, code_verifier: i.code_verifier, grant_type: \"authorization_code\", code: o.code, redirect_uri: i.redirect_uri }, { nonceIn: i.nonce, organizationId: a });\n  }\n  async getUser() {\n    var e;\n    const r = await this._getIdTokenFromCache();\n    return (e = r == null ? void 0 : r.decodedToken) === null || e === void 0 ? void 0 : e.user;\n  }\n  async getIdTokenClaims() {\n    var e;\n    const r = await this._getIdTokenFromCache();\n    return (e = r == null ? void 0 : r.decodedToken) === null || e === void 0 ? void 0 : e.claims;\n  }\n  async loginWithRedirect(e = {}) {\n    var r;\n    const n = gl(e), { openUrl: i, fragment: o, appState: a } = n, s = Jt(n, [\"openUrl\", \"fragment\", \"appState\"]), l = ((r = s.authorizationParams) === null || r === void 0 ? void 0 : r.organization) || this.options.authorizationParams.organization, u = await this._prepareAuthorizeUrl(s.authorizationParams || {}), { url: c } = u, f = Jt(u, [\"url\"]);\n    this.transactionManager.create(Object.assign(Object.assign(Object.assign({}, f), { appState: a }), l && { organizationId: l }));\n    const h = o ? `${c}#${o}` : c;\n    i ? await i(h) : window.location.assign(h);\n  }\n  async handleRedirectCallback(e = window.location.href) {\n    const r = e.split(\"?\").slice(1);\n    if (r.length === 0)\n      throw new Error(\"There are no query params available for parsing.\");\n    const { state: n, code: i, error: o, error_description: a } = ((f) => {\n      f.indexOf(\"#\") > -1 && (f = f.substring(0, f.indexOf(\"#\")));\n      const h = new URLSearchParams(f);\n      return { state: h.get(\"state\"), code: h.get(\"code\") || void 0, error: h.get(\"error\") || void 0, error_description: h.get(\"error_description\") || void 0 };\n    })(r.join(\"\")), s = this.transactionManager.get();\n    if (!s)\n      throw new wt(\"missing_transaction\", \"Invalid state\");\n    if (this.transactionManager.remove(), o)\n      throw new lc(o, a || o, n, s.appState);\n    if (!s.code_verifier || s.state && s.state !== n)\n      throw new wt(\"state_mismatch\", \"Invalid state\");\n    const l = s.organizationId, u = s.nonce, c = s.redirect_uri;\n    return await this._requestToken(Object.assign({ audience: s.audience, scope: s.scope, code_verifier: s.code_verifier, grant_type: \"authorization_code\", code: i }, c ? { redirect_uri: c } : {}), { nonceIn: u, organizationId: l }), { appState: s.appState };\n  }\n  async checkSession(e) {\n    if (!this.cookieStorage.get(this.isAuthenticatedCookieName)) {\n      if (!this.cookieStorage.get(\"auth0.is.authenticated\"))\n        return;\n      this.cookieStorage.save(this.isAuthenticatedCookieName, !0, { daysUntilExpire: this.sessionCheckExpiryDays, cookieDomain: this.options.cookieDomain }), this.cookieStorage.remove(\"auth0.is.authenticated\");\n    }\n    try {\n      await this.getTokenSilently(e);\n    } catch {\n    }\n  }\n  async getTokenSilently(e = {}) {\n    var r;\n    const n = Object.assign(Object.assign({ cacheMode: \"on\" }, e), { authorizationParams: Object.assign(Object.assign(Object.assign({}, this.options.authorizationParams), e.authorizationParams), { scope: li(this.scope, (r = e.authorizationParams) === null || r === void 0 ? void 0 : r.scope) }) }), i = await ((o, a) => {\n      let s = Us[a];\n      return s || (s = o().finally(() => {\n        delete Us[a], s = null;\n      }), Us[a] = s), s;\n    })(() => this._getTokenSilently(n), `${this.options.clientId}::${n.authorizationParams.audience}::${n.authorizationParams.scope}`);\n    return e.detailedResponse ? i : i == null ? void 0 : i.access_token;\n  }\n  async _getTokenSilently(e) {\n    const { cacheMode: r } = e, n = Jt(e, [\"cacheMode\"]);\n    if (r !== \"off\") {\n      const i = await this._getEntryFromCache({ scope: n.authorizationParams.scope, audience: n.authorizationParams.audience || \"default\", clientId: this.options.clientId });\n      if (i)\n        return i;\n    }\n    if (r !== \"cache-only\") {\n      if (!await (async (i, o = 3) => {\n        for (let a = 0; a < o; a++)\n          if (await i())\n            return !0;\n        return !1;\n      })(() => Vs.acquireLock(\"auth0.lock.getTokenSilently\", 5e3), 10))\n        throw new Hn();\n      try {\n        if (window.addEventListener(\"pagehide\", this._releaseLockOnPageHide), r !== \"off\") {\n          const u = await this._getEntryFromCache({ scope: n.authorizationParams.scope, audience: n.authorizationParams.audience || \"default\", clientId: this.options.clientId });\n          if (u)\n            return u;\n        }\n        const i = this.options.useRefreshTokens ? await this._getTokenUsingRefreshToken(n) : await this._getTokenFromIFrame(n), { id_token: o, access_token: a, oauthTokenScope: s, expires_in: l } = i;\n        return Object.assign(Object.assign({ id_token: o, access_token: a }, s ? { scope: s } : null), { expires_in: l });\n      } finally {\n        await Vs.releaseLock(\"auth0.lock.getTokenSilently\"), window.removeEventListener(\"pagehide\", this._releaseLockOnPageHide);\n      }\n    }\n  }\n  async getTokenWithPopup(e = {}, r = {}) {\n    var n;\n    const i = Object.assign(Object.assign({}, e), { authorizationParams: Object.assign(Object.assign(Object.assign({}, this.options.authorizationParams), e.authorizationParams), { scope: li(this.scope, (n = e.authorizationParams) === null || n === void 0 ? void 0 : n.scope) }) });\n    return r = Object.assign(Object.assign({}, Zm), r), await this.loginWithPopup(i, r), (await this.cacheManager.get(new tr({ scope: i.authorizationParams.scope, audience: i.authorizationParams.audience || \"default\", clientId: this.options.clientId }))).access_token;\n  }\n  async isAuthenticated() {\n    return !!await this.getUser();\n  }\n  _buildLogoutUrl(e) {\n    e.clientId !== null ? e.clientId = e.clientId || this.options.clientId : delete e.clientId;\n    const r = e.logoutParams || {}, { federated: n } = r, i = Jt(r, [\"federated\"]), o = n ? \"&federated\" : \"\";\n    return this._url(`/v2/logout?${_a(Object.assign({ clientId: e.clientId }, i))}`) + o;\n  }\n  async logout(e = {}) {\n    const r = gl(e), { openUrl: n } = r, i = Jt(r, [\"openUrl\"]);\n    e.clientId === null ? await this.cacheManager.clear() : await this.cacheManager.clear(e.clientId || this.options.clientId), this.cookieStorage.remove(this.orgHintCookieName, { cookieDomain: this.options.cookieDomain }), this.cookieStorage.remove(this.isAuthenticatedCookieName, { cookieDomain: this.options.cookieDomain }), this.userCache.remove(\"@@user@@\");\n    const o = this._buildLogoutUrl(i);\n    n ? await n(o) : n !== !1 && window.location.assign(o);\n  }\n  async _getTokenFromIFrame(e) {\n    const r = Object.assign(Object.assign({}, e.authorizationParams), { prompt: \"none\" }), n = this.cookieStorage.get(this.orgHintCookieName);\n    n && !r.organization && (r.organization = n);\n    const { url: i, state: o, nonce: a, code_verifier: s, redirect_uri: l, scope: u, audience: c } = await this._prepareAuthorizeUrl(r, { response_mode: \"web_message\" }, window.location.origin);\n    try {\n      if (window.crossOriginIsolated)\n        throw new wt(\"login_required\", \"The application is running in a Cross-Origin Isolated context, silently retrieving a token without refresh token is not possible.\");\n      const f = e.timeoutInSeconds || this.options.authorizeTimeoutInSeconds, h = await ((g, _, T = 60) => new Promise((A, w) => {\n        const O = window.document.createElement(\"iframe\");\n        O.setAttribute(\"width\", \"0\"), O.setAttribute(\"height\", \"0\"), O.style.display = \"none\";\n        const R = () => {\n          window.document.body.contains(O) && (window.document.body.removeChild(O), window.removeEventListener(\"message\", $, !1));\n        };\n        let $;\n        const U = setTimeout(() => {\n          w(new Hn()), R();\n        }, 1e3 * T);\n        $ = function(W) {\n          if (W.origin != _ || !W.data || W.data.type !== \"authorization_response\")\n            return;\n          const G = W.source;\n          G && G.close(), W.data.response.error ? w(wt.fromPayload(W.data.response)) : A(W.data.response), clearTimeout(U), window.removeEventListener(\"message\", $, !1), setTimeout(R, 2e3);\n        }, window.addEventListener(\"message\", $, !1), window.document.body.appendChild(O), O.setAttribute(\"src\", g);\n      }))(i, this.domainUrl, f);\n      if (o !== h.state)\n        throw new wt(\"state_mismatch\", \"Invalid state\");\n      const p = await this._requestToken(Object.assign(Object.assign({}, e.authorizationParams), { code_verifier: s, code: h.code, grant_type: \"authorization_code\", redirect_uri: l, timeout: e.authorizationParams.timeout || this.httpTimeoutMs }), { nonceIn: a });\n      return Object.assign(Object.assign({}, p), { scope: u, oauthTokenScope: p.scope, audience: c });\n    } catch (f) {\n      throw f.error === \"login_required\" && this.logout({ openUrl: !1 }), f;\n    }\n  }\n  async _getTokenUsingRefreshToken(e) {\n    const r = await this.cacheManager.get(new tr({ scope: e.authorizationParams.scope, audience: e.authorizationParams.audience || \"default\", clientId: this.options.clientId }));\n    if (!(r && r.refresh_token || this.worker)) {\n      if (this.options.useRefreshTokensFallback)\n        return await this._getTokenFromIFrame(e);\n      throw new Lo(e.authorizationParams.audience || \"default\", e.authorizationParams.scope);\n    }\n    const n = e.authorizationParams.redirect_uri || this.options.authorizationParams.redirect_uri || window.location.origin, i = typeof e.timeoutInSeconds == \"number\" ? 1e3 * e.timeoutInSeconds : null;\n    try {\n      const o = await this._requestToken(Object.assign(Object.assign(Object.assign({}, e.authorizationParams), { grant_type: \"refresh_token\", refresh_token: r && r.refresh_token, redirect_uri: n }), i && { timeout: i }));\n      return Object.assign(Object.assign({}, o), { scope: e.authorizationParams.scope, oauthTokenScope: o.scope, audience: e.authorizationParams.audience || \"default\" });\n    } catch (o) {\n      if ((o.message.indexOf(\"Missing Refresh Token\") > -1 || o.message && o.message.indexOf(\"invalid refresh token\") > -1) && this.options.useRefreshTokensFallback)\n        return await this._getTokenFromIFrame(e);\n      throw o;\n    }\n  }\n  async _saveEntryInCache(e) {\n    const { id_token: r, decodedToken: n } = e, i = Jt(e, [\"id_token\", \"decodedToken\"]);\n    this.userCache.set(\"@@user@@\", { id_token: r, decodedToken: n }), await this.cacheManager.setIdToken(this.options.clientId, e.id_token, e.decodedToken), await this.cacheManager.set(i);\n  }\n  async _getIdTokenFromCache() {\n    const e = this.options.authorizationParams.audience || \"default\", r = await this.cacheManager.getIdToken(new tr({ clientId: this.options.clientId, audience: e, scope: this.scope })), n = this.userCache.get(\"@@user@@\");\n    return r && r.id_token === (n == null ? void 0 : n.id_token) ? n : (this.userCache.set(\"@@user@@\", r), r);\n  }\n  async _getEntryFromCache({ scope: e, audience: r, clientId: n }) {\n    const i = await this.cacheManager.get(new tr({ scope: e, audience: r, clientId: n }), 60);\n    if (i && i.access_token) {\n      const { access_token: o, oauthTokenScope: a, expires_in: s } = i, l = await this._getIdTokenFromCache();\n      return l && Object.assign(Object.assign({ id_token: l.id_token, access_token: o }, a ? { scope: a } : null), { expires_in: s });\n    }\n  }\n  async _requestToken(e, r) {\n    const { nonceIn: n, organizationId: i } = r || {}, o = await tv(Object.assign({ baseUrl: this.domainUrl, client_id: this.options.clientId, auth0Client: this.options.auth0Client, useFormData: this.options.useFormData, timeout: this.httpTimeoutMs }, e), this.worker), a = await this._verifyIdToken(o.id_token, n, i);\n    return await this._saveEntryInCache(Object.assign(Object.assign(Object.assign(Object.assign({}, o), { decodedToken: a, scope: e.scope, audience: e.audience || \"default\" }), o.scope ? { oauthTokenScope: o.scope } : null), { client_id: this.options.clientId })), this.cookieStorage.save(this.isAuthenticatedCookieName, !0, { daysUntilExpire: this.sessionCheckExpiryDays, cookieDomain: this.options.cookieDomain }), this._processOrgIdHint(a.claims.org_id), Object.assign(Object.assign({}, o), { decodedToken: a });\n  }\n}\nasync function yv(t) {\n  const e = new pv(t);\n  return await e.checkSession(), e;\n}\nfunction Aa(t) {\n  this.message = t;\n}\nAa.prototype = new Error(), Aa.prototype.name = \"InvalidCharacterError\";\nvar xl = typeof window < \"u\" && window.atob && window.atob.bind(window) || function(t) {\n  var e = String(t).replace(/=+$/, \"\");\n  if (e.length % 4 == 1)\n    throw new Aa(\"'atob' failed: The string to be decoded is not correctly encoded.\");\n  for (var r, n, i = 0, o = 0, a = \"\"; n = e.charAt(o++); ~n && (r = i % 4 ? 64 * r + n : n, i++ % 4) ? a += String.fromCharCode(255 & r >> (-2 * i & 6)) : 0)\n    n = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\".indexOf(n);\n  return a;\n};\nfunction mv(t) {\n  var e = t.replace(/-/g, \"+\").replace(/_/g, \"/\");\n  switch (e.length % 4) {\n    case 0:\n      break;\n    case 2:\n      e += \"==\";\n      break;\n    case 3:\n      e += \"=\";\n      break;\n    default:\n      throw \"Illegal base64url string!\";\n  }\n  try {\n    return function(r) {\n      return decodeURIComponent(xl(r).replace(/(.)/g, function(n, i) {\n        var o = i.charCodeAt(0).toString(16).toUpperCase();\n        return o.length < 2 && (o = \"0\" + o), \"%\" + o;\n      }));\n    }(e);\n  } catch {\n    return xl(e);\n  }\n}\nfunction Ri(t) {\n  this.message = t;\n}\nfunction dr(t, e) {\n  if (typeof t != \"string\")\n    throw new Ri(\"Invalid token specified\");\n  var r = (e = e || {}).header === !0 ? 0 : 1;\n  try {\n    return JSON.parse(mv(t.split(\".\")[r]));\n  } catch (n) {\n    throw new Ri(\"Invalid token specified: \" + n.message);\n  }\n}\nRi.prototype = new Error(), Ri.prototype.name = \"InvalidTokenError\";\nvar Ta = {}, vv = {\n  get exports() {\n    return Ta;\n  },\n  set exports(t) {\n    Ta = t;\n  }\n};\nfunction gv(t) {\n  throw new Error('Could not dynamically require \"' + t + '\". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');\n}\nvar Bi = {}, xv = {\n  get exports() {\n    return Bi;\n  },\n  set exports(t) {\n    Bi = t;\n  }\n};\nconst wv = {}, bv = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  default: wv\n}, Symbol.toStringTag, { value: \"Module\" })), pc = /* @__PURE__ */ oy(bv);\nvar wl;\nfunction Ie() {\n  return wl || (wl = 1, function(t, e) {\n    (function(r, n) {\n      t.exports = n();\n    })(ue, function() {\n      var r = r || function(n, i) {\n        var o;\n        if (typeof window < \"u\" && window.crypto && (o = window.crypto), typeof self < \"u\" && self.crypto && (o = self.crypto), typeof globalThis < \"u\" && globalThis.crypto && (o = globalThis.crypto), !o && typeof window < \"u\" && window.msCrypto && (o = window.msCrypto), !o && typeof ue < \"u\" && ue.crypto && (o = ue.crypto), !o && typeof gv == \"function\")\n          try {\n            o = pc;\n          } catch {\n          }\n        var a = function() {\n          if (o) {\n            if (typeof o.getRandomValues == \"function\")\n              try {\n                return o.getRandomValues(new Uint32Array(1))[0];\n              } catch {\n              }\n            if (typeof o.randomBytes == \"function\")\n              try {\n                return o.randomBytes(4).readInt32LE();\n              } catch {\n              }\n          }\n          throw new Error(\"Native crypto module could not be used to get secure random number.\");\n        }, s = Object.create || function() {\n          function w() {\n          }\n          return function(O) {\n            var R;\n            return w.prototype = O, R = new w(), w.prototype = null, R;\n          };\n        }(), l = {}, u = l.lib = {}, c = u.Base = function() {\n          return {\n            /**\n             * Creates a new object that inherits from this object.\n             *\n             * @param {Object} overrides Properties to copy into the new object.\n             *\n             * @return {Object} The new object.\n             *\n             * @static\n             *\n             * @example\n             *\n             *     var MyType = CryptoJS.lib.Base.extend({\n             *         field: 'value',\n             *\n             *         method: function () {\n             *         }\n             *     });\n             */\n            extend: function(w) {\n              var O = s(this);\n              return w && O.mixIn(w), (!O.hasOwnProperty(\"init\") || this.init === O.init) && (O.init = function() {\n                O.$super.init.apply(this, arguments);\n              }), O.init.prototype = O, O.$super = this, O;\n            },\n            /**\n             * Extends this object and runs the init method.\n             * Arguments to create() will be passed to init().\n             *\n             * @return {Object} The new object.\n             *\n             * @static\n             *\n             * @example\n             *\n             *     var instance = MyType.create();\n             */\n            create: function() {\n              var w = this.extend();\n              return w.init.apply(w, arguments), w;\n            },\n            /**\n             * Initializes a newly created object.\n             * Override this method to add some logic when your objects are created.\n             *\n             * @example\n             *\n             *     var MyType = CryptoJS.lib.Base.extend({\n             *         init: function () {\n             *             // ...\n             *         }\n             *     });\n             */\n            init: function() {\n            },\n            /**\n             * Copies properties into this object.\n             *\n             * @param {Object} properties The properties to mix in.\n             *\n             * @example\n             *\n             *     MyType.mixIn({\n             *         field: 'value'\n             *     });\n             */\n            mixIn: function(w) {\n              for (var O in w)\n                w.hasOwnProperty(O) && (this[O] = w[O]);\n              w.hasOwnProperty(\"toString\") && (this.toString = w.toString);\n            },\n            /**\n             * Creates a copy of this object.\n             *\n             * @return {Object} The clone.\n             *\n             * @example\n             *\n             *     var clone = instance.clone();\n             */\n            clone: function() {\n              return this.init.prototype.extend(this);\n            }\n          };\n        }(), f = u.WordArray = c.extend({\n          /**\n           * Initializes a newly created word array.\n           *\n           * @param {Array} words (Optional) An array of 32-bit words.\n           * @param {number} sigBytes (Optional) The number of significant bytes in the words.\n           *\n           * @example\n           *\n           *     var wordArray = CryptoJS.lib.WordArray.create();\n           *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);\n           *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);\n           */\n          init: function(w, O) {\n            w = this.words = w || [], O != i ? this.sigBytes = O : this.sigBytes = w.length * 4;\n          },\n          /**\n           * Converts this word array to a string.\n           *\n           * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex\n           *\n           * @return {string} The stringified word array.\n           *\n           * @example\n           *\n           *     var string = wordArray + '';\n           *     var string = wordArray.toString();\n           *     var string = wordArray.toString(CryptoJS.enc.Utf8);\n           */\n          toString: function(w) {\n            return (w || p).stringify(this);\n          },\n          /**\n           * Concatenates a word array to this word array.\n           *\n           * @param {WordArray} wordArray The word array to append.\n           *\n           * @return {WordArray} This word array.\n           *\n           * @example\n           *\n           *     wordArray1.concat(wordArray2);\n           */\n          concat: function(w) {\n            var O = this.words, R = w.words, $ = this.sigBytes, U = w.sigBytes;\n            if (this.clamp(), $ % 4)\n              for (var W = 0; W < U; W++) {\n                var G = R[W >>> 2] >>> 24 - W % 4 * 8 & 255;\n                O[$ + W >>> 2] |= G << 24 - ($ + W) % 4 * 8;\n              }\n            else\n              for (var Z = 0; Z < U; Z += 4)\n                O[$ + Z >>> 2] = R[Z >>> 2];\n            return this.sigBytes += U, this;\n          },\n          /**\n           * Removes insignificant bits.\n           *\n           * @example\n           *\n           *     wordArray.clamp();\n           */\n          clamp: function() {\n            var w = this.words, O = this.sigBytes;\n            w[O >>> 2] &= 4294967295 << 32 - O % 4 * 8, w.length = n.ceil(O / 4);\n          },\n          /**\n           * Creates a copy of this word array.\n           *\n           * @return {WordArray} The clone.\n           *\n           * @example\n           *\n           *     var clone = wordArray.clone();\n           */\n          clone: function() {\n            var w = c.clone.call(this);\n            return w.words = this.words.slice(0), w;\n          },\n          /**\n           * Creates a word array filled with random bytes.\n           *\n           * @param {number} nBytes The number of random bytes to generate.\n           *\n           * @return {WordArray} The random word array.\n           *\n           * @static\n           *\n           * @example\n           *\n           *     var wordArray = CryptoJS.lib.WordArray.random(16);\n           */\n          random: function(w) {\n            for (var O = [], R = 0; R < w; R += 4)\n              O.push(a());\n            return new f.init(O, w);\n          }\n        }), h = l.enc = {}, p = h.Hex = {\n          /**\n           * Converts a word array to a hex string.\n           *\n           * @param {WordArray} wordArray The word array.\n           *\n           * @return {string} The hex string.\n           *\n           * @static\n           *\n           * @example\n           *\n           *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);\n           */\n          stringify: function(w) {\n            for (var O = w.words, R = w.sigBytes, $ = [], U = 0; U < R; U++) {\n              var W = O[U >>> 2] >>> 24 - U % 4 * 8 & 255;\n              $.push((W >>> 4).toString(16)), $.push((W & 15).toString(16));\n            }\n            return $.join(\"\");\n          },\n          /**\n           * Converts a hex string to a word array.\n           *\n           * @param {string} hexStr The hex string.\n           *\n           * @return {WordArray} The word array.\n           *\n           * @static\n           *\n           * @example\n           *\n           *     var wordArray = CryptoJS.enc.Hex.parse(hexString);\n           */\n          parse: function(w) {\n            for (var O = w.length, R = [], $ = 0; $ < O; $ += 2)\n              R[$ >>> 3] |= parseInt(w.substr($, 2), 16) << 24 - $ % 8 * 4;\n            return new f.init(R, O / 2);\n          }\n        }, g = h.Latin1 = {\n          /**\n           * Converts a word array to a Latin1 string.\n           *\n           * @param {WordArray} wordArray The word array.\n           *\n           * @return {string} The Latin1 string.\n           *\n           * @static\n           *\n           * @example\n           *\n           *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);\n           */\n          stringify: function(w) {\n            for (var O = w.words, R = w.sigBytes, $ = [], U = 0; U < R; U++) {\n              var W = O[U >>> 2] >>> 24 - U % 4 * 8 & 255;\n              $.push(String.fromCharCode(W));\n            }\n            return $.join(\"\");\n          },\n          /**\n           * Converts a Latin1 string to a word array.\n           *\n           * @param {string} latin1Str The Latin1 string.\n           *\n           * @return {WordArray} The word array.\n           *\n           * @static\n           *\n           * @example\n           *\n           *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);\n           */\n          parse: function(w) {\n            for (var O = w.length, R = [], $ = 0; $ < O; $++)\n              R[$ >>> 2] |= (w.charCodeAt($) & 255) << 24 - $ % 4 * 8;\n            return new f.init(R, O);\n          }\n        }, _ = h.Utf8 = {\n          /**\n           * Converts a word array to a UTF-8 string.\n           *\n           * @param {WordArray} wordArray The word array.\n           *\n           * @return {string} The UTF-8 string.\n           *\n           * @static\n           *\n           * @example\n           *\n           *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);\n           */\n          stringify: function(w) {\n            try {\n              return decodeURIComponent(escape(g.stringify(w)));\n            } catch {\n              throw new Error(\"Malformed UTF-8 data\");\n            }\n          },\n          /**\n           * Converts a UTF-8 string to a word array.\n           *\n           * @param {string} utf8Str The UTF-8 string.\n           *\n           * @return {WordArray} The word array.\n           *\n           * @static\n           *\n           * @example\n           *\n           *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);\n           */\n          parse: function(w) {\n            return g.parse(unescape(encodeURIComponent(w)));\n          }\n        }, T = u.BufferedBlockAlgorithm = c.extend({\n          /**\n           * Resets this block algorithm's data buffer to its initial state.\n           *\n           * @example\n           *\n           *     bufferedBlockAlgorithm.reset();\n           */\n          reset: function() {\n            this._data = new f.init(), this._nDataBytes = 0;\n          },\n          /**\n           * Adds new data to this block algorithm's buffer.\n           *\n           * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.\n           *\n           * @example\n           *\n           *     bufferedBlockAlgorithm._append('data');\n           *     bufferedBlockAlgorithm._append(wordArray);\n           */\n          _append: function(w) {\n            typeof w == \"string\" && (w = _.parse(w)), this._data.concat(w), this._nDataBytes += w.sigBytes;\n          },\n          /**\n           * Processes available data blocks.\n           *\n           * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.\n           *\n           * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.\n           *\n           * @return {WordArray} The processed data.\n           *\n           * @example\n           *\n           *     var processedData = bufferedBlockAlgorithm._process();\n           *     var processedData = bufferedBlockAlgorithm._process(!!'flush');\n           */\n          _process: function(w) {\n            var O, R = this._data, $ = R.words, U = R.sigBytes, W = this.blockSize, G = W * 4, Z = U / G;\n            w ? Z = n.ceil(Z) : Z = n.max((Z | 0) - this._minBufferSize, 0);\n            var j = Z * W, P = n.min(j * 4, U);\n            if (j) {\n              for (var d = 0; d < j; d += W)\n                this._doProcessBlock($, d);\n              O = $.splice(0, j), R.sigBytes -= P;\n            }\n            return new f.init(O, P);\n          },\n          /**\n           * Creates a copy of this object.\n           *\n           * @return {Object} The clone.\n           *\n           * @example\n           *\n           *     var clone = bufferedBlockAlgorithm.clone();\n           */\n          clone: function() {\n            var w = c.clone.call(this);\n            return w._data = this._data.clone(), w;\n          },\n          _minBufferSize: 0\n        });\n        u.Hasher = T.extend({\n          /**\n           * Configuration options.\n           */\n          cfg: c.extend(),\n          /**\n           * Initializes a newly created hasher.\n           *\n           * @param {Object} cfg (Optional) The configuration options to use for this hash computation.\n           *\n           * @example\n           *\n           *     var hasher = CryptoJS.algo.SHA256.create();\n           */\n          init: function(w) {\n            this.cfg = this.cfg.extend(w), this.reset();\n          },\n          /**\n           * Resets this hasher to its initial state.\n           *\n           * @example\n           *\n           *     hasher.reset();\n           */\n          reset: function() {\n            T.reset.call(this), this._doReset();\n          },\n          /**\n           * Updates this hasher with a message.\n           *\n           * @param {WordArray|string} messageUpdate The message to append.\n           *\n           * @return {Hasher} This hasher.\n           *\n           * @example\n           *\n           *     hasher.update('message');\n           *     hasher.update(wordArray);\n           */\n          update: function(w) {\n            return this._append(w), this._process(), this;\n          },\n          /**\n           * Finalizes the hash computation.\n           * Note that the finalize operation is effectively a destructive, read-once operation.\n           *\n           * @param {WordArray|string} messageUpdate (Optional) A final message update.\n           *\n           * @return {WordArray} The hash.\n           *\n           * @example\n           *\n           *     var hash = hasher.finalize();\n           *     var hash = hasher.finalize('message');\n           *     var hash = hasher.finalize(wordArray);\n           */\n          finalize: function(w) {\n            w && this._append(w);\n            var O = this._doFinalize();\n            return O;\n          },\n          blockSize: 16,\n          /**\n           * Creates a shortcut function to a hasher's object interface.\n           *\n           * @param {Hasher} hasher The hasher to create a helper for.\n           *\n           * @return {Function} The shortcut function.\n           *\n           * @static\n           *\n           * @example\n           *\n           *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);\n           */\n          _createHelper: function(w) {\n            return function(O, R) {\n              return new w.init(R).finalize(O);\n            };\n          },\n          /**\n           * Creates a shortcut function to the HMAC's object interface.\n           *\n           * @param {Hasher} hasher The hasher to use in this HMAC helper.\n           *\n           * @return {Function} The shortcut function.\n           *\n           * @static\n           *\n           * @example\n           *\n           *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);\n           */\n          _createHmacHelper: function(w) {\n            return function(O, R) {\n              return new A.HMAC.init(w, R).finalize(O);\n            };\n          }\n        });\n        var A = l.algo = {};\n        return l;\n      }(Math);\n      return r;\n    });\n  }(xv)), Bi;\n}\nvar Ii = {}, _v = {\n  get exports() {\n    return Ii;\n  },\n  set exports(t) {\n    Ii = t;\n  }\n}, bl;\nfunction jo() {\n  return bl || (bl = 1, function(t, e) {\n    (function(r, n) {\n      t.exports = n(Ie());\n    })(ue, function(r) {\n      return function(n) {\n        var i = r, o = i.lib, a = o.Base, s = o.WordArray, l = i.x64 = {};\n        l.Word = a.extend({\n          /**\n           * Initializes a newly created 64-bit word.\n           *\n           * @param {number} high The high 32 bits.\n           * @param {number} low The low 32 bits.\n           *\n           * @example\n           *\n           *     var x64Word = CryptoJS.x64.Word.create(0x00010203, 0x04050607);\n           */\n          init: function(u, c) {\n            this.high = u, this.low = c;\n          }\n          /**\n           * Bitwise NOTs this word.\n           *\n           * @return {X64Word} A new x64-Word object after negating.\n           *\n           * @example\n           *\n           *     var negated = x64Word.not();\n           */\n          // not: function () {\n          // var high = ~this.high;\n          // var low = ~this.low;\n          // return X64Word.create(high, low);\n          // },\n          /**\n           * Bitwise ANDs this word with the passed word.\n           *\n           * @param {X64Word} word The x64-Word to AND with this word.\n           *\n           * @return {X64Word} A new x64-Word object after ANDing.\n           *\n           * @example\n           *\n           *     var anded = x64Word.and(anotherX64Word);\n           */\n          // and: function (word) {\n          // var high = this.high & word.high;\n          // var low = this.low & word.low;\n          // return X64Word.create(high, low);\n          // },\n          /**\n           * Bitwise ORs this word with the passed word.\n           *\n           * @param {X64Word} word The x64-Word to OR with this word.\n           *\n           * @return {X64Word} A new x64-Word object after ORing.\n           *\n           * @example\n           *\n           *     var ored = x64Word.or(anotherX64Word);\n           */\n          // or: function (word) {\n          // var high = this.high | word.high;\n          // var low = this.low | word.low;\n          // return X64Word.create(high, low);\n          // },\n          /**\n           * Bitwise XORs this word with the passed word.\n           *\n           * @param {X64Word} word The x64-Word to XOR with this word.\n           *\n           * @return {X64Word} A new x64-Word object after XORing.\n           *\n           * @example\n           *\n           *     var xored = x64Word.xor(anotherX64Word);\n           */\n          // xor: function (word) {\n          // var high = this.high ^ word.high;\n          // var low = this.low ^ word.low;\n          // return X64Word.create(high, low);\n          // },\n          /**\n           * Shifts this word n bits to the left.\n           *\n           * @param {number} n The number of bits to shift.\n           *\n           * @return {X64Word} A new x64-Word object after shifting.\n           *\n           * @example\n           *\n           *     var shifted = x64Word.shiftL(25);\n           */\n          // shiftL: function (n) {\n          // if (n < 32) {\n          // var high = (this.high << n) | (this.low >>> (32 - n));\n          // var low = this.low << n;\n          // } else {\n          // var high = this.low << (n - 32);\n          // var low = 0;\n          // }\n          // return X64Word.create(high, low);\n          // },\n          /**\n           * Shifts this word n bits to the right.\n           *\n           * @param {number} n The number of bits to shift.\n           *\n           * @return {X64Word} A new x64-Word object after shifting.\n           *\n           * @example\n           *\n           *     var shifted = x64Word.shiftR(7);\n           */\n          // shiftR: function (n) {\n          // if (n < 32) {\n          // var low = (this.low >>> n) | (this.high << (32 - n));\n          // var high = this.high >>> n;\n          // } else {\n          // var low = this.high >>> (n - 32);\n          // var high = 0;\n          // }\n          // return X64Word.create(high, low);\n          // },\n          /**\n           * Rotates this word n bits to the left.\n           *\n           * @param {number} n The number of bits to rotate.\n           *\n           * @return {X64Word} A new x64-Word object after rotating.\n           *\n           * @example\n           *\n           *     var rotated = x64Word.rotL(25);\n           */\n          // rotL: function (n) {\n          // return this.shiftL(n).or(this.shiftR(64 - n));\n          // },\n          /**\n           * Rotates this word n bits to the right.\n           *\n           * @param {number} n The number of bits to rotate.\n           *\n           * @return {X64Word} A new x64-Word object after rotating.\n           *\n           * @example\n           *\n           *     var rotated = x64Word.rotR(7);\n           */\n          // rotR: function (n) {\n          // return this.shiftR(n).or(this.shiftL(64 - n));\n          // },\n          /**\n           * Adds this word with the passed word.\n           *\n           * @param {X64Word} word The x64-Word to add with this word.\n           *\n           * @return {X64Word} A new x64-Word object after adding.\n           *\n           * @example\n           *\n           *     var added = x64Word.add(anotherX64Word);\n           */\n          // add: function (word) {\n          // var low = (this.low + word.low) | 0;\n          // var carry = (low >>> 0) < (this.low >>> 0) ? 1 : 0;\n          // var high = (this.high + word.high + carry) | 0;\n          // return X64Word.create(high, low);\n          // }\n        }), l.WordArray = a.extend({\n          /**\n           * Initializes a newly created word array.\n           *\n           * @param {Array} words (Optional) An array of CryptoJS.x64.Word objects.\n           * @param {number} sigBytes (Optional) The number of significant bytes in the words.\n           *\n           * @example\n           *\n           *     var wordArray = CryptoJS.x64.WordArray.create();\n           *\n           *     var wordArray = CryptoJS.x64.WordArray.create([\n           *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),\n           *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)\n           *     ]);\n           *\n           *     var wordArray = CryptoJS.x64.WordArray.create([\n           *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),\n           *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)\n           *     ], 10);\n           */\n          init: function(u, c) {\n            u = this.words = u || [], c != n ? this.sigBytes = c : this.sigBytes = u.length * 8;\n          },\n          /**\n           * Converts this 64-bit word array to a 32-bit word array.\n           *\n           * @return {CryptoJS.lib.WordArray} This word array's data as a 32-bit word array.\n           *\n           * @example\n           *\n           *     var x32WordArray = x64WordArray.toX32();\n           */\n          toX32: function() {\n            for (var u = this.words, c = u.length, f = [], h = 0; h < c; h++) {\n              var p = u[h];\n              f.push(p.high), f.push(p.low);\n            }\n            return s.create(f, this.sigBytes);\n          },\n          /**\n           * Creates a copy of this word array.\n           *\n           * @return {X64WordArray} The clone.\n           *\n           * @example\n           *\n           *     var clone = x64WordArray.clone();\n           */\n          clone: function() {\n            for (var u = a.clone.call(this), c = u.words = this.words.slice(0), f = c.length, h = 0; h < f; h++)\n              c[h] = c[h].clone();\n            return u;\n          }\n        });\n      }(), r;\n    });\n  }(_v)), Ii;\n}\nvar Di = {}, Av = {\n  get exports() {\n    return Di;\n  },\n  set exports(t) {\n    Di = t;\n  }\n}, _l;\nfunction Tv() {\n  return _l || (_l = 1, function(t, e) {\n    (function(r, n) {\n      t.exports = n(Ie());\n    })(ue, function(r) {\n      return function() {\n        if (typeof ArrayBuffer == \"function\") {\n          var n = r, i = n.lib, o = i.WordArray, a = o.init, s = o.init = function(l) {\n            if (l instanceof ArrayBuffer && (l = new Uint8Array(l)), (l instanceof Int8Array || typeof Uint8ClampedArray < \"u\" && l instanceof Uint8ClampedArray || l instanceof Int16Array || l instanceof Uint16Array || l instanceof Int32Array || l instanceof Uint32Array || l instanceof Float32Array || l instanceof Float64Array) && (l = new Uint8Array(l.buffer, l.byteOffset, l.byteLength)), l instanceof Uint8Array) {\n              for (var u = l.byteLength, c = [], f = 0; f < u; f++)\n                c[f >>> 2] |= l[f] << 24 - f % 4 * 8;\n              a.call(this, c, u);\n            } else\n              a.apply(this, arguments);\n          };\n          s.prototype = o;\n        }\n      }(), r.lib.WordArray;\n    });\n  }(Av)), Di;\n}\nvar Ni = {}, Ev = {\n  get exports() {\n    return Ni;\n  },\n  set exports(t) {\n    Ni = t;\n  }\n}, Al;\nfunction Sv() {\n  return Al || (Al = 1, function(t, e) {\n    (function(r, n) {\n      t.exports = n(Ie());\n    })(ue, function(r) {\n      return function() {\n        var n = r, i = n.lib, o = i.WordArray, a = n.enc;\n        a.Utf16 = a.Utf16BE = {\n          /**\n           * Converts a word array to a UTF-16 BE string.\n           *\n           * @param {WordArray} wordArray The word array.\n           *\n           * @return {string} The UTF-16 BE string.\n           *\n           * @static\n           *\n           * @example\n           *\n           *     var utf16String = CryptoJS.enc.Utf16.stringify(wordArray);\n           */\n          stringify: function(l) {\n            for (var u = l.words, c = l.sigBytes, f = [], h = 0; h < c; h += 2) {\n              var p = u[h >>> 2] >>> 16 - h % 4 * 8 & 65535;\n              f.push(String.fromCharCode(p));\n            }\n            return f.join(\"\");\n          },\n          /**\n           * Converts a UTF-16 BE string to a word array.\n           *\n           * @param {string} utf16Str The UTF-16 BE string.\n           *\n           * @return {WordArray} The word array.\n           *\n           * @static\n           *\n           * @example\n           *\n           *     var wordArray = CryptoJS.enc.Utf16.parse(utf16String);\n           */\n          parse: function(l) {\n            for (var u = l.length, c = [], f = 0; f < u; f++)\n              c[f >>> 1] |= l.charCodeAt(f) << 16 - f % 2 * 16;\n            return o.create(c, u * 2);\n          }\n        }, a.Utf16LE = {\n          /**\n           * Converts a word array to a UTF-16 LE string.\n           *\n           * @param {WordArray} wordArray The word array.\n           *\n           * @return {string} The UTF-16 LE string.\n           *\n           * @static\n           *\n           * @example\n           *\n           *     var utf16Str = CryptoJS.enc.Utf16LE.stringify(wordArray);\n           */\n          stringify: function(l) {\n            for (var u = l.words, c = l.sigBytes, f = [], h = 0; h < c; h += 2) {\n              var p = s(u[h >>> 2] >>> 16 - h % 4 * 8 & 65535);\n              f.push(String.fromCharCode(p));\n            }\n            return f.join(\"\");\n          },\n          /**\n           * Converts a UTF-16 LE string to a word array.\n           *\n           * @param {string} utf16Str The UTF-16 LE string.\n           *\n           * @return {WordArray} The word array.\n           *\n           * @static\n           *\n           * @example\n           *\n           *     var wordArray = CryptoJS.enc.Utf16LE.parse(utf16Str);\n           */\n          parse: function(l) {\n            for (var u = l.length, c = [], f = 0; f < u; f++)\n              c[f >>> 1] |= s(l.charCodeAt(f) << 16 - f % 2 * 16);\n            return o.create(c, u * 2);\n          }\n        };\n        function s(l) {\n          return l << 8 & 4278255360 | l >>> 8 & 16711935;\n        }\n      }(), r.enc.Utf16;\n    });\n  }(Ev)), Ni;\n}\nvar Fi = {}, Pv = {\n  get exports() {\n    return Fi;\n  },\n  set exports(t) {\n    Fi = t;\n  }\n}, Tl;\nfunction xn() {\n  return Tl || (Tl = 1, function(t, e) {\n    (function(r, n) {\n      t.exports = n(Ie());\n    })(ue, function(r) {\n      return function() {\n        var n = r, i = n.lib, o = i.WordArray, a = n.enc;\n        a.Base64 = {\n          /**\n           * Converts a word array to a Base64 string.\n           *\n           * @param {WordArray} wordArray The word array.\n           *\n           * @return {string} The Base64 string.\n           *\n           * @static\n           *\n           * @example\n           *\n           *     var base64String = CryptoJS.enc.Base64.stringify(wordArray);\n           */\n          stringify: function(l) {\n            var u = l.words, c = l.sigBytes, f = this._map;\n            l.clamp();\n            for (var h = [], p = 0; p < c; p += 3)\n              for (var g = u[p >>> 2] >>> 24 - p % 4 * 8 & 255, _ = u[p + 1 >>> 2] >>> 24 - (p + 1) % 4 * 8 & 255, T = u[p + 2 >>> 2] >>> 24 - (p + 2) % 4 * 8 & 255, A = g << 16 | _ << 8 | T, w = 0; w < 4 && p + w * 0.75 < c; w++)\n                h.push(f.charAt(A >>> 6 * (3 - w) & 63));\n            var O = f.charAt(64);\n            if (O)\n              for (; h.length % 4; )\n                h.push(O);\n            return h.join(\"\");\n          },\n          /**\n           * Converts a Base64 string to a word array.\n           *\n           * @param {string} base64Str The Base64 string.\n           *\n           * @return {WordArray} The word array.\n           *\n           * @static\n           *\n           * @example\n           *\n           *     var wordArray = CryptoJS.enc.Base64.parse(base64String);\n           */\n          parse: function(l) {\n            var u = l.length, c = this._map, f = this._reverseMap;\n            if (!f) {\n              f = this._reverseMap = [];\n              for (var h = 0; h < c.length; h++)\n                f[c.charCodeAt(h)] = h;\n            }\n            var p = c.charAt(64);\n            if (p) {\n              var g = l.indexOf(p);\n              g !== -1 && (u = g);\n            }\n            return s(l, u, f);\n          },\n          _map: \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\"\n        };\n        function s(l, u, c) {\n          for (var f = [], h = 0, p = 0; p < u; p++)\n            if (p % 4) {\n              var g = c[l.charCodeAt(p - 1)] << p % 4 * 2, _ = c[l.charCodeAt(p)] >>> 6 - p % 4 * 2, T = g | _;\n              f[h >>> 2] |= T << 24 - h % 4 * 8, h++;\n            }\n          return o.create(f, h);\n        }\n      }(), r.enc.Base64;\n    });\n  }(Pv)), Fi;\n}\nvar Li = {}, Cv = {\n  get exports() {\n    return Li;\n  },\n  set exports(t) {\n    Li = t;\n  }\n}, El;\nfunction Ov() {\n  return El || (El = 1, function(t, e) {\n    (function(r, n) {\n      t.exports = n(Ie());\n    })(ue, function(r) {\n      return function() {\n        var n = r, i = n.lib, o = i.WordArray, a = n.enc;\n        a.Base64url = {\n          /**\n           * Converts a word array to a Base64url string.\n           *\n           * @param {WordArray} wordArray The word array.\n           *\n           * @param {boolean} urlSafe Whether to use url safe\n           *\n           * @return {string} The Base64url string.\n           *\n           * @static\n           *\n           * @example\n           *\n           *     var base64String = CryptoJS.enc.Base64url.stringify(wordArray);\n           */\n          stringify: function(l, u = !0) {\n            var c = l.words, f = l.sigBytes, h = u ? this._safe_map : this._map;\n            l.clamp();\n            for (var p = [], g = 0; g < f; g += 3)\n              for (var _ = c[g >>> 2] >>> 24 - g % 4 * 8 & 255, T = c[g + 1 >>> 2] >>> 24 - (g + 1) % 4 * 8 & 255, A = c[g + 2 >>> 2] >>> 24 - (g + 2) % 4 * 8 & 255, w = _ << 16 | T << 8 | A, O = 0; O < 4 && g + O * 0.75 < f; O++)\n                p.push(h.charAt(w >>> 6 * (3 - O) & 63));\n            var R = h.charAt(64);\n            if (R)\n              for (; p.length % 4; )\n                p.push(R);\n            return p.join(\"\");\n          },\n          /**\n           * Converts a Base64url string to a word array.\n           *\n           * @param {string} base64Str The Base64url string.\n           *\n           * @param {boolean} urlSafe Whether to use url safe\n           *\n           * @return {WordArray} The word array.\n           *\n           * @static\n           *\n           * @example\n           *\n           *     var wordArray = CryptoJS.enc.Base64url.parse(base64String);\n           */\n          parse: function(l, u = !0) {\n            var c = l.length, f = u ? this._safe_map : this._map, h = this._reverseMap;\n            if (!h) {\n              h = this._reverseMap = [];\n              for (var p = 0; p < f.length; p++)\n                h[f.charCodeAt(p)] = p;\n            }\n            var g = f.charAt(64);\n            if (g) {\n              var _ = l.indexOf(g);\n              _ !== -1 && (c = _);\n            }\n            return s(l, c, h);\n          },\n          _map: \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\",\n          _safe_map: \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\"\n        };\n        function s(l, u, c) {\n          for (var f = [], h = 0, p = 0; p < u; p++)\n            if (p % 4) {\n              var g = c[l.charCodeAt(p - 1)] << p % 4 * 2, _ = c[l.charCodeAt(p)] >>> 6 - p % 4 * 2, T = g | _;\n              f[h >>> 2] |= T << 24 - h % 4 * 8, h++;\n            }\n          return o.create(f, h);\n        }\n      }(), r.enc.Base64url;\n    });\n  }(Cv)), Li;\n}\nvar ji = {}, Mv = {\n  get exports() {\n    return ji;\n  },\n  set exports(t) {\n    ji = t;\n  }\n}, Sl;\nfunction wn() {\n  return Sl || (Sl = 1, function(t, e) {\n    (function(r, n) {\n      t.exports = n(Ie());\n    })(ue, function(r) {\n      return function(n) {\n        var i = r, o = i.lib, a = o.WordArray, s = o.Hasher, l = i.algo, u = [];\n        (function() {\n          for (var _ = 0; _ < 64; _++)\n            u[_] = n.abs(n.sin(_ + 1)) * 4294967296 | 0;\n        })();\n        var c = l.MD5 = s.extend({\n          _doReset: function() {\n            this._hash = new a.init([\n              1732584193,\n              4023233417,\n              2562383102,\n              271733878\n            ]);\n          },\n          _doProcessBlock: function(_, T) {\n            for (var A = 0; A < 16; A++) {\n              var w = T + A, O = _[w];\n              _[w] = (O << 8 | O >>> 24) & 16711935 | (O << 24 | O >>> 8) & 4278255360;\n            }\n            var R = this._hash.words, $ = _[T + 0], U = _[T + 1], W = _[T + 2], G = _[T + 3], Z = _[T + 4], j = _[T + 5], P = _[T + 6], d = _[T + 7], x = _[T + 8], C = _[T + 9], M = _[T + 10], D = _[T + 11], z = _[T + 12], Y = _[T + 13], L = _[T + 14], m = _[T + 15], E = R[0], B = R[1], V = R[2], I = R[3];\n            E = f(E, B, V, I, $, 7, u[0]), I = f(I, E, B, V, U, 12, u[1]), V = f(V, I, E, B, W, 17, u[2]), B = f(B, V, I, E, G, 22, u[3]), E = f(E, B, V, I, Z, 7, u[4]), I = f(I, E, B, V, j, 12, u[5]), V = f(V, I, E, B, P, 17, u[6]), B = f(B, V, I, E, d, 22, u[7]), E = f(E, B, V, I, x, 7, u[8]), I = f(I, E, B, V, C, 12, u[9]), V = f(V, I, E, B, M, 17, u[10]), B = f(B, V, I, E, D, 22, u[11]), E = f(E, B, V, I, z, 7, u[12]), I = f(I, E, B, V, Y, 12, u[13]), V = f(V, I, E, B, L, 17, u[14]), B = f(B, V, I, E, m, 22, u[15]), E = h(E, B, V, I, U, 5, u[16]), I = h(I, E, B, V, P, 9, u[17]), V = h(V, I, E, B, D, 14, u[18]), B = h(B, V, I, E, $, 20, u[19]), E = h(E, B, V, I, j, 5, u[20]), I = h(I, E, B, V, M, 9, u[21]), V = h(V, I, E, B, m, 14, u[22]), B = h(B, V, I, E, Z, 20, u[23]), E = h(E, B, V, I, C, 5, u[24]), I = h(I, E, B, V, L, 9, u[25]), V = h(V, I, E, B, G, 14, u[26]), B = h(B, V, I, E, x, 20, u[27]), E = h(E, B, V, I, Y, 5, u[28]), I = h(I, E, B, V, W, 9, u[29]), V = h(V, I, E, B, d, 14, u[30]), B = h(B, V, I, E, z, 20, u[31]), E = p(E, B, V, I, j, 4, u[32]), I = p(I, E, B, V, x, 11, u[33]), V = p(V, I, E, B, D, 16, u[34]), B = p(B, V, I, E, L, 23, u[35]), E = p(E, B, V, I, U, 4, u[36]), I = p(I, E, B, V, Z, 11, u[37]), V = p(V, I, E, B, d, 16, u[38]), B = p(B, V, I, E, M, 23, u[39]), E = p(E, B, V, I, Y, 4, u[40]), I = p(I, E, B, V, $, 11, u[41]), V = p(V, I, E, B, G, 16, u[42]), B = p(B, V, I, E, P, 23, u[43]), E = p(E, B, V, I, C, 4, u[44]), I = p(I, E, B, V, z, 11, u[45]), V = p(V, I, E, B, m, 16, u[46]), B = p(B, V, I, E, W, 23, u[47]), E = g(E, B, V, I, $, 6, u[48]), I = g(I, E, B, V, d, 10, u[49]), V = g(V, I, E, B, L, 15, u[50]), B = g(B, V, I, E, j, 21, u[51]), E = g(E, B, V, I, z, 6, u[52]), I = g(I, E, B, V, G, 10, u[53]), V = g(V, I, E, B, M, 15, u[54]), B = g(B, V, I, E, U, 21, u[55]), E = g(E, B, V, I, x, 6, u[56]), I = g(I, E, B, V, m, 10, u[57]), V = g(V, I, E, B, P, 15, u[58]), B = g(B, V, I, E, Y, 21, u[59]), E = g(E, B, V, I, Z, 6, u[60]), I = g(I, E, B, V, D, 10, u[61]), V = g(V, I, E, B, W, 15, u[62]), B = g(B, V, I, E, C, 21, u[63]), R[0] = R[0] + E | 0, R[1] = R[1] + B | 0, R[2] = R[2] + V | 0, R[3] = R[3] + I | 0;\n          },\n          _doFinalize: function() {\n            var _ = this._data, T = _.words, A = this._nDataBytes * 8, w = _.sigBytes * 8;\n            T[w >>> 5] |= 128 << 24 - w % 32;\n            var O = n.floor(A / 4294967296), R = A;\n            T[(w + 64 >>> 9 << 4) + 15] = (O << 8 | O >>> 24) & 16711935 | (O << 24 | O >>> 8) & 4278255360, T[(w + 64 >>> 9 << 4) + 14] = (R << 8 | R >>> 24) & 16711935 | (R << 24 | R >>> 8) & 4278255360, _.sigBytes = (T.length + 1) * 4, this._process();\n            for (var $ = this._hash, U = $.words, W = 0; W < 4; W++) {\n              var G = U[W];\n              U[W] = (G << 8 | G >>> 24) & 16711935 | (G << 24 | G >>> 8) & 4278255360;\n            }\n            return $;\n          },\n          clone: function() {\n            var _ = s.clone.call(this);\n            return _._hash = this._hash.clone(), _;\n          }\n        });\n        function f(_, T, A, w, O, R, $) {\n          var U = _ + (T & A | ~T & w) + O + $;\n          return (U << R | U >>> 32 - R) + T;\n        }\n        function h(_, T, A, w, O, R, $) {\n          var U = _ + (T & w | A & ~w) + O + $;\n          return (U << R | U >>> 32 - R) + T;\n        }\n        function p(_, T, A, w, O, R, $) {\n          var U = _ + (T ^ A ^ w) + O + $;\n          return (U << R | U >>> 32 - R) + T;\n        }\n        function g(_, T, A, w, O, R, $) {\n          var U = _ + (A ^ (T | ~w)) + O + $;\n          return (U << R | U >>> 32 - R) + T;\n        }\n        i.MD5 = s._createHelper(c), i.HmacMD5 = s._createHmacHelper(c);\n      }(Math), r.MD5;\n    });\n  }(Mv)), ji;\n}\nvar Ui = {}, kv = {\n  get exports() {\n    return Ui;\n  },\n  set exports(t) {\n    Ui = t;\n  }\n}, Pl;\nfunction yc() {\n  return Pl || (Pl = 1, function(t, e) {\n    (function(r, n) {\n      t.exports = n(Ie());\n    })(ue, function(r) {\n      return function() {\n        var n = r, i = n.lib, o = i.WordArray, a = i.Hasher, s = n.algo, l = [], u = s.SHA1 = a.extend({\n          _doReset: function() {\n            this._hash = new o.init([\n              1732584193,\n              4023233417,\n              2562383102,\n              271733878,\n              3285377520\n            ]);\n          },\n          _doProcessBlock: function(c, f) {\n            for (var h = this._hash.words, p = h[0], g = h[1], _ = h[2], T = h[3], A = h[4], w = 0; w < 80; w++) {\n              if (w < 16)\n                l[w] = c[f + w] | 0;\n              else {\n                var O = l[w - 3] ^ l[w - 8] ^ l[w - 14] ^ l[w - 16];\n                l[w] = O << 1 | O >>> 31;\n              }\n              var R = (p << 5 | p >>> 27) + A + l[w];\n              w < 20 ? R += (g & _ | ~g & T) + 1518500249 : w < 40 ? R += (g ^ _ ^ T) + 1859775393 : w < 60 ? R += (g & _ | g & T | _ & T) - 1894007588 : R += (g ^ _ ^ T) - 899497514, A = T, T = _, _ = g << 30 | g >>> 2, g = p, p = R;\n            }\n            h[0] = h[0] + p | 0, h[1] = h[1] + g | 0, h[2] = h[2] + _ | 0, h[3] = h[3] + T | 0, h[4] = h[4] + A | 0;\n          },\n          _doFinalize: function() {\n            var c = this._data, f = c.words, h = this._nDataBytes * 8, p = c.sigBytes * 8;\n            return f[p >>> 5] |= 128 << 24 - p % 32, f[(p + 64 >>> 9 << 4) + 14] = Math.floor(h / 4294967296), f[(p + 64 >>> 9 << 4) + 15] = h, c.sigBytes = f.length * 4, this._process(), this._hash;\n          },\n          clone: function() {\n            var c = a.clone.call(this);\n            return c._hash = this._hash.clone(), c;\n          }\n        });\n        n.SHA1 = a._createHelper(u), n.HmacSHA1 = a._createHmacHelper(u);\n      }(), r.SHA1;\n    });\n  }(kv)), Ui;\n}\nvar Vi = {}, Rv = {\n  get exports() {\n    return Vi;\n  },\n  set exports(t) {\n    Vi = t;\n  }\n}, Cl;\nfunction Mh() {\n  return Cl || (Cl = 1, function(t, e) {\n    (function(r, n) {\n      t.exports = n(Ie());\n    })(ue, function(r) {\n      return function(n) {\n        var i = r, o = i.lib, a = o.WordArray, s = o.Hasher, l = i.algo, u = [], c = [];\n        (function() {\n          function p(A) {\n            for (var w = n.sqrt(A), O = 2; O <= w; O++)\n              if (!(A % O))\n                return !1;\n            return !0;\n          }\n          function g(A) {\n            return (A - (A | 0)) * 4294967296 | 0;\n          }\n          for (var _ = 2, T = 0; T < 64; )\n            p(_) && (T < 8 && (u[T] = g(n.pow(_, 1 / 2))), c[T] = g(n.pow(_, 1 / 3)), T++), _++;\n        })();\n        var f = [], h = l.SHA256 = s.extend({\n          _doReset: function() {\n            this._hash = new a.init(u.slice(0));\n          },\n          _doProcessBlock: function(p, g) {\n            for (var _ = this._hash.words, T = _[0], A = _[1], w = _[2], O = _[3], R = _[4], $ = _[5], U = _[6], W = _[7], G = 0; G < 64; G++) {\n              if (G < 16)\n                f[G] = p[g + G] | 0;\n              else {\n                var Z = f[G - 15], j = (Z << 25 | Z >>> 7) ^ (Z << 14 | Z >>> 18) ^ Z >>> 3, P = f[G - 2], d = (P << 15 | P >>> 17) ^ (P << 13 | P >>> 19) ^ P >>> 10;\n                f[G] = j + f[G - 7] + d + f[G - 16];\n              }\n              var x = R & $ ^ ~R & U, C = T & A ^ T & w ^ A & w, M = (T << 30 | T >>> 2) ^ (T << 19 | T >>> 13) ^ (T << 10 | T >>> 22), D = (R << 26 | R >>> 6) ^ (R << 21 | R >>> 11) ^ (R << 7 | R >>> 25), z = W + D + x + c[G] + f[G], Y = M + C;\n              W = U, U = $, $ = R, R = O + z | 0, O = w, w = A, A = T, T = z + Y | 0;\n            }\n            _[0] = _[0] + T | 0, _[1] = _[1] + A | 0, _[2] = _[2] + w | 0, _[3] = _[3] + O | 0, _[4] = _[4] + R | 0, _[5] = _[5] + $ | 0, _[6] = _[6] + U | 0, _[7] = _[7] + W | 0;\n          },\n          _doFinalize: function() {\n            var p = this._data, g = p.words, _ = this._nDataBytes * 8, T = p.sigBytes * 8;\n            return g[T >>> 5] |= 128 << 24 - T % 32, g[(T + 64 >>> 9 << 4) + 14] = n.floor(_ / 4294967296), g[(T + 64 >>> 9 << 4) + 15] = _, p.sigBytes = g.length * 4, this._process(), this._hash;\n          },\n          clone: function() {\n            var p = s.clone.call(this);\n            return p._hash = this._hash.clone(), p;\n          }\n        });\n        i.SHA256 = s._createHelper(h), i.HmacSHA256 = s._createHmacHelper(h);\n      }(Math), r.SHA256;\n    });\n  }(Rv)), Vi;\n}\nvar $i = {}, Bv = {\n  get exports() {\n    return $i;\n  },\n  set exports(t) {\n    $i = t;\n  }\n}, Ol;\nfunction Iv() {\n  return Ol || (Ol = 1, function(t, e) {\n    (function(r, n, i) {\n      t.exports = n(Ie(), Mh());\n    })(ue, function(r) {\n      return function() {\n        var n = r, i = n.lib, o = i.WordArray, a = n.algo, s = a.SHA256, l = a.SHA224 = s.extend({\n          _doReset: function() {\n            this._hash = new o.init([\n              3238371032,\n              914150663,\n              812702999,\n              4144912697,\n              4290775857,\n              1750603025,\n              1694076839,\n              3204075428\n            ]);\n          },\n          _doFinalize: function() {\n            var u = s._doFinalize.call(this);\n            return u.sigBytes -= 4, u;\n          }\n        });\n        n.SHA224 = s._createHelper(l), n.HmacSHA224 = s._createHmacHelper(l);\n      }(), r.SHA224;\n    });\n  }(Bv)), $i;\n}\nvar Hi = {}, Dv = {\n  get exports() {\n    return Hi;\n  },\n  set exports(t) {\n    Hi = t;\n  }\n}, Ml;\nfunction kh() {\n  return Ml || (Ml = 1, function(t, e) {\n    (function(r, n, i) {\n      t.exports = n(Ie(), jo());\n    })(ue, function(r) {\n      return function() {\n        var n = r, i = n.lib, o = i.Hasher, a = n.x64, s = a.Word, l = a.WordArray, u = n.algo;\n        function c() {\n          return s.create.apply(s, arguments);\n        }\n        var f = [\n          c(1116352408, 3609767458),\n          c(1899447441, 602891725),\n          c(3049323471, 3964484399),\n          c(3921009573, 2173295548),\n          c(961987163, 4081628472),\n          c(1508970993, 3053834265),\n          c(2453635748, 2937671579),\n          c(2870763221, 3664609560),\n          c(3624381080, 2734883394),\n          c(310598401, 1164996542),\n          c(607225278, 1323610764),\n          c(1426881987, 3590304994),\n          c(1925078388, 4068182383),\n          c(2162078206, 991336113),\n          c(2614888103, 633803317),\n          c(3248222580, 3479774868),\n          c(3835390401, 2666613458),\n          c(4022224774, 944711139),\n          c(264347078, 2341262773),\n          c(604807628, 2007800933),\n          c(770255983, 1495990901),\n          c(1249150122, 1856431235),\n          c(1555081692, 3175218132),\n          c(1996064986, 2198950837),\n          c(2554220882, 3999719339),\n          c(2821834349, 766784016),\n          c(2952996808, 2566594879),\n          c(3210313671, 3203337956),\n          c(3336571891, 1034457026),\n          c(3584528711, 2466948901),\n          c(113926993, 3758326383),\n          c(338241895, 168717936),\n          c(666307205, 1188179964),\n          c(773529912, 1546045734),\n          c(1294757372, 1522805485),\n          c(1396182291, 2643833823),\n          c(1695183700, 2343527390),\n          c(1986661051, 1014477480),\n          c(2177026350, 1206759142),\n          c(2456956037, 344077627),\n          c(2730485921, 1290863460),\n          c(2820302411, 3158454273),\n          c(3259730800, 3505952657),\n          c(3345764771, 106217008),\n          c(3516065817, 3606008344),\n          c(3600352804, 1432725776),\n          c(4094571909, 1467031594),\n          c(275423344, 851169720),\n          c(430227734, 3100823752),\n          c(506948616, 1363258195),\n          c(659060556, 3750685593),\n          c(883997877, 3785050280),\n          c(958139571, 3318307427),\n          c(1322822218, 3812723403),\n          c(1537002063, 2003034995),\n          c(1747873779, 3602036899),\n          c(1955562222, 1575990012),\n          c(2024104815, 1125592928),\n          c(2227730452, 2716904306),\n          c(2361852424, 442776044),\n          c(2428436474, 593698344),\n          c(2756734187, 3733110249),\n          c(3204031479, 2999351573),\n          c(3329325298, 3815920427),\n          c(3391569614, 3928383900),\n          c(3515267271, 566280711),\n          c(3940187606, 3454069534),\n          c(4118630271, 4000239992),\n          c(116418474, 1914138554),\n          c(174292421, 2731055270),\n          c(289380356, 3203993006),\n          c(460393269, 320620315),\n          c(685471733, 587496836),\n          c(852142971, 1086792851),\n          c(1017036298, 365543100),\n          c(1126000580, 2618297676),\n          c(1288033470, 3409855158),\n          c(1501505948, 4234509866),\n          c(1607167915, 987167468),\n          c(1816402316, 1246189591)\n        ], h = [];\n        (function() {\n          for (var g = 0; g < 80; g++)\n            h[g] = c();\n        })();\n        var p = u.SHA512 = o.extend({\n          _doReset: function() {\n            this._hash = new l.init([\n              new s.init(1779033703, 4089235720),\n              new s.init(3144134277, 2227873595),\n              new s.init(1013904242, 4271175723),\n              new s.init(2773480762, 1595750129),\n              new s.init(1359893119, 2917565137),\n              new s.init(2600822924, 725511199),\n              new s.init(528734635, 4215389547),\n              new s.init(1541459225, 327033209)\n            ]);\n          },\n          _doProcessBlock: function(g, _) {\n            for (var T = this._hash.words, A = T[0], w = T[1], O = T[2], R = T[3], $ = T[4], U = T[5], W = T[6], G = T[7], Z = A.high, j = A.low, P = w.high, d = w.low, x = O.high, C = O.low, M = R.high, D = R.low, z = $.high, Y = $.low, L = U.high, m = U.low, E = W.high, B = W.low, V = G.high, I = G.low, ne = Z, se = j, ce = P, oe = d, he = x, k = C, H = M, N = D, J = z, Q = Y, ee = L, S = m, y = E, v = B, b = V, F = I, K = 0; K < 80; K++) {\n              var te, de, pe = h[K];\n              if (K < 16)\n                de = pe.high = g[_ + K * 2] | 0, te = pe.low = g[_ + K * 2 + 1] | 0;\n              else {\n                var X = h[K - 15], ie = X.high, re = X.low, ae = (ie >>> 1 | re << 31) ^ (ie >>> 8 | re << 24) ^ ie >>> 7, me = (re >>> 1 | ie << 31) ^ (re >>> 8 | ie << 24) ^ (re >>> 7 | ie << 25), Te = h[K - 2], ve = Te.high, _e = Te.low, ye = (ve >>> 19 | _e << 13) ^ (ve << 3 | _e >>> 29) ^ ve >>> 6, we = (_e >>> 19 | ve << 13) ^ (_e << 3 | ve >>> 29) ^ (_e >>> 6 | ve << 26), Ae = h[K - 7], Pe = Ae.high, Se = Ae.low, Sr = h[K - 16], ze = Sr.high, qe = Sr.low;\n                te = me + Se, de = ae + Pe + (te >>> 0 < me >>> 0 ? 1 : 0), te = te + we, de = de + ye + (te >>> 0 < we >>> 0 ? 1 : 0), te = te + qe, de = de + ze + (te >>> 0 < qe >>> 0 ? 1 : 0), pe.high = de, pe.low = te;\n              }\n              var zt = J & ee ^ ~J & y, We = Q & S ^ ~Q & v, Ke = ne & ce ^ ne & he ^ ce & he, Pr = se & oe ^ se & k ^ oe & k, rt = (ne >>> 28 | se << 4) ^ (ne << 30 | se >>> 2) ^ (ne << 25 | se >>> 7), Ge = (se >>> 28 | ne << 4) ^ (se << 30 | ne >>> 2) ^ (se << 25 | ne >>> 7), zr = (J >>> 14 | Q << 18) ^ (J >>> 18 | Q << 14) ^ (J << 23 | Q >>> 9), Je = (Q >>> 14 | J << 18) ^ (Q >>> 18 | J << 14) ^ (Q << 23 | J >>> 9), Ye = f[K], qr = Ye.high, Qe = Ye.low, Be = F + Je, Ct = b + zr + (Be >>> 0 < F >>> 0 ? 1 : 0), Be = Be + We, Ct = Ct + zt + (Be >>> 0 < We >>> 0 ? 1 : 0), Be = Be + Qe, Ct = Ct + qr + (Be >>> 0 < Qe >>> 0 ? 1 : 0), Be = Be + te, Ct = Ct + de + (Be >>> 0 < te >>> 0 ? 1 : 0), et = Ge + Pr, nt = rt + Ke + (et >>> 0 < Ge >>> 0 ? 1 : 0);\n              b = y, F = v, y = ee, v = S, ee = J, S = Q, Q = N + Be | 0, J = H + Ct + (Q >>> 0 < N >>> 0 ? 1 : 0) | 0, H = he, N = k, he = ce, k = oe, ce = ne, oe = se, se = Be + et | 0, ne = Ct + nt + (se >>> 0 < Be >>> 0 ? 1 : 0) | 0;\n            }\n            j = A.low = j + se, A.high = Z + ne + (j >>> 0 < se >>> 0 ? 1 : 0), d = w.low = d + oe, w.high = P + ce + (d >>> 0 < oe >>> 0 ? 1 : 0), C = O.low = C + k, O.high = x + he + (C >>> 0 < k >>> 0 ? 1 : 0), D = R.low = D + N, R.high = M + H + (D >>> 0 < N >>> 0 ? 1 : 0), Y = $.low = Y + Q, $.high = z + J + (Y >>> 0 < Q >>> 0 ? 1 : 0), m = U.low = m + S, U.high = L + ee + (m >>> 0 < S >>> 0 ? 1 : 0), B = W.low = B + v, W.high = E + y + (B >>> 0 < v >>> 0 ? 1 : 0), I = G.low = I + F, G.high = V + b + (I >>> 0 < F >>> 0 ? 1 : 0);\n          },\n          _doFinalize: function() {\n            var g = this._data, _ = g.words, T = this._nDataBytes * 8, A = g.sigBytes * 8;\n            _[A >>> 5] |= 128 << 24 - A % 32, _[(A + 128 >>> 10 << 5) + 30] = Math.floor(T / 4294967296), _[(A + 128 >>> 10 << 5) + 31] = T, g.sigBytes = _.length * 4, this._process();\n            var w = this._hash.toX32();\n            return w;\n          },\n          clone: function() {\n            var g = o.clone.call(this);\n            return g._hash = this._hash.clone(), g;\n          },\n          blockSize: 1024 / 32\n        });\n        n.SHA512 = o._createHelper(p), n.HmacSHA512 = o._createHmacHelper(p);\n      }(), r.SHA512;\n    });\n  }(Dv)), Hi;\n}\nvar Wi = {}, Nv = {\n  get exports() {\n    return Wi;\n  },\n  set exports(t) {\n    Wi = t;\n  }\n}, kl;\nfunction Fv() {\n  return kl || (kl = 1, function(t, e) {\n    (function(r, n, i) {\n      t.exports = n(Ie(), jo(), kh());\n    })(ue, function(r) {\n      return function() {\n        var n = r, i = n.x64, o = i.Word, a = i.WordArray, s = n.algo, l = s.SHA512, u = s.SHA384 = l.extend({\n          _doReset: function() {\n            this._hash = new a.init([\n              new o.init(3418070365, 3238371032),\n              new o.init(1654270250, 914150663),\n              new o.init(2438529370, 812702999),\n              new o.init(355462360, 4144912697),\n              new o.init(1731405415, 4290775857),\n              new o.init(2394180231, 1750603025),\n              new o.init(3675008525, 1694076839),\n              new o.init(1203062813, 3204075428)\n            ]);\n          },\n          _doFinalize: function() {\n            var c = l._doFinalize.call(this);\n            return c.sigBytes -= 16, c;\n          }\n        });\n        n.SHA384 = l._createHelper(u), n.HmacSHA384 = l._createHmacHelper(u);\n      }(), r.SHA384;\n    });\n  }(Nv)), Wi;\n}\nvar zi = {}, Lv = {\n  get exports() {\n    return zi;\n  },\n  set exports(t) {\n    zi = t;\n  }\n}, Rl;\nfunction jv() {\n  return Rl || (Rl = 1, function(t, e) {\n    (function(r, n, i) {\n      t.exports = n(Ie(), jo());\n    })(ue, function(r) {\n      return function(n) {\n        var i = r, o = i.lib, a = o.WordArray, s = o.Hasher, l = i.x64, u = l.Word, c = i.algo, f = [], h = [], p = [];\n        (function() {\n          for (var T = 1, A = 0, w = 0; w < 24; w++) {\n            f[T + 5 * A] = (w + 1) * (w + 2) / 2 % 64;\n            var O = A % 5, R = (2 * T + 3 * A) % 5;\n            T = O, A = R;\n          }\n          for (var T = 0; T < 5; T++)\n            for (var A = 0; A < 5; A++)\n              h[T + 5 * A] = A + (2 * T + 3 * A) % 5 * 5;\n          for (var $ = 1, U = 0; U < 24; U++) {\n            for (var W = 0, G = 0, Z = 0; Z < 7; Z++) {\n              if ($ & 1) {\n                var j = (1 << Z) - 1;\n                j < 32 ? G ^= 1 << j : W ^= 1 << j - 32;\n              }\n              $ & 128 ? $ = $ << 1 ^ 113 : $ <<= 1;\n            }\n            p[U] = u.create(W, G);\n          }\n        })();\n        var g = [];\n        (function() {\n          for (var T = 0; T < 25; T++)\n            g[T] = u.create();\n        })();\n        var _ = c.SHA3 = s.extend({\n          /**\n           * Configuration options.\n           *\n           * @property {number} outputLength\n           *   The desired number of bits in the output hash.\n           *   Only values permitted are: 224, 256, 384, 512.\n           *   Default: 512\n           */\n          cfg: s.cfg.extend({\n            outputLength: 512\n          }),\n          _doReset: function() {\n            for (var T = this._state = [], A = 0; A < 25; A++)\n              T[A] = new u.init();\n            this.blockSize = (1600 - 2 * this.cfg.outputLength) / 32;\n          },\n          _doProcessBlock: function(T, A) {\n            for (var w = this._state, O = this.blockSize / 2, R = 0; R < O; R++) {\n              var $ = T[A + 2 * R], U = T[A + 2 * R + 1];\n              $ = ($ << 8 | $ >>> 24) & 16711935 | ($ << 24 | $ >>> 8) & 4278255360, U = (U << 8 | U >>> 24) & 16711935 | (U << 24 | U >>> 8) & 4278255360;\n              var W = w[R];\n              W.high ^= U, W.low ^= $;\n            }\n            for (var G = 0; G < 24; G++) {\n              for (var Z = 0; Z < 5; Z++) {\n                for (var j = 0, P = 0, d = 0; d < 5; d++) {\n                  var W = w[Z + 5 * d];\n                  j ^= W.high, P ^= W.low;\n                }\n                var x = g[Z];\n                x.high = j, x.low = P;\n              }\n              for (var Z = 0; Z < 5; Z++)\n                for (var C = g[(Z + 4) % 5], M = g[(Z + 1) % 5], D = M.high, z = M.low, j = C.high ^ (D << 1 | z >>> 31), P = C.low ^ (z << 1 | D >>> 31), d = 0; d < 5; d++) {\n                  var W = w[Z + 5 * d];\n                  W.high ^= j, W.low ^= P;\n                }\n              for (var Y = 1; Y < 25; Y++) {\n                var j, P, W = w[Y], L = W.high, m = W.low, E = f[Y];\n                E < 32 ? (j = L << E | m >>> 32 - E, P = m << E | L >>> 32 - E) : (j = m << E - 32 | L >>> 64 - E, P = L << E - 32 | m >>> 64 - E);\n                var B = g[h[Y]];\n                B.high = j, B.low = P;\n              }\n              var V = g[0], I = w[0];\n              V.high = I.high, V.low = I.low;\n              for (var Z = 0; Z < 5; Z++)\n                for (var d = 0; d < 5; d++) {\n                  var Y = Z + 5 * d, W = w[Y], ne = g[Y], se = g[(Z + 1) % 5 + 5 * d], ce = g[(Z + 2) % 5 + 5 * d];\n                  W.high = ne.high ^ ~se.high & ce.high, W.low = ne.low ^ ~se.low & ce.low;\n                }\n              var W = w[0], oe = p[G];\n              W.high ^= oe.high, W.low ^= oe.low;\n            }\n          },\n          _doFinalize: function() {\n            var T = this._data, A = T.words;\n            this._nDataBytes * 8;\n            var w = T.sigBytes * 8, O = this.blockSize * 32;\n            A[w >>> 5] |= 1 << 24 - w % 32, A[(n.ceil((w + 1) / O) * O >>> 5) - 1] |= 128, T.sigBytes = A.length * 4, this._process();\n            for (var R = this._state, $ = this.cfg.outputLength / 8, U = $ / 8, W = [], G = 0; G < U; G++) {\n              var Z = R[G], j = Z.high, P = Z.low;\n              j = (j << 8 | j >>> 24) & 16711935 | (j << 24 | j >>> 8) & 4278255360, P = (P << 8 | P >>> 24) & 16711935 | (P << 24 | P >>> 8) & 4278255360, W.push(P), W.push(j);\n            }\n            return new a.init(W, $);\n          },\n          clone: function() {\n            for (var T = s.clone.call(this), A = T._state = this._state.slice(0), w = 0; w < 25; w++)\n              A[w] = A[w].clone();\n            return T;\n          }\n        });\n        i.SHA3 = s._createHelper(_), i.HmacSHA3 = s._createHmacHelper(_);\n      }(Math), r.SHA3;\n    });\n  }(Lv)), zi;\n}\nvar qi = {}, Uv = {\n  get exports() {\n    return qi;\n  },\n  set exports(t) {\n    qi = t;\n  }\n}, Bl;\nfunction Vv() {\n  return Bl || (Bl = 1, function(t, e) {\n    (function(r, n) {\n      t.exports = n(Ie());\n    })(ue, function(r) {\n      /** @preserve\n      \t\t\t(c) 2012 by Cédric Mesnil. All rights reserved.\n      \n      \t\t\tRedistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n      \n      \t\t\t    - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n      \t\t\t    - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n      \n      \t\t\tTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n      \t\t\t*/\n      return function(n) {\n        var i = r, o = i.lib, a = o.WordArray, s = o.Hasher, l = i.algo, u = a.create([\n          0,\n          1,\n          2,\n          3,\n          4,\n          5,\n          6,\n          7,\n          8,\n          9,\n          10,\n          11,\n          12,\n          13,\n          14,\n          15,\n          7,\n          4,\n          13,\n          1,\n          10,\n          6,\n          15,\n          3,\n          12,\n          0,\n          9,\n          5,\n          2,\n          14,\n          11,\n          8,\n          3,\n          10,\n          14,\n          4,\n          9,\n          15,\n          8,\n          1,\n          2,\n          7,\n          0,\n          6,\n          13,\n          11,\n          5,\n          12,\n          1,\n          9,\n          11,\n          10,\n          0,\n          8,\n          12,\n          4,\n          13,\n          3,\n          7,\n          15,\n          14,\n          5,\n          6,\n          2,\n          4,\n          0,\n          5,\n          9,\n          7,\n          12,\n          2,\n          10,\n          14,\n          1,\n          3,\n          8,\n          11,\n          6,\n          15,\n          13\n        ]), c = a.create([\n          5,\n          14,\n          7,\n          0,\n          9,\n          2,\n          11,\n          4,\n          13,\n          6,\n          15,\n          8,\n          1,\n          10,\n          3,\n          12,\n          6,\n          11,\n          3,\n          7,\n          0,\n          13,\n          5,\n          10,\n          14,\n          15,\n          8,\n          12,\n          4,\n          9,\n          1,\n          2,\n          15,\n          5,\n          1,\n          3,\n          7,\n          14,\n          6,\n          9,\n          11,\n          8,\n          12,\n          2,\n          10,\n          0,\n          4,\n          13,\n          8,\n          6,\n          4,\n          1,\n          3,\n          11,\n          15,\n          0,\n          5,\n          12,\n          2,\n          13,\n          9,\n          7,\n          10,\n          14,\n          12,\n          15,\n          10,\n          4,\n          1,\n          5,\n          8,\n          7,\n          6,\n          2,\n          13,\n          14,\n          0,\n          3,\n          9,\n          11\n        ]), f = a.create([\n          11,\n          14,\n          15,\n          12,\n          5,\n          8,\n          7,\n          9,\n          11,\n          13,\n          14,\n          15,\n          6,\n          7,\n          9,\n          8,\n          7,\n          6,\n          8,\n          13,\n          11,\n          9,\n          7,\n          15,\n          7,\n          12,\n          15,\n          9,\n          11,\n          7,\n          13,\n          12,\n          11,\n          13,\n          6,\n          7,\n          14,\n          9,\n          13,\n          15,\n          14,\n          8,\n          13,\n          6,\n          5,\n          12,\n          7,\n          5,\n          11,\n          12,\n          14,\n          15,\n          14,\n          15,\n          9,\n          8,\n          9,\n          14,\n          5,\n          6,\n          8,\n          6,\n          5,\n          12,\n          9,\n          15,\n          5,\n          11,\n          6,\n          8,\n          13,\n          12,\n          5,\n          12,\n          13,\n          14,\n          11,\n          8,\n          5,\n          6\n        ]), h = a.create([\n          8,\n          9,\n          9,\n          11,\n          13,\n          15,\n          15,\n          5,\n          7,\n          7,\n          8,\n          11,\n          14,\n          14,\n          12,\n          6,\n          9,\n          13,\n          15,\n          7,\n          12,\n          8,\n          9,\n          11,\n          7,\n          7,\n          12,\n          7,\n          6,\n          15,\n          13,\n          11,\n          9,\n          7,\n          15,\n          11,\n          8,\n          6,\n          6,\n          14,\n          12,\n          13,\n          5,\n          14,\n          13,\n          13,\n          7,\n          5,\n          15,\n          5,\n          8,\n          11,\n          14,\n          14,\n          6,\n          14,\n          6,\n          9,\n          12,\n          9,\n          12,\n          5,\n          15,\n          8,\n          8,\n          5,\n          12,\n          9,\n          12,\n          5,\n          14,\n          6,\n          8,\n          13,\n          6,\n          5,\n          15,\n          13,\n          11,\n          11\n        ]), p = a.create([0, 1518500249, 1859775393, 2400959708, 2840853838]), g = a.create([1352829926, 1548603684, 1836072691, 2053994217, 0]), _ = l.RIPEMD160 = s.extend({\n          _doReset: function() {\n            this._hash = a.create([1732584193, 4023233417, 2562383102, 271733878, 3285377520]);\n          },\n          _doProcessBlock: function(U, W) {\n            for (var G = 0; G < 16; G++) {\n              var Z = W + G, j = U[Z];\n              U[Z] = (j << 8 | j >>> 24) & 16711935 | (j << 24 | j >>> 8) & 4278255360;\n            }\n            var P = this._hash.words, d = p.words, x = g.words, C = u.words, M = c.words, D = f.words, z = h.words, Y, L, m, E, B, V, I, ne, se, ce;\n            V = Y = P[0], I = L = P[1], ne = m = P[2], se = E = P[3], ce = B = P[4];\n            for (var oe, G = 0; G < 80; G += 1)\n              oe = Y + U[W + C[G]] | 0, G < 16 ? oe += T(L, m, E) + d[0] : G < 32 ? oe += A(L, m, E) + d[1] : G < 48 ? oe += w(L, m, E) + d[2] : G < 64 ? oe += O(L, m, E) + d[3] : oe += R(L, m, E) + d[4], oe = oe | 0, oe = $(oe, D[G]), oe = oe + B | 0, Y = B, B = E, E = $(m, 10), m = L, L = oe, oe = V + U[W + M[G]] | 0, G < 16 ? oe += R(I, ne, se) + x[0] : G < 32 ? oe += O(I, ne, se) + x[1] : G < 48 ? oe += w(I, ne, se) + x[2] : G < 64 ? oe += A(I, ne, se) + x[3] : oe += T(I, ne, se) + x[4], oe = oe | 0, oe = $(oe, z[G]), oe = oe + ce | 0, V = ce, ce = se, se = $(ne, 10), ne = I, I = oe;\n            oe = P[1] + m + se | 0, P[1] = P[2] + E + ce | 0, P[2] = P[3] + B + V | 0, P[3] = P[4] + Y + I | 0, P[4] = P[0] + L + ne | 0, P[0] = oe;\n          },\n          _doFinalize: function() {\n            var U = this._data, W = U.words, G = this._nDataBytes * 8, Z = U.sigBytes * 8;\n            W[Z >>> 5] |= 128 << 24 - Z % 32, W[(Z + 64 >>> 9 << 4) + 14] = (G << 8 | G >>> 24) & 16711935 | (G << 24 | G >>> 8) & 4278255360, U.sigBytes = (W.length + 1) * 4, this._process();\n            for (var j = this._hash, P = j.words, d = 0; d < 5; d++) {\n              var x = P[d];\n              P[d] = (x << 8 | x >>> 24) & 16711935 | (x << 24 | x >>> 8) & 4278255360;\n            }\n            return j;\n          },\n          clone: function() {\n            var U = s.clone.call(this);\n            return U._hash = this._hash.clone(), U;\n          }\n        });\n        function T(U, W, G) {\n          return U ^ W ^ G;\n        }\n        function A(U, W, G) {\n          return U & W | ~U & G;\n        }\n        function w(U, W, G) {\n          return (U | ~W) ^ G;\n        }\n        function O(U, W, G) {\n          return U & G | W & ~G;\n        }\n        function R(U, W, G) {\n          return U ^ (W | ~G);\n        }\n        function $(U, W) {\n          return U << W | U >>> 32 - W;\n        }\n        i.RIPEMD160 = s._createHelper(_), i.HmacRIPEMD160 = s._createHmacHelper(_);\n      }(), r.RIPEMD160;\n    });\n  }(Uv)), qi;\n}\nvar Ki = {}, $v = {\n  get exports() {\n    return Ki;\n  },\n  set exports(t) {\n    Ki = t;\n  }\n}, Il;\nfunction mc() {\n  return Il || (Il = 1, function(t, e) {\n    (function(r, n) {\n      t.exports = n(Ie());\n    })(ue, function(r) {\n      (function() {\n        var n = r, i = n.lib, o = i.Base, a = n.enc, s = a.Utf8, l = n.algo;\n        l.HMAC = o.extend({\n          /**\n           * Initializes a newly created HMAC.\n           *\n           * @param {Hasher} hasher The hash algorithm to use.\n           * @param {WordArray|string} key The secret key.\n           *\n           * @example\n           *\n           *     var hmacHasher = CryptoJS.algo.HMAC.create(CryptoJS.algo.SHA256, key);\n           */\n          init: function(u, c) {\n            u = this._hasher = new u.init(), typeof c == \"string\" && (c = s.parse(c));\n            var f = u.blockSize, h = f * 4;\n            c.sigBytes > h && (c = u.finalize(c)), c.clamp();\n            for (var p = this._oKey = c.clone(), g = this._iKey = c.clone(), _ = p.words, T = g.words, A = 0; A < f; A++)\n              _[A] ^= 1549556828, T[A] ^= 909522486;\n            p.sigBytes = g.sigBytes = h, this.reset();\n          },\n          /**\n           * Resets this HMAC to its initial state.\n           *\n           * @example\n           *\n           *     hmacHasher.reset();\n           */\n          reset: function() {\n            var u = this._hasher;\n            u.reset(), u.update(this._iKey);\n          },\n          /**\n           * Updates this HMAC with a message.\n           *\n           * @param {WordArray|string} messageUpdate The message to append.\n           *\n           * @return {HMAC} This HMAC instance.\n           *\n           * @example\n           *\n           *     hmacHasher.update('message');\n           *     hmacHasher.update(wordArray);\n           */\n          update: function(u) {\n            return this._hasher.update(u), this;\n          },\n          /**\n           * Finalizes the HMAC computation.\n           * Note that the finalize operation is effectively a destructive, read-once operation.\n           *\n           * @param {WordArray|string} messageUpdate (Optional) A final message update.\n           *\n           * @return {WordArray} The HMAC.\n           *\n           * @example\n           *\n           *     var hmac = hmacHasher.finalize();\n           *     var hmac = hmacHasher.finalize('message');\n           *     var hmac = hmacHasher.finalize(wordArray);\n           */\n          finalize: function(u) {\n            var c = this._hasher, f = c.finalize(u);\n            c.reset();\n            var h = c.finalize(this._oKey.clone().concat(f));\n            return h;\n          }\n        });\n      })();\n    });\n  }($v)), Ki;\n}\nvar Gi = {}, Hv = {\n  get exports() {\n    return Gi;\n  },\n  set exports(t) {\n    Gi = t;\n  }\n}, Dl;\nfunction Wv() {\n  return Dl || (Dl = 1, function(t, e) {\n    (function(r, n, i) {\n      t.exports = n(Ie(), yc(), mc());\n    })(ue, function(r) {\n      return function() {\n        var n = r, i = n.lib, o = i.Base, a = i.WordArray, s = n.algo, l = s.SHA1, u = s.HMAC, c = s.PBKDF2 = o.extend({\n          /**\n           * Configuration options.\n           *\n           * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)\n           * @property {Hasher} hasher The hasher to use. Default: SHA1\n           * @property {number} iterations The number of iterations to perform. Default: 1\n           */\n          cfg: o.extend({\n            keySize: 128 / 32,\n            hasher: l,\n            iterations: 1\n          }),\n          /**\n           * Initializes a newly created key derivation function.\n           *\n           * @param {Object} cfg (Optional) The configuration options to use for the derivation.\n           *\n           * @example\n           *\n           *     var kdf = CryptoJS.algo.PBKDF2.create();\n           *     var kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8 });\n           *     var kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8, iterations: 1000 });\n           */\n          init: function(f) {\n            this.cfg = this.cfg.extend(f);\n          },\n          /**\n           * Computes the Password-Based Key Derivation Function 2.\n           *\n           * @param {WordArray|string} password The password.\n           * @param {WordArray|string} salt A salt.\n           *\n           * @return {WordArray} The derived key.\n           *\n           * @example\n           *\n           *     var key = kdf.compute(password, salt);\n           */\n          compute: function(f, h) {\n            for (var p = this.cfg, g = u.create(p.hasher, f), _ = a.create(), T = a.create([1]), A = _.words, w = T.words, O = p.keySize, R = p.iterations; A.length < O; ) {\n              var $ = g.update(h).finalize(T);\n              g.reset();\n              for (var U = $.words, W = U.length, G = $, Z = 1; Z < R; Z++) {\n                G = g.finalize(G), g.reset();\n                for (var j = G.words, P = 0; P < W; P++)\n                  U[P] ^= j[P];\n              }\n              _.concat($), w[0]++;\n            }\n            return _.sigBytes = O * 4, _;\n          }\n        });\n        n.PBKDF2 = function(f, h, p) {\n          return c.create(p).compute(f, h);\n        };\n      }(), r.PBKDF2;\n    });\n  }(Hv)), Gi;\n}\nvar Yi = {}, zv = {\n  get exports() {\n    return Yi;\n  },\n  set exports(t) {\n    Yi = t;\n  }\n}, Nl;\nfunction $r() {\n  return Nl || (Nl = 1, function(t, e) {\n    (function(r, n, i) {\n      t.exports = n(Ie(), yc(), mc());\n    })(ue, function(r) {\n      return function() {\n        var n = r, i = n.lib, o = i.Base, a = i.WordArray, s = n.algo, l = s.MD5, u = s.EvpKDF = o.extend({\n          /**\n           * Configuration options.\n           *\n           * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)\n           * @property {Hasher} hasher The hash algorithm to use. Default: MD5\n           * @property {number} iterations The number of iterations to perform. Default: 1\n           */\n          cfg: o.extend({\n            keySize: 128 / 32,\n            hasher: l,\n            iterations: 1\n          }),\n          /**\n           * Initializes a newly created key derivation function.\n           *\n           * @param {Object} cfg (Optional) The configuration options to use for the derivation.\n           *\n           * @example\n           *\n           *     var kdf = CryptoJS.algo.EvpKDF.create();\n           *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8 });\n           *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8, iterations: 1000 });\n           */\n          init: function(c) {\n            this.cfg = this.cfg.extend(c);\n          },\n          /**\n           * Derives a key from a password.\n           *\n           * @param {WordArray|string} password The password.\n           * @param {WordArray|string} salt A salt.\n           *\n           * @return {WordArray} The derived key.\n           *\n           * @example\n           *\n           *     var key = kdf.compute(password, salt);\n           */\n          compute: function(c, f) {\n            for (var h, p = this.cfg, g = p.hasher.create(), _ = a.create(), T = _.words, A = p.keySize, w = p.iterations; T.length < A; ) {\n              h && g.update(h), h = g.update(c).finalize(f), g.reset();\n              for (var O = 1; O < w; O++)\n                h = g.finalize(h), g.reset();\n              _.concat(h);\n            }\n            return _.sigBytes = A * 4, _;\n          }\n        });\n        n.EvpKDF = function(c, f, h) {\n          return u.create(h).compute(c, f);\n        };\n      }(), r.EvpKDF;\n    });\n  }(zv)), Yi;\n}\nvar Zi = {}, qv = {\n  get exports() {\n    return Zi;\n  },\n  set exports(t) {\n    Zi = t;\n  }\n}, Fl;\nfunction gt() {\n  return Fl || (Fl = 1, function(t, e) {\n    (function(r, n, i) {\n      t.exports = n(Ie(), $r());\n    })(ue, function(r) {\n      r.lib.Cipher || function(n) {\n        var i = r, o = i.lib, a = o.Base, s = o.WordArray, l = o.BufferedBlockAlgorithm, u = i.enc;\n        u.Utf8;\n        var c = u.Base64, f = i.algo, h = f.EvpKDF, p = o.Cipher = l.extend({\n          /**\n           * Configuration options.\n           *\n           * @property {WordArray} iv The IV to use for this operation.\n           */\n          cfg: a.extend(),\n          /**\n           * Creates this cipher in encryption mode.\n           *\n           * @param {WordArray} key The key.\n           * @param {Object} cfg (Optional) The configuration options to use for this operation.\n           *\n           * @return {Cipher} A cipher instance.\n           *\n           * @static\n           *\n           * @example\n           *\n           *     var cipher = CryptoJS.algo.AES.createEncryptor(keyWordArray, { iv: ivWordArray });\n           */\n          createEncryptor: function(j, P) {\n            return this.create(this._ENC_XFORM_MODE, j, P);\n          },\n          /**\n           * Creates this cipher in decryption mode.\n           *\n           * @param {WordArray} key The key.\n           * @param {Object} cfg (Optional) The configuration options to use for this operation.\n           *\n           * @return {Cipher} A cipher instance.\n           *\n           * @static\n           *\n           * @example\n           *\n           *     var cipher = CryptoJS.algo.AES.createDecryptor(keyWordArray, { iv: ivWordArray });\n           */\n          createDecryptor: function(j, P) {\n            return this.create(this._DEC_XFORM_MODE, j, P);\n          },\n          /**\n           * Initializes a newly created cipher.\n           *\n           * @param {number} xformMode Either the encryption or decryption transormation mode constant.\n           * @param {WordArray} key The key.\n           * @param {Object} cfg (Optional) The configuration options to use for this operation.\n           *\n           * @example\n           *\n           *     var cipher = CryptoJS.algo.AES.create(CryptoJS.algo.AES._ENC_XFORM_MODE, keyWordArray, { iv: ivWordArray });\n           */\n          init: function(j, P, d) {\n            this.cfg = this.cfg.extend(d), this._xformMode = j, this._key = P, this.reset();\n          },\n          /**\n           * Resets this cipher to its initial state.\n           *\n           * @example\n           *\n           *     cipher.reset();\n           */\n          reset: function() {\n            l.reset.call(this), this._doReset();\n          },\n          /**\n           * Adds data to be encrypted or decrypted.\n           *\n           * @param {WordArray|string} dataUpdate The data to encrypt or decrypt.\n           *\n           * @return {WordArray} The data after processing.\n           *\n           * @example\n           *\n           *     var encrypted = cipher.process('data');\n           *     var encrypted = cipher.process(wordArray);\n           */\n          process: function(j) {\n            return this._append(j), this._process();\n          },\n          /**\n           * Finalizes the encryption or decryption process.\n           * Note that the finalize operation is effectively a destructive, read-once operation.\n           *\n           * @param {WordArray|string} dataUpdate The final data to encrypt or decrypt.\n           *\n           * @return {WordArray} The data after final processing.\n           *\n           * @example\n           *\n           *     var encrypted = cipher.finalize();\n           *     var encrypted = cipher.finalize('data');\n           *     var encrypted = cipher.finalize(wordArray);\n           */\n          finalize: function(j) {\n            j && this._append(j);\n            var P = this._doFinalize();\n            return P;\n          },\n          keySize: 128 / 32,\n          ivSize: 128 / 32,\n          _ENC_XFORM_MODE: 1,\n          _DEC_XFORM_MODE: 2,\n          /**\n           * Creates shortcut functions to a cipher's object interface.\n           *\n           * @param {Cipher} cipher The cipher to create a helper for.\n           *\n           * @return {Object} An object with encrypt and decrypt shortcut functions.\n           *\n           * @static\n           *\n           * @example\n           *\n           *     var AES = CryptoJS.lib.Cipher._createHelper(CryptoJS.algo.AES);\n           */\n          _createHelper: function() {\n            function j(P) {\n              return typeof P == \"string\" ? Z : U;\n            }\n            return function(P) {\n              return {\n                encrypt: function(d, x, C) {\n                  return j(x).encrypt(P, d, x, C);\n                },\n                decrypt: function(d, x, C) {\n                  return j(x).decrypt(P, d, x, C);\n                }\n              };\n            };\n          }()\n        });\n        o.StreamCipher = p.extend({\n          _doFinalize: function() {\n            var j = this._process(!0);\n            return j;\n          },\n          blockSize: 1\n        });\n        var g = i.mode = {}, _ = o.BlockCipherMode = a.extend({\n          /**\n           * Creates this mode for encryption.\n           *\n           * @param {Cipher} cipher A block cipher instance.\n           * @param {Array} iv The IV words.\n           *\n           * @static\n           *\n           * @example\n           *\n           *     var mode = CryptoJS.mode.CBC.createEncryptor(cipher, iv.words);\n           */\n          createEncryptor: function(j, P) {\n            return this.Encryptor.create(j, P);\n          },\n          /**\n           * Creates this mode for decryption.\n           *\n           * @param {Cipher} cipher A block cipher instance.\n           * @param {Array} iv The IV words.\n           *\n           * @static\n           *\n           * @example\n           *\n           *     var mode = CryptoJS.mode.CBC.createDecryptor(cipher, iv.words);\n           */\n          createDecryptor: function(j, P) {\n            return this.Decryptor.create(j, P);\n          },\n          /**\n           * Initializes a newly created mode.\n           *\n           * @param {Cipher} cipher A block cipher instance.\n           * @param {Array} iv The IV words.\n           *\n           * @example\n           *\n           *     var mode = CryptoJS.mode.CBC.Encryptor.create(cipher, iv.words);\n           */\n          init: function(j, P) {\n            this._cipher = j, this._iv = P;\n          }\n        }), T = g.CBC = function() {\n          var j = _.extend();\n          j.Encryptor = j.extend({\n            /**\n             * Processes the data block at offset.\n             *\n             * @param {Array} words The data words to operate on.\n             * @param {number} offset The offset where the block starts.\n             *\n             * @example\n             *\n             *     mode.processBlock(data.words, offset);\n             */\n            processBlock: function(d, x) {\n              var C = this._cipher, M = C.blockSize;\n              P.call(this, d, x, M), C.encryptBlock(d, x), this._prevBlock = d.slice(x, x + M);\n            }\n          }), j.Decryptor = j.extend({\n            /**\n             * Processes the data block at offset.\n             *\n             * @param {Array} words The data words to operate on.\n             * @param {number} offset The offset where the block starts.\n             *\n             * @example\n             *\n             *     mode.processBlock(data.words, offset);\n             */\n            processBlock: function(d, x) {\n              var C = this._cipher, M = C.blockSize, D = d.slice(x, x + M);\n              C.decryptBlock(d, x), P.call(this, d, x, M), this._prevBlock = D;\n            }\n          });\n          function P(d, x, C) {\n            var M, D = this._iv;\n            D ? (M = D, this._iv = n) : M = this._prevBlock;\n            for (var z = 0; z < C; z++)\n              d[x + z] ^= M[z];\n          }\n          return j;\n        }(), A = i.pad = {}, w = A.Pkcs7 = {\n          /**\n           * Pads data using the algorithm defined in PKCS #5/7.\n           *\n           * @param {WordArray} data The data to pad.\n           * @param {number} blockSize The multiple that the data should be padded to.\n           *\n           * @static\n           *\n           * @example\n           *\n           *     CryptoJS.pad.Pkcs7.pad(wordArray, 4);\n           */\n          pad: function(j, P) {\n            for (var d = P * 4, x = d - j.sigBytes % d, C = x << 24 | x << 16 | x << 8 | x, M = [], D = 0; D < x; D += 4)\n              M.push(C);\n            var z = s.create(M, x);\n            j.concat(z);\n          },\n          /**\n           * Unpads data that had been padded using the algorithm defined in PKCS #5/7.\n           *\n           * @param {WordArray} data The data to unpad.\n           *\n           * @static\n           *\n           * @example\n           *\n           *     CryptoJS.pad.Pkcs7.unpad(wordArray);\n           */\n          unpad: function(j) {\n            var P = j.words[j.sigBytes - 1 >>> 2] & 255;\n            j.sigBytes -= P;\n          }\n        };\n        o.BlockCipher = p.extend({\n          /**\n           * Configuration options.\n           *\n           * @property {Mode} mode The block mode to use. Default: CBC\n           * @property {Padding} padding The padding strategy to use. Default: Pkcs7\n           */\n          cfg: p.cfg.extend({\n            mode: T,\n            padding: w\n          }),\n          reset: function() {\n            var j;\n            p.reset.call(this);\n            var P = this.cfg, d = P.iv, x = P.mode;\n            this._xformMode == this._ENC_XFORM_MODE ? j = x.createEncryptor : (j = x.createDecryptor, this._minBufferSize = 1), this._mode && this._mode.__creator == j ? this._mode.init(this, d && d.words) : (this._mode = j.call(x, this, d && d.words), this._mode.__creator = j);\n          },\n          _doProcessBlock: function(j, P) {\n            this._mode.processBlock(j, P);\n          },\n          _doFinalize: function() {\n            var j, P = this.cfg.padding;\n            return this._xformMode == this._ENC_XFORM_MODE ? (P.pad(this._data, this.blockSize), j = this._process(!0)) : (j = this._process(!0), P.unpad(j)), j;\n          },\n          blockSize: 128 / 32\n        });\n        var O = o.CipherParams = a.extend({\n          /**\n           * Initializes a newly created cipher params object.\n           *\n           * @param {Object} cipherParams An object with any of the possible cipher parameters.\n           *\n           * @example\n           *\n           *     var cipherParams = CryptoJS.lib.CipherParams.create({\n           *         ciphertext: ciphertextWordArray,\n           *         key: keyWordArray,\n           *         iv: ivWordArray,\n           *         salt: saltWordArray,\n           *         algorithm: CryptoJS.algo.AES,\n           *         mode: CryptoJS.mode.CBC,\n           *         padding: CryptoJS.pad.PKCS7,\n           *         blockSize: 4,\n           *         formatter: CryptoJS.format.OpenSSL\n           *     });\n           */\n          init: function(j) {\n            this.mixIn(j);\n          },\n          /**\n           * Converts this cipher params object to a string.\n           *\n           * @param {Format} formatter (Optional) The formatting strategy to use.\n           *\n           * @return {string} The stringified cipher params.\n           *\n           * @throws Error If neither the formatter nor the default formatter is set.\n           *\n           * @example\n           *\n           *     var string = cipherParams + '';\n           *     var string = cipherParams.toString();\n           *     var string = cipherParams.toString(CryptoJS.format.OpenSSL);\n           */\n          toString: function(j) {\n            return (j || this.formatter).stringify(this);\n          }\n        }), R = i.format = {}, $ = R.OpenSSL = {\n          /**\n           * Converts a cipher params object to an OpenSSL-compatible string.\n           *\n           * @param {CipherParams} cipherParams The cipher params object.\n           *\n           * @return {string} The OpenSSL-compatible string.\n           *\n           * @static\n           *\n           * @example\n           *\n           *     var openSSLString = CryptoJS.format.OpenSSL.stringify(cipherParams);\n           */\n          stringify: function(j) {\n            var P, d = j.ciphertext, x = j.salt;\n            return x ? P = s.create([1398893684, 1701076831]).concat(x).concat(d) : P = d, P.toString(c);\n          },\n          /**\n           * Converts an OpenSSL-compatible string to a cipher params object.\n           *\n           * @param {string} openSSLStr The OpenSSL-compatible string.\n           *\n           * @return {CipherParams} The cipher params object.\n           *\n           * @static\n           *\n           * @example\n           *\n           *     var cipherParams = CryptoJS.format.OpenSSL.parse(openSSLString);\n           */\n          parse: function(j) {\n            var P, d = c.parse(j), x = d.words;\n            return x[0] == 1398893684 && x[1] == 1701076831 && (P = s.create(x.slice(2, 4)), x.splice(0, 4), d.sigBytes -= 16), O.create({ ciphertext: d, salt: P });\n          }\n        }, U = o.SerializableCipher = a.extend({\n          /**\n           * Configuration options.\n           *\n           * @property {Formatter} format The formatting strategy to convert cipher param objects to and from a string. Default: OpenSSL\n           */\n          cfg: a.extend({\n            format: $\n          }),\n          /**\n           * Encrypts a message.\n           *\n           * @param {Cipher} cipher The cipher algorithm to use.\n           * @param {WordArray|string} message The message to encrypt.\n           * @param {WordArray} key The key.\n           * @param {Object} cfg (Optional) The configuration options to use for this operation.\n           *\n           * @return {CipherParams} A cipher params object.\n           *\n           * @static\n           *\n           * @example\n           *\n           *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key);\n           *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv });\n           *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv, format: CryptoJS.format.OpenSSL });\n           */\n          encrypt: function(j, P, d, x) {\n            x = this.cfg.extend(x);\n            var C = j.createEncryptor(d, x), M = C.finalize(P), D = C.cfg;\n            return O.create({\n              ciphertext: M,\n              key: d,\n              iv: D.iv,\n              algorithm: j,\n              mode: D.mode,\n              padding: D.padding,\n              blockSize: j.blockSize,\n              formatter: x.format\n            });\n          },\n          /**\n           * Decrypts serialized ciphertext.\n           *\n           * @param {Cipher} cipher The cipher algorithm to use.\n           * @param {CipherParams|string} ciphertext The ciphertext to decrypt.\n           * @param {WordArray} key The key.\n           * @param {Object} cfg (Optional) The configuration options to use for this operation.\n           *\n           * @return {WordArray} The plaintext.\n           *\n           * @static\n           *\n           * @example\n           *\n           *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, key, { iv: iv, format: CryptoJS.format.OpenSSL });\n           *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, key, { iv: iv, format: CryptoJS.format.OpenSSL });\n           */\n          decrypt: function(j, P, d, x) {\n            x = this.cfg.extend(x), P = this._parse(P, x.format);\n            var C = j.createDecryptor(d, x).finalize(P.ciphertext);\n            return C;\n          },\n          /**\n           * Converts serialized ciphertext to CipherParams,\n           * else assumed CipherParams already and returns ciphertext unchanged.\n           *\n           * @param {CipherParams|string} ciphertext The ciphertext.\n           * @param {Formatter} format The formatting strategy to use to parse serialized ciphertext.\n           *\n           * @return {CipherParams} The unserialized ciphertext.\n           *\n           * @static\n           *\n           * @example\n           *\n           *     var ciphertextParams = CryptoJS.lib.SerializableCipher._parse(ciphertextStringOrParams, format);\n           */\n          _parse: function(j, P) {\n            return typeof j == \"string\" ? P.parse(j, this) : j;\n          }\n        }), W = i.kdf = {}, G = W.OpenSSL = {\n          /**\n           * Derives a key and IV from a password.\n           *\n           * @param {string} password The password to derive from.\n           * @param {number} keySize The size in words of the key to generate.\n           * @param {number} ivSize The size in words of the IV to generate.\n           * @param {WordArray|string} salt (Optional) A 64-bit salt to use. If omitted, a salt will be generated randomly.\n           *\n           * @return {CipherParams} A cipher params object with the key, IV, and salt.\n           *\n           * @static\n           *\n           * @example\n           *\n           *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32);\n           *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32, 'saltsalt');\n           */\n          execute: function(j, P, d, x) {\n            x || (x = s.random(64 / 8));\n            var C = h.create({ keySize: P + d }).compute(j, x), M = s.create(C.words.slice(P), d * 4);\n            return C.sigBytes = P * 4, O.create({ key: C, iv: M, salt: x });\n          }\n        }, Z = o.PasswordBasedCipher = U.extend({\n          /**\n           * Configuration options.\n           *\n           * @property {KDF} kdf The key derivation function to use to generate a key and IV from a password. Default: OpenSSL\n           */\n          cfg: U.cfg.extend({\n            kdf: G\n          }),\n          /**\n           * Encrypts a message using a password.\n           *\n           * @param {Cipher} cipher The cipher algorithm to use.\n           * @param {WordArray|string} message The message to encrypt.\n           * @param {string} password The password.\n           * @param {Object} cfg (Optional) The configuration options to use for this operation.\n           *\n           * @return {CipherParams} A cipher params object.\n           *\n           * @static\n           *\n           * @example\n           *\n           *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password');\n           *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password', { format: CryptoJS.format.OpenSSL });\n           */\n          encrypt: function(j, P, d, x) {\n            x = this.cfg.extend(x);\n            var C = x.kdf.execute(d, j.keySize, j.ivSize);\n            x.iv = C.iv;\n            var M = U.encrypt.call(this, j, P, C.key, x);\n            return M.mixIn(C), M;\n          },\n          /**\n           * Decrypts serialized ciphertext using a password.\n           *\n           * @param {Cipher} cipher The cipher algorithm to use.\n           * @param {CipherParams|string} ciphertext The ciphertext to decrypt.\n           * @param {string} password The password.\n           * @param {Object} cfg (Optional) The configuration options to use for this operation.\n           *\n           * @return {WordArray} The plaintext.\n           *\n           * @static\n           *\n           * @example\n           *\n           *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, 'password', { format: CryptoJS.format.OpenSSL });\n           *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, 'password', { format: CryptoJS.format.OpenSSL });\n           */\n          decrypt: function(j, P, d, x) {\n            x = this.cfg.extend(x), P = this._parse(P, x.format);\n            var C = x.kdf.execute(d, j.keySize, j.ivSize, P.salt);\n            x.iv = C.iv;\n            var M = U.decrypt.call(this, j, P, C.key, x);\n            return M;\n          }\n        });\n      }();\n    });\n  }(qv)), Zi;\n}\nvar Xi = {}, Kv = {\n  get exports() {\n    return Xi;\n  },\n  set exports(t) {\n    Xi = t;\n  }\n}, Ll;\nfunction Gv() {\n  return Ll || (Ll = 1, function(t, e) {\n    (function(r, n, i) {\n      t.exports = n(Ie(), gt());\n    })(ue, function(r) {\n      return r.mode.CFB = function() {\n        var n = r.lib.BlockCipherMode.extend();\n        n.Encryptor = n.extend({\n          processBlock: function(o, a) {\n            var s = this._cipher, l = s.blockSize;\n            i.call(this, o, a, l, s), this._prevBlock = o.slice(a, a + l);\n          }\n        }), n.Decryptor = n.extend({\n          processBlock: function(o, a) {\n            var s = this._cipher, l = s.blockSize, u = o.slice(a, a + l);\n            i.call(this, o, a, l, s), this._prevBlock = u;\n          }\n        });\n        function i(o, a, s, l) {\n          var u, c = this._iv;\n          c ? (u = c.slice(0), this._iv = void 0) : u = this._prevBlock, l.encryptBlock(u, 0);\n          for (var f = 0; f < s; f++)\n            o[a + f] ^= u[f];\n        }\n        return n;\n      }(), r.mode.CFB;\n    });\n  }(Kv)), Xi;\n}\nvar Ji = {}, Yv = {\n  get exports() {\n    return Ji;\n  },\n  set exports(t) {\n    Ji = t;\n  }\n}, jl;\nfunction Zv() {\n  return jl || (jl = 1, function(t, e) {\n    (function(r, n, i) {\n      t.exports = n(Ie(), gt());\n    })(ue, function(r) {\n      return r.mode.CTR = function() {\n        var n = r.lib.BlockCipherMode.extend(), i = n.Encryptor = n.extend({\n          processBlock: function(o, a) {\n            var s = this._cipher, l = s.blockSize, u = this._iv, c = this._counter;\n            u && (c = this._counter = u.slice(0), this._iv = void 0);\n            var f = c.slice(0);\n            s.encryptBlock(f, 0), c[l - 1] = c[l - 1] + 1 | 0;\n            for (var h = 0; h < l; h++)\n              o[a + h] ^= f[h];\n          }\n        });\n        return n.Decryptor = i, n;\n      }(), r.mode.CTR;\n    });\n  }(Yv)), Ji;\n}\nvar Qi = {}, Xv = {\n  get exports() {\n    return Qi;\n  },\n  set exports(t) {\n    Qi = t;\n  }\n}, Ul;\nfunction Jv() {\n  return Ul || (Ul = 1, function(t, e) {\n    (function(r, n, i) {\n      t.exports = n(Ie(), gt());\n    })(ue, function(r) {\n      /** @preserve\n       * Counter block mode compatible with  Dr Brian Gladman fileenc.c\n       * derived from CryptoJS.mode.CTR\n       * Jan Hruby jhruby.web@gmail.com\n       */\n      return r.mode.CTRGladman = function() {\n        var n = r.lib.BlockCipherMode.extend();\n        function i(s) {\n          if ((s >> 24 & 255) === 255) {\n            var l = s >> 16 & 255, u = s >> 8 & 255, c = s & 255;\n            l === 255 ? (l = 0, u === 255 ? (u = 0, c === 255 ? c = 0 : ++c) : ++u) : ++l, s = 0, s += l << 16, s += u << 8, s += c;\n          } else\n            s += 1 << 24;\n          return s;\n        }\n        function o(s) {\n          return (s[0] = i(s[0])) === 0 && (s[1] = i(s[1])), s;\n        }\n        var a = n.Encryptor = n.extend({\n          processBlock: function(s, l) {\n            var u = this._cipher, c = u.blockSize, f = this._iv, h = this._counter;\n            f && (h = this._counter = f.slice(0), this._iv = void 0), o(h);\n            var p = h.slice(0);\n            u.encryptBlock(p, 0);\n            for (var g = 0; g < c; g++)\n              s[l + g] ^= p[g];\n          }\n        });\n        return n.Decryptor = a, n;\n      }(), r.mode.CTRGladman;\n    });\n  }(Xv)), Qi;\n}\nvar eo = {}, Qv = {\n  get exports() {\n    return eo;\n  },\n  set exports(t) {\n    eo = t;\n  }\n}, Vl;\nfunction eg() {\n  return Vl || (Vl = 1, function(t, e) {\n    (function(r, n, i) {\n      t.exports = n(Ie(), gt());\n    })(ue, function(r) {\n      return r.mode.OFB = function() {\n        var n = r.lib.BlockCipherMode.extend(), i = n.Encryptor = n.extend({\n          processBlock: function(o, a) {\n            var s = this._cipher, l = s.blockSize, u = this._iv, c = this._keystream;\n            u && (c = this._keystream = u.slice(0), this._iv = void 0), s.encryptBlock(c, 0);\n            for (var f = 0; f < l; f++)\n              o[a + f] ^= c[f];\n          }\n        });\n        return n.Decryptor = i, n;\n      }(), r.mode.OFB;\n    });\n  }(Qv)), eo;\n}\nvar to = {}, tg = {\n  get exports() {\n    return to;\n  },\n  set exports(t) {\n    to = t;\n  }\n}, $l;\nfunction rg() {\n  return $l || ($l = 1, function(t, e) {\n    (function(r, n, i) {\n      t.exports = n(Ie(), gt());\n    })(ue, function(r) {\n      return r.mode.ECB = function() {\n        var n = r.lib.BlockCipherMode.extend();\n        return n.Encryptor = n.extend({\n          processBlock: function(i, o) {\n            this._cipher.encryptBlock(i, o);\n          }\n        }), n.Decryptor = n.extend({\n          processBlock: function(i, o) {\n            this._cipher.decryptBlock(i, o);\n          }\n        }), n;\n      }(), r.mode.ECB;\n    });\n  }(tg)), to;\n}\nvar ro = {}, ng = {\n  get exports() {\n    return ro;\n  },\n  set exports(t) {\n    ro = t;\n  }\n}, Hl;\nfunction ig() {\n  return Hl || (Hl = 1, function(t, e) {\n    (function(r, n, i) {\n      t.exports = n(Ie(), gt());\n    })(ue, function(r) {\n      return r.pad.AnsiX923 = {\n        pad: function(n, i) {\n          var o = n.sigBytes, a = i * 4, s = a - o % a, l = o + s - 1;\n          n.clamp(), n.words[l >>> 2] |= s << 24 - l % 4 * 8, n.sigBytes += s;\n        },\n        unpad: function(n) {\n          var i = n.words[n.sigBytes - 1 >>> 2] & 255;\n          n.sigBytes -= i;\n        }\n      }, r.pad.Ansix923;\n    });\n  }(ng)), ro;\n}\nvar no = {}, og = {\n  get exports() {\n    return no;\n  },\n  set exports(t) {\n    no = t;\n  }\n}, Wl;\nfunction sg() {\n  return Wl || (Wl = 1, function(t, e) {\n    (function(r, n, i) {\n      t.exports = n(Ie(), gt());\n    })(ue, function(r) {\n      return r.pad.Iso10126 = {\n        pad: function(n, i) {\n          var o = i * 4, a = o - n.sigBytes % o;\n          n.concat(r.lib.WordArray.random(a - 1)).concat(r.lib.WordArray.create([a << 24], 1));\n        },\n        unpad: function(n) {\n          var i = n.words[n.sigBytes - 1 >>> 2] & 255;\n          n.sigBytes -= i;\n        }\n      }, r.pad.Iso10126;\n    });\n  }(og)), no;\n}\nvar io = {}, ag = {\n  get exports() {\n    return io;\n  },\n  set exports(t) {\n    io = t;\n  }\n}, zl;\nfunction cg() {\n  return zl || (zl = 1, function(t, e) {\n    (function(r, n, i) {\n      t.exports = n(Ie(), gt());\n    })(ue, function(r) {\n      return r.pad.Iso97971 = {\n        pad: function(n, i) {\n          n.concat(r.lib.WordArray.create([2147483648], 1)), r.pad.ZeroPadding.pad(n, i);\n        },\n        unpad: function(n) {\n          r.pad.ZeroPadding.unpad(n), n.sigBytes--;\n        }\n      }, r.pad.Iso97971;\n    });\n  }(ag)), io;\n}\nvar oo = {}, ug = {\n  get exports() {\n    return oo;\n  },\n  set exports(t) {\n    oo = t;\n  }\n}, ql;\nfunction lg() {\n  return ql || (ql = 1, function(t, e) {\n    (function(r, n, i) {\n      t.exports = n(Ie(), gt());\n    })(ue, function(r) {\n      return r.pad.ZeroPadding = {\n        pad: function(n, i) {\n          var o = i * 4;\n          n.clamp(), n.sigBytes += o - (n.sigBytes % o || o);\n        },\n        unpad: function(n) {\n          for (var i = n.words, o = n.sigBytes - 1, o = n.sigBytes - 1; o >= 0; o--)\n            if (i[o >>> 2] >>> 24 - o % 4 * 8 & 255) {\n              n.sigBytes = o + 1;\n              break;\n            }\n        }\n      }, r.pad.ZeroPadding;\n    });\n  }(ug)), oo;\n}\nvar so = {}, fg = {\n  get exports() {\n    return so;\n  },\n  set exports(t) {\n    so = t;\n  }\n}, Kl;\nfunction hg() {\n  return Kl || (Kl = 1, function(t, e) {\n    (function(r, n, i) {\n      t.exports = n(Ie(), gt());\n    })(ue, function(r) {\n      return r.pad.NoPadding = {\n        pad: function() {\n        },\n        unpad: function() {\n        }\n      }, r.pad.NoPadding;\n    });\n  }(fg)), so;\n}\nvar ao = {}, dg = {\n  get exports() {\n    return ao;\n  },\n  set exports(t) {\n    ao = t;\n  }\n}, Gl;\nfunction pg() {\n  return Gl || (Gl = 1, function(t, e) {\n    (function(r, n, i) {\n      t.exports = n(Ie(), gt());\n    })(ue, function(r) {\n      return function(n) {\n        var i = r, o = i.lib, a = o.CipherParams, s = i.enc, l = s.Hex, u = i.format;\n        u.Hex = {\n          /**\n           * Converts the ciphertext of a cipher params object to a hexadecimally encoded string.\n           *\n           * @param {CipherParams} cipherParams The cipher params object.\n           *\n           * @return {string} The hexadecimally encoded string.\n           *\n           * @static\n           *\n           * @example\n           *\n           *     var hexString = CryptoJS.format.Hex.stringify(cipherParams);\n           */\n          stringify: function(c) {\n            return c.ciphertext.toString(l);\n          },\n          /**\n           * Converts a hexadecimally encoded ciphertext string to a cipher params object.\n           *\n           * @param {string} input The hexadecimally encoded string.\n           *\n           * @return {CipherParams} The cipher params object.\n           *\n           * @static\n           *\n           * @example\n           *\n           *     var cipherParams = CryptoJS.format.Hex.parse(hexString);\n           */\n          parse: function(c) {\n            var f = l.parse(c);\n            return a.create({ ciphertext: f });\n          }\n        };\n      }(), r.format.Hex;\n    });\n  }(dg)), ao;\n}\nvar co = {}, yg = {\n  get exports() {\n    return co;\n  },\n  set exports(t) {\n    co = t;\n  }\n}, Yl;\nfunction mg() {\n  return Yl || (Yl = 1, function(t, e) {\n    (function(r, n, i) {\n      t.exports = n(Ie(), xn(), wn(), $r(), gt());\n    })(ue, function(r) {\n      return function() {\n        var n = r, i = n.lib, o = i.BlockCipher, a = n.algo, s = [], l = [], u = [], c = [], f = [], h = [], p = [], g = [], _ = [], T = [];\n        (function() {\n          for (var O = [], R = 0; R < 256; R++)\n            R < 128 ? O[R] = R << 1 : O[R] = R << 1 ^ 283;\n          for (var $ = 0, U = 0, R = 0; R < 256; R++) {\n            var W = U ^ U << 1 ^ U << 2 ^ U << 3 ^ U << 4;\n            W = W >>> 8 ^ W & 255 ^ 99, s[$] = W, l[W] = $;\n            var G = O[$], Z = O[G], j = O[Z], P = O[W] * 257 ^ W * 16843008;\n            u[$] = P << 24 | P >>> 8, c[$] = P << 16 | P >>> 16, f[$] = P << 8 | P >>> 24, h[$] = P;\n            var P = j * 16843009 ^ Z * 65537 ^ G * 257 ^ $ * 16843008;\n            p[W] = P << 24 | P >>> 8, g[W] = P << 16 | P >>> 16, _[W] = P << 8 | P >>> 24, T[W] = P, $ ? ($ = G ^ O[O[O[j ^ G]]], U ^= O[O[U]]) : $ = U = 1;\n          }\n        })();\n        var A = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54], w = a.AES = o.extend({\n          _doReset: function() {\n            var O;\n            if (!(this._nRounds && this._keyPriorReset === this._key)) {\n              for (var R = this._keyPriorReset = this._key, $ = R.words, U = R.sigBytes / 4, W = this._nRounds = U + 6, G = (W + 1) * 4, Z = this._keySchedule = [], j = 0; j < G; j++)\n                j < U ? Z[j] = $[j] : (O = Z[j - 1], j % U ? U > 6 && j % U == 4 && (O = s[O >>> 24] << 24 | s[O >>> 16 & 255] << 16 | s[O >>> 8 & 255] << 8 | s[O & 255]) : (O = O << 8 | O >>> 24, O = s[O >>> 24] << 24 | s[O >>> 16 & 255] << 16 | s[O >>> 8 & 255] << 8 | s[O & 255], O ^= A[j / U | 0] << 24), Z[j] = Z[j - U] ^ O);\n              for (var P = this._invKeySchedule = [], d = 0; d < G; d++) {\n                var j = G - d;\n                if (d % 4)\n                  var O = Z[j];\n                else\n                  var O = Z[j - 4];\n                d < 4 || j <= 4 ? P[d] = O : P[d] = p[s[O >>> 24]] ^ g[s[O >>> 16 & 255]] ^ _[s[O >>> 8 & 255]] ^ T[s[O & 255]];\n              }\n            }\n          },\n          encryptBlock: function(O, R) {\n            this._doCryptBlock(O, R, this._keySchedule, u, c, f, h, s);\n          },\n          decryptBlock: function(O, R) {\n            var $ = O[R + 1];\n            O[R + 1] = O[R + 3], O[R + 3] = $, this._doCryptBlock(O, R, this._invKeySchedule, p, g, _, T, l);\n            var $ = O[R + 1];\n            O[R + 1] = O[R + 3], O[R + 3] = $;\n          },\n          _doCryptBlock: function(O, R, $, U, W, G, Z, j) {\n            for (var P = this._nRounds, d = O[R] ^ $[0], x = O[R + 1] ^ $[1], C = O[R + 2] ^ $[2], M = O[R + 3] ^ $[3], D = 4, z = 1; z < P; z++) {\n              var Y = U[d >>> 24] ^ W[x >>> 16 & 255] ^ G[C >>> 8 & 255] ^ Z[M & 255] ^ $[D++], L = U[x >>> 24] ^ W[C >>> 16 & 255] ^ G[M >>> 8 & 255] ^ Z[d & 255] ^ $[D++], m = U[C >>> 24] ^ W[M >>> 16 & 255] ^ G[d >>> 8 & 255] ^ Z[x & 255] ^ $[D++], E = U[M >>> 24] ^ W[d >>> 16 & 255] ^ G[x >>> 8 & 255] ^ Z[C & 255] ^ $[D++];\n              d = Y, x = L, C = m, M = E;\n            }\n            var Y = (j[d >>> 24] << 24 | j[x >>> 16 & 255] << 16 | j[C >>> 8 & 255] << 8 | j[M & 255]) ^ $[D++], L = (j[x >>> 24] << 24 | j[C >>> 16 & 255] << 16 | j[M >>> 8 & 255] << 8 | j[d & 255]) ^ $[D++], m = (j[C >>> 24] << 24 | j[M >>> 16 & 255] << 16 | j[d >>> 8 & 255] << 8 | j[x & 255]) ^ $[D++], E = (j[M >>> 24] << 24 | j[d >>> 16 & 255] << 16 | j[x >>> 8 & 255] << 8 | j[C & 255]) ^ $[D++];\n            O[R] = Y, O[R + 1] = L, O[R + 2] = m, O[R + 3] = E;\n          },\n          keySize: 256 / 32\n        });\n        n.AES = o._createHelper(w);\n      }(), r.AES;\n    });\n  }(yg)), co;\n}\nvar uo = {}, vg = {\n  get exports() {\n    return uo;\n  },\n  set exports(t) {\n    uo = t;\n  }\n}, Zl;\nfunction gg() {\n  return Zl || (Zl = 1, function(t, e) {\n    (function(r, n, i) {\n      t.exports = n(Ie(), xn(), wn(), $r(), gt());\n    })(ue, function(r) {\n      return function() {\n        var n = r, i = n.lib, o = i.WordArray, a = i.BlockCipher, s = n.algo, l = [\n          57,\n          49,\n          41,\n          33,\n          25,\n          17,\n          9,\n          1,\n          58,\n          50,\n          42,\n          34,\n          26,\n          18,\n          10,\n          2,\n          59,\n          51,\n          43,\n          35,\n          27,\n          19,\n          11,\n          3,\n          60,\n          52,\n          44,\n          36,\n          63,\n          55,\n          47,\n          39,\n          31,\n          23,\n          15,\n          7,\n          62,\n          54,\n          46,\n          38,\n          30,\n          22,\n          14,\n          6,\n          61,\n          53,\n          45,\n          37,\n          29,\n          21,\n          13,\n          5,\n          28,\n          20,\n          12,\n          4\n        ], u = [\n          14,\n          17,\n          11,\n          24,\n          1,\n          5,\n          3,\n          28,\n          15,\n          6,\n          21,\n          10,\n          23,\n          19,\n          12,\n          4,\n          26,\n          8,\n          16,\n          7,\n          27,\n          20,\n          13,\n          2,\n          41,\n          52,\n          31,\n          37,\n          47,\n          55,\n          30,\n          40,\n          51,\n          45,\n          33,\n          48,\n          44,\n          49,\n          39,\n          56,\n          34,\n          53,\n          46,\n          42,\n          50,\n          36,\n          29,\n          32\n        ], c = [1, 2, 4, 6, 8, 10, 12, 14, 15, 17, 19, 21, 23, 25, 27, 28], f = [\n          {\n            0: 8421888,\n            268435456: 32768,\n            536870912: 8421378,\n            805306368: 2,\n            1073741824: 512,\n            1342177280: 8421890,\n            1610612736: 8389122,\n            1879048192: 8388608,\n            2147483648: 514,\n            2415919104: 8389120,\n            2684354560: 33280,\n            2952790016: 8421376,\n            3221225472: 32770,\n            3489660928: 8388610,\n            3758096384: 0,\n            4026531840: 33282,\n            134217728: 0,\n            402653184: 8421890,\n            671088640: 33282,\n            939524096: 32768,\n            1207959552: 8421888,\n            1476395008: 512,\n            1744830464: 8421378,\n            2013265920: 2,\n            2281701376: 8389120,\n            2550136832: 33280,\n            2818572288: 8421376,\n            3087007744: 8389122,\n            3355443200: 8388610,\n            3623878656: 32770,\n            3892314112: 514,\n            4160749568: 8388608,\n            1: 32768,\n            268435457: 2,\n            536870913: 8421888,\n            805306369: 8388608,\n            1073741825: 8421378,\n            1342177281: 33280,\n            1610612737: 512,\n            1879048193: 8389122,\n            2147483649: 8421890,\n            2415919105: 8421376,\n            2684354561: 8388610,\n            2952790017: 33282,\n            3221225473: 514,\n            3489660929: 8389120,\n            3758096385: 32770,\n            4026531841: 0,\n            134217729: 8421890,\n            402653185: 8421376,\n            671088641: 8388608,\n            939524097: 512,\n            1207959553: 32768,\n            1476395009: 8388610,\n            1744830465: 2,\n            2013265921: 33282,\n            2281701377: 32770,\n            2550136833: 8389122,\n            2818572289: 514,\n            3087007745: 8421888,\n            3355443201: 8389120,\n            3623878657: 0,\n            3892314113: 33280,\n            4160749569: 8421378\n          },\n          {\n            0: 1074282512,\n            16777216: 16384,\n            33554432: 524288,\n            50331648: 1074266128,\n            67108864: 1073741840,\n            83886080: 1074282496,\n            100663296: 1073758208,\n            117440512: 16,\n            134217728: 540672,\n            150994944: 1073758224,\n            167772160: 1073741824,\n            184549376: 540688,\n            201326592: 524304,\n            218103808: 0,\n            234881024: 16400,\n            251658240: 1074266112,\n            8388608: 1073758208,\n            25165824: 540688,\n            41943040: 16,\n            58720256: 1073758224,\n            75497472: 1074282512,\n            92274688: 1073741824,\n            109051904: 524288,\n            125829120: 1074266128,\n            142606336: 524304,\n            159383552: 0,\n            176160768: 16384,\n            192937984: 1074266112,\n            209715200: 1073741840,\n            226492416: 540672,\n            243269632: 1074282496,\n            260046848: 16400,\n            268435456: 0,\n            285212672: 1074266128,\n            301989888: 1073758224,\n            318767104: 1074282496,\n            335544320: 1074266112,\n            352321536: 16,\n            369098752: 540688,\n            385875968: 16384,\n            402653184: 16400,\n            419430400: 524288,\n            436207616: 524304,\n            452984832: 1073741840,\n            469762048: 540672,\n            486539264: 1073758208,\n            503316480: 1073741824,\n            520093696: 1074282512,\n            276824064: 540688,\n            293601280: 524288,\n            310378496: 1074266112,\n            327155712: 16384,\n            343932928: 1073758208,\n            360710144: 1074282512,\n            377487360: 16,\n            394264576: 1073741824,\n            411041792: 1074282496,\n            427819008: 1073741840,\n            444596224: 1073758224,\n            461373440: 524304,\n            478150656: 0,\n            494927872: 16400,\n            511705088: 1074266128,\n            528482304: 540672\n          },\n          {\n            0: 260,\n            1048576: 0,\n            2097152: 67109120,\n            3145728: 65796,\n            4194304: 65540,\n            5242880: 67108868,\n            6291456: 67174660,\n            7340032: 67174400,\n            8388608: 67108864,\n            9437184: 67174656,\n            10485760: 65792,\n            11534336: 67174404,\n            12582912: 67109124,\n            13631488: 65536,\n            14680064: 4,\n            15728640: 256,\n            524288: 67174656,\n            1572864: 67174404,\n            2621440: 0,\n            3670016: 67109120,\n            4718592: 67108868,\n            5767168: 65536,\n            6815744: 65540,\n            7864320: 260,\n            8912896: 4,\n            9961472: 256,\n            11010048: 67174400,\n            12058624: 65796,\n            13107200: 65792,\n            14155776: 67109124,\n            15204352: 67174660,\n            16252928: 67108864,\n            16777216: 67174656,\n            17825792: 65540,\n            18874368: 65536,\n            19922944: 67109120,\n            20971520: 256,\n            22020096: 67174660,\n            23068672: 67108868,\n            24117248: 0,\n            25165824: 67109124,\n            26214400: 67108864,\n            27262976: 4,\n            28311552: 65792,\n            29360128: 67174400,\n            30408704: 260,\n            31457280: 65796,\n            32505856: 67174404,\n            17301504: 67108864,\n            18350080: 260,\n            19398656: 67174656,\n            20447232: 0,\n            21495808: 65540,\n            22544384: 67109120,\n            23592960: 256,\n            24641536: 67174404,\n            25690112: 65536,\n            26738688: 67174660,\n            27787264: 65796,\n            28835840: 67108868,\n            29884416: 67109124,\n            30932992: 67174400,\n            31981568: 4,\n            33030144: 65792\n          },\n          {\n            0: 2151682048,\n            65536: 2147487808,\n            131072: 4198464,\n            196608: 2151677952,\n            262144: 0,\n            327680: 4198400,\n            393216: 2147483712,\n            458752: 4194368,\n            524288: 2147483648,\n            589824: 4194304,\n            655360: 64,\n            720896: 2147487744,\n            786432: 2151678016,\n            851968: 4160,\n            917504: 4096,\n            983040: 2151682112,\n            32768: 2147487808,\n            98304: 64,\n            163840: 2151678016,\n            229376: 2147487744,\n            294912: 4198400,\n            360448: 2151682112,\n            425984: 0,\n            491520: 2151677952,\n            557056: 4096,\n            622592: 2151682048,\n            688128: 4194304,\n            753664: 4160,\n            819200: 2147483648,\n            884736: 4194368,\n            950272: 4198464,\n            1015808: 2147483712,\n            1048576: 4194368,\n            1114112: 4198400,\n            1179648: 2147483712,\n            1245184: 0,\n            1310720: 4160,\n            1376256: 2151678016,\n            1441792: 2151682048,\n            1507328: 2147487808,\n            1572864: 2151682112,\n            1638400: 2147483648,\n            1703936: 2151677952,\n            1769472: 4198464,\n            1835008: 2147487744,\n            1900544: 4194304,\n            1966080: 64,\n            2031616: 4096,\n            1081344: 2151677952,\n            1146880: 2151682112,\n            1212416: 0,\n            1277952: 4198400,\n            1343488: 4194368,\n            1409024: 2147483648,\n            1474560: 2147487808,\n            1540096: 64,\n            1605632: 2147483712,\n            1671168: 4096,\n            1736704: 2147487744,\n            1802240: 2151678016,\n            1867776: 4160,\n            1933312: 2151682048,\n            1998848: 4194304,\n            2064384: 4198464\n          },\n          {\n            0: 128,\n            4096: 17039360,\n            8192: 262144,\n            12288: 536870912,\n            16384: 537133184,\n            20480: 16777344,\n            24576: 553648256,\n            28672: 262272,\n            32768: 16777216,\n            36864: 537133056,\n            40960: 536871040,\n            45056: 553910400,\n            49152: 553910272,\n            53248: 0,\n            57344: 17039488,\n            61440: 553648128,\n            2048: 17039488,\n            6144: 553648256,\n            10240: 128,\n            14336: 17039360,\n            18432: 262144,\n            22528: 537133184,\n            26624: 553910272,\n            30720: 536870912,\n            34816: 537133056,\n            38912: 0,\n            43008: 553910400,\n            47104: 16777344,\n            51200: 536871040,\n            55296: 553648128,\n            59392: 16777216,\n            63488: 262272,\n            65536: 262144,\n            69632: 128,\n            73728: 536870912,\n            77824: 553648256,\n            81920: 16777344,\n            86016: 553910272,\n            90112: 537133184,\n            94208: 16777216,\n            98304: 553910400,\n            102400: 553648128,\n            106496: 17039360,\n            110592: 537133056,\n            114688: 262272,\n            118784: 536871040,\n            122880: 0,\n            126976: 17039488,\n            67584: 553648256,\n            71680: 16777216,\n            75776: 17039360,\n            79872: 537133184,\n            83968: 536870912,\n            88064: 17039488,\n            92160: 128,\n            96256: 553910272,\n            100352: 262272,\n            104448: 553910400,\n            108544: 0,\n            112640: 553648128,\n            116736: 16777344,\n            120832: 262144,\n            124928: 537133056,\n            129024: 536871040\n          },\n          {\n            0: 268435464,\n            256: 8192,\n            512: 270532608,\n            768: 270540808,\n            1024: 268443648,\n            1280: 2097152,\n            1536: 2097160,\n            1792: 268435456,\n            2048: 0,\n            2304: 268443656,\n            2560: 2105344,\n            2816: 8,\n            3072: 270532616,\n            3328: 2105352,\n            3584: 8200,\n            3840: 270540800,\n            128: 270532608,\n            384: 270540808,\n            640: 8,\n            896: 2097152,\n            1152: 2105352,\n            1408: 268435464,\n            1664: 268443648,\n            1920: 8200,\n            2176: 2097160,\n            2432: 8192,\n            2688: 268443656,\n            2944: 270532616,\n            3200: 0,\n            3456: 270540800,\n            3712: 2105344,\n            3968: 268435456,\n            4096: 268443648,\n            4352: 270532616,\n            4608: 270540808,\n            4864: 8200,\n            5120: 2097152,\n            5376: 268435456,\n            5632: 268435464,\n            5888: 2105344,\n            6144: 2105352,\n            6400: 0,\n            6656: 8,\n            6912: 270532608,\n            7168: 8192,\n            7424: 268443656,\n            7680: 270540800,\n            7936: 2097160,\n            4224: 8,\n            4480: 2105344,\n            4736: 2097152,\n            4992: 268435464,\n            5248: 268443648,\n            5504: 8200,\n            5760: 270540808,\n            6016: 270532608,\n            6272: 270540800,\n            6528: 270532616,\n            6784: 8192,\n            7040: 2105352,\n            7296: 2097160,\n            7552: 0,\n            7808: 268435456,\n            8064: 268443656\n          },\n          {\n            0: 1048576,\n            16: 33555457,\n            32: 1024,\n            48: 1049601,\n            64: 34604033,\n            80: 0,\n            96: 1,\n            112: 34603009,\n            128: 33555456,\n            144: 1048577,\n            160: 33554433,\n            176: 34604032,\n            192: 34603008,\n            208: 1025,\n            224: 1049600,\n            240: 33554432,\n            8: 34603009,\n            24: 0,\n            40: 33555457,\n            56: 34604032,\n            72: 1048576,\n            88: 33554433,\n            104: 33554432,\n            120: 1025,\n            136: 1049601,\n            152: 33555456,\n            168: 34603008,\n            184: 1048577,\n            200: 1024,\n            216: 34604033,\n            232: 1,\n            248: 1049600,\n            256: 33554432,\n            272: 1048576,\n            288: 33555457,\n            304: 34603009,\n            320: 1048577,\n            336: 33555456,\n            352: 34604032,\n            368: 1049601,\n            384: 1025,\n            400: 34604033,\n            416: 1049600,\n            432: 1,\n            448: 0,\n            464: 34603008,\n            480: 33554433,\n            496: 1024,\n            264: 1049600,\n            280: 33555457,\n            296: 34603009,\n            312: 1,\n            328: 33554432,\n            344: 1048576,\n            360: 1025,\n            376: 34604032,\n            392: 33554433,\n            408: 34603008,\n            424: 0,\n            440: 34604033,\n            456: 1049601,\n            472: 1024,\n            488: 33555456,\n            504: 1048577\n          },\n          {\n            0: 134219808,\n            1: 131072,\n            2: 134217728,\n            3: 32,\n            4: 131104,\n            5: 134350880,\n            6: 134350848,\n            7: 2048,\n            8: 134348800,\n            9: 134219776,\n            10: 133120,\n            11: 134348832,\n            12: 2080,\n            13: 0,\n            14: 134217760,\n            15: 133152,\n            2147483648: 2048,\n            2147483649: 134350880,\n            2147483650: 134219808,\n            2147483651: 134217728,\n            2147483652: 134348800,\n            2147483653: 133120,\n            2147483654: 133152,\n            2147483655: 32,\n            2147483656: 134217760,\n            2147483657: 2080,\n            2147483658: 131104,\n            2147483659: 134350848,\n            2147483660: 0,\n            2147483661: 134348832,\n            2147483662: 134219776,\n            2147483663: 131072,\n            16: 133152,\n            17: 134350848,\n            18: 32,\n            19: 2048,\n            20: 134219776,\n            21: 134217760,\n            22: 134348832,\n            23: 131072,\n            24: 0,\n            25: 131104,\n            26: 134348800,\n            27: 134219808,\n            28: 134350880,\n            29: 133120,\n            30: 2080,\n            31: 134217728,\n            2147483664: 131072,\n            2147483665: 2048,\n            2147483666: 134348832,\n            2147483667: 133152,\n            2147483668: 32,\n            2147483669: 134348800,\n            2147483670: 134217728,\n            2147483671: 134219808,\n            2147483672: 134350880,\n            2147483673: 134217760,\n            2147483674: 134219776,\n            2147483675: 0,\n            2147483676: 133120,\n            2147483677: 2080,\n            2147483678: 131104,\n            2147483679: 134350848\n          }\n        ], h = [\n          4160749569,\n          528482304,\n          33030144,\n          2064384,\n          129024,\n          8064,\n          504,\n          2147483679\n        ], p = s.DES = a.extend({\n          _doReset: function() {\n            for (var A = this._key, w = A.words, O = [], R = 0; R < 56; R++) {\n              var $ = l[R] - 1;\n              O[R] = w[$ >>> 5] >>> 31 - $ % 32 & 1;\n            }\n            for (var U = this._subKeys = [], W = 0; W < 16; W++) {\n              for (var G = U[W] = [], Z = c[W], R = 0; R < 24; R++)\n                G[R / 6 | 0] |= O[(u[R] - 1 + Z) % 28] << 31 - R % 6, G[4 + (R / 6 | 0)] |= O[28 + (u[R + 24] - 1 + Z) % 28] << 31 - R % 6;\n              G[0] = G[0] << 1 | G[0] >>> 31;\n              for (var R = 1; R < 7; R++)\n                G[R] = G[R] >>> (R - 1) * 4 + 3;\n              G[7] = G[7] << 5 | G[7] >>> 27;\n            }\n            for (var j = this._invSubKeys = [], R = 0; R < 16; R++)\n              j[R] = U[15 - R];\n          },\n          encryptBlock: function(A, w) {\n            this._doCryptBlock(A, w, this._subKeys);\n          },\n          decryptBlock: function(A, w) {\n            this._doCryptBlock(A, w, this._invSubKeys);\n          },\n          _doCryptBlock: function(A, w, O) {\n            this._lBlock = A[w], this._rBlock = A[w + 1], g.call(this, 4, 252645135), g.call(this, 16, 65535), _.call(this, 2, 858993459), _.call(this, 8, 16711935), g.call(this, 1, 1431655765);\n            for (var R = 0; R < 16; R++) {\n              for (var $ = O[R], U = this._lBlock, W = this._rBlock, G = 0, Z = 0; Z < 8; Z++)\n                G |= f[Z][((W ^ $[Z]) & h[Z]) >>> 0];\n              this._lBlock = W, this._rBlock = U ^ G;\n            }\n            var j = this._lBlock;\n            this._lBlock = this._rBlock, this._rBlock = j, g.call(this, 1, 1431655765), _.call(this, 8, 16711935), _.call(this, 2, 858993459), g.call(this, 16, 65535), g.call(this, 4, 252645135), A[w] = this._lBlock, A[w + 1] = this._rBlock;\n          },\n          keySize: 64 / 32,\n          ivSize: 64 / 32,\n          blockSize: 64 / 32\n        });\n        function g(A, w) {\n          var O = (this._lBlock >>> A ^ this._rBlock) & w;\n          this._rBlock ^= O, this._lBlock ^= O << A;\n        }\n        function _(A, w) {\n          var O = (this._rBlock >>> A ^ this._lBlock) & w;\n          this._lBlock ^= O, this._rBlock ^= O << A;\n        }\n        n.DES = a._createHelper(p);\n        var T = s.TripleDES = a.extend({\n          _doReset: function() {\n            var A = this._key, w = A.words;\n            if (w.length !== 2 && w.length !== 4 && w.length < 6)\n              throw new Error(\"Invalid key length - 3DES requires the key length to be 64, 128, 192 or >192.\");\n            var O = w.slice(0, 2), R = w.length < 4 ? w.slice(0, 2) : w.slice(2, 4), $ = w.length < 6 ? w.slice(0, 2) : w.slice(4, 6);\n            this._des1 = p.createEncryptor(o.create(O)), this._des2 = p.createEncryptor(o.create(R)), this._des3 = p.createEncryptor(o.create($));\n          },\n          encryptBlock: function(A, w) {\n            this._des1.encryptBlock(A, w), this._des2.decryptBlock(A, w), this._des3.encryptBlock(A, w);\n          },\n          decryptBlock: function(A, w) {\n            this._des3.decryptBlock(A, w), this._des2.encryptBlock(A, w), this._des1.decryptBlock(A, w);\n          },\n          keySize: 192 / 32,\n          ivSize: 64 / 32,\n          blockSize: 64 / 32\n        });\n        n.TripleDES = a._createHelper(T);\n      }(), r.TripleDES;\n    });\n  }(vg)), uo;\n}\nvar lo = {}, xg = {\n  get exports() {\n    return lo;\n  },\n  set exports(t) {\n    lo = t;\n  }\n}, Xl;\nfunction wg() {\n  return Xl || (Xl = 1, function(t, e) {\n    (function(r, n, i) {\n      t.exports = n(Ie(), xn(), wn(), $r(), gt());\n    })(ue, function(r) {\n      return function() {\n        var n = r, i = n.lib, o = i.StreamCipher, a = n.algo, s = a.RC4 = o.extend({\n          _doReset: function() {\n            for (var c = this._key, f = c.words, h = c.sigBytes, p = this._S = [], g = 0; g < 256; g++)\n              p[g] = g;\n            for (var g = 0, _ = 0; g < 256; g++) {\n              var T = g % h, A = f[T >>> 2] >>> 24 - T % 4 * 8 & 255;\n              _ = (_ + p[g] + A) % 256;\n              var w = p[g];\n              p[g] = p[_], p[_] = w;\n            }\n            this._i = this._j = 0;\n          },\n          _doProcessBlock: function(c, f) {\n            c[f] ^= l.call(this);\n          },\n          keySize: 256 / 32,\n          ivSize: 0\n        });\n        function l() {\n          for (var c = this._S, f = this._i, h = this._j, p = 0, g = 0; g < 4; g++) {\n            f = (f + 1) % 256, h = (h + c[f]) % 256;\n            var _ = c[f];\n            c[f] = c[h], c[h] = _, p |= c[(c[f] + c[h]) % 256] << 24 - g * 8;\n          }\n          return this._i = f, this._j = h, p;\n        }\n        n.RC4 = o._createHelper(s);\n        var u = a.RC4Drop = s.extend({\n          /**\n           * Configuration options.\n           *\n           * @property {number} drop The number of keystream words to drop. Default 192\n           */\n          cfg: s.cfg.extend({\n            drop: 192\n          }),\n          _doReset: function() {\n            s._doReset.call(this);\n            for (var c = this.cfg.drop; c > 0; c--)\n              l.call(this);\n          }\n        });\n        n.RC4Drop = o._createHelper(u);\n      }(), r.RC4;\n    });\n  }(xg)), lo;\n}\nvar fo = {}, bg = {\n  get exports() {\n    return fo;\n  },\n  set exports(t) {\n    fo = t;\n  }\n}, Jl;\nfunction _g() {\n  return Jl || (Jl = 1, function(t, e) {\n    (function(r, n, i) {\n      t.exports = n(Ie(), xn(), wn(), $r(), gt());\n    })(ue, function(r) {\n      return function() {\n        var n = r, i = n.lib, o = i.StreamCipher, a = n.algo, s = [], l = [], u = [], c = a.Rabbit = o.extend({\n          _doReset: function() {\n            for (var h = this._key.words, p = this.cfg.iv, g = 0; g < 4; g++)\n              h[g] = (h[g] << 8 | h[g] >>> 24) & 16711935 | (h[g] << 24 | h[g] >>> 8) & 4278255360;\n            var _ = this._X = [\n              h[0],\n              h[3] << 16 | h[2] >>> 16,\n              h[1],\n              h[0] << 16 | h[3] >>> 16,\n              h[2],\n              h[1] << 16 | h[0] >>> 16,\n              h[3],\n              h[2] << 16 | h[1] >>> 16\n            ], T = this._C = [\n              h[2] << 16 | h[2] >>> 16,\n              h[0] & 4294901760 | h[1] & 65535,\n              h[3] << 16 | h[3] >>> 16,\n              h[1] & 4294901760 | h[2] & 65535,\n              h[0] << 16 | h[0] >>> 16,\n              h[2] & 4294901760 | h[3] & 65535,\n              h[1] << 16 | h[1] >>> 16,\n              h[3] & 4294901760 | h[0] & 65535\n            ];\n            this._b = 0;\n            for (var g = 0; g < 4; g++)\n              f.call(this);\n            for (var g = 0; g < 8; g++)\n              T[g] ^= _[g + 4 & 7];\n            if (p) {\n              var A = p.words, w = A[0], O = A[1], R = (w << 8 | w >>> 24) & 16711935 | (w << 24 | w >>> 8) & 4278255360, $ = (O << 8 | O >>> 24) & 16711935 | (O << 24 | O >>> 8) & 4278255360, U = R >>> 16 | $ & 4294901760, W = $ << 16 | R & 65535;\n              T[0] ^= R, T[1] ^= U, T[2] ^= $, T[3] ^= W, T[4] ^= R, T[5] ^= U, T[6] ^= $, T[7] ^= W;\n              for (var g = 0; g < 4; g++)\n                f.call(this);\n            }\n          },\n          _doProcessBlock: function(h, p) {\n            var g = this._X;\n            f.call(this), s[0] = g[0] ^ g[5] >>> 16 ^ g[3] << 16, s[1] = g[2] ^ g[7] >>> 16 ^ g[5] << 16, s[2] = g[4] ^ g[1] >>> 16 ^ g[7] << 16, s[3] = g[6] ^ g[3] >>> 16 ^ g[1] << 16;\n            for (var _ = 0; _ < 4; _++)\n              s[_] = (s[_] << 8 | s[_] >>> 24) & 16711935 | (s[_] << 24 | s[_] >>> 8) & 4278255360, h[p + _] ^= s[_];\n          },\n          blockSize: 128 / 32,\n          ivSize: 64 / 32\n        });\n        function f() {\n          for (var h = this._X, p = this._C, g = 0; g < 8; g++)\n            l[g] = p[g];\n          p[0] = p[0] + 1295307597 + this._b | 0, p[1] = p[1] + 3545052371 + (p[0] >>> 0 < l[0] >>> 0 ? 1 : 0) | 0, p[2] = p[2] + 886263092 + (p[1] >>> 0 < l[1] >>> 0 ? 1 : 0) | 0, p[3] = p[3] + 1295307597 + (p[2] >>> 0 < l[2] >>> 0 ? 1 : 0) | 0, p[4] = p[4] + 3545052371 + (p[3] >>> 0 < l[3] >>> 0 ? 1 : 0) | 0, p[5] = p[5] + 886263092 + (p[4] >>> 0 < l[4] >>> 0 ? 1 : 0) | 0, p[6] = p[6] + 1295307597 + (p[5] >>> 0 < l[5] >>> 0 ? 1 : 0) | 0, p[7] = p[7] + 3545052371 + (p[6] >>> 0 < l[6] >>> 0 ? 1 : 0) | 0, this._b = p[7] >>> 0 < l[7] >>> 0 ? 1 : 0;\n          for (var g = 0; g < 8; g++) {\n            var _ = h[g] + p[g], T = _ & 65535, A = _ >>> 16, w = ((T * T >>> 17) + T * A >>> 15) + A * A, O = ((_ & 4294901760) * _ | 0) + ((_ & 65535) * _ | 0);\n            u[g] = w ^ O;\n          }\n          h[0] = u[0] + (u[7] << 16 | u[7] >>> 16) + (u[6] << 16 | u[6] >>> 16) | 0, h[1] = u[1] + (u[0] << 8 | u[0] >>> 24) + u[7] | 0, h[2] = u[2] + (u[1] << 16 | u[1] >>> 16) + (u[0] << 16 | u[0] >>> 16) | 0, h[3] = u[3] + (u[2] << 8 | u[2] >>> 24) + u[1] | 0, h[4] = u[4] + (u[3] << 16 | u[3] >>> 16) + (u[2] << 16 | u[2] >>> 16) | 0, h[5] = u[5] + (u[4] << 8 | u[4] >>> 24) + u[3] | 0, h[6] = u[6] + (u[5] << 16 | u[5] >>> 16) + (u[4] << 16 | u[4] >>> 16) | 0, h[7] = u[7] + (u[6] << 8 | u[6] >>> 24) + u[5] | 0;\n        }\n        n.Rabbit = o._createHelper(c);\n      }(), r.Rabbit;\n    });\n  }(bg)), fo;\n}\nvar ho = {}, Ag = {\n  get exports() {\n    return ho;\n  },\n  set exports(t) {\n    ho = t;\n  }\n}, Ql;\nfunction Tg() {\n  return Ql || (Ql = 1, function(t, e) {\n    (function(r, n, i) {\n      t.exports = n(Ie(), xn(), wn(), $r(), gt());\n    })(ue, function(r) {\n      return function() {\n        var n = r, i = n.lib, o = i.StreamCipher, a = n.algo, s = [], l = [], u = [], c = a.RabbitLegacy = o.extend({\n          _doReset: function() {\n            var h = this._key.words, p = this.cfg.iv, g = this._X = [\n              h[0],\n              h[3] << 16 | h[2] >>> 16,\n              h[1],\n              h[0] << 16 | h[3] >>> 16,\n              h[2],\n              h[1] << 16 | h[0] >>> 16,\n              h[3],\n              h[2] << 16 | h[1] >>> 16\n            ], _ = this._C = [\n              h[2] << 16 | h[2] >>> 16,\n              h[0] & 4294901760 | h[1] & 65535,\n              h[3] << 16 | h[3] >>> 16,\n              h[1] & 4294901760 | h[2] & 65535,\n              h[0] << 16 | h[0] >>> 16,\n              h[2] & 4294901760 | h[3] & 65535,\n              h[1] << 16 | h[1] >>> 16,\n              h[3] & 4294901760 | h[0] & 65535\n            ];\n            this._b = 0;\n            for (var T = 0; T < 4; T++)\n              f.call(this);\n            for (var T = 0; T < 8; T++)\n              _[T] ^= g[T + 4 & 7];\n            if (p) {\n              var A = p.words, w = A[0], O = A[1], R = (w << 8 | w >>> 24) & 16711935 | (w << 24 | w >>> 8) & 4278255360, $ = (O << 8 | O >>> 24) & 16711935 | (O << 24 | O >>> 8) & 4278255360, U = R >>> 16 | $ & 4294901760, W = $ << 16 | R & 65535;\n              _[0] ^= R, _[1] ^= U, _[2] ^= $, _[3] ^= W, _[4] ^= R, _[5] ^= U, _[6] ^= $, _[7] ^= W;\n              for (var T = 0; T < 4; T++)\n                f.call(this);\n            }\n          },\n          _doProcessBlock: function(h, p) {\n            var g = this._X;\n            f.call(this), s[0] = g[0] ^ g[5] >>> 16 ^ g[3] << 16, s[1] = g[2] ^ g[7] >>> 16 ^ g[5] << 16, s[2] = g[4] ^ g[1] >>> 16 ^ g[7] << 16, s[3] = g[6] ^ g[3] >>> 16 ^ g[1] << 16;\n            for (var _ = 0; _ < 4; _++)\n              s[_] = (s[_] << 8 | s[_] >>> 24) & 16711935 | (s[_] << 24 | s[_] >>> 8) & 4278255360, h[p + _] ^= s[_];\n          },\n          blockSize: 128 / 32,\n          ivSize: 64 / 32\n        });\n        function f() {\n          for (var h = this._X, p = this._C, g = 0; g < 8; g++)\n            l[g] = p[g];\n          p[0] = p[0] + 1295307597 + this._b | 0, p[1] = p[1] + 3545052371 + (p[0] >>> 0 < l[0] >>> 0 ? 1 : 0) | 0, p[2] = p[2] + 886263092 + (p[1] >>> 0 < l[1] >>> 0 ? 1 : 0) | 0, p[3] = p[3] + 1295307597 + (p[2] >>> 0 < l[2] >>> 0 ? 1 : 0) | 0, p[4] = p[4] + 3545052371 + (p[3] >>> 0 < l[3] >>> 0 ? 1 : 0) | 0, p[5] = p[5] + 886263092 + (p[4] >>> 0 < l[4] >>> 0 ? 1 : 0) | 0, p[6] = p[6] + 1295307597 + (p[5] >>> 0 < l[5] >>> 0 ? 1 : 0) | 0, p[7] = p[7] + 3545052371 + (p[6] >>> 0 < l[6] >>> 0 ? 1 : 0) | 0, this._b = p[7] >>> 0 < l[7] >>> 0 ? 1 : 0;\n          for (var g = 0; g < 8; g++) {\n            var _ = h[g] + p[g], T = _ & 65535, A = _ >>> 16, w = ((T * T >>> 17) + T * A >>> 15) + A * A, O = ((_ & 4294901760) * _ | 0) + ((_ & 65535) * _ | 0);\n            u[g] = w ^ O;\n          }\n          h[0] = u[0] + (u[7] << 16 | u[7] >>> 16) + (u[6] << 16 | u[6] >>> 16) | 0, h[1] = u[1] + (u[0] << 8 | u[0] >>> 24) + u[7] | 0, h[2] = u[2] + (u[1] << 16 | u[1] >>> 16) + (u[0] << 16 | u[0] >>> 16) | 0, h[3] = u[3] + (u[2] << 8 | u[2] >>> 24) + u[1] | 0, h[4] = u[4] + (u[3] << 16 | u[3] >>> 16) + (u[2] << 16 | u[2] >>> 16) | 0, h[5] = u[5] + (u[4] << 8 | u[4] >>> 24) + u[3] | 0, h[6] = u[6] + (u[5] << 16 | u[5] >>> 16) + (u[4] << 16 | u[4] >>> 16) | 0, h[7] = u[7] + (u[6] << 8 | u[6] >>> 24) + u[5] | 0;\n        }\n        n.RabbitLegacy = o._createHelper(c);\n      }(), r.RabbitLegacy;\n    });\n  }(Ag)), ho;\n}\n(function(t, e) {\n  (function(r, n, i) {\n    t.exports = n(Ie(), jo(), Tv(), Sv(), xn(), Ov(), wn(), yc(), Mh(), Iv(), kh(), Fv(), jv(), Vv(), mc(), Wv(), $r(), gt(), Gv(), Zv(), Jv(), eg(), rg(), ig(), sg(), cg(), lg(), hg(), pg(), mg(), gg(), wg(), _g(), Tg());\n  })(ue, function(r) {\n    return r;\n  });\n})(vv);\nconst $s = Ta;\nasync function Tn(t) {\n  const e = await crypto.subtle.digest(\"SHA-256\", typeof t != \"string\" ? t : new TextEncoder().encode(t));\n  return Array.from(new Uint8Array(e)).map((r) => r.toString(16).padStart(2, \"0\")).join(\"\");\n}\nasync function Eg(t) {\n  const e = t.API_ID, r = window.location.href;\n  return Mt({ method: \"POST\", url: \"https://server.othent.io/use-othent\", data: { API_ID: e, callbackURL: r } }).then((n) => {\n    if (n.data.success === !1)\n      throw new Error(\"Please specify an API ID (you can get one from Othent.io)\");\n    const i = () => yv({ domain: \"auth.othent.io\", clientId: \"dyegx4dZj5yOv0v0RkoUsc48CIqaNS6C\", authorizationParams: { redirect_uri: window.location.origin } });\n    function o(s, l) {\n      return s.getTokenSilently({ detailedResponse: !0, authorizationParams: l, cacheMode: \"off\" });\n    }\n    async function a(s) {\n      let l;\n      if (s instanceof File)\n        l = await async function(u) {\n          return new Promise((c, f) => {\n            const h = new FileReader();\n            h.onload = () => {\n              const p = h.result, g = Buffer.from(p);\n              c(g);\n            }, h.onerror = f, h.readAsArrayBuffer(u);\n          });\n        }(s);\n      else if (typeof s == \"string\")\n        l = Buffer.from(s, \"utf8\");\n      else if (Buffer.isBuffer(s))\n        l = s;\n      else if (s instanceof ArrayBuffer || typeof SharedArrayBuffer < \"u\" && s instanceof SharedArrayBuffer)\n        l = Buffer.from(s);\n      else {\n        if (!(s instanceof Uint8Array))\n          throw new Error(\"Invalid data, we accept: string | Buffer | ArrayBuffer | SharedArrayBuffer | Uint8Array | File\");\n        l = Buffer.from(s.buffer);\n      }\n      return l;\n    }\n    return { getAPIID: async function() {\n      const s = await i(), l = { transaction_input: JSON.stringify({ othentFunction: \"API_ID\" }) }, u = (await o(s, l)).id_token, c = dr(u);\n      if (c.contract_id)\n        return { API_ID: c.API_ID };\n      throw new Error('{ success: false, message: \"Please create a Othent account\" }');\n    }, queryWalletAddressTxns: async function(s) {\n      return await Mt({ method: \"POST\", url: \"https://server.othent.io/query-wallet-address-txns\", data: { walletAddress: s.walletAddress } }).then((l) => l.data).catch((l) => {\n        throw l;\n      });\n    }, ping: async function() {\n      return await Mt({ method: \"GET\", url: \"https://server.othent.io/\" }).then((s) => s.data).catch((s) => {\n        throw s;\n      });\n    }, logIn: async function(s = {}) {\n      var l;\n      (l = s.testNet) !== null && l !== void 0 || (s.testNet = !1);\n      const u = await i(), c = await u.isAuthenticated(), f = { authorizationParams: { transaction_input: JSON.stringify({ othentFunction: \"idToken\", testNet: s.testNet }), redirect_uri: window.location.origin } }, h = async (_) => {\n        await u.loginWithPopup(_);\n        const T = { transaction_input: JSON.stringify({ othentFunction: \"idToken\" }) }, A = await o(u, T), w = dr(A.id_token);\n        if ((O = w) && typeof O.contract_id == \"string\")\n          return { encoded: A.id_token, decoded: w };\n        throw new Error(\"Invalid JWT structure received.\");\n        var O;\n      }, p = async (_, T, A) => (A ? T.test_net_contract_id : T.contract_id) ? ([\"nonce\", \"sid\", \"aud\", \"iss\", \"iat\", \"exp\", \"updated_at\"].forEach((w) => delete T[w]), T) : await g(_, A ? \"testNet\" : \"\"), g = async (_, T = \"\") => (await Mt({ method: \"POST\", url: \"https://server.othent.io/create-user\", data: { JWT: _, API_ID: e, network: T } })).data;\n      if (c) {\n        const { encoded: _, decoded: T } = await h(f);\n        return p(_, T, s.testNet);\n      }\n      try {\n        const { encoded: _, decoded: T } = await h(f);\n        return p(_, T, s.testNet);\n      } catch {\n        throw new Error(\"Your browser is blocking us! Please turn off your shields or allow cross site cookies! :)\");\n      }\n    }, logOut: async function() {\n      return await (await i()).logout({ logoutParams: { returnTo: window.location.origin } }), { response: \"User logged out\" };\n    }, userDetails: async function() {\n      const s = await i(), l = { transaction_input: JSON.stringify({ othentFunction: \"idToken\" }) }, u = (await o(s, l)).id_token, c = dr(u);\n      if (c.contract_id)\n        return delete c.nonce, delete c.sid, delete c.aud, delete c.iss, delete c.iat, delete c.exp, delete c.updated_at, c;\n      throw new Error('{ success: false, message: \"Please create a Othent account\" }');\n    }, readContract: async function() {\n      const s = await i(), l = { transaction_input: JSON.stringify({ othentFunction: \"idToken\" }) }, u = (await o(s, l)).id_token;\n      return await Mt({ method: \"POST\", url: \"https://server.othent.io/read-contract\", data: { JWT: u } }).then((c) => c.data).catch((c) => {\n        throw console.log(c.response.data), c;\n      });\n    }, viewCustomContract: async function(s) {\n      var l, u;\n      let c;\n      return (l = s.tags) !== null && l !== void 0 || (s.tags = []), (u = s.testNet) !== null && u !== void 0 || (s.testNet = !1), c = s.testNet === !0 ? \"testNet\" : \"mainNet\", await Mt({ method: \"POST\", url: \"https://server.othent.io/view-custom-contract-state\", data: { contract_id: s.contract_id, func: s.function, data: s.tags, network: c } }).then((f) => f.data).catch((f) => {\n        throw console.log(f.response.data), f;\n      });\n    }, signTransactionWarp: async function(s) {\n      var l, u;\n      (l = s.tags) !== null && l !== void 0 || (s.tags = []), (u = s.testNet) !== null && u !== void 0 || (s.testNet = !1);\n      const c = { function: s.othentFunction, data: { toContractId: s.data.toContractId, toContractFunction: s.data.toContractFunction, txnData: s.data.txnData } }, f = await i(), h = { transaction_input: JSON.stringify({ othentFunction: s.othentFunction, warpData: c, testNet: s.testNet }) }, p = await o(f, h), g = p.id_token, _ = dr(g);\n      if (!_.contract_id)\n        throw new Error('{success: false, message:\"Please create a Othent account\"}');\n      if (s.testNet === !0 && !_.test_net_contract_id)\n        throw new Error('{success: false, message:\"Please create a Othent test net account\"}');\n      return { JWT: p.id_token, tags: s.tags, testNet: s.testNet };\n    }, sendTransactionWarp: async function(s) {\n      const l = s.JWT, u = s.tags;\n      let c;\n      return c = s.testNet === !0 ? \"testNet\" : \"mainNet\", await Mt({ method: \"POST\", url: \"https://server.othent.io/send-transaction\", data: { JWT: l, tags: u, API_ID: e, network: c } }).then((f) => f.data).catch((f) => {\n        throw console.log(f.response.data), f;\n      });\n    }, signTransactionArweave: async function(s) {\n      var l;\n      (l = s.tags) !== null && l !== void 0 || (s.tags = []);\n      const u = await a(s.data);\n      if (!u)\n        throw new Error(\"Invalid data, we accept: string | Buffer | ArrayBuffer | SharedArrayBuffer | Uint8Array | File\");\n      const c = await Tn(u), f = await i(), h = { transaction_input: JSON.stringify({ othentFunction: s.othentFunction, file_hash: c }) }, p = await o(f, h), g = p.id_token;\n      if (!dr(g).contract_id)\n        throw new Error('{ success: false, message: \"Please create a Othent account\" }');\n      return { data: u, JWT: p.id_token, tags: s.tags };\n    }, sendTransactionArweave: async function(s) {\n      const l = s.data, u = new Blob([l]), c = new FormData();\n      return c.append(\"file\", u), c.append(\"dataHashJWT\", s.JWT), c.append(\"API_ID\", e), c.append(\"tags\", JSON.stringify(s.tags)), await fetch(\"https://server.othent.io/upload-data-arweave\", { method: \"POST\", body: c }).then((f) => f.json()).then((f) => f).catch((f) => {\n        throw console.log(f), f;\n      });\n    }, signTransactionBundlr: async function(s) {\n      var l;\n      (l = s.tags) !== null && l !== void 0 || (s.tags = []);\n      const u = await a(s.data);\n      if (!u)\n        throw new Error(\"Invalid data, we accept: string | Buffer | ArrayBuffer | SharedArrayBuffer | Uint8Array | File\");\n      const c = await Tn(u), f = await i(), h = { transaction_input: JSON.stringify({ othentFunction: s.othentFunction, file_hash: c }) }, p = await o(f, h), g = p.id_token;\n      if (!dr(g).contract_id)\n        throw new Error('{ success: false, message: \"Please create a Othent account\" }');\n      return { data: u, JWT: p.id_token, tags: s.tags };\n    }, sendTransactionBundlr: async function(s) {\n      const l = s.data, u = new Blob([l]), c = new FormData();\n      return c.append(\"file\", u), c.append(\"dataHashJWT\", s.JWT), c.append(\"API_ID\", e), c.append(\"tags\", JSON.stringify(s.tags)), await fetch(\"https://server.othent.io/upload-data-bundlr\", { method: \"POST\", body: c }).then((f) => f.json()).then((f) => f).catch((f) => {\n        throw console.log(f), f;\n      });\n    }, initializeJWK: async function(s) {\n      const l = await i(), u = { transaction_input: JSON.stringify({ othentFunction: \"initializeJWK\", warpData: { function: \"initializeJWK\", data: { JWK_public_key_PEM: s.JWK_public_key_PEM, JWK_public_key: null } } }) }, c = (await o(l, u)).id_token;\n      return Mt({ method: \"POST\", url: \"https://server.othent.io/initialize-JWK\", data: { PEM_key_JWT: c, API_ID: e } }).then((f) => f.data).catch((f) => {\n        throw console.log(f.response.data), f;\n      });\n    }, readCustomContract: async function(s) {\n      var l;\n      let u;\n      return (l = s.testNet) !== null && l !== void 0 || (s.testNet = !1), u = s.testNet === !0 ? \"testNet\" : \"mainNet\", await Mt({ method: \"POST\", url: \"https://server.othent.io/read-custom-contract\", data: { contract_id: s.contract_id, network: u } }).then((c) => c.data).catch((c) => {\n        throw console.log(c.response.data), c;\n      });\n    }, verifyArweaveData: async function(s) {\n      let l;\n      (await (await fetch(`https://arweave.net/tx/${s.transactionId}`, { headers: { responseType: \"arraybuffer\" } })).json()).tags.map((p) => {\n        atob(p.name) === \"File-Hash-JWT\" && (l = dr(atob(p.value)));\n      });\n      const c = l.file_hash;\n      let f = (await Mt.get(`https://arweave.net/${s.transactionId}`, { responseType: \"arraybuffer\" })).data;\n      const h = await Tn(f);\n      return c === h ? { validData: !0, contract_id: l.contract_id, onChainHash: h, tagHash: c, iat: l.iat, userId: l.sub } : { validData: !1, onChainHash: h, tagHash: c };\n    }, verifyBundlrData: async function(s) {\n      let l;\n      (await (await fetch(`https://gateway.bundlr.network/tx/${s.transactionId}`, { headers: { responseType: \"arraybuffer\" } })).json()).tags.map((p) => {\n        p.name === \"File-Hash-JWT\" && (l = dr(p.value));\n      });\n      const c = l.file_hash;\n      let f = (await Mt.get(`https://arweave.net/${s.transactionId}`, { responseType: \"arraybuffer\" })).data;\n      const h = await Tn(f);\n      return c === h ? { validData: !0, contract_id: l.contract_id, onChainHash: h, tagHash: c, iat: l.iat, userId: l.sub } : { validData: !1, onChainHash: h, tagHash: c };\n    }, encryptData: async function(s) {\n      const l = s.data, u = s.key;\n      return { encryptedData: $s.AES.encrypt(l, u).toString() };\n    }, decryptData: async function(s) {\n      const l = s.data, u = s.key, c = $s.AES.decrypt(l, u);\n      return { decryptedData: $s.enc.Utf8.stringify(c) };\n    }, deployWarpContract: async function(s) {\n      var l, u;\n      let c;\n      (l = s.tags) !== null && l !== void 0 || (s.tags = []), (u = s.testNet) !== null && u !== void 0 || (s.testNet = !1), c = s.testNet === !0 ? \"testNet\" : \"mainNet\";\n      const f = await Tn(s.contractSrc), h = await i(), p = { transaction_input: JSON.stringify({ othentFunction: \"uploadData\", file_hash: f }) }, g = (await o(h, p)).id_token;\n      return await Mt({ method: \"POST\", url: \"https://server.othent.io/deploy-warp-contract\", data: { contractSrc: s.contractSrc, contractState: s.state, JWT: g, tags: s.tags, network: c } }).then((_) => _.data).catch((_) => {\n        throw console.log(_.response.data), _;\n      });\n    }, deployWarpContractFromTx: async function(s) {\n      var l, u;\n      let c;\n      (l = s.tags) !== null && l !== void 0 || (s.tags = []), (u = s.testNet) !== null && u !== void 0 || (s.testNet = !1), c = s.testNet === !0 ? \"testNet\" : \"mainNet\";\n      const f = await i(), h = { transaction_input: JSON.stringify({ othentFunction: \"deployWarpContractFromTx\", srcTxId: s.srcTxId }) }, p = (await o(f, h)).id_token;\n      return await Mt({ method: \"POST\", url: \"https://server.othent.io/deploy-warp-contract-from-tx\", data: { srcTxId: s.srcTxId, contractState: s.state, JWT: p, tags: s.tags, network: c } }).then((g) => g.data).catch((g) => {\n        throw console.log(g.response.data), g;\n      });\n    } };\n  }).catch((n) => {\n    throw console.error(\"An error occurred:\", n), n;\n  });\n}\nvar Xn, ar, xr, Fr, at, lt;\nclass Sg {\n  constructor() {\n    Cr(this, at);\n    ot(this, \"id\", \"othent\");\n    ot(this, \"name\", \"Google\");\n    ot(this, \"description\", \"Sign in with Google through Othent Smart Contract Wallets\");\n    ot(this, \"theme\", \"35, 117, 239\");\n    ot(this, \"logo\", \"33nBIUNlGK4MnWtJZQy9EzkVJaAd7WoydIKfkJoMvDs\");\n    ot(this, \"url\", \"https://othent.io\");\n    Cr(this, Xn, \"e923634af8cc8b63bc8c74735d177aae\");\n    Cr(this, ar, []);\n    Cr(this, xr, void 0);\n    Cr(this, Fr, \"\");\n  }\n  /**\n   * Advanced function to override the default API ID\n   * Othent uses.\n   */\n  __overrideApiID(e) {\n    Or(this, Xn, e);\n  }\n  async isAvailable() {\n    try {\n      return await ut(this, at, lt).call(this, !1), !0;\n    } catch {\n      return !1;\n    }\n  }\n  async ping() {\n    return await (await ut(this, at, lt).call(this, !1)).ping();\n  }\n  async connect(e, r, n) {\n    const o = await (await ut(this, at, lt).call(this, !1)).logIn({ testNet: !1 });\n    for (const a of vt(this, ar))\n      a(o.contract_id);\n    Or(this, Fr, o.contract_id);\n  }\n  async disconnect() {\n    await (await ut(this, at, lt).call(this)).logOut();\n    for (const r of vt(this, ar))\n      r(void 0);\n    Or(this, Fr, \"\");\n  }\n  async getPermissions() {\n    const e = await ut(this, at, lt).call(this, !1);\n    try {\n      const r = await e.userDetails();\n      if (r.contract_id !== vt(this, Fr)) {\n        Or(this, Fr, r.contract_id);\n        for (const n of vt(this, ar))\n          n(r.contract_id);\n      }\n      return [\n        \"ACCESS_ADDRESS\",\n        \"ACCESS_PUBLIC_KEY\",\n        \"ACCESS_ALL_ADDRESSES\",\n        \"SIGN_TRANSACTION\",\n        \"ENCRYPT\",\n        \"DECRYPT\",\n        \"SIGNATURE\",\n        \"ACCESS_ARWEAVE_CONFIG\",\n        \"DISPATCH\"\n      ];\n    } catch {\n      return [];\n    }\n  }\n  async getActiveAddress() {\n    return (await (await ut(this, at, lt).call(this, !1)).userDetails()).contract_id;\n  }\n  async getAllAddresses() {\n    return [await this.getActiveAddress()];\n  }\n  /**\n   * Same as \"sendTransactionArweave()\" of the Othent SDK\n   */\n  // @ts-expect-error - Return type is different for Othent transaction signing\n  async sign(e, r) {\n    if (r && console.warn(\n      \"[Arweave Wallet Kit] Othent does not support transaction signature options\"\n    ), e.quantity !== \"0\" && e.target !== \"\")\n      throw new Error(\n        \"[Arweave Wallet Kit] Signing with Othent only supports data type transactions\"\n      );\n    return await (await ut(this, at, lt).call(this, !1)).signTransactionArweave({\n      othentFunction: \"uploadData\",\n      data: e.data,\n      tags: el(e.tags)\n    });\n  }\n  async signTransactionBundlr(e) {\n    return await (await ut(this, at, lt).call(this)).signTransactionBundlr(e);\n  }\n  async signTransactionWarp(e) {\n    return await (await ut(this, at, lt).call(this)).signTransactionWarp(e);\n  }\n  async sendTransactionArweave(e) {\n    return await (await ut(this, at, lt).call(this)).sendTransactionArweave(e);\n  }\n  async sendTransactionBundlr(e) {\n    return await (await ut(this, at, lt).call(this)).sendTransactionBundlr(e);\n  }\n  async sendTransactionWarp(e) {\n    return await (await ut(this, at, lt).call(this)).sendTransactionWarp(e);\n  }\n  async verifyArweaveData(e) {\n    return await (await ut(this, at, lt).call(this)).verifyArweaveData(e);\n  }\n  async verifyBundlrData(e) {\n    return await (await ut(this, at, lt).call(this)).verifyBundlrData(e);\n  }\n  async dispatch(e) {\n    try {\n      const r = await ut(this, at, lt).call(this, !1), n = el(e.tags), i = await r.signTransactionBundlr({\n        othentFunction: \"uploadData\",\n        data: e.data,\n        tags: n\n      }), o = await r.sendTransactionBundlr(i);\n      if (o.success === !0)\n        return { id: o.transactionId, type: \"BUNDLED\" };\n      try {\n        const a = await ut(this, at, lt).call(this, !1), s = await a.signTransactionArweave({\n          othentFunction: \"uploadData\",\n          data: e.data,\n          tags: n\n        }), l = await a.sendTransactionArweave(s);\n        if (l.success === !0)\n          return { id: l.transactionId, type: \"BASE\" };\n        throw new Error(\n          \"Failed to dispatch layer transaction. Please recheck request.\"\n        );\n      } catch (a) {\n        throw new Error(\n          `Unable to dispatch Base layer transaction: ${a}`\n        );\n      }\n    } catch (r) {\n      throw new Error(`Unable to dispatch Bundled transaction: ${r}`);\n    }\n  }\n  async queryWalletAddressTxns(e) {\n    return await (await ut(this, at, lt).call(this)).queryWalletAddressTxns(e);\n  }\n  async userDetails() {\n    return await (await ut(this, at, lt).call(this)).userDetails();\n  }\n  async readContract() {\n    return await (await ut(this, at, lt).call(this)).readContract();\n  }\n  async readCustomContract(e) {\n    return await (await ut(this, at, lt).call(this)).readCustomContract(e);\n  }\n  addAddressEvent(e) {\n    return vt(this, ar).push(e), e;\n  }\n  removeAddressEvent(e) {\n    vt(this, ar).splice(\n      vt(this, ar).indexOf(e),\n      1\n    );\n  }\n}\nXn = new WeakMap(), ar = new WeakMap(), xr = new WeakMap(), Fr = new WeakMap(), at = new WeakSet(), lt = async function(e = !0) {\n  if (vt(this, xr) && !e)\n    return vt(this, xr);\n  if (!vt(this, xr))\n    try {\n      Or(this, xr, await Eg({\n        API_ID: vt(this, Xn)\n      }));\n    } catch (r) {\n      throw new Error(`[Arweave Wallet Kit] ${r.message ?? r}`);\n    }\n  if (e && (await this.getPermissions()).length === 0)\n    throw new Error(\"[Arweave Wallet Kit] You are not connected to Othent\");\n  return vt(this, xr);\n};\nconst Dn = [\n  new Ry(),\n  new ky(),\n  new Sg(),\n  new rc()\n], ti = \"wallet_kit_strategy_id\";\nasync function Pg(t, e) {\n  let r = (localStorage == null ? void 0 : localStorage.getItem(ti)) || !1;\n  if (r && tn(r))\n    return tn(r);\n  for (const n of Dn) {\n    const i = await n.getPermissions();\n    if (!e && i.length > 0)\n      return Ea(n.id), tn(n.id);\n    if (e && nh(t, i))\n      return Ea(n.id), tn(n.id);\n  }\n  return !1;\n}\nfunction Ea(t) {\n  localStorage && localStorage.setItem(ti, t);\n}\nfunction tn(t) {\n  return Dn.find((e) => e.id === t);\n}\nconst vc = {\n  activeModal: !1,\n  activeStrategy: !1,\n  givenPermissions: [],\n  config: {\n    permissions: []\n  }\n}, Rh = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(void 0);\nfunction _t() {\n  const t = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(Rh);\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(\n    () => t || { state: vc, dispatch: () => {\n    } },\n    [t]\n  );\n}\nfunction Cg() {\n  const { state: t } = _t();\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => t.activeStrategy, [t]);\n}\nfunction ir() {\n  const t = Cg();\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => tn(t), [t]);\n}\nfunction i2() {\n  const t = ir();\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    if (!t)\n      return;\n    const r = t, n = [\n      \"name\",\n      \"description\",\n      \"theme\",\n      \"logo\",\n      \"url\",\n      \"resumeSession\",\n      \"isAvailable\",\n      \"addAddressEvent\",\n      \"removeAddressEvent\",\n      \"connect\"\n    ];\n    for (const i in t)\n      n.includes(i) && delete r[i];\n    return r;\n  }, [t]);\n}\nfunction Uo() {\n  const { state: t } = _t();\n  return t == null ? void 0 : t.activeAddress;\n}\nasync function Og() {\n  const t = ir(), { dispatch: e } = _t();\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    (async () => {\n      var i;\n      if (!t)\n        return;\n      const r = async () => {\n        try {\n          const o = await t.getActiveAddress();\n          e({\n            type: \"UPDATE_ADDRESS\",\n            payload: o\n          });\n        } catch (o) {\n          console.error(\n            `[Arweave Wallet Kit] Failed to sync address\n${(o == null ? void 0 : o.message) || o}`\n          );\n        }\n      };\n      await r();\n      const n = (i = t.addAddressEvent) == null ? void 0 : i.call(\n        t,\n        (o) => e({\n          type: \"UPDATE_ADDRESS\",\n          payload: o\n        })\n      );\n      return addEventListener(\"focus\", r), () => {\n        n && t.removeAddressEvent && t.removeAddressEvent(n), removeEventListener(\"focus\", r);\n      };\n    })();\n  }, [t, e]);\n}\nfunction o2() {\n  const [t, e] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(), r = ir(), n = Uo();\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    (async () => !r || !r.getActivePublicKey || e(await r.getActivePublicKey()))();\n  }, [n, r]), t;\n}\nfunction Mg() {\n  const [t, e] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]), r = Uo(), { state: n } = _t(), i = ir();\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    (async () => {\n      if (!i)\n        return e([]);\n      const o = async () => {\n        try {\n          e(await i.getAllAddresses());\n        } catch (a) {\n          console.error(\n            `[Arweave Wallet Kit] Failed to sync addresses\n${(a == null ? void 0 : a.message) || a}`\n          );\n        }\n      };\n      return await o(), addEventListener(\"focus\", o), () => removeEventListener(\"focus\", o);\n    })();\n  }, [r, n, i]), t;\n}\nfunction s2() {\n  const [t, e] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({}), r = Mg(), { state: n } = _t(), i = ir();\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    (async () => {\n      if (!i || !i.getWalletNames)\n        return e({});\n      try {\n        const o = await i.getWalletNames();\n        e(o);\n      } catch (o) {\n        console.error(\n          `[Arweave Wallet Kit] Failed to sync wallet names\n${(o == null ? void 0 : o.message) || o}`\n        );\n      }\n    })();\n  }, [r, n == null ? void 0 : n.activeStrategy]), t;\n}\nvar Wn = {}, kg = {\n  get exports() {\n    return Wn;\n  },\n  set exports(t) {\n    Wn = t;\n  }\n}, En = {};\n/**\n * @license React\n * react-jsx-runtime.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar ef;\nfunction Rg() {\n  if (ef)\n    return En;\n  ef = 1;\n  var t = react__WEBPACK_IMPORTED_MODULE_0__, e = Symbol.for(\"react.element\"), r = Symbol.for(\"react.fragment\"), n = Object.prototype.hasOwnProperty, i = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, o = { key: !0, ref: !0, __self: !0, __source: !0 };\n  function a(s, l, u) {\n    var c, f = {}, h = null, p = null;\n    u !== void 0 && (h = \"\" + u), l.key !== void 0 && (h = \"\" + l.key), l.ref !== void 0 && (p = l.ref);\n    for (c in l)\n      n.call(l, c) && !o.hasOwnProperty(c) && (f[c] = l[c]);\n    if (s && s.defaultProps)\n      for (c in l = s.defaultProps, l)\n        f[c] === void 0 && (f[c] = l[c]);\n    return { $$typeof: e, type: s, key: h, ref: p, props: f, _owner: i.current };\n  }\n  return En.Fragment = r, En.jsx = a, En.jsxs = a, En;\n}\nvar Sn = {};\n/**\n * @license React\n * react-jsx-runtime.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar tf;\nfunction Bg() {\n  return tf || (tf = 1,  true && function() {\n    var t = react__WEBPACK_IMPORTED_MODULE_0__, e = Symbol.for(\"react.element\"), r = Symbol.for(\"react.portal\"), n = Symbol.for(\"react.fragment\"), i = Symbol.for(\"react.strict_mode\"), o = Symbol.for(\"react.profiler\"), a = Symbol.for(\"react.provider\"), s = Symbol.for(\"react.context\"), l = Symbol.for(\"react.forward_ref\"), u = Symbol.for(\"react.suspense\"), c = Symbol.for(\"react.suspense_list\"), f = Symbol.for(\"react.memo\"), h = Symbol.for(\"react.lazy\"), p = Symbol.for(\"react.offscreen\"), g = Symbol.iterator, _ = \"@@iterator\";\n    function T(q) {\n      if (q === null || typeof q != \"object\")\n        return null;\n      var le = g && q[g] || q[_];\n      return typeof le == \"function\" ? le : null;\n    }\n    var A = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n    function w(q) {\n      {\n        for (var le = arguments.length, ge = new Array(le > 1 ? le - 1 : 0), xe = 1; xe < le; xe++)\n          ge[xe - 1] = arguments[xe];\n        O(\"error\", q, ge);\n      }\n    }\n    function O(q, le, ge) {\n      {\n        var xe = A.ReactDebugCurrentFrame, Ee = xe.getStackAddendum();\n        Ee !== \"\" && (le += \"%s\", ge = ge.concat([Ee]));\n        var Fe = ge.map(function(Re) {\n          return String(Re);\n        });\n        Fe.unshift(\"Warning: \" + le), Function.prototype.apply.call(console[q], console, Fe);\n      }\n    }\n    var R = !1, $ = !1, U = !1, W = !1, G = !1, Z;\n    Z = Symbol.for(\"react.module.reference\");\n    function j(q) {\n      return !!(typeof q == \"string\" || typeof q == \"function\" || q === n || q === o || G || q === i || q === u || q === c || W || q === p || R || $ || U || typeof q == \"object\" && q !== null && (q.$$typeof === h || q.$$typeof === f || q.$$typeof === a || q.$$typeof === s || q.$$typeof === l || // This needs to include all possible module reference object\n      // types supported by any Flight configuration anywhere since\n      // we don't know which Flight build this will end up being used\n      // with.\n      q.$$typeof === Z || q.getModuleId !== void 0));\n    }\n    function P(q, le, ge) {\n      var xe = q.displayName;\n      if (xe)\n        return xe;\n      var Ee = le.displayName || le.name || \"\";\n      return Ee !== \"\" ? ge + \"(\" + Ee + \")\" : ge;\n    }\n    function d(q) {\n      return q.displayName || \"Context\";\n    }\n    function x(q) {\n      if (q == null)\n        return null;\n      if (typeof q.tag == \"number\" && w(\"Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.\"), typeof q == \"function\")\n        return q.displayName || q.name || null;\n      if (typeof q == \"string\")\n        return q;\n      switch (q) {\n        case n:\n          return \"Fragment\";\n        case r:\n          return \"Portal\";\n        case o:\n          return \"Profiler\";\n        case i:\n          return \"StrictMode\";\n        case u:\n          return \"Suspense\";\n        case c:\n          return \"SuspenseList\";\n      }\n      if (typeof q == \"object\")\n        switch (q.$$typeof) {\n          case s:\n            var le = q;\n            return d(le) + \".Consumer\";\n          case a:\n            var ge = q;\n            return d(ge._context) + \".Provider\";\n          case l:\n            return P(q, q.render, \"ForwardRef\");\n          case f:\n            var xe = q.displayName || null;\n            return xe !== null ? xe : x(q.type) || \"Memo\";\n          case h: {\n            var Ee = q, Fe = Ee._payload, Re = Ee._init;\n            try {\n              return x(Re(Fe));\n            } catch {\n              return null;\n            }\n          }\n        }\n      return null;\n    }\n    var C = Object.assign, M = 0, D, z, Y, L, m, E, B;\n    function V() {\n    }\n    V.__reactDisabledLog = !0;\n    function I() {\n      {\n        if (M === 0) {\n          D = console.log, z = console.info, Y = console.warn, L = console.error, m = console.group, E = console.groupCollapsed, B = console.groupEnd;\n          var q = {\n            configurable: !0,\n            enumerable: !0,\n            value: V,\n            writable: !0\n          };\n          Object.defineProperties(console, {\n            info: q,\n            log: q,\n            warn: q,\n            error: q,\n            group: q,\n            groupCollapsed: q,\n            groupEnd: q\n          });\n        }\n        M++;\n      }\n    }\n    function ne() {\n      {\n        if (M--, M === 0) {\n          var q = {\n            configurable: !0,\n            enumerable: !0,\n            writable: !0\n          };\n          Object.defineProperties(console, {\n            log: C({}, q, {\n              value: D\n            }),\n            info: C({}, q, {\n              value: z\n            }),\n            warn: C({}, q, {\n              value: Y\n            }),\n            error: C({}, q, {\n              value: L\n            }),\n            group: C({}, q, {\n              value: m\n            }),\n            groupCollapsed: C({}, q, {\n              value: E\n            }),\n            groupEnd: C({}, q, {\n              value: B\n            })\n          });\n        }\n        M < 0 && w(\"disabledDepth fell below zero. This is a bug in React. Please file an issue.\");\n      }\n    }\n    var se = A.ReactCurrentDispatcher, ce;\n    function oe(q, le, ge) {\n      {\n        if (ce === void 0)\n          try {\n            throw Error();\n          } catch (Ee) {\n            var xe = Ee.stack.trim().match(/\\n( *(at )?)/);\n            ce = xe && xe[1] || \"\";\n          }\n        return `\n` + ce + q;\n      }\n    }\n    var he = !1, k;\n    {\n      var H = typeof WeakMap == \"function\" ? WeakMap : Map;\n      k = new H();\n    }\n    function N(q, le) {\n      if (!q || he)\n        return \"\";\n      {\n        var ge = k.get(q);\n        if (ge !== void 0)\n          return ge;\n      }\n      var xe;\n      he = !0;\n      var Ee = Error.prepareStackTrace;\n      Error.prepareStackTrace = void 0;\n      var Fe;\n      Fe = se.current, se.current = null, I();\n      try {\n        if (le) {\n          var Re = function() {\n            throw Error();\n          };\n          if (Object.defineProperty(Re.prototype, \"props\", {\n            set: function() {\n              throw Error();\n            }\n          }), typeof Reflect == \"object\" && Reflect.construct) {\n            try {\n              Reflect.construct(Re, []);\n            } catch (Ot) {\n              xe = Ot;\n            }\n            Reflect.construct(q, [], Re);\n          } else {\n            try {\n              Re.call();\n            } catch (Ot) {\n              xe = Ot;\n            }\n            q.call(Re.prototype);\n          }\n        } else {\n          try {\n            throw Error();\n          } catch (Ot) {\n            xe = Ot;\n          }\n          q();\n        }\n      } catch (Ot) {\n        if (Ot && xe && typeof Ot.stack == \"string\") {\n          for (var ke = Ot.stack.split(`\n`), ht = xe.stack.split(`\n`), tt = ke.length - 1, it = ht.length - 1; tt >= 1 && it >= 0 && ke[tt] !== ht[it]; )\n            it--;\n          for (; tt >= 1 && it >= 0; tt--, it--)\n            if (ke[tt] !== ht[it]) {\n              if (tt !== 1 || it !== 1)\n                do\n                  if (tt--, it--, it < 0 || ke[tt] !== ht[it]) {\n                    var xt = `\n` + ke[tt].replace(\" at new \", \" at \");\n                    return q.displayName && xt.includes(\"<anonymous>\") && (xt = xt.replace(\"<anonymous>\", q.displayName)), typeof q == \"function\" && k.set(q, xt), xt;\n                  }\n                while (tt >= 1 && it >= 0);\n              break;\n            }\n        }\n      } finally {\n        he = !1, se.current = Fe, ne(), Error.prepareStackTrace = Ee;\n      }\n      var Zt = q ? q.displayName || q.name : \"\", Kr = Zt ? oe(Zt) : \"\";\n      return typeof q == \"function\" && k.set(q, Kr), Kr;\n    }\n    function J(q, le, ge) {\n      return N(q, !1);\n    }\n    function Q(q) {\n      var le = q.prototype;\n      return !!(le && le.isReactComponent);\n    }\n    function ee(q, le, ge) {\n      if (q == null)\n        return \"\";\n      if (typeof q == \"function\")\n        return N(q, Q(q));\n      if (typeof q == \"string\")\n        return oe(q);\n      switch (q) {\n        case u:\n          return oe(\"Suspense\");\n        case c:\n          return oe(\"SuspenseList\");\n      }\n      if (typeof q == \"object\")\n        switch (q.$$typeof) {\n          case l:\n            return J(q.render);\n          case f:\n            return ee(q.type, le, ge);\n          case h: {\n            var xe = q, Ee = xe._payload, Fe = xe._init;\n            try {\n              return ee(Fe(Ee), le, ge);\n            } catch {\n            }\n          }\n        }\n      return \"\";\n    }\n    var S = Object.prototype.hasOwnProperty, y = {}, v = A.ReactDebugCurrentFrame;\n    function b(q) {\n      if (q) {\n        var le = q._owner, ge = ee(q.type, q._source, le ? le.type : null);\n        v.setExtraStackFrame(ge);\n      } else\n        v.setExtraStackFrame(null);\n    }\n    function F(q, le, ge, xe, Ee) {\n      {\n        var Fe = Function.call.bind(S);\n        for (var Re in q)\n          if (Fe(q, Re)) {\n            var ke = void 0;\n            try {\n              if (typeof q[Re] != \"function\") {\n                var ht = Error((xe || \"React class\") + \": \" + ge + \" type `\" + Re + \"` is invalid; it must be a function, usually from the `prop-types` package, but received `\" + typeof q[Re] + \"`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.\");\n                throw ht.name = \"Invariant Violation\", ht;\n              }\n              ke = q[Re](le, Re, xe, ge, null, \"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED\");\n            } catch (tt) {\n              ke = tt;\n            }\n            ke && !(ke instanceof Error) && (b(Ee), w(\"%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).\", xe || \"React class\", ge, Re, typeof ke), b(null)), ke instanceof Error && !(ke.message in y) && (y[ke.message] = !0, b(Ee), w(\"Failed %s type: %s\", ge, ke.message), b(null));\n          }\n      }\n    }\n    var K = Array.isArray;\n    function te(q) {\n      return K(q);\n    }\n    function de(q) {\n      {\n        var le = typeof Symbol == \"function\" && Symbol.toStringTag, ge = le && q[Symbol.toStringTag] || q.constructor.name || \"Object\";\n        return ge;\n      }\n    }\n    function pe(q) {\n      try {\n        return X(q), !1;\n      } catch {\n        return !0;\n      }\n    }\n    function X(q) {\n      return \"\" + q;\n    }\n    function ie(q) {\n      if (pe(q))\n        return w(\"The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.\", de(q)), X(q);\n    }\n    var re = A.ReactCurrentOwner, ae = {\n      key: !0,\n      ref: !0,\n      __self: !0,\n      __source: !0\n    }, me, Te, ve;\n    ve = {};\n    function _e(q) {\n      if (S.call(q, \"ref\")) {\n        var le = Object.getOwnPropertyDescriptor(q, \"ref\").get;\n        if (le && le.isReactWarning)\n          return !1;\n      }\n      return q.ref !== void 0;\n    }\n    function ye(q) {\n      if (S.call(q, \"key\")) {\n        var le = Object.getOwnPropertyDescriptor(q, \"key\").get;\n        if (le && le.isReactWarning)\n          return !1;\n      }\n      return q.key !== void 0;\n    }\n    function we(q, le) {\n      if (typeof q.ref == \"string\" && re.current && le && re.current.stateNode !== le) {\n        var ge = x(re.current.type);\n        ve[ge] || (w('Component \"%s\" contains the string ref \"%s\". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', x(re.current.type), q.ref), ve[ge] = !0);\n      }\n    }\n    function Ae(q, le) {\n      {\n        var ge = function() {\n          me || (me = !0, w(\"%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)\", le));\n        };\n        ge.isReactWarning = !0, Object.defineProperty(q, \"key\", {\n          get: ge,\n          configurable: !0\n        });\n      }\n    }\n    function Pe(q, le) {\n      {\n        var ge = function() {\n          Te || (Te = !0, w(\"%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)\", le));\n        };\n        ge.isReactWarning = !0, Object.defineProperty(q, \"ref\", {\n          get: ge,\n          configurable: !0\n        });\n      }\n    }\n    var Se = function(q, le, ge, xe, Ee, Fe, Re) {\n      var ke = {\n        // This tag allows us to uniquely identify this as a React Element\n        $$typeof: e,\n        // Built-in properties that belong on the element\n        type: q,\n        key: le,\n        ref: ge,\n        props: Re,\n        // Record the component responsible for creating this element.\n        _owner: Fe\n      };\n      return ke._store = {}, Object.defineProperty(ke._store, \"validated\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: !1\n      }), Object.defineProperty(ke, \"_self\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !1,\n        value: xe\n      }), Object.defineProperty(ke, \"_source\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !1,\n        value: Ee\n      }), Object.freeze && (Object.freeze(ke.props), Object.freeze(ke)), ke;\n    };\n    function Sr(q, le, ge, xe, Ee) {\n      {\n        var Fe, Re = {}, ke = null, ht = null;\n        ge !== void 0 && (ie(ge), ke = \"\" + ge), ye(le) && (ie(le.key), ke = \"\" + le.key), _e(le) && (ht = le.ref, we(le, Ee));\n        for (Fe in le)\n          S.call(le, Fe) && !ae.hasOwnProperty(Fe) && (Re[Fe] = le[Fe]);\n        if (q && q.defaultProps) {\n          var tt = q.defaultProps;\n          for (Fe in tt)\n            Re[Fe] === void 0 && (Re[Fe] = tt[Fe]);\n        }\n        if (ke || ht) {\n          var it = typeof q == \"function\" ? q.displayName || q.name || \"Unknown\" : q;\n          ke && Ae(Re, it), ht && Pe(Re, it);\n        }\n        return Se(q, ke, ht, Ee, xe, re.current, Re);\n      }\n    }\n    var ze = A.ReactCurrentOwner, qe = A.ReactDebugCurrentFrame;\n    function zt(q) {\n      if (q) {\n        var le = q._owner, ge = ee(q.type, q._source, le ? le.type : null);\n        qe.setExtraStackFrame(ge);\n      } else\n        qe.setExtraStackFrame(null);\n    }\n    var We;\n    We = !1;\n    function Ke(q) {\n      return typeof q == \"object\" && q !== null && q.$$typeof === e;\n    }\n    function Pr() {\n      {\n        if (ze.current) {\n          var q = x(ze.current.type);\n          if (q)\n            return `\n\nCheck the render method of \\`` + q + \"`.\";\n        }\n        return \"\";\n      }\n    }\n    function rt(q) {\n      {\n        if (q !== void 0) {\n          var le = q.fileName.replace(/^.*[\\\\\\/]/, \"\"), ge = q.lineNumber;\n          return `\n\nCheck your code at ` + le + \":\" + ge + \".\";\n        }\n        return \"\";\n      }\n    }\n    var Ge = {};\n    function zr(q) {\n      {\n        var le = Pr();\n        if (!le) {\n          var ge = typeof q == \"string\" ? q : q.displayName || q.name;\n          ge && (le = `\n\nCheck the top-level render call using <` + ge + \">.\");\n        }\n        return le;\n      }\n    }\n    function Je(q, le) {\n      {\n        if (!q._store || q._store.validated || q.key != null)\n          return;\n        q._store.validated = !0;\n        var ge = zr(le);\n        if (Ge[ge])\n          return;\n        Ge[ge] = !0;\n        var xe = \"\";\n        q && q._owner && q._owner !== ze.current && (xe = \" It was passed a child from \" + x(q._owner.type) + \".\"), zt(q), w('Each child in a list should have a unique \"key\" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', ge, xe), zt(null);\n      }\n    }\n    function Ye(q, le) {\n      {\n        if (typeof q != \"object\")\n          return;\n        if (te(q))\n          for (var ge = 0; ge < q.length; ge++) {\n            var xe = q[ge];\n            Ke(xe) && Je(xe, le);\n          }\n        else if (Ke(q))\n          q._store && (q._store.validated = !0);\n        else if (q) {\n          var Ee = T(q);\n          if (typeof Ee == \"function\" && Ee !== q.entries)\n            for (var Fe = Ee.call(q), Re; !(Re = Fe.next()).done; )\n              Ke(Re.value) && Je(Re.value, le);\n        }\n      }\n    }\n    function qr(q) {\n      {\n        var le = q.type;\n        if (le == null || typeof le == \"string\")\n          return;\n        var ge;\n        if (typeof le == \"function\")\n          ge = le.propTypes;\n        else if (typeof le == \"object\" && (le.$$typeof === l || // Note: Memo only checks outer props here.\n        // Inner props are checked in the reconciler.\n        le.$$typeof === f))\n          ge = le.propTypes;\n        else\n          return;\n        if (ge) {\n          var xe = x(le);\n          F(ge, q.props, \"prop\", xe, q);\n        } else if (le.PropTypes !== void 0 && !We) {\n          We = !0;\n          var Ee = x(le);\n          w(\"Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?\", Ee || \"Unknown\");\n        }\n        typeof le.getDefaultProps == \"function\" && !le.getDefaultProps.isReactClassApproved && w(\"getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.\");\n      }\n    }\n    function Qe(q) {\n      {\n        for (var le = Object.keys(q.props), ge = 0; ge < le.length; ge++) {\n          var xe = le[ge];\n          if (xe !== \"children\" && xe !== \"key\") {\n            zt(q), w(\"Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.\", xe), zt(null);\n            break;\n          }\n        }\n        q.ref !== null && (zt(q), w(\"Invalid attribute `ref` supplied to `React.Fragment`.\"), zt(null));\n      }\n    }\n    function Be(q, le, ge, xe, Ee, Fe) {\n      {\n        var Re = j(q);\n        if (!Re) {\n          var ke = \"\";\n          (q === void 0 || typeof q == \"object\" && q !== null && Object.keys(q).length === 0) && (ke += \" You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.\");\n          var ht = rt(Ee);\n          ht ? ke += ht : ke += Pr();\n          var tt;\n          q === null ? tt = \"null\" : te(q) ? tt = \"array\" : q !== void 0 && q.$$typeof === e ? (tt = \"<\" + (x(q.type) || \"Unknown\") + \" />\", ke = \" Did you accidentally export a JSX literal instead of a component?\") : tt = typeof q, w(\"React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s\", tt, ke);\n        }\n        var it = Sr(q, le, ge, Ee, Fe);\n        if (it == null)\n          return it;\n        if (Re) {\n          var xt = le.children;\n          if (xt !== void 0)\n            if (xe)\n              if (te(xt)) {\n                for (var Zt = 0; Zt < xt.length; Zt++)\n                  Ye(xt[Zt], q);\n                Object.freeze && Object.freeze(xt);\n              } else\n                w(\"React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.\");\n            else\n              Ye(xt, q);\n        }\n        return q === n ? Qe(it) : qr(it), it;\n      }\n    }\n    function Ct(q, le, ge) {\n      return Be(q, le, ge, !0);\n    }\n    function et(q, le, ge) {\n      return Be(q, le, ge, !1);\n    }\n    var nt = et, ci = Ct;\n    Sn.Fragment = n, Sn.jsx = nt, Sn.jsxs = ci;\n  }()), Sn;\n}\n(function(t) {\n   false ? 0 : t.exports = Bg();\n})(kg);\nconst zn = Wn.Fragment, be = Wn.jsx, Ue = Wn.jsxs;\nfunction Ig(t) {\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"svg\", Object.assign({\n    width: 24,\n    height: 24,\n    fill: \"none\",\n    viewBox: \"0 0 24 24\"\n  }, t), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", {\n    stroke: \"currentColor\",\n    strokeLinecap: \"round\",\n    strokeLinejoin: \"round\",\n    strokeWidth: 1.5,\n    d: \"M15.25 10.75L12 14.25L8.75 10.75\"\n  }));\n}\nfunction Dg(t) {\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"svg\", Object.assign({\n    width: 24,\n    height: 24,\n    fill: \"none\",\n    viewBox: \"0 0 24 24\"\n  }, t), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", {\n    stroke: \"currentColor\",\n    strokeLinecap: \"round\",\n    strokeLinejoin: \"round\",\n    strokeWidth: 1.5,\n    d: \"M13.25 8.75L9.75 12L13.25 15.25\"\n  }));\n}\nfunction Ng(t) {\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"svg\", Object.assign({\n    width: 24,\n    height: 24,\n    fill: \"none\",\n    viewBox: \"0 0 24 24\"\n  }, t), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", {\n    stroke: \"currentColor\",\n    strokeLinecap: \"round\",\n    strokeLinejoin: \"round\",\n    strokeWidth: 1.5,\n    d: \"M17.25 6.75L6.75 17.25\"\n  }), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", {\n    stroke: \"currentColor\",\n    strokeLinecap: \"round\",\n    strokeLinejoin: \"round\",\n    strokeWidth: 1.5,\n    d: \"M6.75 6.75L17.25 17.25\"\n  }));\n}\nfunction Fg(t) {\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"svg\", Object.assign({\n    width: 24,\n    height: 24,\n    fill: \"none\",\n    viewBox: \"0 0 24 24\"\n  }, t), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", {\n    stroke: \"currentColor\",\n    strokeLinecap: \"round\",\n    strokeLinejoin: \"round\",\n    strokeWidth: 1.5,\n    d: \"M6.5 15.25V15.25C5.5335 15.25 4.75 14.4665 4.75 13.5V6.75C4.75 5.64543 5.64543 4.75 6.75 4.75H13.5C14.4665 4.75 15.25 5.5335 15.25 6.5V6.5\"\n  }), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"rect\", {\n    width: 10.5,\n    height: 10.5,\n    x: 8.75,\n    y: 8.75,\n    stroke: \"currentColor\",\n    strokeLinecap: \"round\",\n    strokeLinejoin: \"round\",\n    strokeWidth: 1.5,\n    rx: 2\n  }));\n}\nfunction Lg(t) {\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"svg\", Object.assign({\n    width: 24,\n    height: 24,\n    fill: \"none\",\n    viewBox: \"0 0 24 24\"\n  }, t), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", {\n    stroke: \"currentColor\",\n    strokeLinecap: \"round\",\n    strokeLinejoin: \"round\",\n    strokeWidth: 1.5,\n    d: \"M15.75 8.75L19.25 12L15.75 15.25\"\n  }), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", {\n    stroke: \"currentColor\",\n    strokeLinecap: \"round\",\n    strokeLinejoin: \"round\",\n    strokeWidth: 1.5,\n    d: \"M19 12H10.75\"\n  }), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", {\n    stroke: \"currentColor\",\n    strokeLinecap: \"round\",\n    strokeLinejoin: \"round\",\n    strokeWidth: 1.5,\n    d: \"M15.25 4.75H6.75C5.64543 4.75 4.75 5.64543 4.75 6.75V17.25C4.75 18.3546 5.64543 19.25 6.75 19.25H15.25\"\n  }));\n}\nfunction Bh(t) {\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"svg\", Object.assign({\n    width: 24,\n    height: 24,\n    fill: \"none\",\n    viewBox: \"0 0 24 24\"\n  }, t), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"circle\", {\n    cx: 12,\n    cy: 8,\n    r: 3.25,\n    stroke: \"currentColor\",\n    strokeLinecap: \"round\",\n    strokeLinejoin: \"round\",\n    strokeWidth: 1.5\n  }), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", {\n    stroke: \"currentColor\",\n    strokeLinecap: \"round\",\n    strokeLinejoin: \"round\",\n    strokeWidth: 1.5,\n    d: \"M6.8475 19.25H17.1525C18.2944 19.25 19.174 18.2681 18.6408 17.2584C17.8563 15.7731 16.068 14 12 14C7.93201 14 6.14367 15.7731 5.35924 17.2584C4.82597 18.2681 5.70558 19.25 6.8475 19.25Z\"\n  }));\n}\nvar gc = {}, po = {}, jg = {\n  get exports() {\n    return po;\n  },\n  set exports(t) {\n    po = t;\n  }\n};\n(function(t, e) {\n  (function(r, n) {\n    t.exports = n();\n  })(ue, function() {\n    var r = function(w) {\n      return n(w) && !i(w);\n    };\n    function n(A) {\n      return !!A && typeof A == \"object\";\n    }\n    function i(A) {\n      var w = Object.prototype.toString.call(A);\n      return w === \"[object RegExp]\" || w === \"[object Date]\" || s(A);\n    }\n    var o = typeof Symbol == \"function\" && Symbol.for, a = o ? Symbol.for(\"react.element\") : 60103;\n    function s(A) {\n      return A.$$typeof === a;\n    }\n    function l(A) {\n      return Array.isArray(A) ? [] : {};\n    }\n    function u(A, w) {\n      return w.clone !== !1 && w.isMergeableObject(A) ? _(l(A), A, w) : A;\n    }\n    function c(A, w, O) {\n      return A.concat(w).map(function(R) {\n        return u(R, O);\n      });\n    }\n    function f(A, w) {\n      if (!w.customMerge)\n        return _;\n      var O = w.customMerge(A);\n      return typeof O == \"function\" ? O : _;\n    }\n    function h(A) {\n      return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(A).filter(function(w) {\n        return A.propertyIsEnumerable(w);\n      }) : [];\n    }\n    function p(A) {\n      return Object.keys(A).concat(h(A));\n    }\n    function g(A, w, O) {\n      var R = {};\n      return O.isMergeableObject(A) && p(A).forEach(function($) {\n        R[$] = u(A[$], O);\n      }), p(w).forEach(function($) {\n        !O.isMergeableObject(w[$]) || !A[$] ? R[$] = u(w[$], O) : R[$] = f($, O)(A[$], w[$], O);\n      }), R;\n    }\n    function _(A, w, O) {\n      O = O || {}, O.arrayMerge = O.arrayMerge || c, O.isMergeableObject = O.isMergeableObject || r;\n      var R = Array.isArray(w), $ = Array.isArray(A), U = R === $;\n      return U ? R ? O.arrayMerge(A, w, O) : g(A, w, O) : u(w, O);\n    }\n    _.all = function(w, O) {\n      if (!Array.isArray(w))\n        throw new Error(\"first argument should be an array\");\n      return w.reduce(function(R, $) {\n        return _(R, $, O);\n      }, {});\n    };\n    var T = _;\n    return T;\n  });\n})(jg);\nvar Vo = {};\nVo.__esModule = !0;\nVo.default = void 0;\nvar rf = Ug(react__WEBPACK_IMPORTED_MODULE_0__);\nfunction Ug(t) {\n  if (t && t.__esModule)\n    return t;\n  var e = {};\n  if (t != null) {\n    for (var r in t)\n      if (Object.prototype.hasOwnProperty.call(t, r)) {\n        var n = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(t, r) : {};\n        n.get || n.set ? Object.defineProperty(e, r, n) : e[r] = t[r];\n      }\n  }\n  return e.default = t, e;\n}\nfunction Vg(t, e) {\n  t.prototype = Object.create(e.prototype), t.prototype.constructor = t, t.__proto__ = e;\n}\nfunction $g(t, e, r) {\n  return e in t ? Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = r, t;\n}\nfunction Hg(t, e) {\n  var r, n;\n  return n = r = /* @__PURE__ */ function(i) {\n    Vg(o, i);\n    function o() {\n      return i.apply(this, arguments) || this;\n    }\n    var a = o.prototype;\n    return a.render = function() {\n      return rf.createElement(e.Provider, {\n        value: this.props.theme\n      }, this.props.children);\n    }, o;\n  }(rf.Component), $g(r, \"defaultProps\", {\n    theme: t\n  }), n;\n}\nvar Wg = Hg;\nVo.default = Wg;\nvar $o = {}, yo = {}, zg = {\n  get exports() {\n    return yo;\n  },\n  set exports(t) {\n    yo = t;\n  }\n}, Le = {};\n/** @license React v16.13.1\n * react-is.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar nf;\nfunction qg() {\n  if (nf)\n    return Le;\n  nf = 1;\n  var t = typeof Symbol == \"function\" && Symbol.for, e = t ? Symbol.for(\"react.element\") : 60103, r = t ? Symbol.for(\"react.portal\") : 60106, n = t ? Symbol.for(\"react.fragment\") : 60107, i = t ? Symbol.for(\"react.strict_mode\") : 60108, o = t ? Symbol.for(\"react.profiler\") : 60114, a = t ? Symbol.for(\"react.provider\") : 60109, s = t ? Symbol.for(\"react.context\") : 60110, l = t ? Symbol.for(\"react.async_mode\") : 60111, u = t ? Symbol.for(\"react.concurrent_mode\") : 60111, c = t ? Symbol.for(\"react.forward_ref\") : 60112, f = t ? Symbol.for(\"react.suspense\") : 60113, h = t ? Symbol.for(\"react.suspense_list\") : 60120, p = t ? Symbol.for(\"react.memo\") : 60115, g = t ? Symbol.for(\"react.lazy\") : 60116, _ = t ? Symbol.for(\"react.block\") : 60121, T = t ? Symbol.for(\"react.fundamental\") : 60117, A = t ? Symbol.for(\"react.responder\") : 60118, w = t ? Symbol.for(\"react.scope\") : 60119;\n  function O($) {\n    if (typeof $ == \"object\" && $ !== null) {\n      var U = $.$$typeof;\n      switch (U) {\n        case e:\n          switch ($ = $.type, $) {\n            case l:\n            case u:\n            case n:\n            case o:\n            case i:\n            case f:\n              return $;\n            default:\n              switch ($ = $ && $.$$typeof, $) {\n                case s:\n                case c:\n                case g:\n                case p:\n                case a:\n                  return $;\n                default:\n                  return U;\n              }\n          }\n        case r:\n          return U;\n      }\n    }\n  }\n  function R($) {\n    return O($) === u;\n  }\n  return Le.AsyncMode = l, Le.ConcurrentMode = u, Le.ContextConsumer = s, Le.ContextProvider = a, Le.Element = e, Le.ForwardRef = c, Le.Fragment = n, Le.Lazy = g, Le.Memo = p, Le.Portal = r, Le.Profiler = o, Le.StrictMode = i, Le.Suspense = f, Le.isAsyncMode = function($) {\n    return R($) || O($) === l;\n  }, Le.isConcurrentMode = R, Le.isContextConsumer = function($) {\n    return O($) === s;\n  }, Le.isContextProvider = function($) {\n    return O($) === a;\n  }, Le.isElement = function($) {\n    return typeof $ == \"object\" && $ !== null && $.$$typeof === e;\n  }, Le.isForwardRef = function($) {\n    return O($) === c;\n  }, Le.isFragment = function($) {\n    return O($) === n;\n  }, Le.isLazy = function($) {\n    return O($) === g;\n  }, Le.isMemo = function($) {\n    return O($) === p;\n  }, Le.isPortal = function($) {\n    return O($) === r;\n  }, Le.isProfiler = function($) {\n    return O($) === o;\n  }, Le.isStrictMode = function($) {\n    return O($) === i;\n  }, Le.isSuspense = function($) {\n    return O($) === f;\n  }, Le.isValidElementType = function($) {\n    return typeof $ == \"string\" || typeof $ == \"function\" || $ === n || $ === u || $ === o || $ === i || $ === f || $ === h || typeof $ == \"object\" && $ !== null && ($.$$typeof === g || $.$$typeof === p || $.$$typeof === a || $.$$typeof === s || $.$$typeof === c || $.$$typeof === T || $.$$typeof === A || $.$$typeof === w || $.$$typeof === _);\n  }, Le.typeOf = O, Le;\n}\nvar je = {};\n/** @license React v16.13.1\n * react-is.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar of;\nfunction Kg() {\n  return of || (of = 1,  true && function() {\n    var t = typeof Symbol == \"function\" && Symbol.for, e = t ? Symbol.for(\"react.element\") : 60103, r = t ? Symbol.for(\"react.portal\") : 60106, n = t ? Symbol.for(\"react.fragment\") : 60107, i = t ? Symbol.for(\"react.strict_mode\") : 60108, o = t ? Symbol.for(\"react.profiler\") : 60114, a = t ? Symbol.for(\"react.provider\") : 60109, s = t ? Symbol.for(\"react.context\") : 60110, l = t ? Symbol.for(\"react.async_mode\") : 60111, u = t ? Symbol.for(\"react.concurrent_mode\") : 60111, c = t ? Symbol.for(\"react.forward_ref\") : 60112, f = t ? Symbol.for(\"react.suspense\") : 60113, h = t ? Symbol.for(\"react.suspense_list\") : 60120, p = t ? Symbol.for(\"react.memo\") : 60115, g = t ? Symbol.for(\"react.lazy\") : 60116, _ = t ? Symbol.for(\"react.block\") : 60121, T = t ? Symbol.for(\"react.fundamental\") : 60117, A = t ? Symbol.for(\"react.responder\") : 60118, w = t ? Symbol.for(\"react.scope\") : 60119;\n    function O(N) {\n      return typeof N == \"string\" || typeof N == \"function\" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.\n      N === n || N === u || N === o || N === i || N === f || N === h || typeof N == \"object\" && N !== null && (N.$$typeof === g || N.$$typeof === p || N.$$typeof === a || N.$$typeof === s || N.$$typeof === c || N.$$typeof === T || N.$$typeof === A || N.$$typeof === w || N.$$typeof === _);\n    }\n    function R(N) {\n      if (typeof N == \"object\" && N !== null) {\n        var J = N.$$typeof;\n        switch (J) {\n          case e:\n            var Q = N.type;\n            switch (Q) {\n              case l:\n              case u:\n              case n:\n              case o:\n              case i:\n              case f:\n                return Q;\n              default:\n                var ee = Q && Q.$$typeof;\n                switch (ee) {\n                  case s:\n                  case c:\n                  case g:\n                  case p:\n                  case a:\n                    return ee;\n                  default:\n                    return J;\n                }\n            }\n          case r:\n            return J;\n        }\n      }\n    }\n    var $ = l, U = u, W = s, G = a, Z = e, j = c, P = n, d = g, x = p, C = r, M = o, D = i, z = f, Y = !1;\n    function L(N) {\n      return Y || (Y = !0, console.warn(\"The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.\")), m(N) || R(N) === l;\n    }\n    function m(N) {\n      return R(N) === u;\n    }\n    function E(N) {\n      return R(N) === s;\n    }\n    function B(N) {\n      return R(N) === a;\n    }\n    function V(N) {\n      return typeof N == \"object\" && N !== null && N.$$typeof === e;\n    }\n    function I(N) {\n      return R(N) === c;\n    }\n    function ne(N) {\n      return R(N) === n;\n    }\n    function se(N) {\n      return R(N) === g;\n    }\n    function ce(N) {\n      return R(N) === p;\n    }\n    function oe(N) {\n      return R(N) === r;\n    }\n    function he(N) {\n      return R(N) === o;\n    }\n    function k(N) {\n      return R(N) === i;\n    }\n    function H(N) {\n      return R(N) === f;\n    }\n    je.AsyncMode = $, je.ConcurrentMode = U, je.ContextConsumer = W, je.ContextProvider = G, je.Element = Z, je.ForwardRef = j, je.Fragment = P, je.Lazy = d, je.Memo = x, je.Portal = C, je.Profiler = M, je.StrictMode = D, je.Suspense = z, je.isAsyncMode = L, je.isConcurrentMode = m, je.isContextConsumer = E, je.isContextProvider = B, je.isElement = V, je.isForwardRef = I, je.isFragment = ne, je.isLazy = se, je.isMemo = ce, je.isPortal = oe, je.isProfiler = he, je.isStrictMode = k, je.isSuspense = H, je.isValidElementType = O, je.typeOf = R;\n  }()), je;\n}\nvar sf;\nfunction xc() {\n  return sf || (sf = 1, function(t) {\n     false ? 0 : t.exports = Kg();\n  }(zg)), yo;\n}\nvar wc = xc(), Gg = {\n  childContextTypes: !0,\n  contextType: !0,\n  contextTypes: !0,\n  defaultProps: !0,\n  displayName: !0,\n  getDefaultProps: !0,\n  getDerivedStateFromError: !0,\n  getDerivedStateFromProps: !0,\n  mixins: !0,\n  propTypes: !0,\n  type: !0\n}, Yg = {\n  name: !0,\n  length: !0,\n  prototype: !0,\n  caller: !0,\n  callee: !0,\n  arguments: !0,\n  arity: !0\n}, Zg = {\n  $$typeof: !0,\n  render: !0,\n  defaultProps: !0,\n  displayName: !0,\n  propTypes: !0\n}, Ih = {\n  $$typeof: !0,\n  compare: !0,\n  defaultProps: !0,\n  displayName: !0,\n  propTypes: !0,\n  type: !0\n}, bc = {};\nbc[wc.ForwardRef] = Zg;\nbc[wc.Memo] = Ih;\nfunction af(t) {\n  return wc.isMemo(t) ? Ih : bc[t.$$typeof] || Gg;\n}\nvar Xg = Object.defineProperty, Jg = Object.getOwnPropertyNames, cf = Object.getOwnPropertySymbols, Qg = Object.getOwnPropertyDescriptor, e1 = Object.getPrototypeOf, uf = Object.prototype;\nfunction Dh(t, e, r) {\n  if (typeof e != \"string\") {\n    if (uf) {\n      var n = e1(e);\n      n && n !== uf && Dh(t, n, r);\n    }\n    var i = Jg(e);\n    cf && (i = i.concat(cf(e)));\n    for (var o = af(t), a = af(e), s = 0; s < i.length; ++s) {\n      var l = i[s];\n      if (!Yg[l] && !(r && r[l]) && !(a && a[l]) && !(o && o[l])) {\n        var u = Qg(e, l);\n        try {\n          Xg(t, l, u);\n        } catch {\n        }\n      }\n    }\n  }\n  return t;\n}\nvar t1 = Dh;\n$o.__esModule = !0;\n$o.default = void 0;\nvar Pn = i1(react__WEBPACK_IMPORTED_MODULE_0__), r1 = Nh(po), n1 = Nh(t1);\nfunction Nh(t) {\n  return t && t.__esModule ? t : { default: t };\n}\nfunction i1(t) {\n  if (t && t.__esModule)\n    return t;\n  var e = {};\n  if (t != null) {\n    for (var r in t)\n      if (Object.prototype.hasOwnProperty.call(t, r)) {\n        var n = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(t, r) : {};\n        n.get || n.set ? Object.defineProperty(e, r, n) : e[r] = t[r];\n      }\n  }\n  return e.default = t, e;\n}\nfunction mo() {\n  return mo = Object.assign || function(t) {\n    for (var e = 1; e < arguments.length; e++) {\n      var r = arguments[e];\n      for (var n in r)\n        Object.prototype.hasOwnProperty.call(r, n) && (t[n] = r[n]);\n    }\n    return t;\n  }, mo.apply(this, arguments);\n}\nfunction o1(t, e) {\n  if (t == null)\n    return {};\n  var r = {}, n = Object.keys(t), i, o;\n  for (o = 0; o < n.length; o++)\n    i = n[o], !(e.indexOf(i) >= 0) && (r[i] = t[i]);\n  return r;\n}\nfunction lf(t) {\n  if (t === void 0)\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  return t;\n}\nfunction s1(t, e) {\n  t.prototype = Object.create(e.prototype), t.prototype.constructor = t, t.__proto__ = e;\n}\nfunction ff(t, e, r) {\n  return e in t ? Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = r, t;\n}\nvar a1 = function(e, r) {\n  return function(i) {\n    var o = /* @__PURE__ */ function(s) {\n      s1(l, s);\n      function l() {\n        for (var c, f = arguments.length, h = new Array(f), p = 0; p < f; p++)\n          h[p] = arguments[p];\n        return c = s.call.apply(s, [this].concat(h)) || this, ff(lf(c), \"_previous\", void 0), ff(lf(c), \"_merge\", function(g, _) {\n          var T = c._previous;\n          if (T && T.a === g && T.b === _)\n            return T.result;\n          var A = g && _ && g !== _ ? (0, r1.default)(g, _) : g || _;\n          return c._previous = {\n            a: g,\n            b: _,\n            result: A\n          }, A;\n        }), c;\n      }\n      var u = l.prototype;\n      return u.render = function() {\n        var f = this, h = this.props, p = h._reactThemeProviderForwardedRef, g = o1(h, [\"_reactThemeProviderForwardedRef\"]);\n        return Pn.createElement(r.Consumer, null, function(_) {\n          return Pn.createElement(i, mo({}, g, {\n            theme: f._merge(_, g.theme),\n            ref: p\n          }));\n        });\n      }, l;\n    }(Pn.Component), a = Pn.forwardRef(function(s, l) {\n      return Pn.createElement(o, mo({}, s, {\n        _reactThemeProviderForwardedRef: l\n      }));\n    });\n    return a.displayName = \"withTheme(\" + (i.displayName || i.name) + \")\", (0, n1.default)(a, i), a;\n  };\n}, c1 = a1;\n$o.default = c1;\ngc.__esModule = !0;\ngc.default = d1;\nvar Hs = h1(react__WEBPACK_IMPORTED_MODULE_0__), u1 = _c(po), l1 = _c(Vo), f1 = _c($o);\nfunction _c(t) {\n  return t && t.__esModule ? t : { default: t };\n}\nfunction h1(t) {\n  if (t && t.__esModule)\n    return t;\n  var e = {};\n  if (t != null) {\n    for (var r in t)\n      if (Object.prototype.hasOwnProperty.call(t, r)) {\n        var n = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(t, r) : {};\n        n.get || n.set ? Object.defineProperty(e, r, n) : e[r] = t[r];\n      }\n  }\n  return e.default = t, e;\n}\nfunction d1(t) {\n  var e = Hs.createContext(t), r = (0, l1.default)(t, e), n = (0, f1.default)(r, e), i = function(a) {\n    var s = Hs.useContext(e), l = Hs.useMemo(function() {\n      return s && a ? (0, u1.default)(s, a) : s || a;\n    }, [s, a]);\n    return l;\n  };\n  return {\n    ThemeContext: e,\n    ThemeProvider: r,\n    withTheme: n,\n    useTheme: i\n  };\n}\nvar p1 = m1(gc), y1 = p1.default;\nfunction m1(t) {\n  return t && t.__esModule ? t : { default: t };\n}\nconst Fh = {\n  primaryText: \"0, 0, 0\",\n  background: \"255, 255, 255\",\n  secondaryText: \"146, 146, 147\",\n  light: \"242, 242, 247\"\n}, v1 = {\n  primaryText: \"240, 240, 240\",\n  background: \"26, 27, 31\",\n  secondaryText: \"161, 161, 161\",\n  light: \"44, 45, 49\"\n}, g1 = {\n  displayTheme: \"light\",\n  accent: {\n    r: 0,\n    g: 0,\n    b: 0\n  },\n  titleHighlight: {\n    r: 0,\n    g: 122,\n    b: 255\n  },\n  radius: \"default\",\n  font: {\n    fontFamily: \"Manrope\"\n  }\n}, Lh = y1({\n  displayTheme: \"light\",\n  theme: \"0, 0, 0\",\n  themeConfig: g1,\n  ...Fh\n}), { ThemeProvider: x1, useTheme: a2 } = Lh, ft = Lh.withTheme || ((t) => t);\nfunction w1() {\n  const { state: t, dispatch: e } = _t(), r = ir();\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    (async () => r && e({\n      type: \"UPDATE_PERMISSIONS\",\n      payload: await r.getPermissions()\n    }))();\n  }, [e]), t.givenPermissions;\n}\nfunction b1() {\n  const { state: t, dispatch: e } = _t(), r = ir();\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    async function n() {\n      if (!r)\n        return o(), e({\n          type: \"UPDATE_PERMISSIONS\",\n          payload: []\n        });\n      try {\n        const s = await r.getPermissions();\n        e({\n          type: \"UPDATE_PERMISSIONS\",\n          payload: s\n        }), s.length === 0 && o();\n      } catch {\n        o(), e({\n          type: \"UPDATE_PERMISSIONS\",\n          payload: []\n        });\n      }\n    }\n    async function i(s) {\n      s.data.type === \"connect_result\" && await n();\n    }\n    function o() {\n      !t.activeAddress && !t.activeStrategy || (e({ type: \"DISCONNECT\" }), localStorage.removeItem(ti));\n    }\n    n(), addEventListener(\"arweaveWalletLoaded\", n), addEventListener(\"focus\", n), addEventListener(\"message\", i);\n    let a;\n    return r && (a = r.addAddressEvent(n)), () => {\n      removeEventListener(\"arweaveWalletLoaded\", n), removeEventListener(\"focus\", n), removeEventListener(\"message\", i), r && a && r.removeAddressEvent(a);\n    };\n  }, [r, e]);\n}\nfunction Ac() {\n  const [t, e] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(!1), r = ir(), n = w1(), { state: i } = _t(), { permissions: o, ensurePermissions: a } = i.config;\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (!r)\n      return e(!1);\n    e(a ? nh(o, n) : n.length > 0);\n  }, [r, n, o, a]), t;\n}\nfunction _1() {\n  const t = ir(), { dispatch: e } = _t(), r = Ac();\n  async function n() {\n    if (!t || !r)\n      throw new Error(\"[Arweave Wallet Kit] Not yet connected\");\n    try {\n      await t.disconnect(), localStorage.removeItem(ti), e({ type: \"DISCONNECT\" });\n    } catch (i) {\n      throw new Error(\n        `[Arweave Wallet Kit] Could not disconnect\n` + ((i == null ? void 0 : i.message) || i)\n      );\n    }\n  }\n  return n;\n}\nfunction A1() {\n  const { dispatch: t } = _t(), e = Ac();\n  return () => new Promise((n, i) => {\n    if (e)\n      return i(\"[Arweave Wallet Kit] Already connected\");\n    t({\n      type: \"OPEN_MODAL\",\n      payload: \"connect\"\n    });\n    async function o(a) {\n      a.data.type === \"connect_result\" && (removeEventListener(\"message\", o), a.data.res ? n() : i(\"[Arweave Wallet Kit] User cancelled the connection\"));\n    }\n    addEventListener(\"message\", o);\n  });\n}\nfunction Tc() {\n  const t = Ac(), e = A1(), r = _1();\n  return {\n    connected: t,\n    connect: e,\n    disconnect: r\n  };\n}\nfunction T1() {\n  const { state: t, dispatch: e } = _t();\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    t.activeStrategy || t.activeModal !== \"profile\" || e({ type: \"CLOSE_MODAL\" });\n  }, [t, e]), {\n    setOpen(r) {\n      if (!t.activeStrategy)\n        throw new Error(\"[Arweave Wallet Kit] App not connected\");\n      e(r ? {\n        type: \"OPEN_MODAL\",\n        payload: \"profile\"\n      } : { type: \"CLOSE_MODAL\" });\n    },\n    open: t.activeModal === \"profile\"\n  };\n}\nvar fi = {}, Ec = {}, Sa = {}, E1 = {\n  get exports() {\n    return Sa;\n  },\n  set exports(t) {\n    Sa = t;\n  }\n};\n(function(t) {\n  (function(e) {\n    var r, n = /^-?(?:\\d+(?:\\.\\d*)?|\\.\\d+)(?:e[+-]?\\d+)?$/i, i = Math.ceil, o = Math.floor, a = \"[BigNumber Error] \", s = a + \"Number primitive has more than 15 significant digits: \", l = 1e14, u = 14, c = 9007199254740991, f = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13], h = 1e7, p = 1e9;\n    function g(U) {\n      var W, G, Z, j = I.prototype = { constructor: I, toString: null, valueOf: null }, P = new I(1), d = 20, x = 4, C = -7, M = 21, D = -1e7, z = 1e7, Y = !1, L = 1, m = 0, E = {\n        prefix: \"\",\n        groupSize: 3,\n        secondaryGroupSize: 0,\n        groupSeparator: \",\",\n        decimalSeparator: \".\",\n        fractionGroupSize: 0,\n        fractionGroupSeparator: \" \",\n        // non-breaking space\n        suffix: \"\"\n      }, B = \"0123456789abcdefghijklmnopqrstuvwxyz\", V = !0;\n      function I(k, H) {\n        var N, J, Q, ee, S, y, v, b, F = this;\n        if (!(F instanceof I))\n          return new I(k, H);\n        if (H == null) {\n          if (k && k._isBigNumber === !0) {\n            F.s = k.s, !k.c || k.e > z ? F.c = F.e = null : k.e < D ? F.c = [F.e = 0] : (F.e = k.e, F.c = k.c.slice());\n            return;\n          }\n          if ((y = typeof k == \"number\") && k * 0 == 0) {\n            if (F.s = 1 / k < 0 ? (k = -k, -1) : 1, k === ~~k) {\n              for (ee = 0, S = k; S >= 10; S /= 10, ee++)\n                ;\n              ee > z ? F.c = F.e = null : (F.e = ee, F.c = [k]);\n              return;\n            }\n            b = String(k);\n          } else {\n            if (!n.test(b = String(k)))\n              return Z(F, b, y);\n            F.s = b.charCodeAt(0) == 45 ? (b = b.slice(1), -1) : 1;\n          }\n          (ee = b.indexOf(\".\")) > -1 && (b = b.replace(\".\", \"\")), (S = b.search(/e/i)) > 0 ? (ee < 0 && (ee = S), ee += +b.slice(S + 1), b = b.substring(0, S)) : ee < 0 && (ee = b.length);\n        } else {\n          if (w(H, 2, B.length, \"Base\"), H == 10 && V)\n            return F = new I(k), oe(F, d + F.e + 1, x);\n          if (b = String(k), y = typeof k == \"number\") {\n            if (k * 0 != 0)\n              return Z(F, b, y, H);\n            if (F.s = 1 / k < 0 ? (b = b.slice(1), -1) : 1, I.DEBUG && b.replace(/^0\\.0*|\\./, \"\").length > 15)\n              throw Error(s + k);\n          } else\n            F.s = b.charCodeAt(0) === 45 ? (b = b.slice(1), -1) : 1;\n          for (N = B.slice(0, H), ee = S = 0, v = b.length; S < v; S++)\n            if (N.indexOf(J = b.charAt(S)) < 0) {\n              if (J == \".\") {\n                if (S > ee) {\n                  ee = v;\n                  continue;\n                }\n              } else if (!Q && (b == b.toUpperCase() && (b = b.toLowerCase()) || b == b.toLowerCase() && (b = b.toUpperCase()))) {\n                Q = !0, S = -1, ee = 0;\n                continue;\n              }\n              return Z(F, String(k), y, H);\n            }\n          y = !1, b = G(b, H, 10, F.s), (ee = b.indexOf(\".\")) > -1 ? b = b.replace(\".\", \"\") : ee = b.length;\n        }\n        for (S = 0; b.charCodeAt(S) === 48; S++)\n          ;\n        for (v = b.length; b.charCodeAt(--v) === 48; )\n          ;\n        if (b = b.slice(S, ++v)) {\n          if (v -= S, y && I.DEBUG && v > 15 && (k > c || k !== o(k)))\n            throw Error(s + F.s * k);\n          if ((ee = ee - S - 1) > z)\n            F.c = F.e = null;\n          else if (ee < D)\n            F.c = [F.e = 0];\n          else {\n            if (F.e = ee, F.c = [], S = (ee + 1) % u, ee < 0 && (S += u), S < v) {\n              for (S && F.c.push(+b.slice(0, S)), v -= u; S < v; )\n                F.c.push(+b.slice(S, S += u));\n              S = u - (b = b.slice(S)).length;\n            } else\n              S -= v;\n            for (; S--; b += \"0\")\n              ;\n            F.c.push(+b);\n          }\n        } else\n          F.c = [F.e = 0];\n      }\n      I.clone = g, I.ROUND_UP = 0, I.ROUND_DOWN = 1, I.ROUND_CEIL = 2, I.ROUND_FLOOR = 3, I.ROUND_HALF_UP = 4, I.ROUND_HALF_DOWN = 5, I.ROUND_HALF_EVEN = 6, I.ROUND_HALF_CEIL = 7, I.ROUND_HALF_FLOOR = 8, I.EUCLID = 9, I.config = I.set = function(k) {\n        var H, N;\n        if (k != null)\n          if (typeof k == \"object\") {\n            if (k.hasOwnProperty(H = \"DECIMAL_PLACES\") && (N = k[H], w(N, 0, p, H), d = N), k.hasOwnProperty(H = \"ROUNDING_MODE\") && (N = k[H], w(N, 0, 8, H), x = N), k.hasOwnProperty(H = \"EXPONENTIAL_AT\") && (N = k[H], N && N.pop ? (w(N[0], -p, 0, H), w(N[1], 0, p, H), C = N[0], M = N[1]) : (w(N, -p, p, H), C = -(M = N < 0 ? -N : N))), k.hasOwnProperty(H = \"RANGE\"))\n              if (N = k[H], N && N.pop)\n                w(N[0], -p, -1, H), w(N[1], 1, p, H), D = N[0], z = N[1];\n              else if (w(N, -p, p, H), N)\n                D = -(z = N < 0 ? -N : N);\n              else\n                throw Error(a + H + \" cannot be zero: \" + N);\n            if (k.hasOwnProperty(H = \"CRYPTO\"))\n              if (N = k[H], N === !!N)\n                if (N)\n                  if (typeof crypto < \"u\" && crypto && (crypto.getRandomValues || crypto.randomBytes))\n                    Y = N;\n                  else\n                    throw Y = !N, Error(a + \"crypto unavailable\");\n                else\n                  Y = N;\n              else\n                throw Error(a + H + \" not true or false: \" + N);\n            if (k.hasOwnProperty(H = \"MODULO_MODE\") && (N = k[H], w(N, 0, 9, H), L = N), k.hasOwnProperty(H = \"POW_PRECISION\") && (N = k[H], w(N, 0, p, H), m = N), k.hasOwnProperty(H = \"FORMAT\"))\n              if (N = k[H], typeof N == \"object\")\n                E = N;\n              else\n                throw Error(a + H + \" not an object: \" + N);\n            if (k.hasOwnProperty(H = \"ALPHABET\"))\n              if (N = k[H], typeof N == \"string\" && !/^.?$|[+\\-.\\s]|(.).*\\1/.test(N))\n                V = N.slice(0, 10) == \"0123456789\", B = N;\n              else\n                throw Error(a + H + \" invalid: \" + N);\n          } else\n            throw Error(a + \"Object expected: \" + k);\n        return {\n          DECIMAL_PLACES: d,\n          ROUNDING_MODE: x,\n          EXPONENTIAL_AT: [C, M],\n          RANGE: [D, z],\n          CRYPTO: Y,\n          MODULO_MODE: L,\n          POW_PRECISION: m,\n          FORMAT: E,\n          ALPHABET: B\n        };\n      }, I.isBigNumber = function(k) {\n        if (!k || k._isBigNumber !== !0)\n          return !1;\n        if (!I.DEBUG)\n          return !0;\n        var H, N, J = k.c, Q = k.e, ee = k.s;\n        e:\n          if ({}.toString.call(J) == \"[object Array]\") {\n            if ((ee === 1 || ee === -1) && Q >= -p && Q <= p && Q === o(Q)) {\n              if (J[0] === 0) {\n                if (Q === 0 && J.length === 1)\n                  return !0;\n                break e;\n              }\n              if (H = (Q + 1) % u, H < 1 && (H += u), String(J[0]).length == H) {\n                for (H = 0; H < J.length; H++)\n                  if (N = J[H], N < 0 || N >= l || N !== o(N))\n                    break e;\n                if (N !== 0)\n                  return !0;\n              }\n            }\n          } else if (J === null && Q === null && (ee === null || ee === 1 || ee === -1))\n            return !0;\n        throw Error(a + \"Invalid BigNumber: \" + k);\n      }, I.maximum = I.max = function() {\n        return se(arguments, j.lt);\n      }, I.minimum = I.min = function() {\n        return se(arguments, j.gt);\n      }, I.random = function() {\n        var k = 9007199254740992, H = Math.random() * k & 2097151 ? function() {\n          return o(Math.random() * k);\n        } : function() {\n          return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);\n        };\n        return function(N) {\n          var J, Q, ee, S, y, v = 0, b = [], F = new I(P);\n          if (N == null ? N = d : w(N, 0, p), S = i(N / u), Y)\n            if (crypto.getRandomValues) {\n              for (J = crypto.getRandomValues(new Uint32Array(S *= 2)); v < S; )\n                y = J[v] * 131072 + (J[v + 1] >>> 11), y >= 9e15 ? (Q = crypto.getRandomValues(new Uint32Array(2)), J[v] = Q[0], J[v + 1] = Q[1]) : (b.push(y % 1e14), v += 2);\n              v = S / 2;\n            } else if (crypto.randomBytes) {\n              for (J = crypto.randomBytes(S *= 7); v < S; )\n                y = (J[v] & 31) * 281474976710656 + J[v + 1] * 1099511627776 + J[v + 2] * 4294967296 + J[v + 3] * 16777216 + (J[v + 4] << 16) + (J[v + 5] << 8) + J[v + 6], y >= 9e15 ? crypto.randomBytes(7).copy(J, v) : (b.push(y % 1e14), v += 7);\n              v = S / 7;\n            } else\n              throw Y = !1, Error(a + \"crypto unavailable\");\n          if (!Y)\n            for (; v < S; )\n              y = H(), y < 9e15 && (b[v++] = y % 1e14);\n          for (S = b[--v], N %= u, S && N && (y = f[u - N], b[v] = o(S / y) * y); b[v] === 0; b.pop(), v--)\n            ;\n          if (v < 0)\n            b = [ee = 0];\n          else {\n            for (ee = -1; b[0] === 0; b.splice(0, 1), ee -= u)\n              ;\n            for (v = 1, y = b[0]; y >= 10; y /= 10, v++)\n              ;\n            v < u && (ee -= u - v);\n          }\n          return F.e = ee, F.c = b, F;\n        };\n      }(), I.sum = function() {\n        for (var k = 1, H = arguments, N = new I(H[0]); k < H.length; )\n          N = N.plus(H[k++]);\n        return N;\n      }, G = function() {\n        var k = \"0123456789\";\n        function H(N, J, Q, ee) {\n          for (var S, y = [0], v, b = 0, F = N.length; b < F; ) {\n            for (v = y.length; v--; y[v] *= J)\n              ;\n            for (y[0] += ee.indexOf(N.charAt(b++)), S = 0; S < y.length; S++)\n              y[S] > Q - 1 && (y[S + 1] == null && (y[S + 1] = 0), y[S + 1] += y[S] / Q | 0, y[S] %= Q);\n          }\n          return y.reverse();\n        }\n        return function(N, J, Q, ee, S) {\n          var y, v, b, F, K, te, de, pe, X = N.indexOf(\".\"), ie = d, re = x;\n          for (X >= 0 && (F = m, m = 0, N = N.replace(\".\", \"\"), pe = new I(J), te = pe.pow(N.length - X), m = F, pe.c = H(\n            $(T(te.c), te.e, \"0\"),\n            10,\n            Q,\n            k\n          ), pe.e = pe.c.length), de = H(N, J, Q, S ? (y = B, k) : (y = k, B)), b = F = de.length; de[--F] == 0; de.pop())\n            ;\n          if (!de[0])\n            return y.charAt(0);\n          if (X < 0 ? --b : (te.c = de, te.e = b, te.s = ee, te = W(te, pe, ie, re, Q), de = te.c, K = te.r, b = te.e), v = b + ie + 1, X = de[v], F = Q / 2, K = K || v < 0 || de[v + 1] != null, K = re < 4 ? (X != null || K) && (re == 0 || re == (te.s < 0 ? 3 : 2)) : X > F || X == F && (re == 4 || K || re == 6 && de[v - 1] & 1 || re == (te.s < 0 ? 8 : 7)), v < 1 || !de[0])\n            N = K ? $(y.charAt(1), -ie, y.charAt(0)) : y.charAt(0);\n          else {\n            if (de.length = v, K)\n              for (--Q; ++de[--v] > Q; )\n                de[v] = 0, v || (++b, de = [1].concat(de));\n            for (F = de.length; !de[--F]; )\n              ;\n            for (X = 0, N = \"\"; X <= F; N += y.charAt(de[X++]))\n              ;\n            N = $(N, b, y.charAt(0));\n          }\n          return N;\n        };\n      }(), W = function() {\n        function k(J, Q, ee) {\n          var S, y, v, b, F = 0, K = J.length, te = Q % h, de = Q / h | 0;\n          for (J = J.slice(); K--; )\n            v = J[K] % h, b = J[K] / h | 0, S = de * v + b * te, y = te * v + S % h * h + F, F = (y / ee | 0) + (S / h | 0) + de * b, J[K] = y % ee;\n          return F && (J = [F].concat(J)), J;\n        }\n        function H(J, Q, ee, S) {\n          var y, v;\n          if (ee != S)\n            v = ee > S ? 1 : -1;\n          else\n            for (y = v = 0; y < ee; y++)\n              if (J[y] != Q[y]) {\n                v = J[y] > Q[y] ? 1 : -1;\n                break;\n              }\n          return v;\n        }\n        function N(J, Q, ee, S) {\n          for (var y = 0; ee--; )\n            J[ee] -= y, y = J[ee] < Q[ee] ? 1 : 0, J[ee] = y * S + J[ee] - Q[ee];\n          for (; !J[0] && J.length > 1; J.splice(0, 1))\n            ;\n        }\n        return function(J, Q, ee, S, y) {\n          var v, b, F, K, te, de, pe, X, ie, re, ae, me, Te, ve, _e, ye, we, Ae = J.s == Q.s ? 1 : -1, Pe = J.c, Se = Q.c;\n          if (!Pe || !Pe[0] || !Se || !Se[0])\n            return new I(\n              // Return NaN if either NaN, or both Infinity or 0.\n              !J.s || !Q.s || (Pe ? Se && Pe[0] == Se[0] : !Se) ? NaN : (\n                // Return ±0 if x is ±0 or y is ±Infinity, or return ±Infinity as y is ±0.\n                Pe && Pe[0] == 0 || !Se ? Ae * 0 : Ae / 0\n              )\n            );\n          for (X = new I(Ae), ie = X.c = [], b = J.e - Q.e, Ae = ee + b + 1, y || (y = l, b = _(J.e / u) - _(Q.e / u), Ae = Ae / u | 0), F = 0; Se[F] == (Pe[F] || 0); F++)\n            ;\n          if (Se[F] > (Pe[F] || 0) && b--, Ae < 0)\n            ie.push(1), K = !0;\n          else {\n            for (ve = Pe.length, ye = Se.length, F = 0, Ae += 2, te = o(y / (Se[0] + 1)), te > 1 && (Se = k(Se, te, y), Pe = k(Pe, te, y), ye = Se.length, ve = Pe.length), Te = ye, re = Pe.slice(0, ye), ae = re.length; ae < ye; re[ae++] = 0)\n              ;\n            we = Se.slice(), we = [0].concat(we), _e = Se[0], Se[1] >= y / 2 && _e++;\n            do {\n              if (te = 0, v = H(Se, re, ye, ae), v < 0) {\n                if (me = re[0], ye != ae && (me = me * y + (re[1] || 0)), te = o(me / _e), te > 1)\n                  for (te >= y && (te = y - 1), de = k(Se, te, y), pe = de.length, ae = re.length; H(de, re, pe, ae) == 1; )\n                    te--, N(de, ye < pe ? we : Se, pe, y), pe = de.length, v = 1;\n                else\n                  te == 0 && (v = te = 1), de = Se.slice(), pe = de.length;\n                if (pe < ae && (de = [0].concat(de)), N(re, de, ae, y), ae = re.length, v == -1)\n                  for (; H(Se, re, ye, ae) < 1; )\n                    te++, N(re, ye < ae ? we : Se, ae, y), ae = re.length;\n              } else\n                v === 0 && (te++, re = [0]);\n              ie[F++] = te, re[0] ? re[ae++] = Pe[Te] || 0 : (re = [Pe[Te]], ae = 1);\n            } while ((Te++ < ve || re[0] != null) && Ae--);\n            K = re[0] != null, ie[0] || ie.splice(0, 1);\n          }\n          if (y == l) {\n            for (F = 1, Ae = ie[0]; Ae >= 10; Ae /= 10, F++)\n              ;\n            oe(X, ee + (X.e = F + b * u - 1) + 1, S, K);\n          } else\n            X.e = b, X.r = +K;\n          return X;\n        };\n      }();\n      function ne(k, H, N, J) {\n        var Q, ee, S, y, v;\n        if (N == null ? N = x : w(N, 0, 8), !k.c)\n          return k.toString();\n        if (Q = k.c[0], S = k.e, H == null)\n          v = T(k.c), v = J == 1 || J == 2 && (S <= C || S >= M) ? R(v, S) : $(v, S, \"0\");\n        else if (k = oe(new I(k), H, N), ee = k.e, v = T(k.c), y = v.length, J == 1 || J == 2 && (H <= ee || ee <= C)) {\n          for (; y < H; v += \"0\", y++)\n            ;\n          v = R(v, ee);\n        } else if (H -= S, v = $(v, ee, \"0\"), ee + 1 > y) {\n          if (--H > 0)\n            for (v += \".\"; H--; v += \"0\")\n              ;\n        } else if (H += ee - y, H > 0)\n          for (ee + 1 == y && (v += \".\"); H--; v += \"0\")\n            ;\n        return k.s < 0 && Q ? \"-\" + v : v;\n      }\n      function se(k, H) {\n        for (var N, J = 1, Q = new I(k[0]); J < k.length; J++)\n          if (N = new I(k[J]), N.s)\n            H.call(Q, N) && (Q = N);\n          else {\n            Q = N;\n            break;\n          }\n        return Q;\n      }\n      function ce(k, H, N) {\n        for (var J = 1, Q = H.length; !H[--Q]; H.pop())\n          ;\n        for (Q = H[0]; Q >= 10; Q /= 10, J++)\n          ;\n        return (N = J + N * u - 1) > z ? k.c = k.e = null : N < D ? k.c = [k.e = 0] : (k.e = N, k.c = H), k;\n      }\n      Z = function() {\n        var k = /^(-?)0([xbo])(?=\\w[\\w.]*$)/i, H = /^([^.]+)\\.$/, N = /^\\.([^.]+)$/, J = /^-?(Infinity|NaN)$/, Q = /^\\s*\\+(?=[\\w.])|^\\s+|\\s+$/g;\n        return function(ee, S, y, v) {\n          var b, F = y ? S : S.replace(Q, \"\");\n          if (J.test(F))\n            ee.s = isNaN(F) ? null : F < 0 ? -1 : 1;\n          else {\n            if (!y && (F = F.replace(k, function(K, te, de) {\n              return b = (de = de.toLowerCase()) == \"x\" ? 16 : de == \"b\" ? 2 : 8, !v || v == b ? te : K;\n            }), v && (b = v, F = F.replace(H, \"$1\").replace(N, \"0.$1\")), S != F))\n              return new I(F, b);\n            if (I.DEBUG)\n              throw Error(a + \"Not a\" + (v ? \" base \" + v : \"\") + \" number: \" + S);\n            ee.s = null;\n          }\n          ee.c = ee.e = null;\n        };\n      }();\n      function oe(k, H, N, J) {\n        var Q, ee, S, y, v, b, F, K = k.c, te = f;\n        if (K) {\n          e: {\n            for (Q = 1, y = K[0]; y >= 10; y /= 10, Q++)\n              ;\n            if (ee = H - Q, ee < 0)\n              ee += u, S = H, v = K[b = 0], F = v / te[Q - S - 1] % 10 | 0;\n            else if (b = i((ee + 1) / u), b >= K.length)\n              if (J) {\n                for (; K.length <= b; K.push(0))\n                  ;\n                v = F = 0, Q = 1, ee %= u, S = ee - u + 1;\n              } else\n                break e;\n            else {\n              for (v = y = K[b], Q = 1; y >= 10; y /= 10, Q++)\n                ;\n              ee %= u, S = ee - u + Q, F = S < 0 ? 0 : v / te[Q - S - 1] % 10 | 0;\n            }\n            if (J = J || H < 0 || // Are there any non-zero digits after the rounding digit?\n            // The expression  n % pows10[d - j - 1]  returns all digits of n to the right\n            // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.\n            K[b + 1] != null || (S < 0 ? v : v % te[Q - S - 1]), J = N < 4 ? (F || J) && (N == 0 || N == (k.s < 0 ? 3 : 2)) : F > 5 || F == 5 && (N == 4 || J || N == 6 && (ee > 0 ? S > 0 ? v / te[Q - S] : 0 : K[b - 1]) % 10 & 1 || N == (k.s < 0 ? 8 : 7)), H < 1 || !K[0])\n              return K.length = 0, J ? (H -= k.e + 1, K[0] = te[(u - H % u) % u], k.e = -H || 0) : K[0] = k.e = 0, k;\n            if (ee == 0 ? (K.length = b, y = 1, b--) : (K.length = b + 1, y = te[u - ee], K[b] = S > 0 ? o(v / te[Q - S] % te[S]) * y : 0), J)\n              for (; ; )\n                if (b == 0) {\n                  for (ee = 1, S = K[0]; S >= 10; S /= 10, ee++)\n                    ;\n                  for (S = K[0] += y, y = 1; S >= 10; S /= 10, y++)\n                    ;\n                  ee != y && (k.e++, K[0] == l && (K[0] = 1));\n                  break;\n                } else {\n                  if (K[b] += y, K[b] != l)\n                    break;\n                  K[b--] = 0, y = 1;\n                }\n            for (ee = K.length; K[--ee] === 0; K.pop())\n              ;\n          }\n          k.e > z ? k.c = k.e = null : k.e < D && (k.c = [k.e = 0]);\n        }\n        return k;\n      }\n      function he(k) {\n        var H, N = k.e;\n        return N === null ? k.toString() : (H = T(k.c), H = N <= C || N >= M ? R(H, N) : $(H, N, \"0\"), k.s < 0 ? \"-\" + H : H);\n      }\n      return j.absoluteValue = j.abs = function() {\n        var k = new I(this);\n        return k.s < 0 && (k.s = 1), k;\n      }, j.comparedTo = function(k, H) {\n        return A(this, new I(k, H));\n      }, j.decimalPlaces = j.dp = function(k, H) {\n        var N, J, Q, ee = this;\n        if (k != null)\n          return w(k, 0, p), H == null ? H = x : w(H, 0, 8), oe(new I(ee), k + ee.e + 1, H);\n        if (!(N = ee.c))\n          return null;\n        if (J = ((Q = N.length - 1) - _(this.e / u)) * u, Q = N[Q])\n          for (; Q % 10 == 0; Q /= 10, J--)\n            ;\n        return J < 0 && (J = 0), J;\n      }, j.dividedBy = j.div = function(k, H) {\n        return W(this, new I(k, H), d, x);\n      }, j.dividedToIntegerBy = j.idiv = function(k, H) {\n        return W(this, new I(k, H), 0, 1);\n      }, j.exponentiatedBy = j.pow = function(k, H) {\n        var N, J, Q, ee, S, y, v, b, F, K = this;\n        if (k = new I(k), k.c && !k.isInteger())\n          throw Error(a + \"Exponent not an integer: \" + he(k));\n        if (H != null && (H = new I(H)), y = k.e > 14, !K.c || !K.c[0] || K.c[0] == 1 && !K.e && K.c.length == 1 || !k.c || !k.c[0])\n          return F = new I(Math.pow(+he(K), y ? k.s * (2 - O(k)) : +he(k))), H ? F.mod(H) : F;\n        if (v = k.s < 0, H) {\n          if (H.c ? !H.c[0] : !H.s)\n            return new I(NaN);\n          J = !v && K.isInteger() && H.isInteger(), J && (K = K.mod(H));\n        } else {\n          if (k.e > 9 && (K.e > 0 || K.e < -1 || (K.e == 0 ? K.c[0] > 1 || y && K.c[1] >= 24e7 : K.c[0] < 8e13 || y && K.c[0] <= 9999975e7)))\n            return ee = K.s < 0 && O(k) ? -0 : 0, K.e > -1 && (ee = 1 / ee), new I(v ? 1 / ee : ee);\n          m && (ee = i(m / u + 2));\n        }\n        for (y ? (N = new I(0.5), v && (k.s = 1), b = O(k)) : (Q = Math.abs(+he(k)), b = Q % 2), F = new I(P); ; ) {\n          if (b) {\n            if (F = F.times(K), !F.c)\n              break;\n            ee ? F.c.length > ee && (F.c.length = ee) : J && (F = F.mod(H));\n          }\n          if (Q) {\n            if (Q = o(Q / 2), Q === 0)\n              break;\n            b = Q % 2;\n          } else if (k = k.times(N), oe(k, k.e + 1, 1), k.e > 14)\n            b = O(k);\n          else {\n            if (Q = +he(k), Q === 0)\n              break;\n            b = Q % 2;\n          }\n          K = K.times(K), ee ? K.c && K.c.length > ee && (K.c.length = ee) : J && (K = K.mod(H));\n        }\n        return J ? F : (v && (F = P.div(F)), H ? F.mod(H) : ee ? oe(F, m, x, S) : F);\n      }, j.integerValue = function(k) {\n        var H = new I(this);\n        return k == null ? k = x : w(k, 0, 8), oe(H, H.e + 1, k);\n      }, j.isEqualTo = j.eq = function(k, H) {\n        return A(this, new I(k, H)) === 0;\n      }, j.isFinite = function() {\n        return !!this.c;\n      }, j.isGreaterThan = j.gt = function(k, H) {\n        return A(this, new I(k, H)) > 0;\n      }, j.isGreaterThanOrEqualTo = j.gte = function(k, H) {\n        return (H = A(this, new I(k, H))) === 1 || H === 0;\n      }, j.isInteger = function() {\n        return !!this.c && _(this.e / u) > this.c.length - 2;\n      }, j.isLessThan = j.lt = function(k, H) {\n        return A(this, new I(k, H)) < 0;\n      }, j.isLessThanOrEqualTo = j.lte = function(k, H) {\n        return (H = A(this, new I(k, H))) === -1 || H === 0;\n      }, j.isNaN = function() {\n        return !this.s;\n      }, j.isNegative = function() {\n        return this.s < 0;\n      }, j.isPositive = function() {\n        return this.s > 0;\n      }, j.isZero = function() {\n        return !!this.c && this.c[0] == 0;\n      }, j.minus = function(k, H) {\n        var N, J, Q, ee, S = this, y = S.s;\n        if (k = new I(k, H), H = k.s, !y || !H)\n          return new I(NaN);\n        if (y != H)\n          return k.s = -H, S.plus(k);\n        var v = S.e / u, b = k.e / u, F = S.c, K = k.c;\n        if (!v || !b) {\n          if (!F || !K)\n            return F ? (k.s = -H, k) : new I(K ? S : NaN);\n          if (!F[0] || !K[0])\n            return K[0] ? (k.s = -H, k) : new I(F[0] ? S : (\n              // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity\n              x == 3 ? -0 : 0\n            ));\n        }\n        if (v = _(v), b = _(b), F = F.slice(), y = v - b) {\n          for ((ee = y < 0) ? (y = -y, Q = F) : (b = v, Q = K), Q.reverse(), H = y; H--; Q.push(0))\n            ;\n          Q.reverse();\n        } else\n          for (J = (ee = (y = F.length) < (H = K.length)) ? y : H, y = H = 0; H < J; H++)\n            if (F[H] != K[H]) {\n              ee = F[H] < K[H];\n              break;\n            }\n        if (ee && (Q = F, F = K, K = Q, k.s = -k.s), H = (J = K.length) - (N = F.length), H > 0)\n          for (; H--; F[N++] = 0)\n            ;\n        for (H = l - 1; J > y; ) {\n          if (F[--J] < K[J]) {\n            for (N = J; N && !F[--N]; F[N] = H)\n              ;\n            --F[N], F[J] += l;\n          }\n          F[J] -= K[J];\n        }\n        for (; F[0] == 0; F.splice(0, 1), --b)\n          ;\n        return F[0] ? ce(k, F, b) : (k.s = x == 3 ? -1 : 1, k.c = [k.e = 0], k);\n      }, j.modulo = j.mod = function(k, H) {\n        var N, J, Q = this;\n        return k = new I(k, H), !Q.c || !k.s || k.c && !k.c[0] ? new I(NaN) : !k.c || Q.c && !Q.c[0] ? new I(Q) : (L == 9 ? (J = k.s, k.s = 1, N = W(Q, k, 0, 3), k.s = J, N.s *= J) : N = W(Q, k, 0, L), k = Q.minus(N.times(k)), !k.c[0] && L == 1 && (k.s = Q.s), k);\n      }, j.multipliedBy = j.times = function(k, H) {\n        var N, J, Q, ee, S, y, v, b, F, K, te, de, pe, X, ie, re = this, ae = re.c, me = (k = new I(k, H)).c;\n        if (!ae || !me || !ae[0] || !me[0])\n          return !re.s || !k.s || ae && !ae[0] && !me || me && !me[0] && !ae ? k.c = k.e = k.s = null : (k.s *= re.s, !ae || !me ? k.c = k.e = null : (k.c = [0], k.e = 0)), k;\n        for (J = _(re.e / u) + _(k.e / u), k.s *= re.s, v = ae.length, K = me.length, v < K && (pe = ae, ae = me, me = pe, Q = v, v = K, K = Q), Q = v + K, pe = []; Q--; pe.push(0))\n          ;\n        for (X = l, ie = h, Q = K; --Q >= 0; ) {\n          for (N = 0, te = me[Q] % ie, de = me[Q] / ie | 0, S = v, ee = Q + S; ee > Q; )\n            b = ae[--S] % ie, F = ae[S] / ie | 0, y = de * b + F * te, b = te * b + y % ie * ie + pe[ee] + N, N = (b / X | 0) + (y / ie | 0) + de * F, pe[ee--] = b % X;\n          pe[ee] = N;\n        }\n        return N ? ++J : pe.splice(0, 1), ce(k, pe, J);\n      }, j.negated = function() {\n        var k = new I(this);\n        return k.s = -k.s || null, k;\n      }, j.plus = function(k, H) {\n        var N, J = this, Q = J.s;\n        if (k = new I(k, H), H = k.s, !Q || !H)\n          return new I(NaN);\n        if (Q != H)\n          return k.s = -H, J.minus(k);\n        var ee = J.e / u, S = k.e / u, y = J.c, v = k.c;\n        if (!ee || !S) {\n          if (!y || !v)\n            return new I(Q / 0);\n          if (!y[0] || !v[0])\n            return v[0] ? k : new I(y[0] ? J : Q * 0);\n        }\n        if (ee = _(ee), S = _(S), y = y.slice(), Q = ee - S) {\n          for (Q > 0 ? (S = ee, N = v) : (Q = -Q, N = y), N.reverse(); Q--; N.push(0))\n            ;\n          N.reverse();\n        }\n        for (Q = y.length, H = v.length, Q - H < 0 && (N = v, v = y, y = N, H = Q), Q = 0; H; )\n          Q = (y[--H] = y[H] + v[H] + Q) / l | 0, y[H] = l === y[H] ? 0 : y[H] % l;\n        return Q && (y = [Q].concat(y), ++S), ce(k, y, S);\n      }, j.precision = j.sd = function(k, H) {\n        var N, J, Q, ee = this;\n        if (k != null && k !== !!k)\n          return w(k, 1, p), H == null ? H = x : w(H, 0, 8), oe(new I(ee), k, H);\n        if (!(N = ee.c))\n          return null;\n        if (Q = N.length - 1, J = Q * u + 1, Q = N[Q]) {\n          for (; Q % 10 == 0; Q /= 10, J--)\n            ;\n          for (Q = N[0]; Q >= 10; Q /= 10, J++)\n            ;\n        }\n        return k && ee.e + 1 > J && (J = ee.e + 1), J;\n      }, j.shiftedBy = function(k) {\n        return w(k, -c, c), this.times(\"1e\" + k);\n      }, j.squareRoot = j.sqrt = function() {\n        var k, H, N, J, Q, ee = this, S = ee.c, y = ee.s, v = ee.e, b = d + 4, F = new I(\"0.5\");\n        if (y !== 1 || !S || !S[0])\n          return new I(!y || y < 0 && (!S || S[0]) ? NaN : S ? ee : 1 / 0);\n        if (y = Math.sqrt(+he(ee)), y == 0 || y == 1 / 0 ? (H = T(S), (H.length + v) % 2 == 0 && (H += \"0\"), y = Math.sqrt(+H), v = _((v + 1) / 2) - (v < 0 || v % 2), y == 1 / 0 ? H = \"5e\" + v : (H = y.toExponential(), H = H.slice(0, H.indexOf(\"e\") + 1) + v), N = new I(H)) : N = new I(y + \"\"), N.c[0]) {\n          for (v = N.e, y = v + b, y < 3 && (y = 0); ; )\n            if (Q = N, N = F.times(Q.plus(W(ee, Q, b, 1))), T(Q.c).slice(0, y) === (H = T(N.c)).slice(0, y))\n              if (N.e < v && --y, H = H.slice(y - 3, y + 1), H == \"9999\" || !J && H == \"4999\") {\n                if (!J && (oe(Q, Q.e + d + 2, 0), Q.times(Q).eq(ee))) {\n                  N = Q;\n                  break;\n                }\n                b += 4, y += 4, J = 1;\n              } else {\n                (!+H || !+H.slice(1) && H.charAt(0) == \"5\") && (oe(N, N.e + d + 2, 1), k = !N.times(N).eq(ee));\n                break;\n              }\n        }\n        return oe(N, N.e + d + 1, x, k);\n      }, j.toExponential = function(k, H) {\n        return k != null && (w(k, 0, p), k++), ne(this, k, H, 1);\n      }, j.toFixed = function(k, H) {\n        return k != null && (w(k, 0, p), k = k + this.e + 1), ne(this, k, H);\n      }, j.toFormat = function(k, H, N) {\n        var J, Q = this;\n        if (N == null)\n          k != null && H && typeof H == \"object\" ? (N = H, H = null) : k && typeof k == \"object\" ? (N = k, k = H = null) : N = E;\n        else if (typeof N != \"object\")\n          throw Error(a + \"Argument not an object: \" + N);\n        if (J = Q.toFixed(k, H), Q.c) {\n          var ee, S = J.split(\".\"), y = +N.groupSize, v = +N.secondaryGroupSize, b = N.groupSeparator || \"\", F = S[0], K = S[1], te = Q.s < 0, de = te ? F.slice(1) : F, pe = de.length;\n          if (v && (ee = y, y = v, v = ee, pe -= ee), y > 0 && pe > 0) {\n            for (ee = pe % y || y, F = de.substr(0, ee); ee < pe; ee += y)\n              F += b + de.substr(ee, y);\n            v > 0 && (F += b + de.slice(ee)), te && (F = \"-\" + F);\n          }\n          J = K ? F + (N.decimalSeparator || \"\") + ((v = +N.fractionGroupSize) ? K.replace(\n            new RegExp(\"\\\\d{\" + v + \"}\\\\B\", \"g\"),\n            \"$&\" + (N.fractionGroupSeparator || \"\")\n          ) : K) : F;\n        }\n        return (N.prefix || \"\") + J + (N.suffix || \"\");\n      }, j.toFraction = function(k) {\n        var H, N, J, Q, ee, S, y, v, b, F, K, te, de = this, pe = de.c;\n        if (k != null && (y = new I(k), !y.isInteger() && (y.c || y.s !== 1) || y.lt(P)))\n          throw Error(a + \"Argument \" + (y.isInteger() ? \"out of range: \" : \"not an integer: \") + he(y));\n        if (!pe)\n          return new I(de);\n        for (H = new I(P), b = N = new I(P), J = v = new I(P), te = T(pe), ee = H.e = te.length - de.e - 1, H.c[0] = f[(S = ee % u) < 0 ? u + S : S], k = !k || y.comparedTo(H) > 0 ? ee > 0 ? H : b : y, S = z, z = 1 / 0, y = new I(te), v.c[0] = 0; F = W(y, H, 0, 1), Q = N.plus(F.times(J)), Q.comparedTo(k) != 1; )\n          N = J, J = Q, b = v.plus(F.times(Q = b)), v = Q, H = y.minus(F.times(Q = H)), y = Q;\n        return Q = W(k.minus(N), J, 0, 1), v = v.plus(Q.times(b)), N = N.plus(Q.times(J)), v.s = b.s = de.s, ee = ee * 2, K = W(b, J, ee, x).minus(de).abs().comparedTo(\n          W(v, N, ee, x).minus(de).abs()\n        ) < 1 ? [b, J] : [v, N], z = S, K;\n      }, j.toNumber = function() {\n        return +he(this);\n      }, j.toPrecision = function(k, H) {\n        return k != null && w(k, 1, p), ne(this, k, H, 2);\n      }, j.toString = function(k) {\n        var H, N = this, J = N.s, Q = N.e;\n        return Q === null ? J ? (H = \"Infinity\", J < 0 && (H = \"-\" + H)) : H = \"NaN\" : (k == null ? H = Q <= C || Q >= M ? R(T(N.c), Q) : $(T(N.c), Q, \"0\") : k === 10 && V ? (N = oe(new I(N), d + Q + 1, x), H = $(T(N.c), N.e, \"0\")) : (w(k, 2, B.length, \"Base\"), H = G($(T(N.c), Q, \"0\"), 10, k, J, !0)), J < 0 && N.c[0] && (H = \"-\" + H)), H;\n      }, j.valueOf = j.toJSON = function() {\n        return he(this);\n      }, j._isBigNumber = !0, U != null && I.set(U), I;\n    }\n    function _(U) {\n      var W = U | 0;\n      return U > 0 || U === W ? W : W - 1;\n    }\n    function T(U) {\n      for (var W, G, Z = 1, j = U.length, P = U[0] + \"\"; Z < j; ) {\n        for (W = U[Z++] + \"\", G = u - W.length; G--; W = \"0\" + W)\n          ;\n        P += W;\n      }\n      for (j = P.length; P.charCodeAt(--j) === 48; )\n        ;\n      return P.slice(0, j + 1 || 1);\n    }\n    function A(U, W) {\n      var G, Z, j = U.c, P = W.c, d = U.s, x = W.s, C = U.e, M = W.e;\n      if (!d || !x)\n        return null;\n      if (G = j && !j[0], Z = P && !P[0], G || Z)\n        return G ? Z ? 0 : -x : d;\n      if (d != x)\n        return d;\n      if (G = d < 0, Z = C == M, !j || !P)\n        return Z ? 0 : !j ^ G ? 1 : -1;\n      if (!Z)\n        return C > M ^ G ? 1 : -1;\n      for (x = (C = j.length) < (M = P.length) ? C : M, d = 0; d < x; d++)\n        if (j[d] != P[d])\n          return j[d] > P[d] ^ G ? 1 : -1;\n      return C == M ? 0 : C > M ^ G ? 1 : -1;\n    }\n    function w(U, W, G, Z) {\n      if (U < W || U > G || U !== o(U))\n        throw Error(a + (Z || \"Argument\") + (typeof U == \"number\" ? U < W || U > G ? \" out of range: \" : \" not an integer: \" : \" not a primitive number: \") + String(U));\n    }\n    function O(U) {\n      var W = U.c.length - 1;\n      return _(U.e / u) == W && U.c[W] % 2 != 0;\n    }\n    function R(U, W) {\n      return (U.length > 1 ? U.charAt(0) + \".\" + U.slice(1) : U) + (W < 0 ? \"e\" : \"e+\") + W;\n    }\n    function $(U, W, G) {\n      var Z, j;\n      if (W < 0) {\n        for (j = G + \".\"; ++W; j += G)\n          ;\n        U = j + U;\n      } else if (Z = U.length, ++W > Z) {\n        for (j = G, W -= Z; --W; j += G)\n          ;\n        U += j;\n      } else\n        W < Z && (U = U.slice(0, W) + \".\" + U.slice(W));\n      return U;\n    }\n    r = g(), r.default = r.BigNumber = r, t.exports ? t.exports = r : (e || (e = typeof self < \"u\" && self ? self : window), e.BigNumber = r);\n  })(ue);\n})(E1);\nObject.defineProperty(Ec, \"__esModule\", { value: !0 });\nconst S1 = Sa;\nclass P1 {\n  constructor() {\n    this.BigNum = (e, r) => {\n      let n = S1.BigNumber.clone({ DECIMAL_PLACES: r });\n      return new n(e);\n    };\n  }\n  winstonToAr(e, { formatted: r = !1, decimals: n = 12, trim: i = !0 } = {}) {\n    let o = this.stringToBigNum(e, n).shiftedBy(-12);\n    return r ? o.toFormat(n) : o.toFixed(n);\n  }\n  arToWinston(e, { formatted: r = !1 } = {}) {\n    let n = this.stringToBigNum(e).shiftedBy(12);\n    return r ? n.toFormat() : n.toFixed(0);\n  }\n  compare(e, r) {\n    let n = this.stringToBigNum(e), i = this.stringToBigNum(r);\n    return n.comparedTo(i);\n  }\n  isEqual(e, r) {\n    return this.compare(e, r) === 0;\n  }\n  isLessThan(e, r) {\n    let n = this.stringToBigNum(e), i = this.stringToBigNum(r);\n    return n.isLessThan(i);\n  }\n  isGreaterThan(e, r) {\n    let n = this.stringToBigNum(e), i = this.stringToBigNum(r);\n    return n.isGreaterThan(i);\n  }\n  add(e, r) {\n    let n = this.stringToBigNum(e);\n    return this.stringToBigNum(r), n.plus(r).toFixed(0);\n  }\n  sub(e, r) {\n    let n = this.stringToBigNum(e);\n    return this.stringToBigNum(r), n.minus(r).toFixed(0);\n  }\n  stringToBigNum(e, r = 12) {\n    return this.BigNum(e, r);\n  }\n}\nEc.default = P1;\nvar Sc = {};\nObject.defineProperty(Sc, \"__esModule\", { value: !0 });\nclass C1 {\n  constructor(e) {\n    this.METHOD_GET = \"GET\", this.METHOD_POST = \"POST\", this.applyConfig(e);\n  }\n  applyConfig(e) {\n    this.config = this.mergeDefaults(e);\n  }\n  getConfig() {\n    return this.config;\n  }\n  mergeDefaults(e) {\n    const r = e.protocol || \"http\", n = e.port || (r === \"https\" ? 443 : 80);\n    return {\n      host: e.host || \"127.0.0.1\",\n      protocol: r,\n      port: n,\n      timeout: e.timeout || 2e4,\n      logging: e.logging || !1,\n      logger: e.logger || console.log,\n      network: e.network\n    };\n  }\n  async get(e, r) {\n    return await this.request(e, { ...r, method: this.METHOD_GET });\n  }\n  async post(e, r, n) {\n    const i = new Headers((n == null ? void 0 : n.headers) || {});\n    return i.append(\"content-type\", \"application/json\"), i.append(\"accept\", \"application/json, text/plain, */*\"), await this.request(e, {\n      ...n,\n      method: this.METHOD_POST,\n      body: JSON.stringify(r),\n      headers: i\n    });\n  }\n  async request(e, r) {\n    const n = new Headers((r == null ? void 0 : r.headers) || {}), i = `${this.config.protocol}://${this.config.host}:${this.config.port}`;\n    e.startsWith(\"/\") && (e = e.replace(\"/\", \"\")), this.config.network && n.append(\"x-network\", this.config.network), this.config.logging && this.config.logger(`Requesting: ${i}/${e}`);\n    let o = await fetch(`${i}/${e}`, {\n      ...r || {},\n      headers: n\n    });\n    this.config.logging && this.config.logger(`Response:   ${o.url} - ${o.status}`);\n    const a = o.headers.get(\"content-type\"), s = o;\n    if (a != null && a.startsWith(\"application/json\"))\n      s.data = await o.clone().json();\n    else\n      try {\n        s.data = await o.clone().text();\n      } catch {\n        s.data = await o.clone().arrayBuffer();\n      }\n    return s;\n  }\n}\nSc.default = C1;\nvar Pc = {}, hn = {}, jh = {}, vo = {}, O1 = {\n  get exports() {\n    return vo;\n  },\n  set exports(t) {\n    vo = t;\n  }\n};\n(function(t) {\n  (function(e, r) {\n    function n(P, d) {\n      if (!P)\n        throw new Error(d || \"Assertion failed\");\n    }\n    function i(P, d) {\n      P.super_ = d;\n      var x = function() {\n      };\n      x.prototype = d.prototype, P.prototype = new x(), P.prototype.constructor = P;\n    }\n    function o(P, d, x) {\n      if (o.isBN(P))\n        return P;\n      this.negative = 0, this.words = null, this.length = 0, this.red = null, P !== null && ((d === \"le\" || d === \"be\") && (x = d, d = 10), this._init(P || 0, d || 10, x || \"be\"));\n    }\n    typeof e == \"object\" ? e.exports = o : r.BN = o, o.BN = o, o.wordSize = 26;\n    var a;\n    try {\n      typeof window < \"u\" && typeof window.Buffer < \"u\" ? a = window.Buffer : a = pc.Buffer;\n    } catch {\n    }\n    o.isBN = function(d) {\n      return d instanceof o ? !0 : d !== null && typeof d == \"object\" && d.constructor.wordSize === o.wordSize && Array.isArray(d.words);\n    }, o.max = function(d, x) {\n      return d.cmp(x) > 0 ? d : x;\n    }, o.min = function(d, x) {\n      return d.cmp(x) < 0 ? d : x;\n    }, o.prototype._init = function(d, x, C) {\n      if (typeof d == \"number\")\n        return this._initNumber(d, x, C);\n      if (typeof d == \"object\")\n        return this._initArray(d, x, C);\n      x === \"hex\" && (x = 16), n(x === (x | 0) && x >= 2 && x <= 36), d = d.toString().replace(/\\s+/g, \"\");\n      var M = 0;\n      d[0] === \"-\" && (M++, this.negative = 1), M < d.length && (x === 16 ? this._parseHex(d, M, C) : (this._parseBase(d, x, M), C === \"le\" && this._initArray(this.toArray(), x, C)));\n    }, o.prototype._initNumber = function(d, x, C) {\n      d < 0 && (this.negative = 1, d = -d), d < 67108864 ? (this.words = [d & 67108863], this.length = 1) : d < 4503599627370496 ? (this.words = [\n        d & 67108863,\n        d / 67108864 & 67108863\n      ], this.length = 2) : (n(d < 9007199254740992), this.words = [\n        d & 67108863,\n        d / 67108864 & 67108863,\n        1\n      ], this.length = 3), C === \"le\" && this._initArray(this.toArray(), x, C);\n    }, o.prototype._initArray = function(d, x, C) {\n      if (n(typeof d.length == \"number\"), d.length <= 0)\n        return this.words = [0], this.length = 1, this;\n      this.length = Math.ceil(d.length / 3), this.words = new Array(this.length);\n      for (var M = 0; M < this.length; M++)\n        this.words[M] = 0;\n      var D, z, Y = 0;\n      if (C === \"be\")\n        for (M = d.length - 1, D = 0; M >= 0; M -= 3)\n          z = d[M] | d[M - 1] << 8 | d[M - 2] << 16, this.words[D] |= z << Y & 67108863, this.words[D + 1] = z >>> 26 - Y & 67108863, Y += 24, Y >= 26 && (Y -= 26, D++);\n      else if (C === \"le\")\n        for (M = 0, D = 0; M < d.length; M += 3)\n          z = d[M] | d[M + 1] << 8 | d[M + 2] << 16, this.words[D] |= z << Y & 67108863, this.words[D + 1] = z >>> 26 - Y & 67108863, Y += 24, Y >= 26 && (Y -= 26, D++);\n      return this.strip();\n    };\n    function s(P, d) {\n      var x = P.charCodeAt(d);\n      return x >= 65 && x <= 70 ? x - 55 : x >= 97 && x <= 102 ? x - 87 : x - 48 & 15;\n    }\n    function l(P, d, x) {\n      var C = s(P, x);\n      return x - 1 >= d && (C |= s(P, x - 1) << 4), C;\n    }\n    o.prototype._parseHex = function(d, x, C) {\n      this.length = Math.ceil((d.length - x) / 6), this.words = new Array(this.length);\n      for (var M = 0; M < this.length; M++)\n        this.words[M] = 0;\n      var D = 0, z = 0, Y;\n      if (C === \"be\")\n        for (M = d.length - 1; M >= x; M -= 2)\n          Y = l(d, x, M) << D, this.words[z] |= Y & 67108863, D >= 18 ? (D -= 18, z += 1, this.words[z] |= Y >>> 26) : D += 8;\n      else {\n        var L = d.length - x;\n        for (M = L % 2 === 0 ? x + 1 : x; M < d.length; M += 2)\n          Y = l(d, x, M) << D, this.words[z] |= Y & 67108863, D >= 18 ? (D -= 18, z += 1, this.words[z] |= Y >>> 26) : D += 8;\n      }\n      this.strip();\n    };\n    function u(P, d, x, C) {\n      for (var M = 0, D = Math.min(P.length, x), z = d; z < D; z++) {\n        var Y = P.charCodeAt(z) - 48;\n        M *= C, Y >= 49 ? M += Y - 49 + 10 : Y >= 17 ? M += Y - 17 + 10 : M += Y;\n      }\n      return M;\n    }\n    o.prototype._parseBase = function(d, x, C) {\n      this.words = [0], this.length = 1;\n      for (var M = 0, D = 1; D <= 67108863; D *= x)\n        M++;\n      M--, D = D / x | 0;\n      for (var z = d.length - C, Y = z % M, L = Math.min(z, z - Y) + C, m = 0, E = C; E < L; E += M)\n        m = u(d, E, E + M, x), this.imuln(D), this.words[0] + m < 67108864 ? this.words[0] += m : this._iaddn(m);\n      if (Y !== 0) {\n        var B = 1;\n        for (m = u(d, E, d.length, x), E = 0; E < Y; E++)\n          B *= x;\n        this.imuln(B), this.words[0] + m < 67108864 ? this.words[0] += m : this._iaddn(m);\n      }\n      this.strip();\n    }, o.prototype.copy = function(d) {\n      d.words = new Array(this.length);\n      for (var x = 0; x < this.length; x++)\n        d.words[x] = this.words[x];\n      d.length = this.length, d.negative = this.negative, d.red = this.red;\n    }, o.prototype.clone = function() {\n      var d = new o(null);\n      return this.copy(d), d;\n    }, o.prototype._expand = function(d) {\n      for (; this.length < d; )\n        this.words[this.length++] = 0;\n      return this;\n    }, o.prototype.strip = function() {\n      for (; this.length > 1 && this.words[this.length - 1] === 0; )\n        this.length--;\n      return this._normSign();\n    }, o.prototype._normSign = function() {\n      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;\n    }, o.prototype.inspect = function() {\n      return (this.red ? \"<BN-R: \" : \"<BN: \") + this.toString(16) + \">\";\n    };\n    var c = [\n      \"\",\n      \"0\",\n      \"00\",\n      \"000\",\n      \"0000\",\n      \"00000\",\n      \"000000\",\n      \"0000000\",\n      \"00000000\",\n      \"000000000\",\n      \"0000000000\",\n      \"00000000000\",\n      \"000000000000\",\n      \"0000000000000\",\n      \"00000000000000\",\n      \"000000000000000\",\n      \"0000000000000000\",\n      \"00000000000000000\",\n      \"000000000000000000\",\n      \"0000000000000000000\",\n      \"00000000000000000000\",\n      \"000000000000000000000\",\n      \"0000000000000000000000\",\n      \"00000000000000000000000\",\n      \"000000000000000000000000\",\n      \"0000000000000000000000000\"\n    ], f = [\n      0,\n      0,\n      25,\n      16,\n      12,\n      11,\n      10,\n      9,\n      8,\n      8,\n      7,\n      7,\n      7,\n      7,\n      6,\n      6,\n      6,\n      6,\n      6,\n      6,\n      6,\n      5,\n      5,\n      5,\n      5,\n      5,\n      5,\n      5,\n      5,\n      5,\n      5,\n      5,\n      5,\n      5,\n      5,\n      5,\n      5\n    ], h = [\n      0,\n      0,\n      33554432,\n      43046721,\n      16777216,\n      48828125,\n      60466176,\n      40353607,\n      16777216,\n      43046721,\n      1e7,\n      19487171,\n      35831808,\n      62748517,\n      7529536,\n      11390625,\n      16777216,\n      24137569,\n      34012224,\n      47045881,\n      64e6,\n      4084101,\n      5153632,\n      6436343,\n      7962624,\n      9765625,\n      11881376,\n      14348907,\n      17210368,\n      20511149,\n      243e5,\n      28629151,\n      33554432,\n      39135393,\n      45435424,\n      52521875,\n      60466176\n    ];\n    o.prototype.toString = function(d, x) {\n      d = d || 10, x = x | 0 || 1;\n      var C;\n      if (d === 16 || d === \"hex\") {\n        C = \"\";\n        for (var M = 0, D = 0, z = 0; z < this.length; z++) {\n          var Y = this.words[z], L = ((Y << M | D) & 16777215).toString(16);\n          D = Y >>> 24 - M & 16777215, D !== 0 || z !== this.length - 1 ? C = c[6 - L.length] + L + C : C = L + C, M += 2, M >= 26 && (M -= 26, z--);\n        }\n        for (D !== 0 && (C = D.toString(16) + C); C.length % x !== 0; )\n          C = \"0\" + C;\n        return this.negative !== 0 && (C = \"-\" + C), C;\n      }\n      if (d === (d | 0) && d >= 2 && d <= 36) {\n        var m = f[d], E = h[d];\n        C = \"\";\n        var B = this.clone();\n        for (B.negative = 0; !B.isZero(); ) {\n          var V = B.modn(E).toString(d);\n          B = B.idivn(E), B.isZero() ? C = V + C : C = c[m - V.length] + V + C;\n        }\n        for (this.isZero() && (C = \"0\" + C); C.length % x !== 0; )\n          C = \"0\" + C;\n        return this.negative !== 0 && (C = \"-\" + C), C;\n      }\n      n(!1, \"Base should be between 2 and 36\");\n    }, o.prototype.toNumber = function() {\n      var d = this.words[0];\n      return this.length === 2 ? d += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? d += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && n(!1, \"Number can only safely store up to 53 bits\"), this.negative !== 0 ? -d : d;\n    }, o.prototype.toJSON = function() {\n      return this.toString(16);\n    }, o.prototype.toBuffer = function(d, x) {\n      return n(typeof a < \"u\"), this.toArrayLike(a, d, x);\n    }, o.prototype.toArray = function(d, x) {\n      return this.toArrayLike(Array, d, x);\n    }, o.prototype.toArrayLike = function(d, x, C) {\n      var M = this.byteLength(), D = C || Math.max(1, M);\n      n(M <= D, \"byte array longer than desired length\"), n(D > 0, \"Requested array length <= 0\"), this.strip();\n      var z = x === \"le\", Y = new d(D), L, m, E = this.clone();\n      if (z) {\n        for (m = 0; !E.isZero(); m++)\n          L = E.andln(255), E.iushrn(8), Y[m] = L;\n        for (; m < D; m++)\n          Y[m] = 0;\n      } else {\n        for (m = 0; m < D - M; m++)\n          Y[m] = 0;\n        for (m = 0; !E.isZero(); m++)\n          L = E.andln(255), E.iushrn(8), Y[D - m - 1] = L;\n      }\n      return Y;\n    }, Math.clz32 ? o.prototype._countBits = function(d) {\n      return 32 - Math.clz32(d);\n    } : o.prototype._countBits = function(d) {\n      var x = d, C = 0;\n      return x >= 4096 && (C += 13, x >>>= 13), x >= 64 && (C += 7, x >>>= 7), x >= 8 && (C += 4, x >>>= 4), x >= 2 && (C += 2, x >>>= 2), C + x;\n    }, o.prototype._zeroBits = function(d) {\n      if (d === 0)\n        return 26;\n      var x = d, C = 0;\n      return x & 8191 || (C += 13, x >>>= 13), x & 127 || (C += 7, x >>>= 7), x & 15 || (C += 4, x >>>= 4), x & 3 || (C += 2, x >>>= 2), x & 1 || C++, C;\n    }, o.prototype.bitLength = function() {\n      var d = this.words[this.length - 1], x = this._countBits(d);\n      return (this.length - 1) * 26 + x;\n    };\n    function p(P) {\n      for (var d = new Array(P.bitLength()), x = 0; x < d.length; x++) {\n        var C = x / 26 | 0, M = x % 26;\n        d[x] = (P.words[C] & 1 << M) >>> M;\n      }\n      return d;\n    }\n    o.prototype.zeroBits = function() {\n      if (this.isZero())\n        return 0;\n      for (var d = 0, x = 0; x < this.length; x++) {\n        var C = this._zeroBits(this.words[x]);\n        if (d += C, C !== 26)\n          break;\n      }\n      return d;\n    }, o.prototype.byteLength = function() {\n      return Math.ceil(this.bitLength() / 8);\n    }, o.prototype.toTwos = function(d) {\n      return this.negative !== 0 ? this.abs().inotn(d).iaddn(1) : this.clone();\n    }, o.prototype.fromTwos = function(d) {\n      return this.testn(d - 1) ? this.notn(d).iaddn(1).ineg() : this.clone();\n    }, o.prototype.isNeg = function() {\n      return this.negative !== 0;\n    }, o.prototype.neg = function() {\n      return this.clone().ineg();\n    }, o.prototype.ineg = function() {\n      return this.isZero() || (this.negative ^= 1), this;\n    }, o.prototype.iuor = function(d) {\n      for (; this.length < d.length; )\n        this.words[this.length++] = 0;\n      for (var x = 0; x < d.length; x++)\n        this.words[x] = this.words[x] | d.words[x];\n      return this.strip();\n    }, o.prototype.ior = function(d) {\n      return n((this.negative | d.negative) === 0), this.iuor(d);\n    }, o.prototype.or = function(d) {\n      return this.length > d.length ? this.clone().ior(d) : d.clone().ior(this);\n    }, o.prototype.uor = function(d) {\n      return this.length > d.length ? this.clone().iuor(d) : d.clone().iuor(this);\n    }, o.prototype.iuand = function(d) {\n      var x;\n      this.length > d.length ? x = d : x = this;\n      for (var C = 0; C < x.length; C++)\n        this.words[C] = this.words[C] & d.words[C];\n      return this.length = x.length, this.strip();\n    }, o.prototype.iand = function(d) {\n      return n((this.negative | d.negative) === 0), this.iuand(d);\n    }, o.prototype.and = function(d) {\n      return this.length > d.length ? this.clone().iand(d) : d.clone().iand(this);\n    }, o.prototype.uand = function(d) {\n      return this.length > d.length ? this.clone().iuand(d) : d.clone().iuand(this);\n    }, o.prototype.iuxor = function(d) {\n      var x, C;\n      this.length > d.length ? (x = this, C = d) : (x = d, C = this);\n      for (var M = 0; M < C.length; M++)\n        this.words[M] = x.words[M] ^ C.words[M];\n      if (this !== x)\n        for (; M < x.length; M++)\n          this.words[M] = x.words[M];\n      return this.length = x.length, this.strip();\n    }, o.prototype.ixor = function(d) {\n      return n((this.negative | d.negative) === 0), this.iuxor(d);\n    }, o.prototype.xor = function(d) {\n      return this.length > d.length ? this.clone().ixor(d) : d.clone().ixor(this);\n    }, o.prototype.uxor = function(d) {\n      return this.length > d.length ? this.clone().iuxor(d) : d.clone().iuxor(this);\n    }, o.prototype.inotn = function(d) {\n      n(typeof d == \"number\" && d >= 0);\n      var x = Math.ceil(d / 26) | 0, C = d % 26;\n      this._expand(x), C > 0 && x--;\n      for (var M = 0; M < x; M++)\n        this.words[M] = ~this.words[M] & 67108863;\n      return C > 0 && (this.words[M] = ~this.words[M] & 67108863 >> 26 - C), this.strip();\n    }, o.prototype.notn = function(d) {\n      return this.clone().inotn(d);\n    }, o.prototype.setn = function(d, x) {\n      n(typeof d == \"number\" && d >= 0);\n      var C = d / 26 | 0, M = d % 26;\n      return this._expand(C + 1), x ? this.words[C] = this.words[C] | 1 << M : this.words[C] = this.words[C] & ~(1 << M), this.strip();\n    }, o.prototype.iadd = function(d) {\n      var x;\n      if (this.negative !== 0 && d.negative === 0)\n        return this.negative = 0, x = this.isub(d), this.negative ^= 1, this._normSign();\n      if (this.negative === 0 && d.negative !== 0)\n        return d.negative = 0, x = this.isub(d), d.negative = 1, x._normSign();\n      var C, M;\n      this.length > d.length ? (C = this, M = d) : (C = d, M = this);\n      for (var D = 0, z = 0; z < M.length; z++)\n        x = (C.words[z] | 0) + (M.words[z] | 0) + D, this.words[z] = x & 67108863, D = x >>> 26;\n      for (; D !== 0 && z < C.length; z++)\n        x = (C.words[z] | 0) + D, this.words[z] = x & 67108863, D = x >>> 26;\n      if (this.length = C.length, D !== 0)\n        this.words[this.length] = D, this.length++;\n      else if (C !== this)\n        for (; z < C.length; z++)\n          this.words[z] = C.words[z];\n      return this;\n    }, o.prototype.add = function(d) {\n      var x;\n      return d.negative !== 0 && this.negative === 0 ? (d.negative = 0, x = this.sub(d), d.negative ^= 1, x) : d.negative === 0 && this.negative !== 0 ? (this.negative = 0, x = d.sub(this), this.negative = 1, x) : this.length > d.length ? this.clone().iadd(d) : d.clone().iadd(this);\n    }, o.prototype.isub = function(d) {\n      if (d.negative !== 0) {\n        d.negative = 0;\n        var x = this.iadd(d);\n        return d.negative = 1, x._normSign();\n      } else if (this.negative !== 0)\n        return this.negative = 0, this.iadd(d), this.negative = 1, this._normSign();\n      var C = this.cmp(d);\n      if (C === 0)\n        return this.negative = 0, this.length = 1, this.words[0] = 0, this;\n      var M, D;\n      C > 0 ? (M = this, D = d) : (M = d, D = this);\n      for (var z = 0, Y = 0; Y < D.length; Y++)\n        x = (M.words[Y] | 0) - (D.words[Y] | 0) + z, z = x >> 26, this.words[Y] = x & 67108863;\n      for (; z !== 0 && Y < M.length; Y++)\n        x = (M.words[Y] | 0) + z, z = x >> 26, this.words[Y] = x & 67108863;\n      if (z === 0 && Y < M.length && M !== this)\n        for (; Y < M.length; Y++)\n          this.words[Y] = M.words[Y];\n      return this.length = Math.max(this.length, Y), M !== this && (this.negative = 1), this.strip();\n    }, o.prototype.sub = function(d) {\n      return this.clone().isub(d);\n    };\n    function g(P, d, x) {\n      x.negative = d.negative ^ P.negative;\n      var C = P.length + d.length | 0;\n      x.length = C, C = C - 1 | 0;\n      var M = P.words[0] | 0, D = d.words[0] | 0, z = M * D, Y = z & 67108863, L = z / 67108864 | 0;\n      x.words[0] = Y;\n      for (var m = 1; m < C; m++) {\n        for (var E = L >>> 26, B = L & 67108863, V = Math.min(m, d.length - 1), I = Math.max(0, m - P.length + 1); I <= V; I++) {\n          var ne = m - I | 0;\n          M = P.words[ne] | 0, D = d.words[I] | 0, z = M * D + B, E += z / 67108864 | 0, B = z & 67108863;\n        }\n        x.words[m] = B | 0, L = E | 0;\n      }\n      return L !== 0 ? x.words[m] = L | 0 : x.length--, x.strip();\n    }\n    var _ = function(d, x, C) {\n      var M = d.words, D = x.words, z = C.words, Y = 0, L, m, E, B = M[0] | 0, V = B & 8191, I = B >>> 13, ne = M[1] | 0, se = ne & 8191, ce = ne >>> 13, oe = M[2] | 0, he = oe & 8191, k = oe >>> 13, H = M[3] | 0, N = H & 8191, J = H >>> 13, Q = M[4] | 0, ee = Q & 8191, S = Q >>> 13, y = M[5] | 0, v = y & 8191, b = y >>> 13, F = M[6] | 0, K = F & 8191, te = F >>> 13, de = M[7] | 0, pe = de & 8191, X = de >>> 13, ie = M[8] | 0, re = ie & 8191, ae = ie >>> 13, me = M[9] | 0, Te = me & 8191, ve = me >>> 13, _e = D[0] | 0, ye = _e & 8191, we = _e >>> 13, Ae = D[1] | 0, Pe = Ae & 8191, Se = Ae >>> 13, Sr = D[2] | 0, ze = Sr & 8191, qe = Sr >>> 13, zt = D[3] | 0, We = zt & 8191, Ke = zt >>> 13, Pr = D[4] | 0, rt = Pr & 8191, Ge = Pr >>> 13, zr = D[5] | 0, Je = zr & 8191, Ye = zr >>> 13, qr = D[6] | 0, Qe = qr & 8191, Be = qr >>> 13, Ct = D[7] | 0, et = Ct & 8191, nt = Ct >>> 13, ci = D[8] | 0, q = ci & 8191, le = ci >>> 13, ge = D[9] | 0, xe = ge & 8191, Ee = ge >>> 13;\n      C.negative = d.negative ^ x.negative, C.length = 19, L = Math.imul(V, ye), m = Math.imul(V, we), m = m + Math.imul(I, ye) | 0, E = Math.imul(I, we);\n      var Fe = (Y + L | 0) + ((m & 8191) << 13) | 0;\n      Y = (E + (m >>> 13) | 0) + (Fe >>> 26) | 0, Fe &= 67108863, L = Math.imul(se, ye), m = Math.imul(se, we), m = m + Math.imul(ce, ye) | 0, E = Math.imul(ce, we), L = L + Math.imul(V, Pe) | 0, m = m + Math.imul(V, Se) | 0, m = m + Math.imul(I, Pe) | 0, E = E + Math.imul(I, Se) | 0;\n      var Re = (Y + L | 0) + ((m & 8191) << 13) | 0;\n      Y = (E + (m >>> 13) | 0) + (Re >>> 26) | 0, Re &= 67108863, L = Math.imul(he, ye), m = Math.imul(he, we), m = m + Math.imul(k, ye) | 0, E = Math.imul(k, we), L = L + Math.imul(se, Pe) | 0, m = m + Math.imul(se, Se) | 0, m = m + Math.imul(ce, Pe) | 0, E = E + Math.imul(ce, Se) | 0, L = L + Math.imul(V, ze) | 0, m = m + Math.imul(V, qe) | 0, m = m + Math.imul(I, ze) | 0, E = E + Math.imul(I, qe) | 0;\n      var ke = (Y + L | 0) + ((m & 8191) << 13) | 0;\n      Y = (E + (m >>> 13) | 0) + (ke >>> 26) | 0, ke &= 67108863, L = Math.imul(N, ye), m = Math.imul(N, we), m = m + Math.imul(J, ye) | 0, E = Math.imul(J, we), L = L + Math.imul(he, Pe) | 0, m = m + Math.imul(he, Se) | 0, m = m + Math.imul(k, Pe) | 0, E = E + Math.imul(k, Se) | 0, L = L + Math.imul(se, ze) | 0, m = m + Math.imul(se, qe) | 0, m = m + Math.imul(ce, ze) | 0, E = E + Math.imul(ce, qe) | 0, L = L + Math.imul(V, We) | 0, m = m + Math.imul(V, Ke) | 0, m = m + Math.imul(I, We) | 0, E = E + Math.imul(I, Ke) | 0;\n      var ht = (Y + L | 0) + ((m & 8191) << 13) | 0;\n      Y = (E + (m >>> 13) | 0) + (ht >>> 26) | 0, ht &= 67108863, L = Math.imul(ee, ye), m = Math.imul(ee, we), m = m + Math.imul(S, ye) | 0, E = Math.imul(S, we), L = L + Math.imul(N, Pe) | 0, m = m + Math.imul(N, Se) | 0, m = m + Math.imul(J, Pe) | 0, E = E + Math.imul(J, Se) | 0, L = L + Math.imul(he, ze) | 0, m = m + Math.imul(he, qe) | 0, m = m + Math.imul(k, ze) | 0, E = E + Math.imul(k, qe) | 0, L = L + Math.imul(se, We) | 0, m = m + Math.imul(se, Ke) | 0, m = m + Math.imul(ce, We) | 0, E = E + Math.imul(ce, Ke) | 0, L = L + Math.imul(V, rt) | 0, m = m + Math.imul(V, Ge) | 0, m = m + Math.imul(I, rt) | 0, E = E + Math.imul(I, Ge) | 0;\n      var tt = (Y + L | 0) + ((m & 8191) << 13) | 0;\n      Y = (E + (m >>> 13) | 0) + (tt >>> 26) | 0, tt &= 67108863, L = Math.imul(v, ye), m = Math.imul(v, we), m = m + Math.imul(b, ye) | 0, E = Math.imul(b, we), L = L + Math.imul(ee, Pe) | 0, m = m + Math.imul(ee, Se) | 0, m = m + Math.imul(S, Pe) | 0, E = E + Math.imul(S, Se) | 0, L = L + Math.imul(N, ze) | 0, m = m + Math.imul(N, qe) | 0, m = m + Math.imul(J, ze) | 0, E = E + Math.imul(J, qe) | 0, L = L + Math.imul(he, We) | 0, m = m + Math.imul(he, Ke) | 0, m = m + Math.imul(k, We) | 0, E = E + Math.imul(k, Ke) | 0, L = L + Math.imul(se, rt) | 0, m = m + Math.imul(se, Ge) | 0, m = m + Math.imul(ce, rt) | 0, E = E + Math.imul(ce, Ge) | 0, L = L + Math.imul(V, Je) | 0, m = m + Math.imul(V, Ye) | 0, m = m + Math.imul(I, Je) | 0, E = E + Math.imul(I, Ye) | 0;\n      var it = (Y + L | 0) + ((m & 8191) << 13) | 0;\n      Y = (E + (m >>> 13) | 0) + (it >>> 26) | 0, it &= 67108863, L = Math.imul(K, ye), m = Math.imul(K, we), m = m + Math.imul(te, ye) | 0, E = Math.imul(te, we), L = L + Math.imul(v, Pe) | 0, m = m + Math.imul(v, Se) | 0, m = m + Math.imul(b, Pe) | 0, E = E + Math.imul(b, Se) | 0, L = L + Math.imul(ee, ze) | 0, m = m + Math.imul(ee, qe) | 0, m = m + Math.imul(S, ze) | 0, E = E + Math.imul(S, qe) | 0, L = L + Math.imul(N, We) | 0, m = m + Math.imul(N, Ke) | 0, m = m + Math.imul(J, We) | 0, E = E + Math.imul(J, Ke) | 0, L = L + Math.imul(he, rt) | 0, m = m + Math.imul(he, Ge) | 0, m = m + Math.imul(k, rt) | 0, E = E + Math.imul(k, Ge) | 0, L = L + Math.imul(se, Je) | 0, m = m + Math.imul(se, Ye) | 0, m = m + Math.imul(ce, Je) | 0, E = E + Math.imul(ce, Ye) | 0, L = L + Math.imul(V, Qe) | 0, m = m + Math.imul(V, Be) | 0, m = m + Math.imul(I, Qe) | 0, E = E + Math.imul(I, Be) | 0;\n      var xt = (Y + L | 0) + ((m & 8191) << 13) | 0;\n      Y = (E + (m >>> 13) | 0) + (xt >>> 26) | 0, xt &= 67108863, L = Math.imul(pe, ye), m = Math.imul(pe, we), m = m + Math.imul(X, ye) | 0, E = Math.imul(X, we), L = L + Math.imul(K, Pe) | 0, m = m + Math.imul(K, Se) | 0, m = m + Math.imul(te, Pe) | 0, E = E + Math.imul(te, Se) | 0, L = L + Math.imul(v, ze) | 0, m = m + Math.imul(v, qe) | 0, m = m + Math.imul(b, ze) | 0, E = E + Math.imul(b, qe) | 0, L = L + Math.imul(ee, We) | 0, m = m + Math.imul(ee, Ke) | 0, m = m + Math.imul(S, We) | 0, E = E + Math.imul(S, Ke) | 0, L = L + Math.imul(N, rt) | 0, m = m + Math.imul(N, Ge) | 0, m = m + Math.imul(J, rt) | 0, E = E + Math.imul(J, Ge) | 0, L = L + Math.imul(he, Je) | 0, m = m + Math.imul(he, Ye) | 0, m = m + Math.imul(k, Je) | 0, E = E + Math.imul(k, Ye) | 0, L = L + Math.imul(se, Qe) | 0, m = m + Math.imul(se, Be) | 0, m = m + Math.imul(ce, Qe) | 0, E = E + Math.imul(ce, Be) | 0, L = L + Math.imul(V, et) | 0, m = m + Math.imul(V, nt) | 0, m = m + Math.imul(I, et) | 0, E = E + Math.imul(I, nt) | 0;\n      var Zt = (Y + L | 0) + ((m & 8191) << 13) | 0;\n      Y = (E + (m >>> 13) | 0) + (Zt >>> 26) | 0, Zt &= 67108863, L = Math.imul(re, ye), m = Math.imul(re, we), m = m + Math.imul(ae, ye) | 0, E = Math.imul(ae, we), L = L + Math.imul(pe, Pe) | 0, m = m + Math.imul(pe, Se) | 0, m = m + Math.imul(X, Pe) | 0, E = E + Math.imul(X, Se) | 0, L = L + Math.imul(K, ze) | 0, m = m + Math.imul(K, qe) | 0, m = m + Math.imul(te, ze) | 0, E = E + Math.imul(te, qe) | 0, L = L + Math.imul(v, We) | 0, m = m + Math.imul(v, Ke) | 0, m = m + Math.imul(b, We) | 0, E = E + Math.imul(b, Ke) | 0, L = L + Math.imul(ee, rt) | 0, m = m + Math.imul(ee, Ge) | 0, m = m + Math.imul(S, rt) | 0, E = E + Math.imul(S, Ge) | 0, L = L + Math.imul(N, Je) | 0, m = m + Math.imul(N, Ye) | 0, m = m + Math.imul(J, Je) | 0, E = E + Math.imul(J, Ye) | 0, L = L + Math.imul(he, Qe) | 0, m = m + Math.imul(he, Be) | 0, m = m + Math.imul(k, Qe) | 0, E = E + Math.imul(k, Be) | 0, L = L + Math.imul(se, et) | 0, m = m + Math.imul(se, nt) | 0, m = m + Math.imul(ce, et) | 0, E = E + Math.imul(ce, nt) | 0, L = L + Math.imul(V, q) | 0, m = m + Math.imul(V, le) | 0, m = m + Math.imul(I, q) | 0, E = E + Math.imul(I, le) | 0;\n      var Kr = (Y + L | 0) + ((m & 8191) << 13) | 0;\n      Y = (E + (m >>> 13) | 0) + (Kr >>> 26) | 0, Kr &= 67108863, L = Math.imul(Te, ye), m = Math.imul(Te, we), m = m + Math.imul(ve, ye) | 0, E = Math.imul(ve, we), L = L + Math.imul(re, Pe) | 0, m = m + Math.imul(re, Se) | 0, m = m + Math.imul(ae, Pe) | 0, E = E + Math.imul(ae, Se) | 0, L = L + Math.imul(pe, ze) | 0, m = m + Math.imul(pe, qe) | 0, m = m + Math.imul(X, ze) | 0, E = E + Math.imul(X, qe) | 0, L = L + Math.imul(K, We) | 0, m = m + Math.imul(K, Ke) | 0, m = m + Math.imul(te, We) | 0, E = E + Math.imul(te, Ke) | 0, L = L + Math.imul(v, rt) | 0, m = m + Math.imul(v, Ge) | 0, m = m + Math.imul(b, rt) | 0, E = E + Math.imul(b, Ge) | 0, L = L + Math.imul(ee, Je) | 0, m = m + Math.imul(ee, Ye) | 0, m = m + Math.imul(S, Je) | 0, E = E + Math.imul(S, Ye) | 0, L = L + Math.imul(N, Qe) | 0, m = m + Math.imul(N, Be) | 0, m = m + Math.imul(J, Qe) | 0, E = E + Math.imul(J, Be) | 0, L = L + Math.imul(he, et) | 0, m = m + Math.imul(he, nt) | 0, m = m + Math.imul(k, et) | 0, E = E + Math.imul(k, nt) | 0, L = L + Math.imul(se, q) | 0, m = m + Math.imul(se, le) | 0, m = m + Math.imul(ce, q) | 0, E = E + Math.imul(ce, le) | 0, L = L + Math.imul(V, xe) | 0, m = m + Math.imul(V, Ee) | 0, m = m + Math.imul(I, xe) | 0, E = E + Math.imul(I, Ee) | 0;\n      var Ot = (Y + L | 0) + ((m & 8191) << 13) | 0;\n      Y = (E + (m >>> 13) | 0) + (Ot >>> 26) | 0, Ot &= 67108863, L = Math.imul(Te, Pe), m = Math.imul(Te, Se), m = m + Math.imul(ve, Pe) | 0, E = Math.imul(ve, Se), L = L + Math.imul(re, ze) | 0, m = m + Math.imul(re, qe) | 0, m = m + Math.imul(ae, ze) | 0, E = E + Math.imul(ae, qe) | 0, L = L + Math.imul(pe, We) | 0, m = m + Math.imul(pe, Ke) | 0, m = m + Math.imul(X, We) | 0, E = E + Math.imul(X, Ke) | 0, L = L + Math.imul(K, rt) | 0, m = m + Math.imul(K, Ge) | 0, m = m + Math.imul(te, rt) | 0, E = E + Math.imul(te, Ge) | 0, L = L + Math.imul(v, Je) | 0, m = m + Math.imul(v, Ye) | 0, m = m + Math.imul(b, Je) | 0, E = E + Math.imul(b, Ye) | 0, L = L + Math.imul(ee, Qe) | 0, m = m + Math.imul(ee, Be) | 0, m = m + Math.imul(S, Qe) | 0, E = E + Math.imul(S, Be) | 0, L = L + Math.imul(N, et) | 0, m = m + Math.imul(N, nt) | 0, m = m + Math.imul(J, et) | 0, E = E + Math.imul(J, nt) | 0, L = L + Math.imul(he, q) | 0, m = m + Math.imul(he, le) | 0, m = m + Math.imul(k, q) | 0, E = E + Math.imul(k, le) | 0, L = L + Math.imul(se, xe) | 0, m = m + Math.imul(se, Ee) | 0, m = m + Math.imul(ce, xe) | 0, E = E + Math.imul(ce, Ee) | 0;\n      var is = (Y + L | 0) + ((m & 8191) << 13) | 0;\n      Y = (E + (m >>> 13) | 0) + (is >>> 26) | 0, is &= 67108863, L = Math.imul(Te, ze), m = Math.imul(Te, qe), m = m + Math.imul(ve, ze) | 0, E = Math.imul(ve, qe), L = L + Math.imul(re, We) | 0, m = m + Math.imul(re, Ke) | 0, m = m + Math.imul(ae, We) | 0, E = E + Math.imul(ae, Ke) | 0, L = L + Math.imul(pe, rt) | 0, m = m + Math.imul(pe, Ge) | 0, m = m + Math.imul(X, rt) | 0, E = E + Math.imul(X, Ge) | 0, L = L + Math.imul(K, Je) | 0, m = m + Math.imul(K, Ye) | 0, m = m + Math.imul(te, Je) | 0, E = E + Math.imul(te, Ye) | 0, L = L + Math.imul(v, Qe) | 0, m = m + Math.imul(v, Be) | 0, m = m + Math.imul(b, Qe) | 0, E = E + Math.imul(b, Be) | 0, L = L + Math.imul(ee, et) | 0, m = m + Math.imul(ee, nt) | 0, m = m + Math.imul(S, et) | 0, E = E + Math.imul(S, nt) | 0, L = L + Math.imul(N, q) | 0, m = m + Math.imul(N, le) | 0, m = m + Math.imul(J, q) | 0, E = E + Math.imul(J, le) | 0, L = L + Math.imul(he, xe) | 0, m = m + Math.imul(he, Ee) | 0, m = m + Math.imul(k, xe) | 0, E = E + Math.imul(k, Ee) | 0;\n      var os = (Y + L | 0) + ((m & 8191) << 13) | 0;\n      Y = (E + (m >>> 13) | 0) + (os >>> 26) | 0, os &= 67108863, L = Math.imul(Te, We), m = Math.imul(Te, Ke), m = m + Math.imul(ve, We) | 0, E = Math.imul(ve, Ke), L = L + Math.imul(re, rt) | 0, m = m + Math.imul(re, Ge) | 0, m = m + Math.imul(ae, rt) | 0, E = E + Math.imul(ae, Ge) | 0, L = L + Math.imul(pe, Je) | 0, m = m + Math.imul(pe, Ye) | 0, m = m + Math.imul(X, Je) | 0, E = E + Math.imul(X, Ye) | 0, L = L + Math.imul(K, Qe) | 0, m = m + Math.imul(K, Be) | 0, m = m + Math.imul(te, Qe) | 0, E = E + Math.imul(te, Be) | 0, L = L + Math.imul(v, et) | 0, m = m + Math.imul(v, nt) | 0, m = m + Math.imul(b, et) | 0, E = E + Math.imul(b, nt) | 0, L = L + Math.imul(ee, q) | 0, m = m + Math.imul(ee, le) | 0, m = m + Math.imul(S, q) | 0, E = E + Math.imul(S, le) | 0, L = L + Math.imul(N, xe) | 0, m = m + Math.imul(N, Ee) | 0, m = m + Math.imul(J, xe) | 0, E = E + Math.imul(J, Ee) | 0;\n      var ss = (Y + L | 0) + ((m & 8191) << 13) | 0;\n      Y = (E + (m >>> 13) | 0) + (ss >>> 26) | 0, ss &= 67108863, L = Math.imul(Te, rt), m = Math.imul(Te, Ge), m = m + Math.imul(ve, rt) | 0, E = Math.imul(ve, Ge), L = L + Math.imul(re, Je) | 0, m = m + Math.imul(re, Ye) | 0, m = m + Math.imul(ae, Je) | 0, E = E + Math.imul(ae, Ye) | 0, L = L + Math.imul(pe, Qe) | 0, m = m + Math.imul(pe, Be) | 0, m = m + Math.imul(X, Qe) | 0, E = E + Math.imul(X, Be) | 0, L = L + Math.imul(K, et) | 0, m = m + Math.imul(K, nt) | 0, m = m + Math.imul(te, et) | 0, E = E + Math.imul(te, nt) | 0, L = L + Math.imul(v, q) | 0, m = m + Math.imul(v, le) | 0, m = m + Math.imul(b, q) | 0, E = E + Math.imul(b, le) | 0, L = L + Math.imul(ee, xe) | 0, m = m + Math.imul(ee, Ee) | 0, m = m + Math.imul(S, xe) | 0, E = E + Math.imul(S, Ee) | 0;\n      var as = (Y + L | 0) + ((m & 8191) << 13) | 0;\n      Y = (E + (m >>> 13) | 0) + (as >>> 26) | 0, as &= 67108863, L = Math.imul(Te, Je), m = Math.imul(Te, Ye), m = m + Math.imul(ve, Je) | 0, E = Math.imul(ve, Ye), L = L + Math.imul(re, Qe) | 0, m = m + Math.imul(re, Be) | 0, m = m + Math.imul(ae, Qe) | 0, E = E + Math.imul(ae, Be) | 0, L = L + Math.imul(pe, et) | 0, m = m + Math.imul(pe, nt) | 0, m = m + Math.imul(X, et) | 0, E = E + Math.imul(X, nt) | 0, L = L + Math.imul(K, q) | 0, m = m + Math.imul(K, le) | 0, m = m + Math.imul(te, q) | 0, E = E + Math.imul(te, le) | 0, L = L + Math.imul(v, xe) | 0, m = m + Math.imul(v, Ee) | 0, m = m + Math.imul(b, xe) | 0, E = E + Math.imul(b, Ee) | 0;\n      var cs = (Y + L | 0) + ((m & 8191) << 13) | 0;\n      Y = (E + (m >>> 13) | 0) + (cs >>> 26) | 0, cs &= 67108863, L = Math.imul(Te, Qe), m = Math.imul(Te, Be), m = m + Math.imul(ve, Qe) | 0, E = Math.imul(ve, Be), L = L + Math.imul(re, et) | 0, m = m + Math.imul(re, nt) | 0, m = m + Math.imul(ae, et) | 0, E = E + Math.imul(ae, nt) | 0, L = L + Math.imul(pe, q) | 0, m = m + Math.imul(pe, le) | 0, m = m + Math.imul(X, q) | 0, E = E + Math.imul(X, le) | 0, L = L + Math.imul(K, xe) | 0, m = m + Math.imul(K, Ee) | 0, m = m + Math.imul(te, xe) | 0, E = E + Math.imul(te, Ee) | 0;\n      var us = (Y + L | 0) + ((m & 8191) << 13) | 0;\n      Y = (E + (m >>> 13) | 0) + (us >>> 26) | 0, us &= 67108863, L = Math.imul(Te, et), m = Math.imul(Te, nt), m = m + Math.imul(ve, et) | 0, E = Math.imul(ve, nt), L = L + Math.imul(re, q) | 0, m = m + Math.imul(re, le) | 0, m = m + Math.imul(ae, q) | 0, E = E + Math.imul(ae, le) | 0, L = L + Math.imul(pe, xe) | 0, m = m + Math.imul(pe, Ee) | 0, m = m + Math.imul(X, xe) | 0, E = E + Math.imul(X, Ee) | 0;\n      var ls = (Y + L | 0) + ((m & 8191) << 13) | 0;\n      Y = (E + (m >>> 13) | 0) + (ls >>> 26) | 0, ls &= 67108863, L = Math.imul(Te, q), m = Math.imul(Te, le), m = m + Math.imul(ve, q) | 0, E = Math.imul(ve, le), L = L + Math.imul(re, xe) | 0, m = m + Math.imul(re, Ee) | 0, m = m + Math.imul(ae, xe) | 0, E = E + Math.imul(ae, Ee) | 0;\n      var fs = (Y + L | 0) + ((m & 8191) << 13) | 0;\n      Y = (E + (m >>> 13) | 0) + (fs >>> 26) | 0, fs &= 67108863, L = Math.imul(Te, xe), m = Math.imul(Te, Ee), m = m + Math.imul(ve, xe) | 0, E = Math.imul(ve, Ee);\n      var hs = (Y + L | 0) + ((m & 8191) << 13) | 0;\n      return Y = (E + (m >>> 13) | 0) + (hs >>> 26) | 0, hs &= 67108863, z[0] = Fe, z[1] = Re, z[2] = ke, z[3] = ht, z[4] = tt, z[5] = it, z[6] = xt, z[7] = Zt, z[8] = Kr, z[9] = Ot, z[10] = is, z[11] = os, z[12] = ss, z[13] = as, z[14] = cs, z[15] = us, z[16] = ls, z[17] = fs, z[18] = hs, Y !== 0 && (z[19] = Y, C.length++), C;\n    };\n    Math.imul || (_ = g);\n    function T(P, d, x) {\n      x.negative = d.negative ^ P.negative, x.length = P.length + d.length;\n      for (var C = 0, M = 0, D = 0; D < x.length - 1; D++) {\n        var z = M;\n        M = 0;\n        for (var Y = C & 67108863, L = Math.min(D, d.length - 1), m = Math.max(0, D - P.length + 1); m <= L; m++) {\n          var E = D - m, B = P.words[E] | 0, V = d.words[m] | 0, I = B * V, ne = I & 67108863;\n          z = z + (I / 67108864 | 0) | 0, ne = ne + Y | 0, Y = ne & 67108863, z = z + (ne >>> 26) | 0, M += z >>> 26, z &= 67108863;\n        }\n        x.words[D] = Y, C = z, z = M;\n      }\n      return C !== 0 ? x.words[D] = C : x.length--, x.strip();\n    }\n    function A(P, d, x) {\n      var C = new w();\n      return C.mulp(P, d, x);\n    }\n    o.prototype.mulTo = function(d, x) {\n      var C, M = this.length + d.length;\n      return this.length === 10 && d.length === 10 ? C = _(this, d, x) : M < 63 ? C = g(this, d, x) : M < 1024 ? C = T(this, d, x) : C = A(this, d, x), C;\n    };\n    function w(P, d) {\n      this.x = P, this.y = d;\n    }\n    w.prototype.makeRBT = function(d) {\n      for (var x = new Array(d), C = o.prototype._countBits(d) - 1, M = 0; M < d; M++)\n        x[M] = this.revBin(M, C, d);\n      return x;\n    }, w.prototype.revBin = function(d, x, C) {\n      if (d === 0 || d === C - 1)\n        return d;\n      for (var M = 0, D = 0; D < x; D++)\n        M |= (d & 1) << x - D - 1, d >>= 1;\n      return M;\n    }, w.prototype.permute = function(d, x, C, M, D, z) {\n      for (var Y = 0; Y < z; Y++)\n        M[Y] = x[d[Y]], D[Y] = C[d[Y]];\n    }, w.prototype.transform = function(d, x, C, M, D, z) {\n      this.permute(z, d, x, C, M, D);\n      for (var Y = 1; Y < D; Y <<= 1)\n        for (var L = Y << 1, m = Math.cos(2 * Math.PI / L), E = Math.sin(2 * Math.PI / L), B = 0; B < D; B += L)\n          for (var V = m, I = E, ne = 0; ne < Y; ne++) {\n            var se = C[B + ne], ce = M[B + ne], oe = C[B + ne + Y], he = M[B + ne + Y], k = V * oe - I * he;\n            he = V * he + I * oe, oe = k, C[B + ne] = se + oe, M[B + ne] = ce + he, C[B + ne + Y] = se - oe, M[B + ne + Y] = ce - he, ne !== L && (k = m * V - E * I, I = m * I + E * V, V = k);\n          }\n    }, w.prototype.guessLen13b = function(d, x) {\n      var C = Math.max(x, d) | 1, M = C & 1, D = 0;\n      for (C = C / 2 | 0; C; C = C >>> 1)\n        D++;\n      return 1 << D + 1 + M;\n    }, w.prototype.conjugate = function(d, x, C) {\n      if (!(C <= 1))\n        for (var M = 0; M < C / 2; M++) {\n          var D = d[M];\n          d[M] = d[C - M - 1], d[C - M - 1] = D, D = x[M], x[M] = -x[C - M - 1], x[C - M - 1] = -D;\n        }\n    }, w.prototype.normalize13b = function(d, x) {\n      for (var C = 0, M = 0; M < x / 2; M++) {\n        var D = Math.round(d[2 * M + 1] / x) * 8192 + Math.round(d[2 * M] / x) + C;\n        d[M] = D & 67108863, D < 67108864 ? C = 0 : C = D / 67108864 | 0;\n      }\n      return d;\n    }, w.prototype.convert13b = function(d, x, C, M) {\n      for (var D = 0, z = 0; z < x; z++)\n        D = D + (d[z] | 0), C[2 * z] = D & 8191, D = D >>> 13, C[2 * z + 1] = D & 8191, D = D >>> 13;\n      for (z = 2 * x; z < M; ++z)\n        C[z] = 0;\n      n(D === 0), n((D & -8192) === 0);\n    }, w.prototype.stub = function(d) {\n      for (var x = new Array(d), C = 0; C < d; C++)\n        x[C] = 0;\n      return x;\n    }, w.prototype.mulp = function(d, x, C) {\n      var M = 2 * this.guessLen13b(d.length, x.length), D = this.makeRBT(M), z = this.stub(M), Y = new Array(M), L = new Array(M), m = new Array(M), E = new Array(M), B = new Array(M), V = new Array(M), I = C.words;\n      I.length = M, this.convert13b(d.words, d.length, Y, M), this.convert13b(x.words, x.length, E, M), this.transform(Y, z, L, m, M, D), this.transform(E, z, B, V, M, D);\n      for (var ne = 0; ne < M; ne++) {\n        var se = L[ne] * B[ne] - m[ne] * V[ne];\n        m[ne] = L[ne] * V[ne] + m[ne] * B[ne], L[ne] = se;\n      }\n      return this.conjugate(L, m, M), this.transform(L, m, I, z, M, D), this.conjugate(I, z, M), this.normalize13b(I, M), C.negative = d.negative ^ x.negative, C.length = d.length + x.length, C.strip();\n    }, o.prototype.mul = function(d) {\n      var x = new o(null);\n      return x.words = new Array(this.length + d.length), this.mulTo(d, x);\n    }, o.prototype.mulf = function(d) {\n      var x = new o(null);\n      return x.words = new Array(this.length + d.length), A(this, d, x);\n    }, o.prototype.imul = function(d) {\n      return this.clone().mulTo(d, this);\n    }, o.prototype.imuln = function(d) {\n      n(typeof d == \"number\"), n(d < 67108864);\n      for (var x = 0, C = 0; C < this.length; C++) {\n        var M = (this.words[C] | 0) * d, D = (M & 67108863) + (x & 67108863);\n        x >>= 26, x += M / 67108864 | 0, x += D >>> 26, this.words[C] = D & 67108863;\n      }\n      return x !== 0 && (this.words[C] = x, this.length++), this;\n    }, o.prototype.muln = function(d) {\n      return this.clone().imuln(d);\n    }, o.prototype.sqr = function() {\n      return this.mul(this);\n    }, o.prototype.isqr = function() {\n      return this.imul(this.clone());\n    }, o.prototype.pow = function(d) {\n      var x = p(d);\n      if (x.length === 0)\n        return new o(1);\n      for (var C = this, M = 0; M < x.length && x[M] === 0; M++, C = C.sqr())\n        ;\n      if (++M < x.length)\n        for (var D = C.sqr(); M < x.length; M++, D = D.sqr())\n          x[M] !== 0 && (C = C.mul(D));\n      return C;\n    }, o.prototype.iushln = function(d) {\n      n(typeof d == \"number\" && d >= 0);\n      var x = d % 26, C = (d - x) / 26, M = 67108863 >>> 26 - x << 26 - x, D;\n      if (x !== 0) {\n        var z = 0;\n        for (D = 0; D < this.length; D++) {\n          var Y = this.words[D] & M, L = (this.words[D] | 0) - Y << x;\n          this.words[D] = L | z, z = Y >>> 26 - x;\n        }\n        z && (this.words[D] = z, this.length++);\n      }\n      if (C !== 0) {\n        for (D = this.length - 1; D >= 0; D--)\n          this.words[D + C] = this.words[D];\n        for (D = 0; D < C; D++)\n          this.words[D] = 0;\n        this.length += C;\n      }\n      return this.strip();\n    }, o.prototype.ishln = function(d) {\n      return n(this.negative === 0), this.iushln(d);\n    }, o.prototype.iushrn = function(d, x, C) {\n      n(typeof d == \"number\" && d >= 0);\n      var M;\n      x ? M = (x - x % 26) / 26 : M = 0;\n      var D = d % 26, z = Math.min((d - D) / 26, this.length), Y = 67108863 ^ 67108863 >>> D << D, L = C;\n      if (M -= z, M = Math.max(0, M), L) {\n        for (var m = 0; m < z; m++)\n          L.words[m] = this.words[m];\n        L.length = z;\n      }\n      if (z !== 0)\n        if (this.length > z)\n          for (this.length -= z, m = 0; m < this.length; m++)\n            this.words[m] = this.words[m + z];\n        else\n          this.words[0] = 0, this.length = 1;\n      var E = 0;\n      for (m = this.length - 1; m >= 0 && (E !== 0 || m >= M); m--) {\n        var B = this.words[m] | 0;\n        this.words[m] = E << 26 - D | B >>> D, E = B & Y;\n      }\n      return L && E !== 0 && (L.words[L.length++] = E), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();\n    }, o.prototype.ishrn = function(d, x, C) {\n      return n(this.negative === 0), this.iushrn(d, x, C);\n    }, o.prototype.shln = function(d) {\n      return this.clone().ishln(d);\n    }, o.prototype.ushln = function(d) {\n      return this.clone().iushln(d);\n    }, o.prototype.shrn = function(d) {\n      return this.clone().ishrn(d);\n    }, o.prototype.ushrn = function(d) {\n      return this.clone().iushrn(d);\n    }, o.prototype.testn = function(d) {\n      n(typeof d == \"number\" && d >= 0);\n      var x = d % 26, C = (d - x) / 26, M = 1 << x;\n      if (this.length <= C)\n        return !1;\n      var D = this.words[C];\n      return !!(D & M);\n    }, o.prototype.imaskn = function(d) {\n      n(typeof d == \"number\" && d >= 0);\n      var x = d % 26, C = (d - x) / 26;\n      if (n(this.negative === 0, \"imaskn works only with positive numbers\"), this.length <= C)\n        return this;\n      if (x !== 0 && C++, this.length = Math.min(C, this.length), x !== 0) {\n        var M = 67108863 ^ 67108863 >>> x << x;\n        this.words[this.length - 1] &= M;\n      }\n      return this.strip();\n    }, o.prototype.maskn = function(d) {\n      return this.clone().imaskn(d);\n    }, o.prototype.iaddn = function(d) {\n      return n(typeof d == \"number\"), n(d < 67108864), d < 0 ? this.isubn(-d) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < d ? (this.words[0] = d - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(d), this.negative = 1, this) : this._iaddn(d);\n    }, o.prototype._iaddn = function(d) {\n      this.words[0] += d;\n      for (var x = 0; x < this.length && this.words[x] >= 67108864; x++)\n        this.words[x] -= 67108864, x === this.length - 1 ? this.words[x + 1] = 1 : this.words[x + 1]++;\n      return this.length = Math.max(this.length, x + 1), this;\n    }, o.prototype.isubn = function(d) {\n      if (n(typeof d == \"number\"), n(d < 67108864), d < 0)\n        return this.iaddn(-d);\n      if (this.negative !== 0)\n        return this.negative = 0, this.iaddn(d), this.negative = 1, this;\n      if (this.words[0] -= d, this.length === 1 && this.words[0] < 0)\n        this.words[0] = -this.words[0], this.negative = 1;\n      else\n        for (var x = 0; x < this.length && this.words[x] < 0; x++)\n          this.words[x] += 67108864, this.words[x + 1] -= 1;\n      return this.strip();\n    }, o.prototype.addn = function(d) {\n      return this.clone().iaddn(d);\n    }, o.prototype.subn = function(d) {\n      return this.clone().isubn(d);\n    }, o.prototype.iabs = function() {\n      return this.negative = 0, this;\n    }, o.prototype.abs = function() {\n      return this.clone().iabs();\n    }, o.prototype._ishlnsubmul = function(d, x, C) {\n      var M = d.length + C, D;\n      this._expand(M);\n      var z, Y = 0;\n      for (D = 0; D < d.length; D++) {\n        z = (this.words[D + C] | 0) + Y;\n        var L = (d.words[D] | 0) * x;\n        z -= L & 67108863, Y = (z >> 26) - (L / 67108864 | 0), this.words[D + C] = z & 67108863;\n      }\n      for (; D < this.length - C; D++)\n        z = (this.words[D + C] | 0) + Y, Y = z >> 26, this.words[D + C] = z & 67108863;\n      if (Y === 0)\n        return this.strip();\n      for (n(Y === -1), Y = 0, D = 0; D < this.length; D++)\n        z = -(this.words[D] | 0) + Y, Y = z >> 26, this.words[D] = z & 67108863;\n      return this.negative = 1, this.strip();\n    }, o.prototype._wordDiv = function(d, x) {\n      var C = this.length - d.length, M = this.clone(), D = d, z = D.words[D.length - 1] | 0, Y = this._countBits(z);\n      C = 26 - Y, C !== 0 && (D = D.ushln(C), M.iushln(C), z = D.words[D.length - 1] | 0);\n      var L = M.length - D.length, m;\n      if (x !== \"mod\") {\n        m = new o(null), m.length = L + 1, m.words = new Array(m.length);\n        for (var E = 0; E < m.length; E++)\n          m.words[E] = 0;\n      }\n      var B = M.clone()._ishlnsubmul(D, 1, L);\n      B.negative === 0 && (M = B, m && (m.words[L] = 1));\n      for (var V = L - 1; V >= 0; V--) {\n        var I = (M.words[D.length + V] | 0) * 67108864 + (M.words[D.length + V - 1] | 0);\n        for (I = Math.min(I / z | 0, 67108863), M._ishlnsubmul(D, I, V); M.negative !== 0; )\n          I--, M.negative = 0, M._ishlnsubmul(D, 1, V), M.isZero() || (M.negative ^= 1);\n        m && (m.words[V] = I);\n      }\n      return m && m.strip(), M.strip(), x !== \"div\" && C !== 0 && M.iushrn(C), {\n        div: m || null,\n        mod: M\n      };\n    }, o.prototype.divmod = function(d, x, C) {\n      if (n(!d.isZero()), this.isZero())\n        return {\n          div: new o(0),\n          mod: new o(0)\n        };\n      var M, D, z;\n      return this.negative !== 0 && d.negative === 0 ? (z = this.neg().divmod(d, x), x !== \"mod\" && (M = z.div.neg()), x !== \"div\" && (D = z.mod.neg(), C && D.negative !== 0 && D.iadd(d)), {\n        div: M,\n        mod: D\n      }) : this.negative === 0 && d.negative !== 0 ? (z = this.divmod(d.neg(), x), x !== \"mod\" && (M = z.div.neg()), {\n        div: M,\n        mod: z.mod\n      }) : this.negative & d.negative ? (z = this.neg().divmod(d.neg(), x), x !== \"div\" && (D = z.mod.neg(), C && D.negative !== 0 && D.isub(d)), {\n        div: z.div,\n        mod: D\n      }) : d.length > this.length || this.cmp(d) < 0 ? {\n        div: new o(0),\n        mod: this\n      } : d.length === 1 ? x === \"div\" ? {\n        div: this.divn(d.words[0]),\n        mod: null\n      } : x === \"mod\" ? {\n        div: null,\n        mod: new o(this.modn(d.words[0]))\n      } : {\n        div: this.divn(d.words[0]),\n        mod: new o(this.modn(d.words[0]))\n      } : this._wordDiv(d, x);\n    }, o.prototype.div = function(d) {\n      return this.divmod(d, \"div\", !1).div;\n    }, o.prototype.mod = function(d) {\n      return this.divmod(d, \"mod\", !1).mod;\n    }, o.prototype.umod = function(d) {\n      return this.divmod(d, \"mod\", !0).mod;\n    }, o.prototype.divRound = function(d) {\n      var x = this.divmod(d);\n      if (x.mod.isZero())\n        return x.div;\n      var C = x.div.negative !== 0 ? x.mod.isub(d) : x.mod, M = d.ushrn(1), D = d.andln(1), z = C.cmp(M);\n      return z < 0 || D === 1 && z === 0 ? x.div : x.div.negative !== 0 ? x.div.isubn(1) : x.div.iaddn(1);\n    }, o.prototype.modn = function(d) {\n      n(d <= 67108863);\n      for (var x = (1 << 26) % d, C = 0, M = this.length - 1; M >= 0; M--)\n        C = (x * C + (this.words[M] | 0)) % d;\n      return C;\n    }, o.prototype.idivn = function(d) {\n      n(d <= 67108863);\n      for (var x = 0, C = this.length - 1; C >= 0; C--) {\n        var M = (this.words[C] | 0) + x * 67108864;\n        this.words[C] = M / d | 0, x = M % d;\n      }\n      return this.strip();\n    }, o.prototype.divn = function(d) {\n      return this.clone().idivn(d);\n    }, o.prototype.egcd = function(d) {\n      n(d.negative === 0), n(!d.isZero());\n      var x = this, C = d.clone();\n      x.negative !== 0 ? x = x.umod(d) : x = x.clone();\n      for (var M = new o(1), D = new o(0), z = new o(0), Y = new o(1), L = 0; x.isEven() && C.isEven(); )\n        x.iushrn(1), C.iushrn(1), ++L;\n      for (var m = C.clone(), E = x.clone(); !x.isZero(); ) {\n        for (var B = 0, V = 1; !(x.words[0] & V) && B < 26; ++B, V <<= 1)\n          ;\n        if (B > 0)\n          for (x.iushrn(B); B-- > 0; )\n            (M.isOdd() || D.isOdd()) && (M.iadd(m), D.isub(E)), M.iushrn(1), D.iushrn(1);\n        for (var I = 0, ne = 1; !(C.words[0] & ne) && I < 26; ++I, ne <<= 1)\n          ;\n        if (I > 0)\n          for (C.iushrn(I); I-- > 0; )\n            (z.isOdd() || Y.isOdd()) && (z.iadd(m), Y.isub(E)), z.iushrn(1), Y.iushrn(1);\n        x.cmp(C) >= 0 ? (x.isub(C), M.isub(z), D.isub(Y)) : (C.isub(x), z.isub(M), Y.isub(D));\n      }\n      return {\n        a: z,\n        b: Y,\n        gcd: C.iushln(L)\n      };\n    }, o.prototype._invmp = function(d) {\n      n(d.negative === 0), n(!d.isZero());\n      var x = this, C = d.clone();\n      x.negative !== 0 ? x = x.umod(d) : x = x.clone();\n      for (var M = new o(1), D = new o(0), z = C.clone(); x.cmpn(1) > 0 && C.cmpn(1) > 0; ) {\n        for (var Y = 0, L = 1; !(x.words[0] & L) && Y < 26; ++Y, L <<= 1)\n          ;\n        if (Y > 0)\n          for (x.iushrn(Y); Y-- > 0; )\n            M.isOdd() && M.iadd(z), M.iushrn(1);\n        for (var m = 0, E = 1; !(C.words[0] & E) && m < 26; ++m, E <<= 1)\n          ;\n        if (m > 0)\n          for (C.iushrn(m); m-- > 0; )\n            D.isOdd() && D.iadd(z), D.iushrn(1);\n        x.cmp(C) >= 0 ? (x.isub(C), M.isub(D)) : (C.isub(x), D.isub(M));\n      }\n      var B;\n      return x.cmpn(1) === 0 ? B = M : B = D, B.cmpn(0) < 0 && B.iadd(d), B;\n    }, o.prototype.gcd = function(d) {\n      if (this.isZero())\n        return d.abs();\n      if (d.isZero())\n        return this.abs();\n      var x = this.clone(), C = d.clone();\n      x.negative = 0, C.negative = 0;\n      for (var M = 0; x.isEven() && C.isEven(); M++)\n        x.iushrn(1), C.iushrn(1);\n      do {\n        for (; x.isEven(); )\n          x.iushrn(1);\n        for (; C.isEven(); )\n          C.iushrn(1);\n        var D = x.cmp(C);\n        if (D < 0) {\n          var z = x;\n          x = C, C = z;\n        } else if (D === 0 || C.cmpn(1) === 0)\n          break;\n        x.isub(C);\n      } while (!0);\n      return C.iushln(M);\n    }, o.prototype.invm = function(d) {\n      return this.egcd(d).a.umod(d);\n    }, o.prototype.isEven = function() {\n      return (this.words[0] & 1) === 0;\n    }, o.prototype.isOdd = function() {\n      return (this.words[0] & 1) === 1;\n    }, o.prototype.andln = function(d) {\n      return this.words[0] & d;\n    }, o.prototype.bincn = function(d) {\n      n(typeof d == \"number\");\n      var x = d % 26, C = (d - x) / 26, M = 1 << x;\n      if (this.length <= C)\n        return this._expand(C + 1), this.words[C] |= M, this;\n      for (var D = M, z = C; D !== 0 && z < this.length; z++) {\n        var Y = this.words[z] | 0;\n        Y += D, D = Y >>> 26, Y &= 67108863, this.words[z] = Y;\n      }\n      return D !== 0 && (this.words[z] = D, this.length++), this;\n    }, o.prototype.isZero = function() {\n      return this.length === 1 && this.words[0] === 0;\n    }, o.prototype.cmpn = function(d) {\n      var x = d < 0;\n      if (this.negative !== 0 && !x)\n        return -1;\n      if (this.negative === 0 && x)\n        return 1;\n      this.strip();\n      var C;\n      if (this.length > 1)\n        C = 1;\n      else {\n        x && (d = -d), n(d <= 67108863, \"Number is too big\");\n        var M = this.words[0] | 0;\n        C = M === d ? 0 : M < d ? -1 : 1;\n      }\n      return this.negative !== 0 ? -C | 0 : C;\n    }, o.prototype.cmp = function(d) {\n      if (this.negative !== 0 && d.negative === 0)\n        return -1;\n      if (this.negative === 0 && d.negative !== 0)\n        return 1;\n      var x = this.ucmp(d);\n      return this.negative !== 0 ? -x | 0 : x;\n    }, o.prototype.ucmp = function(d) {\n      if (this.length > d.length)\n        return 1;\n      if (this.length < d.length)\n        return -1;\n      for (var x = 0, C = this.length - 1; C >= 0; C--) {\n        var M = this.words[C] | 0, D = d.words[C] | 0;\n        if (M !== D) {\n          M < D ? x = -1 : M > D && (x = 1);\n          break;\n        }\n      }\n      return x;\n    }, o.prototype.gtn = function(d) {\n      return this.cmpn(d) === 1;\n    }, o.prototype.gt = function(d) {\n      return this.cmp(d) === 1;\n    }, o.prototype.gten = function(d) {\n      return this.cmpn(d) >= 0;\n    }, o.prototype.gte = function(d) {\n      return this.cmp(d) >= 0;\n    }, o.prototype.ltn = function(d) {\n      return this.cmpn(d) === -1;\n    }, o.prototype.lt = function(d) {\n      return this.cmp(d) === -1;\n    }, o.prototype.lten = function(d) {\n      return this.cmpn(d) <= 0;\n    }, o.prototype.lte = function(d) {\n      return this.cmp(d) <= 0;\n    }, o.prototype.eqn = function(d) {\n      return this.cmpn(d) === 0;\n    }, o.prototype.eq = function(d) {\n      return this.cmp(d) === 0;\n    }, o.red = function(d) {\n      return new Z(d);\n    }, o.prototype.toRed = function(d) {\n      return n(!this.red, \"Already a number in reduction context\"), n(this.negative === 0, \"red works only with positives\"), d.convertTo(this)._forceRed(d);\n    }, o.prototype.fromRed = function() {\n      return n(this.red, \"fromRed works only with numbers in reduction context\"), this.red.convertFrom(this);\n    }, o.prototype._forceRed = function(d) {\n      return this.red = d, this;\n    }, o.prototype.forceRed = function(d) {\n      return n(!this.red, \"Already a number in reduction context\"), this._forceRed(d);\n    }, o.prototype.redAdd = function(d) {\n      return n(this.red, \"redAdd works only with red numbers\"), this.red.add(this, d);\n    }, o.prototype.redIAdd = function(d) {\n      return n(this.red, \"redIAdd works only with red numbers\"), this.red.iadd(this, d);\n    }, o.prototype.redSub = function(d) {\n      return n(this.red, \"redSub works only with red numbers\"), this.red.sub(this, d);\n    }, o.prototype.redISub = function(d) {\n      return n(this.red, \"redISub works only with red numbers\"), this.red.isub(this, d);\n    }, o.prototype.redShl = function(d) {\n      return n(this.red, \"redShl works only with red numbers\"), this.red.shl(this, d);\n    }, o.prototype.redMul = function(d) {\n      return n(this.red, \"redMul works only with red numbers\"), this.red._verify2(this, d), this.red.mul(this, d);\n    }, o.prototype.redIMul = function(d) {\n      return n(this.red, \"redMul works only with red numbers\"), this.red._verify2(this, d), this.red.imul(this, d);\n    }, o.prototype.redSqr = function() {\n      return n(this.red, \"redSqr works only with red numbers\"), this.red._verify1(this), this.red.sqr(this);\n    }, o.prototype.redISqr = function() {\n      return n(this.red, \"redISqr works only with red numbers\"), this.red._verify1(this), this.red.isqr(this);\n    }, o.prototype.redSqrt = function() {\n      return n(this.red, \"redSqrt works only with red numbers\"), this.red._verify1(this), this.red.sqrt(this);\n    }, o.prototype.redInvm = function() {\n      return n(this.red, \"redInvm works only with red numbers\"), this.red._verify1(this), this.red.invm(this);\n    }, o.prototype.redNeg = function() {\n      return n(this.red, \"redNeg works only with red numbers\"), this.red._verify1(this), this.red.neg(this);\n    }, o.prototype.redPow = function(d) {\n      return n(this.red && !d.red, \"redPow(normalNum)\"), this.red._verify1(this), this.red.pow(this, d);\n    };\n    var O = {\n      k256: null,\n      p224: null,\n      p192: null,\n      p25519: null\n    };\n    function R(P, d) {\n      this.name = P, this.p = new o(d, 16), this.n = this.p.bitLength(), this.k = new o(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();\n    }\n    R.prototype._tmp = function() {\n      var d = new o(null);\n      return d.words = new Array(Math.ceil(this.n / 13)), d;\n    }, R.prototype.ireduce = function(d) {\n      var x = d, C;\n      do\n        this.split(x, this.tmp), x = this.imulK(x), x = x.iadd(this.tmp), C = x.bitLength();\n      while (C > this.n);\n      var M = C < this.n ? -1 : x.ucmp(this.p);\n      return M === 0 ? (x.words[0] = 0, x.length = 1) : M > 0 ? x.isub(this.p) : x.strip !== void 0 ? x.strip() : x._strip(), x;\n    }, R.prototype.split = function(d, x) {\n      d.iushrn(this.n, 0, x);\n    }, R.prototype.imulK = function(d) {\n      return d.imul(this.k);\n    };\n    function $() {\n      R.call(\n        this,\n        \"k256\",\n        \"ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f\"\n      );\n    }\n    i($, R), $.prototype.split = function(d, x) {\n      for (var C = 4194303, M = Math.min(d.length, 9), D = 0; D < M; D++)\n        x.words[D] = d.words[D];\n      if (x.length = M, d.length <= 9) {\n        d.words[0] = 0, d.length = 1;\n        return;\n      }\n      var z = d.words[9];\n      for (x.words[x.length++] = z & C, D = 10; D < d.length; D++) {\n        var Y = d.words[D] | 0;\n        d.words[D - 10] = (Y & C) << 4 | z >>> 22, z = Y;\n      }\n      z >>>= 22, d.words[D - 10] = z, z === 0 && d.length > 10 ? d.length -= 10 : d.length -= 9;\n    }, $.prototype.imulK = function(d) {\n      d.words[d.length] = 0, d.words[d.length + 1] = 0, d.length += 2;\n      for (var x = 0, C = 0; C < d.length; C++) {\n        var M = d.words[C] | 0;\n        x += M * 977, d.words[C] = x & 67108863, x = M * 64 + (x / 67108864 | 0);\n      }\n      return d.words[d.length - 1] === 0 && (d.length--, d.words[d.length - 1] === 0 && d.length--), d;\n    };\n    function U() {\n      R.call(\n        this,\n        \"p224\",\n        \"ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001\"\n      );\n    }\n    i(U, R);\n    function W() {\n      R.call(\n        this,\n        \"p192\",\n        \"ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff\"\n      );\n    }\n    i(W, R);\n    function G() {\n      R.call(\n        this,\n        \"25519\",\n        \"7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed\"\n      );\n    }\n    i(G, R), G.prototype.imulK = function(d) {\n      for (var x = 0, C = 0; C < d.length; C++) {\n        var M = (d.words[C] | 0) * 19 + x, D = M & 67108863;\n        M >>>= 26, d.words[C] = D, x = M;\n      }\n      return x !== 0 && (d.words[d.length++] = x), d;\n    }, o._prime = function(d) {\n      if (O[d])\n        return O[d];\n      var x;\n      if (d === \"k256\")\n        x = new $();\n      else if (d === \"p224\")\n        x = new U();\n      else if (d === \"p192\")\n        x = new W();\n      else if (d === \"p25519\")\n        x = new G();\n      else\n        throw new Error(\"Unknown prime \" + d);\n      return O[d] = x, x;\n    };\n    function Z(P) {\n      if (typeof P == \"string\") {\n        var d = o._prime(P);\n        this.m = d.p, this.prime = d;\n      } else\n        n(P.gtn(1), \"modulus must be greater than 1\"), this.m = P, this.prime = null;\n    }\n    Z.prototype._verify1 = function(d) {\n      n(d.negative === 0, \"red works only with positives\"), n(d.red, \"red works only with red numbers\");\n    }, Z.prototype._verify2 = function(d, x) {\n      n((d.negative | x.negative) === 0, \"red works only with positives\"), n(\n        d.red && d.red === x.red,\n        \"red works only with red numbers\"\n      );\n    }, Z.prototype.imod = function(d) {\n      return this.prime ? this.prime.ireduce(d)._forceRed(this) : d.umod(this.m)._forceRed(this);\n    }, Z.prototype.neg = function(d) {\n      return d.isZero() ? d.clone() : this.m.sub(d)._forceRed(this);\n    }, Z.prototype.add = function(d, x) {\n      this._verify2(d, x);\n      var C = d.add(x);\n      return C.cmp(this.m) >= 0 && C.isub(this.m), C._forceRed(this);\n    }, Z.prototype.iadd = function(d, x) {\n      this._verify2(d, x);\n      var C = d.iadd(x);\n      return C.cmp(this.m) >= 0 && C.isub(this.m), C;\n    }, Z.prototype.sub = function(d, x) {\n      this._verify2(d, x);\n      var C = d.sub(x);\n      return C.cmpn(0) < 0 && C.iadd(this.m), C._forceRed(this);\n    }, Z.prototype.isub = function(d, x) {\n      this._verify2(d, x);\n      var C = d.isub(x);\n      return C.cmpn(0) < 0 && C.iadd(this.m), C;\n    }, Z.prototype.shl = function(d, x) {\n      return this._verify1(d), this.imod(d.ushln(x));\n    }, Z.prototype.imul = function(d, x) {\n      return this._verify2(d, x), this.imod(d.imul(x));\n    }, Z.prototype.mul = function(d, x) {\n      return this._verify2(d, x), this.imod(d.mul(x));\n    }, Z.prototype.isqr = function(d) {\n      return this.imul(d, d.clone());\n    }, Z.prototype.sqr = function(d) {\n      return this.mul(d, d);\n    }, Z.prototype.sqrt = function(d) {\n      if (d.isZero())\n        return d.clone();\n      var x = this.m.andln(3);\n      if (n(x % 2 === 1), x === 3) {\n        var C = this.m.add(new o(1)).iushrn(2);\n        return this.pow(d, C);\n      }\n      for (var M = this.m.subn(1), D = 0; !M.isZero() && M.andln(1) === 0; )\n        D++, M.iushrn(1);\n      n(!M.isZero());\n      var z = new o(1).toRed(this), Y = z.redNeg(), L = this.m.subn(1).iushrn(1), m = this.m.bitLength();\n      for (m = new o(2 * m * m).toRed(this); this.pow(m, L).cmp(Y) !== 0; )\n        m.redIAdd(Y);\n      for (var E = this.pow(m, M), B = this.pow(d, M.addn(1).iushrn(1)), V = this.pow(d, M), I = D; V.cmp(z) !== 0; ) {\n        for (var ne = V, se = 0; ne.cmp(z) !== 0; se++)\n          ne = ne.redSqr();\n        n(se < I);\n        var ce = this.pow(E, new o(1).iushln(I - se - 1));\n        B = B.redMul(ce), E = ce.redSqr(), V = V.redMul(E), I = se;\n      }\n      return B;\n    }, Z.prototype.invm = function(d) {\n      var x = d._invmp(this.m);\n      return x.negative !== 0 ? (x.negative = 0, this.imod(x).redNeg()) : this.imod(x);\n    }, Z.prototype.pow = function(d, x) {\n      if (x.isZero())\n        return new o(1).toRed(this);\n      if (x.cmpn(1) === 0)\n        return d.clone();\n      var C = 4, M = new Array(1 << C);\n      M[0] = new o(1).toRed(this), M[1] = d;\n      for (var D = 2; D < M.length; D++)\n        M[D] = this.mul(M[D - 1], d);\n      var z = M[0], Y = 0, L = 0, m = x.bitLength() % 26;\n      for (m === 0 && (m = 26), D = x.length - 1; D >= 0; D--) {\n        for (var E = x.words[D], B = m - 1; B >= 0; B--) {\n          var V = E >> B & 1;\n          if (z !== M[0] && (z = this.sqr(z)), V === 0 && Y === 0) {\n            L = 0;\n            continue;\n          }\n          Y <<= 1, Y |= V, L++, !(L !== C && (D !== 0 || B !== 0)) && (z = this.mul(z, M[Y]), L = 0, Y = 0);\n        }\n        m = 26;\n      }\n      return z;\n    }, Z.prototype.convertTo = function(d) {\n      var x = d.umod(this.m);\n      return x === d ? x.clone() : x;\n    }, Z.prototype.convertFrom = function(d) {\n      var x = d.clone();\n      return x.red = null, x;\n    }, o.mont = function(d) {\n      return new j(d);\n    };\n    function j(P) {\n      Z.call(this, P), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new o(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);\n    }\n    i(j, Z), j.prototype.convertTo = function(d) {\n      return this.imod(d.ushln(this.shift));\n    }, j.prototype.convertFrom = function(d) {\n      var x = this.imod(d.mul(this.rinv));\n      return x.red = null, x;\n    }, j.prototype.imul = function(d, x) {\n      if (d.isZero() || x.isZero())\n        return d.words[0] = 0, d.length = 1, d;\n      var C = d.imul(x), M = C.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), D = C.isub(M).iushrn(this.shift), z = D;\n      return D.cmp(this.m) >= 0 ? z = D.isub(this.m) : D.cmpn(0) < 0 && (z = D.iadd(this.m)), z._forceRed(this);\n    }, j.prototype.mul = function(d, x) {\n      if (d.isZero() || x.isZero())\n        return new o(0)._forceRed(this);\n      var C = d.mul(x), M = C.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), D = C.isub(M).iushrn(this.shift), z = D;\n      return D.cmp(this.m) >= 0 ? z = D.isub(this.m) : D.cmpn(0) < 0 && (z = D.iadd(this.m)), z._forceRed(this);\n    }, j.prototype.invm = function(d) {\n      var x = this.imod(d._invmp(this.m).mul(this.r2));\n      return x._forceRed(this);\n    };\n  })(t, ue);\n})(O1);\nvar Uh = {}, Cc = {}, Vh = {}, ri = {};\nri.byteLength = R1;\nri.toByteArray = I1;\nri.fromByteArray = F1;\nvar Qt = [], Ft = [], M1 = typeof Uint8Array < \"u\" ? Uint8Array : Array, Ws = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\nfor (var Gr = 0, k1 = Ws.length; Gr < k1; ++Gr)\n  Qt[Gr] = Ws[Gr], Ft[Ws.charCodeAt(Gr)] = Gr;\nFt[\"-\".charCodeAt(0)] = 62;\nFt[\"_\".charCodeAt(0)] = 63;\nfunction $h(t) {\n  var e = t.length;\n  if (e % 4 > 0)\n    throw new Error(\"Invalid string. Length must be a multiple of 4\");\n  var r = t.indexOf(\"=\");\n  r === -1 && (r = e);\n  var n = r === e ? 0 : 4 - r % 4;\n  return [r, n];\n}\nfunction R1(t) {\n  var e = $h(t), r = e[0], n = e[1];\n  return (r + n) * 3 / 4 - n;\n}\nfunction B1(t, e, r) {\n  return (e + r) * 3 / 4 - r;\n}\nfunction I1(t) {\n  var e, r = $h(t), n = r[0], i = r[1], o = new M1(B1(t, n, i)), a = 0, s = i > 0 ? n - 4 : n, l;\n  for (l = 0; l < s; l += 4)\n    e = Ft[t.charCodeAt(l)] << 18 | Ft[t.charCodeAt(l + 1)] << 12 | Ft[t.charCodeAt(l + 2)] << 6 | Ft[t.charCodeAt(l + 3)], o[a++] = e >> 16 & 255, o[a++] = e >> 8 & 255, o[a++] = e & 255;\n  return i === 2 && (e = Ft[t.charCodeAt(l)] << 2 | Ft[t.charCodeAt(l + 1)] >> 4, o[a++] = e & 255), i === 1 && (e = Ft[t.charCodeAt(l)] << 10 | Ft[t.charCodeAt(l + 1)] << 4 | Ft[t.charCodeAt(l + 2)] >> 2, o[a++] = e >> 8 & 255, o[a++] = e & 255), o;\n}\nfunction D1(t) {\n  return Qt[t >> 18 & 63] + Qt[t >> 12 & 63] + Qt[t >> 6 & 63] + Qt[t & 63];\n}\nfunction N1(t, e, r) {\n  for (var n, i = [], o = e; o < r; o += 3)\n    n = (t[o] << 16 & 16711680) + (t[o + 1] << 8 & 65280) + (t[o + 2] & 255), i.push(D1(n));\n  return i.join(\"\");\n}\nfunction F1(t) {\n  for (var e, r = t.length, n = r % 3, i = [], o = 16383, a = 0, s = r - n; a < s; a += o)\n    i.push(N1(t, a, a + o > s ? s : a + o));\n  return n === 1 ? (e = t[r - 1], i.push(\n    Qt[e >> 2] + Qt[e << 4 & 63] + \"==\"\n  )) : n === 2 && (e = (t[r - 2] << 8) + t[r - 1], i.push(\n    Qt[e >> 10] + Qt[e >> 4 & 63] + Qt[e << 2 & 63] + \"=\"\n  )), i.join(\"\");\n}\nvar Oc = {};\n/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\nOc.read = function(t, e, r, n, i) {\n  var o, a, s = i * 8 - n - 1, l = (1 << s) - 1, u = l >> 1, c = -7, f = r ? i - 1 : 0, h = r ? -1 : 1, p = t[e + f];\n  for (f += h, o = p & (1 << -c) - 1, p >>= -c, c += s; c > 0; o = o * 256 + t[e + f], f += h, c -= 8)\n    ;\n  for (a = o & (1 << -c) - 1, o >>= -c, c += n; c > 0; a = a * 256 + t[e + f], f += h, c -= 8)\n    ;\n  if (o === 0)\n    o = 1 - u;\n  else {\n    if (o === l)\n      return a ? NaN : (p ? -1 : 1) * (1 / 0);\n    a = a + Math.pow(2, n), o = o - u;\n  }\n  return (p ? -1 : 1) * a * Math.pow(2, o - n);\n};\nOc.write = function(t, e, r, n, i, o) {\n  var a, s, l, u = o * 8 - i - 1, c = (1 << u) - 1, f = c >> 1, h = i === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, p = n ? 0 : o - 1, g = n ? 1 : -1, _ = e < 0 || e === 0 && 1 / e < 0 ? 1 : 0;\n  for (e = Math.abs(e), isNaN(e) || e === 1 / 0 ? (s = isNaN(e) ? 1 : 0, a = c) : (a = Math.floor(Math.log(e) / Math.LN2), e * (l = Math.pow(2, -a)) < 1 && (a--, l *= 2), a + f >= 1 ? e += h / l : e += h * Math.pow(2, 1 - f), e * l >= 2 && (a++, l /= 2), a + f >= c ? (s = 0, a = c) : a + f >= 1 ? (s = (e * l - 1) * Math.pow(2, i), a = a + f) : (s = e * Math.pow(2, f - 1) * Math.pow(2, i), a = 0)); i >= 8; t[r + p] = s & 255, p += g, s /= 256, i -= 8)\n    ;\n  for (a = a << i | s, u += i; u > 0; t[r + p] = a & 255, p += g, a /= 256, u -= 8)\n    ;\n  t[r + p - g] |= _ * 128;\n};\n/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n(function(t) {\n  var e = ri, r = Oc, n = typeof Symbol == \"function\" && typeof Symbol.for == \"function\" ? Symbol.for(\"nodejs.util.inspect.custom\") : null;\n  t.Buffer = s, t.SlowBuffer = w, t.INSPECT_MAX_BYTES = 50;\n  var i = 2147483647;\n  t.kMaxLength = i, s.TYPED_ARRAY_SUPPORT = o(), !s.TYPED_ARRAY_SUPPORT && typeof console < \"u\" && typeof console.error == \"function\" && console.error(\n    \"This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.\"\n  );\n  function o() {\n    try {\n      var S = new Uint8Array(1), y = { foo: function() {\n        return 42;\n      } };\n      return Object.setPrototypeOf(y, Uint8Array.prototype), Object.setPrototypeOf(S, y), S.foo() === 42;\n    } catch {\n      return !1;\n    }\n  }\n  Object.defineProperty(s.prototype, \"parent\", {\n    enumerable: !0,\n    get: function() {\n      if (s.isBuffer(this))\n        return this.buffer;\n    }\n  }), Object.defineProperty(s.prototype, \"offset\", {\n    enumerable: !0,\n    get: function() {\n      if (s.isBuffer(this))\n        return this.byteOffset;\n    }\n  });\n  function a(S) {\n    if (S > i)\n      throw new RangeError('The value \"' + S + '\" is invalid for option \"size\"');\n    var y = new Uint8Array(S);\n    return Object.setPrototypeOf(y, s.prototype), y;\n  }\n  function s(S, y, v) {\n    if (typeof S == \"number\") {\n      if (typeof y == \"string\")\n        throw new TypeError(\n          'The \"string\" argument must be of type string. Received type number'\n        );\n      return f(S);\n    }\n    return l(S, y, v);\n  }\n  s.poolSize = 8192;\n  function l(S, y, v) {\n    if (typeof S == \"string\")\n      return h(S, y);\n    if (ArrayBuffer.isView(S))\n      return g(S);\n    if (S == null)\n      throw new TypeError(\n        \"The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type \" + typeof S\n      );\n    if (J(S, ArrayBuffer) || S && J(S.buffer, ArrayBuffer) || typeof SharedArrayBuffer < \"u\" && (J(S, SharedArrayBuffer) || S && J(S.buffer, SharedArrayBuffer)))\n      return _(S, y, v);\n    if (typeof S == \"number\")\n      throw new TypeError(\n        'The \"value\" argument must not be of type number. Received type number'\n      );\n    var b = S.valueOf && S.valueOf();\n    if (b != null && b !== S)\n      return s.from(b, y, v);\n    var F = T(S);\n    if (F)\n      return F;\n    if (typeof Symbol < \"u\" && Symbol.toPrimitive != null && typeof S[Symbol.toPrimitive] == \"function\")\n      return s.from(\n        S[Symbol.toPrimitive](\"string\"),\n        y,\n        v\n      );\n    throw new TypeError(\n      \"The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type \" + typeof S\n    );\n  }\n  s.from = function(S, y, v) {\n    return l(S, y, v);\n  }, Object.setPrototypeOf(s.prototype, Uint8Array.prototype), Object.setPrototypeOf(s, Uint8Array);\n  function u(S) {\n    if (typeof S != \"number\")\n      throw new TypeError('\"size\" argument must be of type number');\n    if (S < 0)\n      throw new RangeError('The value \"' + S + '\" is invalid for option \"size\"');\n  }\n  function c(S, y, v) {\n    return u(S), S <= 0 ? a(S) : y !== void 0 ? typeof v == \"string\" ? a(S).fill(y, v) : a(S).fill(y) : a(S);\n  }\n  s.alloc = function(S, y, v) {\n    return c(S, y, v);\n  };\n  function f(S) {\n    return u(S), a(S < 0 ? 0 : A(S) | 0);\n  }\n  s.allocUnsafe = function(S) {\n    return f(S);\n  }, s.allocUnsafeSlow = function(S) {\n    return f(S);\n  };\n  function h(S, y) {\n    if ((typeof y != \"string\" || y === \"\") && (y = \"utf8\"), !s.isEncoding(y))\n      throw new TypeError(\"Unknown encoding: \" + y);\n    var v = O(S, y) | 0, b = a(v), F = b.write(S, y);\n    return F !== v && (b = b.slice(0, F)), b;\n  }\n  function p(S) {\n    for (var y = S.length < 0 ? 0 : A(S.length) | 0, v = a(y), b = 0; b < y; b += 1)\n      v[b] = S[b] & 255;\n    return v;\n  }\n  function g(S) {\n    if (J(S, Uint8Array)) {\n      var y = new Uint8Array(S);\n      return _(y.buffer, y.byteOffset, y.byteLength);\n    }\n    return p(S);\n  }\n  function _(S, y, v) {\n    if (y < 0 || S.byteLength < y)\n      throw new RangeError('\"offset\" is outside of buffer bounds');\n    if (S.byteLength < y + (v || 0))\n      throw new RangeError('\"length\" is outside of buffer bounds');\n    var b;\n    return y === void 0 && v === void 0 ? b = new Uint8Array(S) : v === void 0 ? b = new Uint8Array(S, y) : b = new Uint8Array(S, y, v), Object.setPrototypeOf(b, s.prototype), b;\n  }\n  function T(S) {\n    if (s.isBuffer(S)) {\n      var y = A(S.length) | 0, v = a(y);\n      return v.length === 0 || S.copy(v, 0, 0, y), v;\n    }\n    if (S.length !== void 0)\n      return typeof S.length != \"number\" || Q(S.length) ? a(0) : p(S);\n    if (S.type === \"Buffer\" && Array.isArray(S.data))\n      return p(S.data);\n  }\n  function A(S) {\n    if (S >= i)\n      throw new RangeError(\"Attempt to allocate Buffer larger than maximum size: 0x\" + i.toString(16) + \" bytes\");\n    return S | 0;\n  }\n  function w(S) {\n    return +S != S && (S = 0), s.alloc(+S);\n  }\n  s.isBuffer = function(y) {\n    return y != null && y._isBuffer === !0 && y !== s.prototype;\n  }, s.compare = function(y, v) {\n    if (J(y, Uint8Array) && (y = s.from(y, y.offset, y.byteLength)), J(v, Uint8Array) && (v = s.from(v, v.offset, v.byteLength)), !s.isBuffer(y) || !s.isBuffer(v))\n      throw new TypeError(\n        'The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array'\n      );\n    if (y === v)\n      return 0;\n    for (var b = y.length, F = v.length, K = 0, te = Math.min(b, F); K < te; ++K)\n      if (y[K] !== v[K]) {\n        b = y[K], F = v[K];\n        break;\n      }\n    return b < F ? -1 : F < b ? 1 : 0;\n  }, s.isEncoding = function(y) {\n    switch (String(y).toLowerCase()) {\n      case \"hex\":\n      case \"utf8\":\n      case \"utf-8\":\n      case \"ascii\":\n      case \"latin1\":\n      case \"binary\":\n      case \"base64\":\n      case \"ucs2\":\n      case \"ucs-2\":\n      case \"utf16le\":\n      case \"utf-16le\":\n        return !0;\n      default:\n        return !1;\n    }\n  }, s.concat = function(y, v) {\n    if (!Array.isArray(y))\n      throw new TypeError('\"list\" argument must be an Array of Buffers');\n    if (y.length === 0)\n      return s.alloc(0);\n    var b;\n    if (v === void 0)\n      for (v = 0, b = 0; b < y.length; ++b)\n        v += y[b].length;\n    var F = s.allocUnsafe(v), K = 0;\n    for (b = 0; b < y.length; ++b) {\n      var te = y[b];\n      if (J(te, Uint8Array))\n        K + te.length > F.length ? s.from(te).copy(F, K) : Uint8Array.prototype.set.call(\n          F,\n          te,\n          K\n        );\n      else if (s.isBuffer(te))\n        te.copy(F, K);\n      else\n        throw new TypeError('\"list\" argument must be an Array of Buffers');\n      K += te.length;\n    }\n    return F;\n  };\n  function O(S, y) {\n    if (s.isBuffer(S))\n      return S.length;\n    if (ArrayBuffer.isView(S) || J(S, ArrayBuffer))\n      return S.byteLength;\n    if (typeof S != \"string\")\n      throw new TypeError(\n        'The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof S\n      );\n    var v = S.length, b = arguments.length > 2 && arguments[2] === !0;\n    if (!b && v === 0)\n      return 0;\n    for (var F = !1; ; )\n      switch (y) {\n        case \"ascii\":\n        case \"latin1\":\n        case \"binary\":\n          return v;\n        case \"utf8\":\n        case \"utf-8\":\n          return oe(S).length;\n        case \"ucs2\":\n        case \"ucs-2\":\n        case \"utf16le\":\n        case \"utf-16le\":\n          return v * 2;\n        case \"hex\":\n          return v >>> 1;\n        case \"base64\":\n          return H(S).length;\n        default:\n          if (F)\n            return b ? -1 : oe(S).length;\n          y = (\"\" + y).toLowerCase(), F = !0;\n      }\n  }\n  s.byteLength = O;\n  function R(S, y, v) {\n    var b = !1;\n    if ((y === void 0 || y < 0) && (y = 0), y > this.length || ((v === void 0 || v > this.length) && (v = this.length), v <= 0) || (v >>>= 0, y >>>= 0, v <= y))\n      return \"\";\n    for (S || (S = \"utf8\"); ; )\n      switch (S) {\n        case \"hex\":\n          return L(this, y, v);\n        case \"utf8\":\n        case \"utf-8\":\n          return C(this, y, v);\n        case \"ascii\":\n          return z(this, y, v);\n        case \"latin1\":\n        case \"binary\":\n          return Y(this, y, v);\n        case \"base64\":\n          return x(this, y, v);\n        case \"ucs2\":\n        case \"ucs-2\":\n        case \"utf16le\":\n        case \"utf-16le\":\n          return m(this, y, v);\n        default:\n          if (b)\n            throw new TypeError(\"Unknown encoding: \" + S);\n          S = (S + \"\").toLowerCase(), b = !0;\n      }\n  }\n  s.prototype._isBuffer = !0;\n  function $(S, y, v) {\n    var b = S[y];\n    S[y] = S[v], S[v] = b;\n  }\n  s.prototype.swap16 = function() {\n    var y = this.length;\n    if (y % 2 !== 0)\n      throw new RangeError(\"Buffer size must be a multiple of 16-bits\");\n    for (var v = 0; v < y; v += 2)\n      $(this, v, v + 1);\n    return this;\n  }, s.prototype.swap32 = function() {\n    var y = this.length;\n    if (y % 4 !== 0)\n      throw new RangeError(\"Buffer size must be a multiple of 32-bits\");\n    for (var v = 0; v < y; v += 4)\n      $(this, v, v + 3), $(this, v + 1, v + 2);\n    return this;\n  }, s.prototype.swap64 = function() {\n    var y = this.length;\n    if (y % 8 !== 0)\n      throw new RangeError(\"Buffer size must be a multiple of 64-bits\");\n    for (var v = 0; v < y; v += 8)\n      $(this, v, v + 7), $(this, v + 1, v + 6), $(this, v + 2, v + 5), $(this, v + 3, v + 4);\n    return this;\n  }, s.prototype.toString = function() {\n    var y = this.length;\n    return y === 0 ? \"\" : arguments.length === 0 ? C(this, 0, y) : R.apply(this, arguments);\n  }, s.prototype.toLocaleString = s.prototype.toString, s.prototype.equals = function(y) {\n    if (!s.isBuffer(y))\n      throw new TypeError(\"Argument must be a Buffer\");\n    return this === y ? !0 : s.compare(this, y) === 0;\n  }, s.prototype.inspect = function() {\n    var y = \"\", v = t.INSPECT_MAX_BYTES;\n    return y = this.toString(\"hex\", 0, v).replace(/(.{2})/g, \"$1 \").trim(), this.length > v && (y += \" ... \"), \"<Buffer \" + y + \">\";\n  }, n && (s.prototype[n] = s.prototype.inspect), s.prototype.compare = function(y, v, b, F, K) {\n    if (J(y, Uint8Array) && (y = s.from(y, y.offset, y.byteLength)), !s.isBuffer(y))\n      throw new TypeError(\n        'The \"target\" argument must be one of type Buffer or Uint8Array. Received type ' + typeof y\n      );\n    if (v === void 0 && (v = 0), b === void 0 && (b = y ? y.length : 0), F === void 0 && (F = 0), K === void 0 && (K = this.length), v < 0 || b > y.length || F < 0 || K > this.length)\n      throw new RangeError(\"out of range index\");\n    if (F >= K && v >= b)\n      return 0;\n    if (F >= K)\n      return -1;\n    if (v >= b)\n      return 1;\n    if (v >>>= 0, b >>>= 0, F >>>= 0, K >>>= 0, this === y)\n      return 0;\n    for (var te = K - F, de = b - v, pe = Math.min(te, de), X = this.slice(F, K), ie = y.slice(v, b), re = 0; re < pe; ++re)\n      if (X[re] !== ie[re]) {\n        te = X[re], de = ie[re];\n        break;\n      }\n    return te < de ? -1 : de < te ? 1 : 0;\n  };\n  function U(S, y, v, b, F) {\n    if (S.length === 0)\n      return -1;\n    if (typeof v == \"string\" ? (b = v, v = 0) : v > 2147483647 ? v = 2147483647 : v < -2147483648 && (v = -2147483648), v = +v, Q(v) && (v = F ? 0 : S.length - 1), v < 0 && (v = S.length + v), v >= S.length) {\n      if (F)\n        return -1;\n      v = S.length - 1;\n    } else if (v < 0)\n      if (F)\n        v = 0;\n      else\n        return -1;\n    if (typeof y == \"string\" && (y = s.from(y, b)), s.isBuffer(y))\n      return y.length === 0 ? -1 : W(S, y, v, b, F);\n    if (typeof y == \"number\")\n      return y = y & 255, typeof Uint8Array.prototype.indexOf == \"function\" ? F ? Uint8Array.prototype.indexOf.call(S, y, v) : Uint8Array.prototype.lastIndexOf.call(S, y, v) : W(S, [y], v, b, F);\n    throw new TypeError(\"val must be string, number or Buffer\");\n  }\n  function W(S, y, v, b, F) {\n    var K = 1, te = S.length, de = y.length;\n    if (b !== void 0 && (b = String(b).toLowerCase(), b === \"ucs2\" || b === \"ucs-2\" || b === \"utf16le\" || b === \"utf-16le\")) {\n      if (S.length < 2 || y.length < 2)\n        return -1;\n      K = 2, te /= 2, de /= 2, v /= 2;\n    }\n    function pe(me, Te) {\n      return K === 1 ? me[Te] : me.readUInt16BE(Te * K);\n    }\n    var X;\n    if (F) {\n      var ie = -1;\n      for (X = v; X < te; X++)\n        if (pe(S, X) === pe(y, ie === -1 ? 0 : X - ie)) {\n          if (ie === -1 && (ie = X), X - ie + 1 === de)\n            return ie * K;\n        } else\n          ie !== -1 && (X -= X - ie), ie = -1;\n    } else\n      for (v + de > te && (v = te - de), X = v; X >= 0; X--) {\n        for (var re = !0, ae = 0; ae < de; ae++)\n          if (pe(S, X + ae) !== pe(y, ae)) {\n            re = !1;\n            break;\n          }\n        if (re)\n          return X;\n      }\n    return -1;\n  }\n  s.prototype.includes = function(y, v, b) {\n    return this.indexOf(y, v, b) !== -1;\n  }, s.prototype.indexOf = function(y, v, b) {\n    return U(this, y, v, b, !0);\n  }, s.prototype.lastIndexOf = function(y, v, b) {\n    return U(this, y, v, b, !1);\n  };\n  function G(S, y, v, b) {\n    v = Number(v) || 0;\n    var F = S.length - v;\n    b ? (b = Number(b), b > F && (b = F)) : b = F;\n    var K = y.length;\n    b > K / 2 && (b = K / 2);\n    for (var te = 0; te < b; ++te) {\n      var de = parseInt(y.substr(te * 2, 2), 16);\n      if (Q(de))\n        return te;\n      S[v + te] = de;\n    }\n    return te;\n  }\n  function Z(S, y, v, b) {\n    return N(oe(y, S.length - v), S, v, b);\n  }\n  function j(S, y, v, b) {\n    return N(he(y), S, v, b);\n  }\n  function P(S, y, v, b) {\n    return N(H(y), S, v, b);\n  }\n  function d(S, y, v, b) {\n    return N(k(y, S.length - v), S, v, b);\n  }\n  s.prototype.write = function(y, v, b, F) {\n    if (v === void 0)\n      F = \"utf8\", b = this.length, v = 0;\n    else if (b === void 0 && typeof v == \"string\")\n      F = v, b = this.length, v = 0;\n    else if (isFinite(v))\n      v = v >>> 0, isFinite(b) ? (b = b >>> 0, F === void 0 && (F = \"utf8\")) : (F = b, b = void 0);\n    else\n      throw new Error(\n        \"Buffer.write(string, encoding, offset[, length]) is no longer supported\"\n      );\n    var K = this.length - v;\n    if ((b === void 0 || b > K) && (b = K), y.length > 0 && (b < 0 || v < 0) || v > this.length)\n      throw new RangeError(\"Attempt to write outside buffer bounds\");\n    F || (F = \"utf8\");\n    for (var te = !1; ; )\n      switch (F) {\n        case \"hex\":\n          return G(this, y, v, b);\n        case \"utf8\":\n        case \"utf-8\":\n          return Z(this, y, v, b);\n        case \"ascii\":\n        case \"latin1\":\n        case \"binary\":\n          return j(this, y, v, b);\n        case \"base64\":\n          return P(this, y, v, b);\n        case \"ucs2\":\n        case \"ucs-2\":\n        case \"utf16le\":\n        case \"utf-16le\":\n          return d(this, y, v, b);\n        default:\n          if (te)\n            throw new TypeError(\"Unknown encoding: \" + F);\n          F = (\"\" + F).toLowerCase(), te = !0;\n      }\n  }, s.prototype.toJSON = function() {\n    return {\n      type: \"Buffer\",\n      data: Array.prototype.slice.call(this._arr || this, 0)\n    };\n  };\n  function x(S, y, v) {\n    return y === 0 && v === S.length ? e.fromByteArray(S) : e.fromByteArray(S.slice(y, v));\n  }\n  function C(S, y, v) {\n    v = Math.min(S.length, v);\n    for (var b = [], F = y; F < v; ) {\n      var K = S[F], te = null, de = K > 239 ? 4 : K > 223 ? 3 : K > 191 ? 2 : 1;\n      if (F + de <= v) {\n        var pe, X, ie, re;\n        switch (de) {\n          case 1:\n            K < 128 && (te = K);\n            break;\n          case 2:\n            pe = S[F + 1], (pe & 192) === 128 && (re = (K & 31) << 6 | pe & 63, re > 127 && (te = re));\n            break;\n          case 3:\n            pe = S[F + 1], X = S[F + 2], (pe & 192) === 128 && (X & 192) === 128 && (re = (K & 15) << 12 | (pe & 63) << 6 | X & 63, re > 2047 && (re < 55296 || re > 57343) && (te = re));\n            break;\n          case 4:\n            pe = S[F + 1], X = S[F + 2], ie = S[F + 3], (pe & 192) === 128 && (X & 192) === 128 && (ie & 192) === 128 && (re = (K & 15) << 18 | (pe & 63) << 12 | (X & 63) << 6 | ie & 63, re > 65535 && re < 1114112 && (te = re));\n        }\n      }\n      te === null ? (te = 65533, de = 1) : te > 65535 && (te -= 65536, b.push(te >>> 10 & 1023 | 55296), te = 56320 | te & 1023), b.push(te), F += de;\n    }\n    return D(b);\n  }\n  var M = 4096;\n  function D(S) {\n    var y = S.length;\n    if (y <= M)\n      return String.fromCharCode.apply(String, S);\n    for (var v = \"\", b = 0; b < y; )\n      v += String.fromCharCode.apply(\n        String,\n        S.slice(b, b += M)\n      );\n    return v;\n  }\n  function z(S, y, v) {\n    var b = \"\";\n    v = Math.min(S.length, v);\n    for (var F = y; F < v; ++F)\n      b += String.fromCharCode(S[F] & 127);\n    return b;\n  }\n  function Y(S, y, v) {\n    var b = \"\";\n    v = Math.min(S.length, v);\n    for (var F = y; F < v; ++F)\n      b += String.fromCharCode(S[F]);\n    return b;\n  }\n  function L(S, y, v) {\n    var b = S.length;\n    (!y || y < 0) && (y = 0), (!v || v < 0 || v > b) && (v = b);\n    for (var F = \"\", K = y; K < v; ++K)\n      F += ee[S[K]];\n    return F;\n  }\n  function m(S, y, v) {\n    for (var b = S.slice(y, v), F = \"\", K = 0; K < b.length - 1; K += 2)\n      F += String.fromCharCode(b[K] + b[K + 1] * 256);\n    return F;\n  }\n  s.prototype.slice = function(y, v) {\n    var b = this.length;\n    y = ~~y, v = v === void 0 ? b : ~~v, y < 0 ? (y += b, y < 0 && (y = 0)) : y > b && (y = b), v < 0 ? (v += b, v < 0 && (v = 0)) : v > b && (v = b), v < y && (v = y);\n    var F = this.subarray(y, v);\n    return Object.setPrototypeOf(F, s.prototype), F;\n  };\n  function E(S, y, v) {\n    if (S % 1 !== 0 || S < 0)\n      throw new RangeError(\"offset is not uint\");\n    if (S + y > v)\n      throw new RangeError(\"Trying to access beyond buffer length\");\n  }\n  s.prototype.readUintLE = s.prototype.readUIntLE = function(y, v, b) {\n    y = y >>> 0, v = v >>> 0, b || E(y, v, this.length);\n    for (var F = this[y], K = 1, te = 0; ++te < v && (K *= 256); )\n      F += this[y + te] * K;\n    return F;\n  }, s.prototype.readUintBE = s.prototype.readUIntBE = function(y, v, b) {\n    y = y >>> 0, v = v >>> 0, b || E(y, v, this.length);\n    for (var F = this[y + --v], K = 1; v > 0 && (K *= 256); )\n      F += this[y + --v] * K;\n    return F;\n  }, s.prototype.readUint8 = s.prototype.readUInt8 = function(y, v) {\n    return y = y >>> 0, v || E(y, 1, this.length), this[y];\n  }, s.prototype.readUint16LE = s.prototype.readUInt16LE = function(y, v) {\n    return y = y >>> 0, v || E(y, 2, this.length), this[y] | this[y + 1] << 8;\n  }, s.prototype.readUint16BE = s.prototype.readUInt16BE = function(y, v) {\n    return y = y >>> 0, v || E(y, 2, this.length), this[y] << 8 | this[y + 1];\n  }, s.prototype.readUint32LE = s.prototype.readUInt32LE = function(y, v) {\n    return y = y >>> 0, v || E(y, 4, this.length), (this[y] | this[y + 1] << 8 | this[y + 2] << 16) + this[y + 3] * 16777216;\n  }, s.prototype.readUint32BE = s.prototype.readUInt32BE = function(y, v) {\n    return y = y >>> 0, v || E(y, 4, this.length), this[y] * 16777216 + (this[y + 1] << 16 | this[y + 2] << 8 | this[y + 3]);\n  }, s.prototype.readIntLE = function(y, v, b) {\n    y = y >>> 0, v = v >>> 0, b || E(y, v, this.length);\n    for (var F = this[y], K = 1, te = 0; ++te < v && (K *= 256); )\n      F += this[y + te] * K;\n    return K *= 128, F >= K && (F -= Math.pow(2, 8 * v)), F;\n  }, s.prototype.readIntBE = function(y, v, b) {\n    y = y >>> 0, v = v >>> 0, b || E(y, v, this.length);\n    for (var F = v, K = 1, te = this[y + --F]; F > 0 && (K *= 256); )\n      te += this[y + --F] * K;\n    return K *= 128, te >= K && (te -= Math.pow(2, 8 * v)), te;\n  }, s.prototype.readInt8 = function(y, v) {\n    return y = y >>> 0, v || E(y, 1, this.length), this[y] & 128 ? (255 - this[y] + 1) * -1 : this[y];\n  }, s.prototype.readInt16LE = function(y, v) {\n    y = y >>> 0, v || E(y, 2, this.length);\n    var b = this[y] | this[y + 1] << 8;\n    return b & 32768 ? b | 4294901760 : b;\n  }, s.prototype.readInt16BE = function(y, v) {\n    y = y >>> 0, v || E(y, 2, this.length);\n    var b = this[y + 1] | this[y] << 8;\n    return b & 32768 ? b | 4294901760 : b;\n  }, s.prototype.readInt32LE = function(y, v) {\n    return y = y >>> 0, v || E(y, 4, this.length), this[y] | this[y + 1] << 8 | this[y + 2] << 16 | this[y + 3] << 24;\n  }, s.prototype.readInt32BE = function(y, v) {\n    return y = y >>> 0, v || E(y, 4, this.length), this[y] << 24 | this[y + 1] << 16 | this[y + 2] << 8 | this[y + 3];\n  }, s.prototype.readFloatLE = function(y, v) {\n    return y = y >>> 0, v || E(y, 4, this.length), r.read(this, y, !0, 23, 4);\n  }, s.prototype.readFloatBE = function(y, v) {\n    return y = y >>> 0, v || E(y, 4, this.length), r.read(this, y, !1, 23, 4);\n  }, s.prototype.readDoubleLE = function(y, v) {\n    return y = y >>> 0, v || E(y, 8, this.length), r.read(this, y, !0, 52, 8);\n  }, s.prototype.readDoubleBE = function(y, v) {\n    return y = y >>> 0, v || E(y, 8, this.length), r.read(this, y, !1, 52, 8);\n  };\n  function B(S, y, v, b, F, K) {\n    if (!s.isBuffer(S))\n      throw new TypeError('\"buffer\" argument must be a Buffer instance');\n    if (y > F || y < K)\n      throw new RangeError('\"value\" argument is out of bounds');\n    if (v + b > S.length)\n      throw new RangeError(\"Index out of range\");\n  }\n  s.prototype.writeUintLE = s.prototype.writeUIntLE = function(y, v, b, F) {\n    if (y = +y, v = v >>> 0, b = b >>> 0, !F) {\n      var K = Math.pow(2, 8 * b) - 1;\n      B(this, y, v, b, K, 0);\n    }\n    var te = 1, de = 0;\n    for (this[v] = y & 255; ++de < b && (te *= 256); )\n      this[v + de] = y / te & 255;\n    return v + b;\n  }, s.prototype.writeUintBE = s.prototype.writeUIntBE = function(y, v, b, F) {\n    if (y = +y, v = v >>> 0, b = b >>> 0, !F) {\n      var K = Math.pow(2, 8 * b) - 1;\n      B(this, y, v, b, K, 0);\n    }\n    var te = b - 1, de = 1;\n    for (this[v + te] = y & 255; --te >= 0 && (de *= 256); )\n      this[v + te] = y / de & 255;\n    return v + b;\n  }, s.prototype.writeUint8 = s.prototype.writeUInt8 = function(y, v, b) {\n    return y = +y, v = v >>> 0, b || B(this, y, v, 1, 255, 0), this[v] = y & 255, v + 1;\n  }, s.prototype.writeUint16LE = s.prototype.writeUInt16LE = function(y, v, b) {\n    return y = +y, v = v >>> 0, b || B(this, y, v, 2, 65535, 0), this[v] = y & 255, this[v + 1] = y >>> 8, v + 2;\n  }, s.prototype.writeUint16BE = s.prototype.writeUInt16BE = function(y, v, b) {\n    return y = +y, v = v >>> 0, b || B(this, y, v, 2, 65535, 0), this[v] = y >>> 8, this[v + 1] = y & 255, v + 2;\n  }, s.prototype.writeUint32LE = s.prototype.writeUInt32LE = function(y, v, b) {\n    return y = +y, v = v >>> 0, b || B(this, y, v, 4, 4294967295, 0), this[v + 3] = y >>> 24, this[v + 2] = y >>> 16, this[v + 1] = y >>> 8, this[v] = y & 255, v + 4;\n  }, s.prototype.writeUint32BE = s.prototype.writeUInt32BE = function(y, v, b) {\n    return y = +y, v = v >>> 0, b || B(this, y, v, 4, 4294967295, 0), this[v] = y >>> 24, this[v + 1] = y >>> 16, this[v + 2] = y >>> 8, this[v + 3] = y & 255, v + 4;\n  }, s.prototype.writeIntLE = function(y, v, b, F) {\n    if (y = +y, v = v >>> 0, !F) {\n      var K = Math.pow(2, 8 * b - 1);\n      B(this, y, v, b, K - 1, -K);\n    }\n    var te = 0, de = 1, pe = 0;\n    for (this[v] = y & 255; ++te < b && (de *= 256); )\n      y < 0 && pe === 0 && this[v + te - 1] !== 0 && (pe = 1), this[v + te] = (y / de >> 0) - pe & 255;\n    return v + b;\n  }, s.prototype.writeIntBE = function(y, v, b, F) {\n    if (y = +y, v = v >>> 0, !F) {\n      var K = Math.pow(2, 8 * b - 1);\n      B(this, y, v, b, K - 1, -K);\n    }\n    var te = b - 1, de = 1, pe = 0;\n    for (this[v + te] = y & 255; --te >= 0 && (de *= 256); )\n      y < 0 && pe === 0 && this[v + te + 1] !== 0 && (pe = 1), this[v + te] = (y / de >> 0) - pe & 255;\n    return v + b;\n  }, s.prototype.writeInt8 = function(y, v, b) {\n    return y = +y, v = v >>> 0, b || B(this, y, v, 1, 127, -128), y < 0 && (y = 255 + y + 1), this[v] = y & 255, v + 1;\n  }, s.prototype.writeInt16LE = function(y, v, b) {\n    return y = +y, v = v >>> 0, b || B(this, y, v, 2, 32767, -32768), this[v] = y & 255, this[v + 1] = y >>> 8, v + 2;\n  }, s.prototype.writeInt16BE = function(y, v, b) {\n    return y = +y, v = v >>> 0, b || B(this, y, v, 2, 32767, -32768), this[v] = y >>> 8, this[v + 1] = y & 255, v + 2;\n  }, s.prototype.writeInt32LE = function(y, v, b) {\n    return y = +y, v = v >>> 0, b || B(this, y, v, 4, 2147483647, -2147483648), this[v] = y & 255, this[v + 1] = y >>> 8, this[v + 2] = y >>> 16, this[v + 3] = y >>> 24, v + 4;\n  }, s.prototype.writeInt32BE = function(y, v, b) {\n    return y = +y, v = v >>> 0, b || B(this, y, v, 4, 2147483647, -2147483648), y < 0 && (y = 4294967295 + y + 1), this[v] = y >>> 24, this[v + 1] = y >>> 16, this[v + 2] = y >>> 8, this[v + 3] = y & 255, v + 4;\n  };\n  function V(S, y, v, b, F, K) {\n    if (v + b > S.length)\n      throw new RangeError(\"Index out of range\");\n    if (v < 0)\n      throw new RangeError(\"Index out of range\");\n  }\n  function I(S, y, v, b, F) {\n    return y = +y, v = v >>> 0, F || V(S, y, v, 4), r.write(S, y, v, b, 23, 4), v + 4;\n  }\n  s.prototype.writeFloatLE = function(y, v, b) {\n    return I(this, y, v, !0, b);\n  }, s.prototype.writeFloatBE = function(y, v, b) {\n    return I(this, y, v, !1, b);\n  };\n  function ne(S, y, v, b, F) {\n    return y = +y, v = v >>> 0, F || V(S, y, v, 8), r.write(S, y, v, b, 52, 8), v + 8;\n  }\n  s.prototype.writeDoubleLE = function(y, v, b) {\n    return ne(this, y, v, !0, b);\n  }, s.prototype.writeDoubleBE = function(y, v, b) {\n    return ne(this, y, v, !1, b);\n  }, s.prototype.copy = function(y, v, b, F) {\n    if (!s.isBuffer(y))\n      throw new TypeError(\"argument should be a Buffer\");\n    if (b || (b = 0), !F && F !== 0 && (F = this.length), v >= y.length && (v = y.length), v || (v = 0), F > 0 && F < b && (F = b), F === b || y.length === 0 || this.length === 0)\n      return 0;\n    if (v < 0)\n      throw new RangeError(\"targetStart out of bounds\");\n    if (b < 0 || b >= this.length)\n      throw new RangeError(\"Index out of range\");\n    if (F < 0)\n      throw new RangeError(\"sourceEnd out of bounds\");\n    F > this.length && (F = this.length), y.length - v < F - b && (F = y.length - v + b);\n    var K = F - b;\n    return this === y && typeof Uint8Array.prototype.copyWithin == \"function\" ? this.copyWithin(v, b, F) : Uint8Array.prototype.set.call(\n      y,\n      this.subarray(b, F),\n      v\n    ), K;\n  }, s.prototype.fill = function(y, v, b, F) {\n    if (typeof y == \"string\") {\n      if (typeof v == \"string\" ? (F = v, v = 0, b = this.length) : typeof b == \"string\" && (F = b, b = this.length), F !== void 0 && typeof F != \"string\")\n        throw new TypeError(\"encoding must be a string\");\n      if (typeof F == \"string\" && !s.isEncoding(F))\n        throw new TypeError(\"Unknown encoding: \" + F);\n      if (y.length === 1) {\n        var K = y.charCodeAt(0);\n        (F === \"utf8\" && K < 128 || F === \"latin1\") && (y = K);\n      }\n    } else\n      typeof y == \"number\" ? y = y & 255 : typeof y == \"boolean\" && (y = Number(y));\n    if (v < 0 || this.length < v || this.length < b)\n      throw new RangeError(\"Out of range index\");\n    if (b <= v)\n      return this;\n    v = v >>> 0, b = b === void 0 ? this.length : b >>> 0, y || (y = 0);\n    var te;\n    if (typeof y == \"number\")\n      for (te = v; te < b; ++te)\n        this[te] = y;\n    else {\n      var de = s.isBuffer(y) ? y : s.from(y, F), pe = de.length;\n      if (pe === 0)\n        throw new TypeError('The value \"' + y + '\" is invalid for argument \"value\"');\n      for (te = 0; te < b - v; ++te)\n        this[te + v] = de[te % pe];\n    }\n    return this;\n  };\n  var se = /[^+/0-9A-Za-z-_]/g;\n  function ce(S) {\n    if (S = S.split(\"=\")[0], S = S.trim().replace(se, \"\"), S.length < 2)\n      return \"\";\n    for (; S.length % 4 !== 0; )\n      S = S + \"=\";\n    return S;\n  }\n  function oe(S, y) {\n    y = y || 1 / 0;\n    for (var v, b = S.length, F = null, K = [], te = 0; te < b; ++te) {\n      if (v = S.charCodeAt(te), v > 55295 && v < 57344) {\n        if (!F) {\n          if (v > 56319) {\n            (y -= 3) > -1 && K.push(239, 191, 189);\n            continue;\n          } else if (te + 1 === b) {\n            (y -= 3) > -1 && K.push(239, 191, 189);\n            continue;\n          }\n          F = v;\n          continue;\n        }\n        if (v < 56320) {\n          (y -= 3) > -1 && K.push(239, 191, 189), F = v;\n          continue;\n        }\n        v = (F - 55296 << 10 | v - 56320) + 65536;\n      } else\n        F && (y -= 3) > -1 && K.push(239, 191, 189);\n      if (F = null, v < 128) {\n        if ((y -= 1) < 0)\n          break;\n        K.push(v);\n      } else if (v < 2048) {\n        if ((y -= 2) < 0)\n          break;\n        K.push(\n          v >> 6 | 192,\n          v & 63 | 128\n        );\n      } else if (v < 65536) {\n        if ((y -= 3) < 0)\n          break;\n        K.push(\n          v >> 12 | 224,\n          v >> 6 & 63 | 128,\n          v & 63 | 128\n        );\n      } else if (v < 1114112) {\n        if ((y -= 4) < 0)\n          break;\n        K.push(\n          v >> 18 | 240,\n          v >> 12 & 63 | 128,\n          v >> 6 & 63 | 128,\n          v & 63 | 128\n        );\n      } else\n        throw new Error(\"Invalid code point\");\n    }\n    return K;\n  }\n  function he(S) {\n    for (var y = [], v = 0; v < S.length; ++v)\n      y.push(S.charCodeAt(v) & 255);\n    return y;\n  }\n  function k(S, y) {\n    for (var v, b, F, K = [], te = 0; te < S.length && !((y -= 2) < 0); ++te)\n      v = S.charCodeAt(te), b = v >> 8, F = v % 256, K.push(F), K.push(b);\n    return K;\n  }\n  function H(S) {\n    return e.toByteArray(ce(S));\n  }\n  function N(S, y, v, b) {\n    for (var F = 0; F < b && !(F + v >= y.length || F >= S.length); ++F)\n      y[F + v] = S[F];\n    return F;\n  }\n  function J(S, y) {\n    return S instanceof y || S != null && S.constructor != null && S.constructor.name != null && S.constructor.name === y.name;\n  }\n  function Q(S) {\n    return S !== S;\n  }\n  var ee = function() {\n    for (var S = \"0123456789abcdef\", y = new Array(256), v = 0; v < 16; ++v)\n      for (var b = v * 16, F = 0; F < 16; ++F)\n        y[b + F] = S[v] + S[F];\n    return y;\n  }();\n})(Vh);\nvar Ti = Vh, sn = Ti.Buffer, Lt = {}, jt;\nfor (jt in Ti)\n  Ti.hasOwnProperty(jt) && (jt === \"SlowBuffer\" || jt === \"Buffer\" || (Lt[jt] = Ti[jt]));\nvar an = Lt.Buffer = {};\nfor (jt in sn)\n  sn.hasOwnProperty(jt) && (jt === \"allocUnsafe\" || jt === \"allocUnsafeSlow\" || (an[jt] = sn[jt]));\nLt.Buffer.prototype = sn.prototype;\n(!an.from || an.from === Uint8Array.from) && (an.from = function(t, e, r) {\n  if (typeof t == \"number\")\n    throw new TypeError('The \"value\" argument must not be of type number. Received type ' + typeof t);\n  if (t && typeof t.length > \"u\")\n    throw new TypeError(\"The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type \" + typeof t);\n  return sn(t, e, r);\n});\nan.alloc || (an.alloc = function(t, e, r) {\n  if (typeof t != \"number\")\n    throw new TypeError('The \"size\" argument must be of type number. Received type ' + typeof t);\n  if (t < 0 || t >= 2 * (1 << 30))\n    throw new RangeError('The value \"' + t + '\" is invalid for option \"size\"');\n  var n = sn(t);\n  return !e || e.length === 0 ? n.fill(0) : typeof r == \"string\" ? n.fill(e, r) : n.fill(e), n;\n});\nif (!Lt.kStringMaxLength)\n  try {\n    Lt.kStringMaxLength = process.binding(\"buffer\").kStringMaxLength;\n  } catch {\n  }\nLt.constants || (Lt.constants = {\n  MAX_LENGTH: Lt.kMaxLength\n}, Lt.kStringMaxLength && (Lt.constants.MAX_STRING_LENGTH = Lt.kStringMaxLength));\nvar Mc = Lt, Ho = {};\nconst L1 = Tr();\nfunction Wt(t) {\n  this._reporterState = {\n    obj: null,\n    path: [],\n    options: t || {},\n    errors: []\n  };\n}\nHo.Reporter = Wt;\nWt.prototype.isError = function(e) {\n  return e instanceof dn;\n};\nWt.prototype.save = function() {\n  const e = this._reporterState;\n  return { obj: e.obj, pathLen: e.path.length };\n};\nWt.prototype.restore = function(e) {\n  const r = this._reporterState;\n  r.obj = e.obj, r.path = r.path.slice(0, e.pathLen);\n};\nWt.prototype.enterKey = function(e) {\n  return this._reporterState.path.push(e);\n};\nWt.prototype.exitKey = function(e) {\n  const r = this._reporterState;\n  r.path = r.path.slice(0, e - 1);\n};\nWt.prototype.leaveKey = function(e, r, n) {\n  const i = this._reporterState;\n  this.exitKey(e), i.obj !== null && (i.obj[r] = n);\n};\nWt.prototype.path = function() {\n  return this._reporterState.path.join(\"/\");\n};\nWt.prototype.enterObject = function() {\n  const e = this._reporterState, r = e.obj;\n  return e.obj = {}, r;\n};\nWt.prototype.leaveObject = function(e) {\n  const r = this._reporterState, n = r.obj;\n  return r.obj = e, n;\n};\nWt.prototype.error = function(e) {\n  let r;\n  const n = this._reporterState, i = e instanceof dn;\n  if (i ? r = e : r = new dn(n.path.map(function(o) {\n    return \"[\" + JSON.stringify(o) + \"]\";\n  }).join(\"\"), e.message || e, e.stack), !n.options.partial)\n    throw r;\n  return i || n.errors.push(r), r;\n};\nWt.prototype.wrapResult = function(e) {\n  const r = this._reporterState;\n  return r.options.partial ? {\n    result: this.isError(e) ? null : e,\n    errors: r.errors\n  } : e;\n};\nfunction dn(t, e) {\n  this.path = t, this.rethrow(e);\n}\nL1(dn, Error);\ndn.prototype.rethrow = function(e) {\n  if (this.message = e + \" at: \" + (this.path || \"(shallow)\"), Error.captureStackTrace && Error.captureStackTrace(this, dn), !this.stack)\n    try {\n      throw new Error(this.message);\n    } catch (r) {\n      this.stack = r.stack;\n    }\n  return this;\n};\nvar Ur = {};\nconst j1 = Tr(), Wo = Ho.Reporter, pn = Mc.Buffer;\nfunction $t(t, e) {\n  if (Wo.call(this, e), !pn.isBuffer(t)) {\n    this.error(\"Input not Buffer\");\n    return;\n  }\n  this.base = t, this.offset = 0, this.length = t.length;\n}\nj1($t, Wo);\nUr.DecoderBuffer = $t;\n$t.isDecoderBuffer = function(e) {\n  return e instanceof $t ? !0 : typeof e == \"object\" && pn.isBuffer(e.base) && e.constructor.name === \"DecoderBuffer\" && typeof e.offset == \"number\" && typeof e.length == \"number\" && typeof e.save == \"function\" && typeof e.restore == \"function\" && typeof e.isEmpty == \"function\" && typeof e.readUInt8 == \"function\" && typeof e.skip == \"function\" && typeof e.raw == \"function\";\n};\n$t.prototype.save = function() {\n  return { offset: this.offset, reporter: Wo.prototype.save.call(this) };\n};\n$t.prototype.restore = function(e) {\n  const r = new $t(this.base);\n  return r.offset = e.offset, r.length = this.offset, this.offset = e.offset, Wo.prototype.restore.call(this, e.reporter), r;\n};\n$t.prototype.isEmpty = function() {\n  return this.offset === this.length;\n};\n$t.prototype.readUInt8 = function(e) {\n  return this.offset + 1 <= this.length ? this.base.readUInt8(this.offset++, !0) : this.error(e || \"DecoderBuffer overrun\");\n};\n$t.prototype.skip = function(e, r) {\n  if (!(this.offset + e <= this.length))\n    return this.error(r || \"DecoderBuffer overrun\");\n  const n = new $t(this.base);\n  return n._reporterState = this._reporterState, n.offset = this.offset, n.length = this.offset + e, this.offset += e, n;\n};\n$t.prototype.raw = function(e) {\n  return this.base.slice(e ? e.offset : this.offset, this.length);\n};\nfunction yn(t, e) {\n  if (Array.isArray(t))\n    this.length = 0, this.value = t.map(function(r) {\n      return yn.isEncoderBuffer(r) || (r = new yn(r, e)), this.length += r.length, r;\n    }, this);\n  else if (typeof t == \"number\") {\n    if (!(0 <= t && t <= 255))\n      return e.error(\"non-byte EncoderBuffer value\");\n    this.value = t, this.length = 1;\n  } else if (typeof t == \"string\")\n    this.value = t, this.length = pn.byteLength(t);\n  else if (pn.isBuffer(t))\n    this.value = t, this.length = t.length;\n  else\n    return e.error(\"Unsupported type: \" + typeof t);\n}\nUr.EncoderBuffer = yn;\nyn.isEncoderBuffer = function(e) {\n  return e instanceof yn ? !0 : typeof e == \"object\" && e.constructor.name === \"EncoderBuffer\" && typeof e.length == \"number\" && typeof e.join == \"function\";\n};\nyn.prototype.join = function(e, r) {\n  return e || (e = pn.alloc(this.length)), r || (r = 0), this.length === 0 || (Array.isArray(this.value) ? this.value.forEach(function(n) {\n    n.join(e, r), r += n.length;\n  }) : (typeof this.value == \"number\" ? e[r] = this.value : typeof this.value == \"string\" ? e.write(this.value, r) : pn.isBuffer(this.value) && this.value.copy(e, r), r += this.length)), e;\n};\nvar U1 = Hh;\nfunction Hh(t, e) {\n  if (!t)\n    throw new Error(e || \"Assertion failed\");\n}\nHh.equal = function(e, r, n) {\n  if (e != r)\n    throw new Error(n || \"Assertion failed: \" + e + \" != \" + r);\n};\nconst V1 = Ho.Reporter, $1 = Ur.EncoderBuffer, H1 = Ur.DecoderBuffer, Et = U1, Wh = [\n  \"seq\",\n  \"seqof\",\n  \"set\",\n  \"setof\",\n  \"objid\",\n  \"bool\",\n  \"gentime\",\n  \"utctime\",\n  \"null_\",\n  \"enum\",\n  \"int\",\n  \"objDesc\",\n  \"bitstr\",\n  \"bmpstr\",\n  \"charstr\",\n  \"genstr\",\n  \"graphstr\",\n  \"ia5str\",\n  \"iso646str\",\n  \"numstr\",\n  \"octstr\",\n  \"printstr\",\n  \"t61str\",\n  \"unistr\",\n  \"utf8str\",\n  \"videostr\"\n], W1 = [\n  \"key\",\n  \"obj\",\n  \"use\",\n  \"optional\",\n  \"explicit\",\n  \"implicit\",\n  \"def\",\n  \"choice\",\n  \"any\",\n  \"contains\"\n].concat(Wh), z1 = [\n  \"_peekTag\",\n  \"_decodeTag\",\n  \"_use\",\n  \"_decodeStr\",\n  \"_decodeObjid\",\n  \"_decodeTime\",\n  \"_decodeNull\",\n  \"_decodeInt\",\n  \"_decodeBool\",\n  \"_decodeList\",\n  \"_encodeComposite\",\n  \"_encodeStr\",\n  \"_encodeObjid\",\n  \"_encodeTime\",\n  \"_encodeNull\",\n  \"_encodeInt\",\n  \"_encodeBool\"\n];\nfunction He(t, e, r) {\n  const n = {};\n  this._baseState = n, n.name = r, n.enc = t, n.parent = e || null, n.children = null, n.tag = null, n.args = null, n.reverseArgs = null, n.choice = null, n.optional = !1, n.any = !1, n.obj = !1, n.use = null, n.useDecoder = null, n.key = null, n.default = null, n.explicit = null, n.implicit = null, n.contains = null, n.parent || (n.children = [], this._wrap());\n}\nvar kc = He;\nconst q1 = [\n  \"enc\",\n  \"parent\",\n  \"children\",\n  \"tag\",\n  \"args\",\n  \"reverseArgs\",\n  \"choice\",\n  \"optional\",\n  \"any\",\n  \"obj\",\n  \"use\",\n  \"alteredUse\",\n  \"key\",\n  \"default\",\n  \"explicit\",\n  \"implicit\",\n  \"contains\"\n];\nHe.prototype.clone = function() {\n  const e = this._baseState, r = {};\n  q1.forEach(function(i) {\n    r[i] = e[i];\n  });\n  const n = new this.constructor(r.parent);\n  return n._baseState = r, n;\n};\nHe.prototype._wrap = function() {\n  const e = this._baseState;\n  W1.forEach(function(r) {\n    this[r] = function() {\n      const i = new this.constructor(this);\n      return e.children.push(i), i[r].apply(i, arguments);\n    };\n  }, this);\n};\nHe.prototype._init = function(e) {\n  const r = this._baseState;\n  Et(r.parent === null), e.call(this), r.children = r.children.filter(function(n) {\n    return n._baseState.parent === this;\n  }, this), Et.equal(r.children.length, 1, \"Root node can have only one child\");\n};\nHe.prototype._useArgs = function(e) {\n  const r = this._baseState, n = e.filter(function(i) {\n    return i instanceof this.constructor;\n  }, this);\n  e = e.filter(function(i) {\n    return !(i instanceof this.constructor);\n  }, this), n.length !== 0 && (Et(r.children === null), r.children = n, n.forEach(function(i) {\n    i._baseState.parent = this;\n  }, this)), e.length !== 0 && (Et(r.args === null), r.args = e, r.reverseArgs = e.map(function(i) {\n    if (typeof i != \"object\" || i.constructor !== Object)\n      return i;\n    const o = {};\n    return Object.keys(i).forEach(function(a) {\n      a == (a | 0) && (a |= 0);\n      const s = i[a];\n      o[s] = a;\n    }), o;\n  }));\n};\nz1.forEach(function(t) {\n  He.prototype[t] = function() {\n    const r = this._baseState;\n    throw new Error(t + \" not implemented for encoding: \" + r.enc);\n  };\n});\nWh.forEach(function(t) {\n  He.prototype[t] = function() {\n    const r = this._baseState, n = Array.prototype.slice.call(arguments);\n    return Et(r.tag === null), r.tag = t, this._useArgs(n), this;\n  };\n});\nHe.prototype.use = function(e) {\n  Et(e);\n  const r = this._baseState;\n  return Et(r.use === null), r.use = e, this;\n};\nHe.prototype.optional = function() {\n  const e = this._baseState;\n  return e.optional = !0, this;\n};\nHe.prototype.def = function(e) {\n  const r = this._baseState;\n  return Et(r.default === null), r.default = e, r.optional = !0, this;\n};\nHe.prototype.explicit = function(e) {\n  const r = this._baseState;\n  return Et(r.explicit === null && r.implicit === null), r.explicit = e, this;\n};\nHe.prototype.implicit = function(e) {\n  const r = this._baseState;\n  return Et(r.explicit === null && r.implicit === null), r.implicit = e, this;\n};\nHe.prototype.obj = function() {\n  const e = this._baseState, r = Array.prototype.slice.call(arguments);\n  return e.obj = !0, r.length !== 0 && this._useArgs(r), this;\n};\nHe.prototype.key = function(e) {\n  const r = this._baseState;\n  return Et(r.key === null), r.key = e, this;\n};\nHe.prototype.any = function() {\n  const e = this._baseState;\n  return e.any = !0, this;\n};\nHe.prototype.choice = function(e) {\n  const r = this._baseState;\n  return Et(r.choice === null), r.choice = e, this._useArgs(Object.keys(e).map(function(n) {\n    return e[n];\n  })), this;\n};\nHe.prototype.contains = function(e) {\n  const r = this._baseState;\n  return Et(r.use === null), r.contains = e, this;\n};\nHe.prototype._decode = function(e, r) {\n  const n = this._baseState;\n  if (n.parent === null)\n    return e.wrapResult(n.children[0]._decode(e, r));\n  let i = n.default, o = !0, a = null;\n  if (n.key !== null && (a = e.enterKey(n.key)), n.optional) {\n    let l = null;\n    if (n.explicit !== null ? l = n.explicit : n.implicit !== null ? l = n.implicit : n.tag !== null && (l = n.tag), l === null && !n.any) {\n      const u = e.save();\n      try {\n        n.choice === null ? this._decodeGeneric(n.tag, e, r) : this._decodeChoice(e, r), o = !0;\n      } catch {\n        o = !1;\n      }\n      e.restore(u);\n    } else if (o = this._peekTag(e, l, n.any), e.isError(o))\n      return o;\n  }\n  let s;\n  if (n.obj && o && (s = e.enterObject()), o) {\n    if (n.explicit !== null) {\n      const u = this._decodeTag(e, n.explicit);\n      if (e.isError(u))\n        return u;\n      e = u;\n    }\n    const l = e.offset;\n    if (n.use === null && n.choice === null) {\n      let u;\n      n.any && (u = e.save());\n      const c = this._decodeTag(\n        e,\n        n.implicit !== null ? n.implicit : n.tag,\n        n.any\n      );\n      if (e.isError(c))\n        return c;\n      n.any ? i = e.raw(u) : e = c;\n    }\n    if (r && r.track && n.tag !== null && r.track(e.path(), l, e.length, \"tagged\"), r && r.track && n.tag !== null && r.track(e.path(), e.offset, e.length, \"content\"), n.any || (n.choice === null ? i = this._decodeGeneric(n.tag, e, r) : i = this._decodeChoice(e, r)), e.isError(i))\n      return i;\n    if (!n.any && n.choice === null && n.children !== null && n.children.forEach(function(c) {\n      c._decode(e, r);\n    }), n.contains && (n.tag === \"octstr\" || n.tag === \"bitstr\")) {\n      const u = new H1(i);\n      i = this._getUse(n.contains, e._reporterState.obj)._decode(u, r);\n    }\n  }\n  return n.obj && o && (i = e.leaveObject(s)), n.key !== null && (i !== null || o === !0) ? e.leaveKey(a, n.key, i) : a !== null && e.exitKey(a), i;\n};\nHe.prototype._decodeGeneric = function(e, r, n) {\n  const i = this._baseState;\n  return e === \"seq\" || e === \"set\" ? null : e === \"seqof\" || e === \"setof\" ? this._decodeList(r, e, i.args[0], n) : /str$/.test(e) ? this._decodeStr(r, e, n) : e === \"objid\" && i.args ? this._decodeObjid(r, i.args[0], i.args[1], n) : e === \"objid\" ? this._decodeObjid(r, null, null, n) : e === \"gentime\" || e === \"utctime\" ? this._decodeTime(r, e, n) : e === \"null_\" ? this._decodeNull(r, n) : e === \"bool\" ? this._decodeBool(r, n) : e === \"objDesc\" ? this._decodeStr(r, e, n) : e === \"int\" || e === \"enum\" ? this._decodeInt(r, i.args && i.args[0], n) : i.use !== null ? this._getUse(i.use, r._reporterState.obj)._decode(r, n) : r.error(\"unknown tag: \" + e);\n};\nHe.prototype._getUse = function(e, r) {\n  const n = this._baseState;\n  return n.useDecoder = this._use(e, r), Et(n.useDecoder._baseState.parent === null), n.useDecoder = n.useDecoder._baseState.children[0], n.implicit !== n.useDecoder._baseState.implicit && (n.useDecoder = n.useDecoder.clone(), n.useDecoder._baseState.implicit = n.implicit), n.useDecoder;\n};\nHe.prototype._decodeChoice = function(e, r) {\n  const n = this._baseState;\n  let i = null, o = !1;\n  return Object.keys(n.choice).some(function(a) {\n    const s = e.save(), l = n.choice[a];\n    try {\n      const u = l._decode(e, r);\n      if (e.isError(u))\n        return !1;\n      i = { type: a, value: u }, o = !0;\n    } catch {\n      return e.restore(s), !1;\n    }\n    return !0;\n  }, this), o ? i : e.error(\"Choice not matched\");\n};\nHe.prototype._createEncoderBuffer = function(e) {\n  return new $1(e, this.reporter);\n};\nHe.prototype._encode = function(e, r, n) {\n  const i = this._baseState;\n  if (i.default !== null && i.default === e)\n    return;\n  const o = this._encodeValue(e, r, n);\n  if (o !== void 0 && !this._skipDefault(o, r, n))\n    return o;\n};\nHe.prototype._encodeValue = function(e, r, n) {\n  const i = this._baseState;\n  if (i.parent === null)\n    return i.children[0]._encode(e, r || new V1());\n  let o = null;\n  if (this.reporter = r, i.optional && e === void 0)\n    if (i.default !== null)\n      e = i.default;\n    else\n      return;\n  let a = null, s = !1;\n  if (i.any)\n    o = this._createEncoderBuffer(e);\n  else if (i.choice)\n    o = this._encodeChoice(e, r);\n  else if (i.contains)\n    a = this._getUse(i.contains, n)._encode(e, r), s = !0;\n  else if (i.children)\n    a = i.children.map(function(l) {\n      if (l._baseState.tag === \"null_\")\n        return l._encode(null, r, e);\n      if (l._baseState.key === null)\n        return r.error(\"Child should have a key\");\n      const u = r.enterKey(l._baseState.key);\n      if (typeof e != \"object\")\n        return r.error(\"Child expected, but input is not object\");\n      const c = l._encode(e[l._baseState.key], r, e);\n      return r.leaveKey(u), c;\n    }, this).filter(function(l) {\n      return l;\n    }), a = this._createEncoderBuffer(a);\n  else if (i.tag === \"seqof\" || i.tag === \"setof\") {\n    if (!(i.args && i.args.length === 1))\n      return r.error(\"Too many args for : \" + i.tag);\n    if (!Array.isArray(e))\n      return r.error(\"seqof/setof, but data is not Array\");\n    const l = this.clone();\n    l._baseState.implicit = null, a = this._createEncoderBuffer(e.map(function(u) {\n      const c = this._baseState;\n      return this._getUse(c.args[0], e)._encode(u, r);\n    }, l));\n  } else\n    i.use !== null ? o = this._getUse(i.use, n)._encode(e, r) : (a = this._encodePrimitive(i.tag, e), s = !0);\n  if (!i.any && i.choice === null) {\n    const l = i.implicit !== null ? i.implicit : i.tag, u = i.implicit === null ? \"universal\" : \"context\";\n    l === null ? i.use === null && r.error(\"Tag could be omitted only for .use()\") : i.use === null && (o = this._encodeComposite(l, s, u, a));\n  }\n  return i.explicit !== null && (o = this._encodeComposite(i.explicit, !1, \"context\", o)), o;\n};\nHe.prototype._encodeChoice = function(e, r) {\n  const n = this._baseState, i = n.choice[e.type];\n  return i || Et(\n    !1,\n    e.type + \" not found in \" + JSON.stringify(Object.keys(n.choice))\n  ), i._encode(e.value, r);\n};\nHe.prototype._encodePrimitive = function(e, r) {\n  const n = this._baseState;\n  if (/str$/.test(e))\n    return this._encodeStr(r, e);\n  if (e === \"objid\" && n.args)\n    return this._encodeObjid(r, n.reverseArgs[0], n.args[1]);\n  if (e === \"objid\")\n    return this._encodeObjid(r, null, null);\n  if (e === \"gentime\" || e === \"utctime\")\n    return this._encodeTime(r, e);\n  if (e === \"null_\")\n    return this._encodeNull();\n  if (e === \"int\" || e === \"enum\")\n    return this._encodeInt(r, n.args && n.reverseArgs[0]);\n  if (e === \"bool\")\n    return this._encodeBool(r);\n  if (e === \"objDesc\")\n    return this._encodeStr(r, e);\n  throw new Error(\"Unsupported tag: \" + e);\n};\nHe.prototype._isNumstr = function(e) {\n  return /^[0-9 ]*$/.test(e);\n};\nHe.prototype._isPrintstr = function(e) {\n  return /^[A-Za-z0-9 '()+,-./:=?]*$/.test(e);\n};\nvar zo = {};\n(function(t) {\n  function e(r) {\n    const n = {};\n    return Object.keys(r).forEach(function(i) {\n      (i | 0) == i && (i = i | 0);\n      const o = r[i];\n      n[o] = i;\n    }), n;\n  }\n  t.tagClass = {\n    0: \"universal\",\n    1: \"application\",\n    2: \"context\",\n    3: \"private\"\n  }, t.tagClassByName = e(t.tagClass), t.tag = {\n    0: \"end\",\n    1: \"bool\",\n    2: \"int\",\n    3: \"bitstr\",\n    4: \"octstr\",\n    5: \"null_\",\n    6: \"objid\",\n    7: \"objDesc\",\n    8: \"external\",\n    9: \"real\",\n    10: \"enum\",\n    11: \"embed\",\n    12: \"utf8str\",\n    13: \"relativeOid\",\n    16: \"seq\",\n    17: \"set\",\n    18: \"numstr\",\n    19: \"printstr\",\n    20: \"t61str\",\n    21: \"videostr\",\n    22: \"ia5str\",\n    23: \"utctime\",\n    24: \"gentime\",\n    25: \"graphstr\",\n    26: \"iso646str\",\n    27: \"genstr\",\n    28: \"unistr\",\n    29: \"charstr\",\n    30: \"bmpstr\"\n  }, t.tagByName = e(t.tag);\n})(zo);\nconst K1 = Tr(), cr = Mc.Buffer, zh = kc, zs = zo;\nfunction qh(t) {\n  this.enc = \"der\", this.name = t.name, this.entity = t, this.tree = new Yt(), this.tree._init(t.body);\n}\nvar Kh = qh;\nqh.prototype.encode = function(e, r) {\n  return this.tree._encode(e, r).join();\n};\nfunction Yt(t) {\n  zh.call(this, \"der\", t);\n}\nK1(Yt, zh);\nYt.prototype._encodeComposite = function(e, r, n, i) {\n  const o = G1(e, r, n, this.reporter);\n  if (i.length < 128) {\n    const l = cr.alloc(2);\n    return l[0] = o, l[1] = i.length, this._createEncoderBuffer([l, i]);\n  }\n  let a = 1;\n  for (let l = i.length; l >= 256; l >>= 8)\n    a++;\n  const s = cr.alloc(1 + 1 + a);\n  s[0] = o, s[1] = 128 | a;\n  for (let l = 1 + a, u = i.length; u > 0; l--, u >>= 8)\n    s[l] = u & 255;\n  return this._createEncoderBuffer([s, i]);\n};\nYt.prototype._encodeStr = function(e, r) {\n  if (r === \"bitstr\")\n    return this._createEncoderBuffer([e.unused | 0, e.data]);\n  if (r === \"bmpstr\") {\n    const n = cr.alloc(e.length * 2);\n    for (let i = 0; i < e.length; i++)\n      n.writeUInt16BE(e.charCodeAt(i), i * 2);\n    return this._createEncoderBuffer(n);\n  } else\n    return r === \"numstr\" ? this._isNumstr(e) ? this._createEncoderBuffer(e) : this.reporter.error(\"Encoding of string type: numstr supports only digits and space\") : r === \"printstr\" ? this._isPrintstr(e) ? this._createEncoderBuffer(e) : this.reporter.error(\"Encoding of string type: printstr supports only latin upper and lower case letters, digits, space, apostrophe, left and rigth parenthesis, plus sign, comma, hyphen, dot, slash, colon, equal sign, question mark\") : /str$/.test(r) ? this._createEncoderBuffer(e) : r === \"objDesc\" ? this._createEncoderBuffer(e) : this.reporter.error(\"Encoding of string type: \" + r + \" unsupported\");\n};\nYt.prototype._encodeObjid = function(e, r, n) {\n  if (typeof e == \"string\") {\n    if (!r)\n      return this.reporter.error(\"string objid given, but no values map found\");\n    if (!r.hasOwnProperty(e))\n      return this.reporter.error(\"objid not found in values map\");\n    e = r[e].split(/[\\s.]+/g);\n    for (let s = 0; s < e.length; s++)\n      e[s] |= 0;\n  } else if (Array.isArray(e)) {\n    e = e.slice();\n    for (let s = 0; s < e.length; s++)\n      e[s] |= 0;\n  }\n  if (!Array.isArray(e))\n    return this.reporter.error(\"objid() should be either array or string, got: \" + JSON.stringify(e));\n  if (!n) {\n    if (e[1] >= 40)\n      return this.reporter.error(\"Second objid identifier OOB\");\n    e.splice(0, 2, e[0] * 40 + e[1]);\n  }\n  let i = 0;\n  for (let s = 0; s < e.length; s++) {\n    let l = e[s];\n    for (i++; l >= 128; l >>= 7)\n      i++;\n  }\n  const o = cr.alloc(i);\n  let a = o.length - 1;\n  for (let s = e.length - 1; s >= 0; s--) {\n    let l = e[s];\n    for (o[a--] = l & 127; (l >>= 7) > 0; )\n      o[a--] = 128 | l & 127;\n  }\n  return this._createEncoderBuffer(o);\n};\nfunction Dt(t) {\n  return t < 10 ? \"0\" + t : t;\n}\nYt.prototype._encodeTime = function(e, r) {\n  let n;\n  const i = new Date(e);\n  return r === \"gentime\" ? n = [\n    Dt(i.getUTCFullYear()),\n    Dt(i.getUTCMonth() + 1),\n    Dt(i.getUTCDate()),\n    Dt(i.getUTCHours()),\n    Dt(i.getUTCMinutes()),\n    Dt(i.getUTCSeconds()),\n    \"Z\"\n  ].join(\"\") : r === \"utctime\" ? n = [\n    Dt(i.getUTCFullYear() % 100),\n    Dt(i.getUTCMonth() + 1),\n    Dt(i.getUTCDate()),\n    Dt(i.getUTCHours()),\n    Dt(i.getUTCMinutes()),\n    Dt(i.getUTCSeconds()),\n    \"Z\"\n  ].join(\"\") : this.reporter.error(\"Encoding \" + r + \" time is not supported yet\"), this._encodeStr(n, \"octstr\");\n};\nYt.prototype._encodeNull = function() {\n  return this._createEncoderBuffer(\"\");\n};\nYt.prototype._encodeInt = function(e, r) {\n  if (typeof e == \"string\") {\n    if (!r)\n      return this.reporter.error(\"String int or enum given, but no values map\");\n    if (!r.hasOwnProperty(e))\n      return this.reporter.error(\"Values map doesn't contain: \" + JSON.stringify(e));\n    e = r[e];\n  }\n  if (typeof e != \"number\" && !cr.isBuffer(e)) {\n    const o = e.toArray();\n    !e.sign && o[0] & 128 && o.unshift(0), e = cr.from(o);\n  }\n  if (cr.isBuffer(e)) {\n    let o = e.length;\n    e.length === 0 && o++;\n    const a = cr.alloc(o);\n    return e.copy(a), e.length === 0 && (a[0] = 0), this._createEncoderBuffer(a);\n  }\n  if (e < 128)\n    return this._createEncoderBuffer(e);\n  if (e < 256)\n    return this._createEncoderBuffer([0, e]);\n  let n = 1;\n  for (let o = e; o >= 256; o >>= 8)\n    n++;\n  const i = new Array(n);\n  for (let o = i.length - 1; o >= 0; o--)\n    i[o] = e & 255, e >>= 8;\n  return i[0] & 128 && i.unshift(0), this._createEncoderBuffer(cr.from(i));\n};\nYt.prototype._encodeBool = function(e) {\n  return this._createEncoderBuffer(e ? 255 : 0);\n};\nYt.prototype._use = function(e, r) {\n  return typeof e == \"function\" && (e = e(r)), e._getEncoder(\"der\").tree;\n};\nYt.prototype._skipDefault = function(e, r, n) {\n  const i = this._baseState;\n  let o;\n  if (i.default === null)\n    return !1;\n  const a = e.join();\n  if (i.defaultBuffer === void 0 && (i.defaultBuffer = this._encodeValue(i.default, r, n).join()), a.length !== i.defaultBuffer.length)\n    return !1;\n  for (o = 0; o < a.length; o++)\n    if (a[o] !== i.defaultBuffer[o])\n      return !1;\n  return !0;\n};\nfunction G1(t, e, r, n) {\n  let i;\n  if (t === \"seqof\" ? t = \"seq\" : t === \"setof\" && (t = \"set\"), zs.tagByName.hasOwnProperty(t))\n    i = zs.tagByName[t];\n  else if (typeof t == \"number\" && (t | 0) === t)\n    i = t;\n  else\n    return n.error(\"Unknown tag: \" + t);\n  return i >= 31 ? n.error(\"Multi-octet tag encoding unsupported\") : (e || (i |= 32), i |= zs.tagClassByName[r || \"universal\"] << 6, i);\n}\nconst Y1 = Tr(), Rc = Kh;\nfunction Bc(t) {\n  Rc.call(this, t), this.enc = \"pem\";\n}\nY1(Bc, Rc);\nvar Z1 = Bc;\nBc.prototype.encode = function(e, r) {\n  const i = Rc.prototype.encode.call(this, e).toString(\"base64\"), o = [\"-----BEGIN \" + r.label + \"-----\"];\n  for (let a = 0; a < i.length; a += 64)\n    o.push(i.slice(a, a + 64));\n  return o.push(\"-----END \" + r.label + \"-----\"), o.join(`\n`);\n};\n(function(t) {\n  const e = t;\n  e.der = Kh, e.pem = Z1;\n})(Cc);\nvar Ic = {};\nconst X1 = Tr(), J1 = vo, hf = Ur.DecoderBuffer, Gh = kc, df = zo;\nfunction Yh(t) {\n  this.enc = \"der\", this.name = t.name, this.entity = t, this.tree = new It(), this.tree._init(t.body);\n}\nvar Zh = Yh;\nYh.prototype.decode = function(e, r) {\n  return hf.isDecoderBuffer(e) || (e = new hf(e, r)), this.tree._decode(e, r);\n};\nfunction It(t) {\n  Gh.call(this, \"der\", t);\n}\nX1(It, Gh);\nIt.prototype._peekTag = function(e, r, n) {\n  if (e.isEmpty())\n    return !1;\n  const i = e.save(), o = Dc(e, 'Failed to peek tag: \"' + r + '\"');\n  return e.isError(o) ? o : (e.restore(i), o.tag === r || o.tagStr === r || o.tagStr + \"of\" === r || n);\n};\nIt.prototype._decodeTag = function(e, r, n) {\n  const i = Dc(\n    e,\n    'Failed to decode tag of \"' + r + '\"'\n  );\n  if (e.isError(i))\n    return i;\n  let o = Xh(\n    e,\n    i.primitive,\n    'Failed to get length of \"' + r + '\"'\n  );\n  if (e.isError(o))\n    return o;\n  if (!n && i.tag !== r && i.tagStr !== r && i.tagStr + \"of\" !== r)\n    return e.error('Failed to match tag: \"' + r + '\"');\n  if (i.primitive || o !== null)\n    return e.skip(o, 'Failed to match body of: \"' + r + '\"');\n  const a = e.save(), s = this._skipUntilEnd(\n    e,\n    'Failed to skip indefinite length body: \"' + this.tag + '\"'\n  );\n  return e.isError(s) ? s : (o = e.offset - a.offset, e.restore(a), e.skip(o, 'Failed to match body of: \"' + r + '\"'));\n};\nIt.prototype._skipUntilEnd = function(e, r) {\n  for (; ; ) {\n    const n = Dc(e, r);\n    if (e.isError(n))\n      return n;\n    const i = Xh(e, n.primitive, r);\n    if (e.isError(i))\n      return i;\n    let o;\n    if (n.primitive || i !== null ? o = e.skip(i) : o = this._skipUntilEnd(e, r), e.isError(o))\n      return o;\n    if (n.tagStr === \"end\")\n      break;\n  }\n};\nIt.prototype._decodeList = function(e, r, n, i) {\n  const o = [];\n  for (; !e.isEmpty(); ) {\n    const a = this._peekTag(e, \"end\");\n    if (e.isError(a))\n      return a;\n    const s = n.decode(e, \"der\", i);\n    if (e.isError(s) && a)\n      break;\n    o.push(s);\n  }\n  return o;\n};\nIt.prototype._decodeStr = function(e, r) {\n  if (r === \"bitstr\") {\n    const n = e.readUInt8();\n    return e.isError(n) ? n : { unused: n, data: e.raw() };\n  } else if (r === \"bmpstr\") {\n    const n = e.raw();\n    if (n.length % 2 === 1)\n      return e.error(\"Decoding of string type: bmpstr length mismatch\");\n    let i = \"\";\n    for (let o = 0; o < n.length / 2; o++)\n      i += String.fromCharCode(n.readUInt16BE(o * 2));\n    return i;\n  } else if (r === \"numstr\") {\n    const n = e.raw().toString(\"ascii\");\n    return this._isNumstr(n) ? n : e.error(\"Decoding of string type: numstr unsupported characters\");\n  } else {\n    if (r === \"octstr\")\n      return e.raw();\n    if (r === \"objDesc\")\n      return e.raw();\n    if (r === \"printstr\") {\n      const n = e.raw().toString(\"ascii\");\n      return this._isPrintstr(n) ? n : e.error(\"Decoding of string type: printstr unsupported characters\");\n    } else\n      return /str$/.test(r) ? e.raw().toString() : e.error(\"Decoding of string type: \" + r + \" unsupported\");\n  }\n};\nIt.prototype._decodeObjid = function(e, r, n) {\n  let i;\n  const o = [];\n  let a = 0, s = 0;\n  for (; !e.isEmpty(); )\n    s = e.readUInt8(), a <<= 7, a |= s & 127, s & 128 || (o.push(a), a = 0);\n  s & 128 && o.push(a);\n  const l = o[0] / 40 | 0, u = o[0] % 40;\n  if (n ? i = o : i = [l, u].concat(o.slice(1)), r) {\n    let c = r[i.join(\" \")];\n    c === void 0 && (c = r[i.join(\".\")]), c !== void 0 && (i = c);\n  }\n  return i;\n};\nIt.prototype._decodeTime = function(e, r) {\n  const n = e.raw().toString();\n  let i, o, a, s, l, u;\n  if (r === \"gentime\")\n    i = n.slice(0, 4) | 0, o = n.slice(4, 6) | 0, a = n.slice(6, 8) | 0, s = n.slice(8, 10) | 0, l = n.slice(10, 12) | 0, u = n.slice(12, 14) | 0;\n  else if (r === \"utctime\")\n    i = n.slice(0, 2) | 0, o = n.slice(2, 4) | 0, a = n.slice(4, 6) | 0, s = n.slice(6, 8) | 0, l = n.slice(8, 10) | 0, u = n.slice(10, 12) | 0, i < 70 ? i = 2e3 + i : i = 1900 + i;\n  else\n    return e.error(\"Decoding \" + r + \" time is not supported yet\");\n  return Date.UTC(i, o - 1, a, s, l, u, 0);\n};\nIt.prototype._decodeNull = function() {\n  return null;\n};\nIt.prototype._decodeBool = function(e) {\n  const r = e.readUInt8();\n  return e.isError(r) ? r : r !== 0;\n};\nIt.prototype._decodeInt = function(e, r) {\n  const n = e.raw();\n  let i = new J1(n);\n  return r && (i = r[i.toString(10)] || i), i;\n};\nIt.prototype._use = function(e, r) {\n  return typeof e == \"function\" && (e = e(r)), e._getDecoder(\"der\").tree;\n};\nfunction Dc(t, e) {\n  let r = t.readUInt8(e);\n  if (t.isError(r))\n    return r;\n  const n = df.tagClass[r >> 6], i = (r & 32) === 0;\n  if ((r & 31) === 31) {\n    let a = r;\n    for (r = 0; (a & 128) === 128; ) {\n      if (a = t.readUInt8(e), t.isError(a))\n        return a;\n      r <<= 7, r |= a & 127;\n    }\n  } else\n    r &= 31;\n  const o = df.tag[r];\n  return {\n    cls: n,\n    primitive: i,\n    tag: r,\n    tagStr: o\n  };\n}\nfunction Xh(t, e, r) {\n  let n = t.readUInt8(r);\n  if (t.isError(n))\n    return n;\n  if (!e && n === 128)\n    return null;\n  if (!(n & 128))\n    return n;\n  const i = n & 127;\n  if (i > 4)\n    return t.error(\"length octect is too long\");\n  n = 0;\n  for (let o = 0; o < i; o++) {\n    n <<= 8;\n    const a = t.readUInt8(r);\n    if (t.isError(a))\n      return a;\n    n |= a;\n  }\n  return n;\n}\nconst Q1 = Tr(), ex = Mc.Buffer, Nc = Zh;\nfunction Fc(t) {\n  Nc.call(this, t), this.enc = \"pem\";\n}\nQ1(Fc, Nc);\nvar tx = Fc;\nFc.prototype.decode = function(e, r) {\n  const n = e.toString().split(/[\\r\\n]+/g), i = r.label.toUpperCase(), o = /^-----(BEGIN|END) ([^-]+)-----$/;\n  let a = -1, s = -1;\n  for (let c = 0; c < n.length; c++) {\n    const f = n[c].match(o);\n    if (f !== null && f[2] === i)\n      if (a === -1) {\n        if (f[1] !== \"BEGIN\")\n          break;\n        a = c;\n      } else {\n        if (f[1] !== \"END\")\n          break;\n        s = c;\n        break;\n      }\n  }\n  if (a === -1 || s === -1)\n    throw new Error(\"PEM section not found for: \" + i);\n  const l = n.slice(a + 1, s).join(\"\");\n  l.replace(/[^a-z0-9+/=]+/gi, \"\");\n  const u = ex.from(l, \"base64\");\n  return Nc.prototype.decode.call(this, u, r);\n};\n(function(t) {\n  const e = t;\n  e.der = Zh, e.pem = tx;\n})(Ic);\n(function(t) {\n  const e = Cc, r = Ic, n = Tr(), i = t;\n  i.define = function(s, l) {\n    return new o(s, l);\n  };\n  function o(a, s) {\n    this.name = a, this.body = s, this.decoders = {}, this.encoders = {};\n  }\n  o.prototype._createNamed = function(s) {\n    const l = this.name;\n    function u(c) {\n      this._initNamed(c, l);\n    }\n    return n(u, s), u.prototype._initNamed = function(f, h) {\n      s.call(this, f, h);\n    }, new u(this);\n  }, o.prototype._getDecoder = function(s) {\n    return s = s || \"der\", this.decoders.hasOwnProperty(s) || (this.decoders[s] = this._createNamed(r[s])), this.decoders[s];\n  }, o.prototype.decode = function(s, l, u) {\n    return this._getDecoder(l).decode(s, u);\n  }, o.prototype._getEncoder = function(s) {\n    return s = s || \"der\", this.encoders.hasOwnProperty(s) || (this.encoders[s] = this._createNamed(e[s])), this.encoders[s];\n  }, o.prototype.encode = function(s, l, u) {\n    return this._getEncoder(l).encode(s, u);\n  };\n})(Uh);\nvar Jh = {};\n(function(t) {\n  const e = t;\n  e.Reporter = Ho.Reporter, e.DecoderBuffer = Ur.DecoderBuffer, e.EncoderBuffer = Ur.EncoderBuffer, e.Node = kc;\n})(Jh);\nvar Qh = {};\n(function(t) {\n  const e = t;\n  e._reverse = function(n) {\n    const i = {};\n    return Object.keys(n).forEach(function(o) {\n      (o | 0) == o && (o = o | 0);\n      const a = n[o];\n      i[a] = o;\n    }), i;\n  }, e.der = zo;\n})(Qh);\n(function(t) {\n  const e = t;\n  e.bignum = vo, e.define = Uh.define, e.base = Jh, e.constants = Qh, e.decoders = Ic, e.encoders = Cc;\n})(jh);\nvar rx = ue && ue.__createBinding || (Object.create ? function(t, e, r, n) {\n  n === void 0 && (n = r);\n  var i = Object.getOwnPropertyDescriptor(e, r);\n  (!i || (\"get\" in i ? !e.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {\n    return e[r];\n  } }), Object.defineProperty(t, n, i);\n} : function(t, e, r, n) {\n  n === void 0 && (n = r), t[n] = e[r];\n}), nx = ue && ue.__setModuleDefault || (Object.create ? function(t, e) {\n  Object.defineProperty(t, \"default\", { enumerable: !0, value: e });\n} : function(t, e) {\n  t.default = e;\n}), ix = ue && ue.__importStar || function(t) {\n  if (t && t.__esModule)\n    return t;\n  var e = {};\n  if (t != null)\n    for (var r in t)\n      r !== \"default\" && Object.prototype.hasOwnProperty.call(t, r) && rx(e, t, r);\n  return nx(e, t), e;\n};\nObject.defineProperty(hn, \"__esModule\", { value: !0 });\nhn.jwkTopem = hn.pemTojwk = void 0;\nconst fr = ix(jh);\nfunction ox(t) {\n  return t.replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/=/g, \"\");\n}\nfunction Lc(t) {\n  return ox(Buffer.from(t, \"hex\").toString(\"base64\"));\n}\nvar ed = fr.define(\"RSAPublicKey\", function() {\n  this.seq().obj(this.key(\"n\").int(), this.key(\"e\").int());\n}), td = fr.define(\"AlgorithmIdentifier\", function() {\n  this.seq().obj(this.key(\"algorithm\").objid(), this.key(\"parameters\").optional().any());\n}), sx = fr.define(\"PublicKeyInfo\", function() {\n  this.seq().obj(this.key(\"algorithm\").use(td), this.key(\"publicKey\").bitstr());\n}), rd = fr.define(\"Version\", function() {\n  this.int({\n    0: \"two-prime\",\n    1: \"multi\"\n  });\n}), ax = fr.define(\"OtherPrimeInfos\", function() {\n  this.seq().obj(this.key(\"ri\").int(), this.key(\"di\").int(), this.key(\"ti\").int());\n}), nd = fr.define(\"RSAPrivateKey\", function() {\n  this.seq().obj(this.key(\"version\").use(rd), this.key(\"n\").int(), this.key(\"e\").int(), this.key(\"d\").int(), this.key(\"p\").int(), this.key(\"q\").int(), this.key(\"dp\").int(), this.key(\"dq\").int(), this.key(\"qi\").int(), this.key(\"other\").optional().use(ax));\n}), cx = fr.define(\"PrivateKeyInfo\", function() {\n  this.seq().obj(this.key(\"version\").use(rd), this.key(\"algorithm\").use(td), this.key(\"privateKey\").bitstr());\n});\nfunction id(t, e) {\n  return e = e || {}, Object.keys(e).forEach(function(r) {\n    t[r] = e[r];\n  }), t;\n}\nfunction jc(t) {\n  return t.length % 2 === 1 ? \"0\" + t : t;\n}\nfunction od(t, e) {\n  var r = ed.decode(t, \"der\"), n = jc(r.e.toString(16)), i = {\n    kty: \"RSA\",\n    n: yr(r.n),\n    e: Lc(n)\n  };\n  return id(i, e);\n}\nfunction sd(t, e) {\n  var r = nd.decode(t, \"der\"), n = jc(r.e.toString(16)), i = {\n    kty: \"RSA\",\n    n: yr(r.n),\n    e: Lc(n),\n    d: yr(r.d),\n    p: yr(r.p),\n    q: yr(r.q),\n    dp: yr(r.dp),\n    dq: yr(r.dq),\n    qi: yr(r.qi)\n  };\n  return id(i, e);\n}\nfunction ux(t, e) {\n  var r = sx.decode(t, \"der\");\n  return od(r.publicKey.data, e);\n}\nfunction lx(t, e) {\n  var r = cx.decode(t, \"der\");\n  return sd(r.privateKey.data, e);\n}\nfunction fx(t) {\n  var e = /^-----BEGIN (RSA )?(PUBLIC|PRIVATE) KEY-----$/.exec(t);\n  if (!e)\n    return null;\n  var r = !!e[1], n = e[2] === \"PRIVATE\";\n  return n ? r ? sd : lx : r ? od : ux;\n}\nfunction hx(t) {\n  return {\n    n: pr(t.n),\n    e: pr(t.e),\n    d: t.d && pr(t.d),\n    p: t.p && pr(t.p),\n    q: t.q && pr(t.q),\n    dp: t.dp && pr(t.dp),\n    dq: t.dq && pr(t.dq),\n    qi: t.qi && pr(t.qi)\n  };\n}\nfunction yr(t) {\n  return Lc(jc(t.toString(16)));\n}\nfunction dx(t) {\n  return new fr.bignum(Buffer.from(t, \"base64\"));\n}\nfunction pr(t) {\n  return /^[0-9]+$/.test(t) ? new fr.bignum(t, 10) : dx(t);\n}\nfunction px(t, e) {\n  var r = t.toString().split(/(\\r\\n|\\r|\\n)+/g);\n  r = r.filter(function(i) {\n    return i.trim().length !== 0;\n  });\n  var n = fx(r[0]);\n  return r = r.slice(1, -1).join(\"\"), n(Buffer.from(r.replace(/[^\\w\\d\\+\\/=]+/g, \"\"), \"base64\"), e);\n}\nhn.pemTojwk = px;\nfunction yx(t) {\n  var e = hx(t), r = !!e.d, n = r ? \"PRIVATE\" : \"PUBLIC\", i = \"-----BEGIN RSA \" + n + ` KEY-----\n`, o = `\n-----END RSA ` + n + ` KEY-----\n`, a = Buffer.alloc(0);\n  r ? (e.version = \"two-prime\", a = nd.encode(e, \"der\")) : a = ed.encode(e, \"der\");\n  var s = a.toString(\"base64\").match(/.{1,64}/g).join(`\n`);\n  return i + s + o;\n}\nhn.jwkTopem = yx;\nvar mx = ue && ue.__createBinding || (Object.create ? function(t, e, r, n) {\n  n === void 0 && (n = r);\n  var i = Object.getOwnPropertyDescriptor(e, r);\n  (!i || (\"get\" in i ? !e.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {\n    return e[r];\n  } }), Object.defineProperty(t, n, i);\n} : function(t, e, r, n) {\n  n === void 0 && (n = r), t[n] = e[r];\n}), vx = ue && ue.__setModuleDefault || (Object.create ? function(t, e) {\n  Object.defineProperty(t, \"default\", { enumerable: !0, value: e });\n} : function(t, e) {\n  t.default = e;\n}), gx = ue && ue.__importStar || function(t) {\n  if (t && t.__esModule)\n    return t;\n  var e = {};\n  if (t != null)\n    for (var r in t)\n      r !== \"default\" && Object.prototype.hasOwnProperty.call(t, r) && mx(e, t, r);\n  return vx(e, t), e;\n};\nObject.defineProperty(Pc, \"__esModule\", { value: !0 });\nconst pf = hn, Nt = gx(pc);\nclass xx {\n  constructor() {\n    this.keyLength = 4096, this.publicExponent = 65537, this.hashAlgorithm = \"sha256\", this.encryptionAlgorithm = \"aes-256-cbc\";\n  }\n  generateJWK() {\n    if (typeof Nt.generateKeyPair != \"function\")\n      throw new Error(\"Keypair generation not supported in this version of Node, only supported in versions 10+\");\n    return new Promise((e, r) => {\n      Nt.generateKeyPair(\"rsa\", {\n        modulusLength: this.keyLength,\n        publicExponent: this.publicExponent,\n        privateKeyEncoding: {\n          type: \"pkcs1\",\n          format: \"pem\"\n        },\n        publicKeyEncoding: { type: \"pkcs1\", format: \"pem\" }\n      }, (n, i, o) => {\n        n && r(n), e(this.pemToJWK(o));\n      });\n    });\n  }\n  sign(e, r, { saltLength: n } = {}) {\n    return new Promise((i, o) => {\n      i(Nt.createSign(this.hashAlgorithm).update(r).sign({\n        key: this.jwkToPem(e),\n        padding: Nt.constants.RSA_PKCS1_PSS_PADDING,\n        saltLength: n\n      }));\n    });\n  }\n  verify(e, r, n) {\n    return new Promise((i, o) => {\n      const a = {\n        kty: \"RSA\",\n        e: \"AQAB\",\n        n: e\n      }, s = this.jwkToPem(a);\n      i(Nt.createVerify(this.hashAlgorithm).update(r).verify({\n        key: s,\n        padding: Nt.constants.RSA_PKCS1_PSS_PADDING\n      }, n));\n    });\n  }\n  hash(e, r = \"SHA-256\") {\n    return new Promise((n, i) => {\n      n(Nt.createHash(this.parseHashAlgorithm(r)).update(e).digest());\n    });\n  }\n  /**\n   * If a key is passed as a buffer it *must* be exactly 32 bytes.\n   * If a key is passed as a string then any length may be used.\n   *\n   * @param {Buffer} data\n   * @param {(string | Buffer)} key\n   * @returns {Promise<Uint8Array>}\n   */\n  async encrypt(e, r, n) {\n    const i = Nt.pbkdf2Sync(r, n = n || \"salt\", 1e5, 32, this.hashAlgorithm), o = Nt.randomBytes(16), a = Nt.createCipheriv(this.encryptionAlgorithm, i, o);\n    return Buffer.concat([o, a.update(e), a.final()]);\n  }\n  /**\n   * If a key is passed as a buffer it *must* be exactly 32 bytes.\n   * If a key is passed as a string then any length may be used.\n   *\n   * @param {Buffer} encrypted\n   * @param {(string | Buffer)} key\n   * @returns {Promise<Uint8Array>}\n   */\n  async decrypt(e, r, n) {\n    try {\n      const i = Nt.pbkdf2Sync(r, n = n || \"salt\", 1e5, 32, this.hashAlgorithm), o = e.slice(0, 16), a = e.slice(16), s = Nt.createDecipheriv(this.encryptionAlgorithm, i, o);\n      return Buffer.concat([\n        s.update(a),\n        s.final()\n      ]);\n    } catch {\n      throw new Error(\"Failed to decrypt\");\n    }\n  }\n  jwkToPem(e) {\n    return (0, pf.jwkTopem)(e);\n  }\n  pemToJWK(e) {\n    return (0, pf.pemTojwk)(e);\n  }\n  parseHashAlgorithm(e) {\n    switch (e) {\n      case \"SHA-256\":\n        return \"sha256\";\n      case \"SHA-384\":\n        return \"sha384\";\n      default:\n        throw new Error(`Algorithm not supported: ${e}`);\n    }\n  }\n}\nPc.default = xx;\nvar Uc = {};\nObject.defineProperty(Uc, \"__esModule\", { value: !0 });\nclass wx {\n  constructor(e) {\n    this.api = e;\n  }\n  getInfo() {\n    return this.api.get(\"info\").then((e) => e.data);\n  }\n  getPeers() {\n    return this.api.get(\"peers\").then((e) => e.data);\n  }\n}\nUc.default = wx;\nvar hi = {}, Er = {};\nObject.defineProperty(Er, \"__esModule\", { value: !0 });\nEr.getError = void 0;\nclass bx extends Error {\n  constructor(e, r = {}) {\n    r.message ? super(r.message) : super(), this.type = e, this.response = r.response;\n  }\n  getType() {\n    return this.type;\n  }\n}\nEr.default = bx;\nfunction _x(t) {\n  let e = t.data;\n  if (typeof t.data == \"string\")\n    try {\n      e = JSON.parse(t.data);\n    } catch {\n    }\n  if (t.data instanceof ArrayBuffer || t.data instanceof Uint8Array)\n    try {\n      e = JSON.parse(e.toString());\n    } catch {\n    }\n  return e ? e.error || e : t.statusText || \"unknown\";\n}\nEr.getError = _x;\nvar Yr = {}, $e = {}, Ax = ue && ue.__createBinding || (Object.create ? function(t, e, r, n) {\n  n === void 0 && (n = r);\n  var i = Object.getOwnPropertyDescriptor(e, r);\n  (!i || (\"get\" in i ? !e.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {\n    return e[r];\n  } }), Object.defineProperty(t, n, i);\n} : function(t, e, r, n) {\n  n === void 0 && (n = r), t[n] = e[r];\n}), Tx = ue && ue.__setModuleDefault || (Object.create ? function(t, e) {\n  Object.defineProperty(t, \"default\", { enumerable: !0, value: e });\n} : function(t, e) {\n  t.default = e;\n}), Ex = ue && ue.__importStar || function(t) {\n  if (t && t.__esModule)\n    return t;\n  var e = {};\n  if (t != null)\n    for (var r in t)\n      r !== \"default\" && Object.prototype.hasOwnProperty.call(t, r) && Ax(e, t, r);\n  return Tx(e, t), e;\n};\nObject.defineProperty($e, \"__esModule\", { value: !0 });\n$e.b64UrlDecode = $e.b64UrlEncode = $e.bufferTob64Url = $e.bufferTob64 = $e.b64UrlToBuffer = $e.stringToB64Url = $e.stringToBuffer = $e.bufferToString = $e.b64UrlToString = $e.concatBuffers = void 0;\nconst ad = Ex(ri);\nfunction Sx(t) {\n  let e = 0;\n  for (let i = 0; i < t.length; i++)\n    e += t[i].byteLength;\n  let r = new Uint8Array(e), n = 0;\n  r.set(new Uint8Array(t[0]), n), n += t[0].byteLength;\n  for (let i = 1; i < t.length; i++)\n    r.set(new Uint8Array(t[i]), n), n += t[i].byteLength;\n  return r;\n}\n$e.concatBuffers = Sx;\nfunction Px(t) {\n  let e = ld(t);\n  return cd(e);\n}\n$e.b64UrlToString = Px;\nfunction cd(t) {\n  if (typeof TextDecoder > \"u\") {\n    const e = ec().TextDecoder;\n    return new e(\"utf-8\", { fatal: !0 }).decode(t);\n  }\n  return new TextDecoder(\"utf-8\", { fatal: !0 }).decode(t);\n}\n$e.bufferToString = cd;\nfunction ud(t) {\n  if (typeof TextEncoder > \"u\") {\n    const e = ec().TextEncoder;\n    return new e().encode(t);\n  }\n  return new TextEncoder().encode(t);\n}\n$e.stringToBuffer = ud;\nfunction Cx(t) {\n  return hd(ud(t));\n}\n$e.stringToB64Url = Cx;\nfunction ld(t) {\n  return new Uint8Array(ad.toByteArray(pd(t)));\n}\n$e.b64UrlToBuffer = ld;\nfunction fd(t) {\n  return ad.fromByteArray(new Uint8Array(t));\n}\n$e.bufferTob64 = fd;\nfunction hd(t) {\n  return dd(fd(t));\n}\n$e.bufferTob64Url = hd;\nfunction dd(t) {\n  return t.replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/\\=/g, \"\");\n}\n$e.b64UrlEncode = dd;\nfunction pd(t) {\n  t = t.replace(/\\-/g, \"+\").replace(/\\_/g, \"/\");\n  let e;\n  return t.length % 4 == 0 ? e = 0 : e = 4 - t.length % 4, t.concat(\"=\".repeat(e));\n}\n$e.b64UrlDecode = pd;\nvar di = {}, yf;\nfunction Ox() {\n  if (yf)\n    return di;\n  yf = 1;\n  var t = ue && ue.__importDefault || function(i) {\n    return i && i.__esModule ? i : { default: i };\n  };\n  Object.defineProperty(di, \"__esModule\", { value: !0 });\n  const e = t(zc());\n  async function r(i) {\n    if (Array.isArray(i)) {\n      const s = e.default.utils.concatBuffers([\n        e.default.utils.stringToBuffer(\"list\"),\n        e.default.utils.stringToBuffer(i.length.toString())\n      ]);\n      return await n(i, await e.default.crypto.hash(s, \"SHA-384\"));\n    }\n    const o = e.default.utils.concatBuffers([\n      e.default.utils.stringToBuffer(\"blob\"),\n      e.default.utils.stringToBuffer(i.byteLength.toString())\n    ]), a = e.default.utils.concatBuffers([\n      await e.default.crypto.hash(o, \"SHA-384\"),\n      await e.default.crypto.hash(i, \"SHA-384\")\n    ]);\n    return await e.default.crypto.hash(a, \"SHA-384\");\n  }\n  di.default = r;\n  async function n(i, o) {\n    if (i.length < 1)\n      return o;\n    const a = e.default.utils.concatBuffers([\n      o,\n      await r(i[0])\n    ]), s = await e.default.crypto.hash(a, \"SHA-384\");\n    return await n(i.slice(1), s);\n  }\n  return di;\n}\nvar qs = {}, mf;\nfunction yd() {\n  return mf || (mf = 1, function(t) {\n    var e = ue && ue.__importDefault || function(U) {\n      return U && U.__esModule ? U : { default: U };\n    };\n    Object.defineProperty(t, \"__esModule\", { value: !0 }), t.debug = t.validatePath = t.arrayCompare = t.bufferToInt = t.intToBuffer = t.arrayFlatten = t.generateProofs = t.buildLayers = t.generateTransactionChunks = t.generateTree = t.computeRootHash = t.generateLeaves = t.chunkData = t.MIN_CHUNK_SIZE = t.MAX_CHUNK_SIZE = void 0;\n    const r = e(zc()), n = $e;\n    t.MAX_CHUNK_SIZE = 256 * 1024, t.MIN_CHUNK_SIZE = 32 * 1024;\n    const i = 32, o = 32;\n    async function a(U) {\n      let W = [], G = U, Z = 0;\n      for (; G.byteLength >= t.MAX_CHUNK_SIZE; ) {\n        let j = t.MAX_CHUNK_SIZE, P = G.byteLength - t.MAX_CHUNK_SIZE;\n        P > 0 && P < t.MIN_CHUNK_SIZE && (j = Math.ceil(G.byteLength / 2));\n        const d = G.slice(0, j), x = await r.default.crypto.hash(d);\n        Z += d.byteLength, W.push({\n          dataHash: x,\n          minByteRange: Z - d.byteLength,\n          maxByteRange: Z\n        }), G = G.slice(j);\n      }\n      return W.push({\n        dataHash: await r.default.crypto.hash(G),\n        minByteRange: Z,\n        maxByteRange: Z + G.byteLength\n      }), W;\n    }\n    t.chunkData = a;\n    async function s(U) {\n      return Promise.all(U.map(async ({ dataHash: W, minByteRange: G, maxByteRange: Z }) => ({\n        type: \"leaf\",\n        id: await T(await Promise.all([T(W), T(A(Z))])),\n        dataHash: W,\n        minByteRange: G,\n        maxByteRange: Z\n      })));\n    }\n    t.generateLeaves = s;\n    async function l(U) {\n      return (await u(U)).id;\n    }\n    t.computeRootHash = l;\n    async function u(U) {\n      return await f(await s(await a(U)));\n    }\n    t.generateTree = u;\n    async function c(U) {\n      const W = await a(U), G = await s(W), Z = await f(G), j = await h(Z), P = W.slice(-1)[0];\n      return P.maxByteRange - P.minByteRange === 0 && (W.splice(W.length - 1, 1), j.splice(j.length - 1, 1)), {\n        data_root: Z.id,\n        chunks: W,\n        proofs: j\n      };\n    }\n    t.generateTransactionChunks = c;\n    async function f(U, W = 0) {\n      if (U.length < 2)\n        return U[0];\n      const G = [];\n      for (let Z = 0; Z < U.length; Z += 2)\n        G.push(await _(U[Z], U[Z + 1]));\n      return f(G, W + 1);\n    }\n    t.buildLayers = f;\n    function h(U) {\n      const W = p(U);\n      return Array.isArray(W) ? g(W) : [W];\n    }\n    t.generateProofs = h;\n    function p(U, W = new Uint8Array(), G = 0) {\n      if (U.type == \"leaf\")\n        return {\n          offset: U.maxByteRange - 1,\n          proof: (0, n.concatBuffers)([\n            W,\n            U.dataHash,\n            A(U.maxByteRange)\n          ])\n        };\n      if (U.type == \"branch\") {\n        const Z = (0, n.concatBuffers)([\n          W,\n          U.leftChild.id,\n          U.rightChild.id,\n          A(U.byteRange)\n        ]);\n        return [\n          p(U.leftChild, Z, G + 1),\n          p(U.rightChild, Z, G + 1)\n        ];\n      }\n      throw new Error(\"Unexpected node type\");\n    }\n    function g(U) {\n      const W = [];\n      return U.forEach((G) => {\n        Array.isArray(G) ? W.push(...g(G)) : W.push(G);\n      }), W;\n    }\n    t.arrayFlatten = g;\n    async function _(U, W) {\n      return W ? {\n        type: \"branch\",\n        id: await T([\n          await T(U.id),\n          await T(W.id),\n          await T(A(U.maxByteRange))\n        ]),\n        byteRange: U.maxByteRange,\n        maxByteRange: W.maxByteRange,\n        leftChild: U,\n        rightChild: W\n      } : U;\n    }\n    async function T(U) {\n      return Array.isArray(U) && (U = r.default.utils.concatBuffers(U)), new Uint8Array(await r.default.crypto.hash(U));\n    }\n    function A(U) {\n      const W = new Uint8Array(i);\n      for (var G = W.length - 1; G >= 0; G--) {\n        var Z = U % 256;\n        W[G] = Z, U = (U - Z) / 256;\n      }\n      return W;\n    }\n    t.intToBuffer = A;\n    function w(U) {\n      let W = 0;\n      for (var G = 0; G < U.length; G++)\n        W *= 256, W += U[G];\n      return W;\n    }\n    t.bufferToInt = w;\n    const O = (U, W) => U.every((G, Z) => W[Z] === G);\n    t.arrayCompare = O;\n    async function R(U, W, G, Z, j) {\n      if (Z <= 0)\n        return !1;\n      if (W >= Z)\n        return R(U, 0, Z - 1, Z, j);\n      if (W < 0)\n        return R(U, 0, 0, Z, j);\n      if (j.length == o + i) {\n        const z = j.slice(0, o), Y = j.slice(z.length, z.length + i), L = await T([\n          await T(z),\n          await T(Y)\n        ]);\n        return (0, t.arrayCompare)(U, L) ? {\n          offset: Z - 1,\n          leftBound: G,\n          rightBound: Z,\n          chunkSize: Z - G\n        } : !1;\n      }\n      const P = j.slice(0, o), d = j.slice(P.length, P.length + o), x = j.slice(P.length + d.length, P.length + d.length + i), C = w(x), M = j.slice(P.length + d.length + x.length), D = await T([\n        await T(P),\n        await T(d),\n        await T(x)\n      ]);\n      return (0, t.arrayCompare)(U, D) ? W < C ? await R(P, W, G, Math.min(Z, C), M) : await R(d, W, Math.max(G, C), Z, M) : !1;\n    }\n    t.validatePath = R;\n    async function $(U, W = \"\") {\n      if (U.byteLength < 1)\n        return W;\n      const G = U.slice(0, o), Z = U.slice(G.length, G.length + o), j = U.slice(G.length + Z.length, G.length + Z.length + i), P = w(j), d = U.slice(G.length + Z.length + j.length), x = await T([\n        await T(G),\n        await T(Z),\n        await T(j)\n      ]), C = `${W}\n${JSON.stringify(Buffer.from(G))},${JSON.stringify(Buffer.from(Z))},${P} => ${JSON.stringify(x)}`;\n      return $(d, C);\n    }\n    t.debug = $;\n  }(qs)), qs;\n}\nvar vf;\nfunction Vc() {\n  if (vf)\n    return Yr;\n  vf = 1;\n  var t = ue && ue.__createBinding || (Object.create ? function(c, f, h, p) {\n    p === void 0 && (p = h);\n    var g = Object.getOwnPropertyDescriptor(f, h);\n    (!g || (\"get\" in g ? !f.__esModule : g.writable || g.configurable)) && (g = { enumerable: !0, get: function() {\n      return f[h];\n    } }), Object.defineProperty(c, p, g);\n  } : function(c, f, h, p) {\n    p === void 0 && (p = h), c[p] = f[h];\n  }), e = ue && ue.__setModuleDefault || (Object.create ? function(c, f) {\n    Object.defineProperty(c, \"default\", { enumerable: !0, value: f });\n  } : function(c, f) {\n    c.default = f;\n  }), r = ue && ue.__importStar || function(c) {\n    if (c && c.__esModule)\n      return c;\n    var f = {};\n    if (c != null)\n      for (var h in c)\n        h !== \"default\" && Object.prototype.hasOwnProperty.call(c, h) && t(f, c, h);\n    return e(f, c), f;\n  }, n = ue && ue.__importDefault || function(c) {\n    return c && c.__esModule ? c : { default: c };\n  };\n  Object.defineProperty(Yr, \"__esModule\", { value: !0 }), Yr.Tag = void 0;\n  const i = r($e), o = n(Ox()), a = yd();\n  class s {\n    get(f, h) {\n      if (!Object.getOwnPropertyNames(this).includes(f))\n        throw new Error(`Field \"${f}\" is not a property of the Arweave Transaction class.`);\n      return this[f] instanceof Uint8Array ? h && h.decode && h.string ? i.bufferToString(this[f]) : h && h.decode && !h.string ? this[f] : i.bufferTob64Url(this[f]) : h && h.decode == !0 ? h && h.string ? i.b64UrlToString(this[f]) : i.b64UrlToBuffer(this[f]) : this[f];\n    }\n  }\n  class l extends s {\n    constructor(f, h, p = !1) {\n      super(), this.name = f, this.value = h;\n    }\n  }\n  Yr.Tag = l;\n  class u extends s {\n    constructor(f = {}) {\n      super(), this.format = 2, this.id = \"\", this.last_tx = \"\", this.owner = \"\", this.tags = [], this.target = \"\", this.quantity = \"0\", this.data_size = \"0\", this.data = new Uint8Array(), this.data_root = \"\", this.reward = \"0\", this.signature = \"\", Object.assign(this, f), typeof this.data == \"string\" && (this.data = i.b64UrlToBuffer(this.data)), f.tags && (this.tags = f.tags.map((h) => new l(h.name, h.value)));\n    }\n    addTag(f, h) {\n      this.tags.push(new l(i.stringToB64Url(f), i.stringToB64Url(h)));\n    }\n    toJSON() {\n      return {\n        format: this.format,\n        id: this.id,\n        last_tx: this.last_tx,\n        owner: this.owner,\n        tags: this.tags,\n        target: this.target,\n        quantity: this.quantity,\n        data: i.bufferTob64Url(this.data),\n        data_size: this.data_size,\n        data_root: this.data_root,\n        data_tree: this.data_tree,\n        reward: this.reward,\n        signature: this.signature\n      };\n    }\n    setOwner(f) {\n      this.owner = f;\n    }\n    setSignature({ id: f, owner: h, reward: p, tags: g, signature: _ }) {\n      this.id = f, this.owner = h, p && (this.reward = p), g && (this.tags = g), this.signature = _;\n    }\n    async prepareChunks(f) {\n      !this.chunks && f.byteLength > 0 && (this.chunks = await (0, a.generateTransactionChunks)(f), this.data_root = i.bufferTob64Url(this.chunks.data_root)), !this.chunks && f.byteLength === 0 && (this.chunks = {\n        chunks: [],\n        data_root: new Uint8Array(),\n        proofs: []\n      }, this.data_root = \"\");\n    }\n    // Returns a chunk in a format suitable for posting to /chunk.\n    // Similar to `prepareChunks()` this does not operate `this.data`,\n    // instead using the data passed in.\n    getChunk(f, h) {\n      if (!this.chunks)\n        throw new Error(\"Chunks have not been prepared\");\n      const p = this.chunks.proofs[f], g = this.chunks.chunks[f];\n      return {\n        data_root: this.data_root,\n        data_size: this.data_size,\n        data_path: i.bufferTob64Url(p.proof),\n        offset: p.offset.toString(),\n        chunk: i.bufferTob64Url(h.slice(g.minByteRange, g.maxByteRange))\n      };\n    }\n    async getSignatureData() {\n      switch (this.format) {\n        case 1:\n          let f = this.tags.reduce((p, g) => i.concatBuffers([\n            p,\n            g.get(\"name\", { decode: !0, string: !1 }),\n            g.get(\"value\", { decode: !0, string: !1 })\n          ]), new Uint8Array());\n          return i.concatBuffers([\n            this.get(\"owner\", { decode: !0, string: !1 }),\n            this.get(\"target\", { decode: !0, string: !1 }),\n            this.get(\"data\", { decode: !0, string: !1 }),\n            i.stringToBuffer(this.quantity),\n            i.stringToBuffer(this.reward),\n            this.get(\"last_tx\", { decode: !0, string: !1 }),\n            f\n          ]);\n        case 2:\n          this.data_root || await this.prepareChunks(this.data);\n          const h = this.tags.map((p) => [\n            p.get(\"name\", { decode: !0, string: !1 }),\n            p.get(\"value\", { decode: !0, string: !1 })\n          ]);\n          return await (0, o.default)([\n            i.stringToBuffer(this.format.toString()),\n            this.get(\"owner\", { decode: !0, string: !1 }),\n            this.get(\"target\", { decode: !0, string: !1 }),\n            i.stringToBuffer(this.quantity),\n            i.stringToBuffer(this.reward),\n            this.get(\"last_tx\", { decode: !0, string: !1 }),\n            h,\n            i.stringToBuffer(this.data_size),\n            this.get(\"data_root\", { decode: !0, string: !1 })\n          ]);\n        default:\n          throw new Error(`Unexpected transaction format: ${this.format}`);\n      }\n    }\n  }\n  return Yr.default = u, Yr;\n}\nvar Cn = {}, gf;\nfunction Mx() {\n  if (gf)\n    return Cn;\n  gf = 1;\n  var t = ue && ue.__createBinding || (Object.create ? function(h, p, g, _) {\n    _ === void 0 && (_ = g);\n    var T = Object.getOwnPropertyDescriptor(p, g);\n    (!T || (\"get\" in T ? !p.__esModule : T.writable || T.configurable)) && (T = { enumerable: !0, get: function() {\n      return p[g];\n    } }), Object.defineProperty(h, _, T);\n  } : function(h, p, g, _) {\n    _ === void 0 && (_ = g), h[_] = p[g];\n  }), e = ue && ue.__setModuleDefault || (Object.create ? function(h, p) {\n    Object.defineProperty(h, \"default\", { enumerable: !0, value: p });\n  } : function(h, p) {\n    h.default = p;\n  }), r = ue && ue.__importStar || function(h) {\n    if (h && h.__esModule)\n      return h;\n    var p = {};\n    if (h != null)\n      for (var g in h)\n        g !== \"default\" && Object.prototype.hasOwnProperty.call(h, g) && t(p, h, g);\n    return e(p, h), p;\n  }, n = ue && ue.__importDefault || function(h) {\n    return h && h.__esModule ? h : { default: h };\n  };\n  Object.defineProperty(Cn, \"__esModule\", { value: !0 }), Cn.TransactionUploader = void 0;\n  const i = n(Vc()), o = r($e), a = Er, s = yd(), l = 1, u = [\n    \"invalid_json\",\n    \"chunk_too_big\",\n    \"data_path_too_big\",\n    \"offset_too_big\",\n    \"data_size_too_big\",\n    \"chunk_proof_ratio_not_attractive\",\n    \"invalid_proof\"\n  ], c = 1e3 * 40;\n  class f {\n    get isComplete() {\n      return this.txPosted && this.chunkIndex === this.transaction.chunks.chunks.length;\n    }\n    get totalChunks() {\n      return this.transaction.chunks.chunks.length;\n    }\n    get uploadedChunks() {\n      return this.chunkIndex;\n    }\n    get pctComplete() {\n      return Math.trunc(this.uploadedChunks / this.totalChunks * 100);\n    }\n    constructor(p, g) {\n      if (this.api = p, this.chunkIndex = 0, this.txPosted = !1, this.lastRequestTimeEnd = 0, this.totalErrors = 0, this.lastResponseStatus = 0, this.lastResponseError = \"\", !g.id)\n        throw new Error(\"Transaction is not signed\");\n      if (!g.chunks)\n        throw new Error(\"Transaction chunks not prepared\");\n      this.data = g.data, this.transaction = new i.default(Object.assign({}, g, { data: new Uint8Array(0) }));\n    }\n    /**\n     * Uploads the next part of the transaction.\n     * On the first call this posts the transaction\n     * itself and on any subsequent calls uploads the\n     * next chunk until it completes.\n     */\n    async uploadChunk(p) {\n      if (this.isComplete)\n        throw new Error(\"Upload is already complete\");\n      if (this.lastResponseError !== \"\" ? this.totalErrors++ : this.totalErrors = 0, this.totalErrors === 100)\n        throw new Error(`Unable to complete upload: ${this.lastResponseStatus}: ${this.lastResponseError}`);\n      let g = this.lastResponseError === \"\" ? 0 : Math.max(this.lastRequestTimeEnd + c - Date.now(), c);\n      if (g > 0 && (g = g - g * Math.random() * 0.3, await new Promise((w) => setTimeout(w, g))), this.lastResponseError = \"\", !this.txPosted) {\n        await this.postTransaction();\n        return;\n      }\n      p && (this.chunkIndex = p);\n      const _ = this.transaction.getChunk(p || this.chunkIndex, this.data);\n      if (!await (0, s.validatePath)(this.transaction.chunks.data_root, parseInt(_.offset), 0, parseInt(_.data_size), o.b64UrlToBuffer(_.data_path)))\n        throw new Error(`Unable to validate chunk ${this.chunkIndex}`);\n      const A = await this.api.post(\"chunk\", this.transaction.getChunk(this.chunkIndex, this.data)).catch((w) => (console.error(w.message), { status: -1, data: { error: w.message } }));\n      if (this.lastRequestTimeEnd = Date.now(), this.lastResponseStatus = A.status, this.lastResponseStatus == 200)\n        this.chunkIndex++;\n      else if (this.lastResponseError = (0, a.getError)(A), u.includes(this.lastResponseError))\n        throw new Error(`Fatal error uploading chunk ${this.chunkIndex}: ${this.lastResponseError}`);\n    }\n    /**\n     * Reconstructs an upload from its serialized state and data.\n     * Checks if data matches the expected data_root.\n     *\n     * @param serialized\n     * @param data\n     */\n    static async fromSerialized(p, g, _) {\n      if (!g || typeof g.chunkIndex != \"number\" || typeof g.transaction != \"object\")\n        throw new Error(\"Serialized object does not match expected format.\");\n      var T = new i.default(g.transaction);\n      T.chunks || await T.prepareChunks(_);\n      const A = new f(p, T);\n      if (A.chunkIndex = g.chunkIndex, A.lastRequestTimeEnd = g.lastRequestTimeEnd, A.lastResponseError = g.lastResponseError, A.lastResponseStatus = g.lastResponseStatus, A.txPosted = g.txPosted, A.data = _, A.transaction.data_root !== g.transaction.data_root)\n        throw new Error(\"Data mismatch: Uploader doesn't match provided data.\");\n      return A;\n    }\n    /**\n     * Reconstruct an upload from the tx metadata, ie /tx/<id>.\n     *\n     * @param api\n     * @param id\n     * @param data\n     */\n    static async fromTransactionId(p, g) {\n      const _ = await p.get(`tx/${g}`);\n      if (_.status !== 200)\n        throw new Error(`Tx ${g} not found: ${_.status}`);\n      const T = _.data;\n      return T.data = new Uint8Array(0), {\n        txPosted: !0,\n        chunkIndex: 0,\n        lastResponseError: \"\",\n        lastRequestTimeEnd: 0,\n        lastResponseStatus: 0,\n        transaction: T\n      };\n    }\n    toJSON() {\n      return {\n        chunkIndex: this.chunkIndex,\n        transaction: this.transaction,\n        lastRequestTimeEnd: this.lastRequestTimeEnd,\n        lastResponseStatus: this.lastResponseStatus,\n        lastResponseError: this.lastResponseError,\n        txPosted: this.txPosted\n      };\n    }\n    // POST to /tx\n    async postTransaction() {\n      if (this.totalChunks <= l) {\n        this.transaction.data = this.data;\n        const _ = await this.api.post(\"tx\", this.transaction).catch((T) => (console.error(T), { status: -1, data: { error: T.message } }));\n        if (this.lastRequestTimeEnd = Date.now(), this.lastResponseStatus = _.status, this.transaction.data = new Uint8Array(0), _.status >= 200 && _.status < 300) {\n          this.txPosted = !0, this.chunkIndex = l;\n          return;\n        }\n        throw this.lastResponseError = (0, a.getError)(_), new Error(`Unable to upload transaction: ${_.status}, ${this.lastResponseError}`);\n      }\n      const g = await this.api.post(\"tx\", this.transaction);\n      if (this.lastRequestTimeEnd = Date.now(), this.lastResponseStatus = g.status, !(g.status >= 200 && g.status < 300))\n        throw this.lastResponseError = (0, a.getError)(g), new Error(`Unable to upload transaction: ${g.status}, ${this.lastResponseError}`);\n      this.txPosted = !0;\n    }\n  }\n  return Cn.TransactionUploader = f, Cn;\n}\nvar xf;\nfunction kx() {\n  if (xf)\n    return hi;\n  xf = 1;\n  var t = ue && ue.__createBinding || (Object.create ? function(u, c, f, h) {\n    h === void 0 && (h = f);\n    var p = Object.getOwnPropertyDescriptor(c, f);\n    (!p || (\"get\" in p ? !c.__esModule : p.writable || p.configurable)) && (p = { enumerable: !0, get: function() {\n      return c[f];\n    } }), Object.defineProperty(u, h, p);\n  } : function(u, c, f, h) {\n    h === void 0 && (h = f), u[h] = c[f];\n  }), e = ue && ue.__setModuleDefault || (Object.create ? function(u, c) {\n    Object.defineProperty(u, \"default\", { enumerable: !0, value: c });\n  } : function(u, c) {\n    u.default = c;\n  }), r = ue && ue.__importStar || function(u) {\n    if (u && u.__esModule)\n      return u;\n    var c = {};\n    if (u != null)\n      for (var f in u)\n        f !== \"default\" && Object.prototype.hasOwnProperty.call(u, f) && t(c, u, f);\n    return e(c, u), c;\n  }, n = ue && ue.__importDefault || function(u) {\n    return u && u.__esModule ? u : { default: u };\n  };\n  Object.defineProperty(hi, \"__esModule\", { value: !0 });\n  const i = n(Er), o = n(Vc()), a = r($e), s = Mx();\n  class l {\n    constructor(c, f, h) {\n      this.api = c, this.crypto = f, this.chunks = h;\n    }\n    getTransactionAnchor() {\n      return this.api.get(\"tx_anchor\").then((c) => c.data);\n    }\n    getPrice(c, f) {\n      let h = f ? `price/${c}/${f}` : `price/${c}`;\n      return this.api.get(h).then((p) => p.data);\n    }\n    async get(c) {\n      const f = await this.api.get(`tx/${c}`);\n      if (f.status == 200) {\n        const h = parseInt(f.data.data_size);\n        if (f.data.format >= 2 && h > 0 && h <= 1024 * 1024 * 12) {\n          const p = await this.getData(c);\n          return new o.default({\n            ...f.data,\n            data: p\n          });\n        }\n        return new o.default({\n          ...f.data,\n          format: f.data.format || 1\n        });\n      }\n      throw f.status == 404 ? new i.default(\n        \"TX_NOT_FOUND\"\n        /* ArweaveErrorType.TX_NOT_FOUND */\n      ) : f.status == 410 ? new i.default(\n        \"TX_FAILED\"\n        /* ArweaveErrorType.TX_FAILED */\n      ) : new i.default(\n        \"TX_INVALID\"\n        /* ArweaveErrorType.TX_INVALID */\n      );\n    }\n    fromRaw(c) {\n      return new o.default(c);\n    }\n    async search(c, f) {\n      return this.api.post(\"arql\", {\n        op: \"equals\",\n        expr1: c,\n        expr2: f\n      }).then((h) => h.data ? h.data : []);\n    }\n    getStatus(c) {\n      return this.api.get(`tx/${c}/status`).then((f) => f.status == 200 ? {\n        status: 200,\n        confirmed: f.data\n      } : {\n        status: f.status,\n        confirmed: null\n      });\n    }\n    async getData(c, f) {\n      let h;\n      try {\n        h = await this.chunks.downloadChunkedData(c);\n      } catch (p) {\n        console.error(`Error while trying to download chunked data for ${c}`), console.error(p);\n      }\n      if (!h) {\n        console.warn(`Falling back to gateway cache for ${c}`);\n        try {\n          h = (await this.api.get(`/${c}`)).data;\n        } catch (p) {\n          console.error(`Error while trying to download contiguous data from gateway cache for ${c}`), console.error(p);\n        }\n      }\n      if (!h)\n        throw new Error(`${c} was not found!`);\n      return f && f.decode && !f.string ? h : f && f.decode && f.string ? a.bufferToString(h) : a.bufferTob64Url(h);\n    }\n    async sign(c, f, h) {\n      if (!f && typeof arweaveWallet != \"object\")\n        throw new Error(\"A new Arweave transaction must provide the jwk parameter.\");\n      if (!f || f === \"use_wallet\") {\n        try {\n          (await arweaveWallet.getPermissions()).includes(\"SIGN_TRANSACTION\") || await arweaveWallet.connect([\"SIGN_TRANSACTION\"]);\n        } catch {\n        }\n        const p = await arweaveWallet.sign(c, h);\n        c.setSignature({\n          id: p.id,\n          owner: p.owner,\n          reward: p.reward,\n          tags: p.tags,\n          signature: p.signature\n        });\n      } else {\n        c.setOwner(f.n);\n        let p = await c.getSignatureData(), g = await this.crypto.sign(f, p, h), _ = await this.crypto.hash(g);\n        c.setSignature({\n          id: a.bufferTob64Url(_),\n          owner: f.n,\n          signature: a.bufferTob64Url(g)\n        });\n      }\n    }\n    async verify(c) {\n      const f = await c.getSignatureData(), h = c.get(\"signature\", {\n        decode: !0,\n        string: !1\n      }), p = a.bufferTob64Url(await this.crypto.hash(h));\n      if (c.id !== p)\n        throw new Error(\"Invalid transaction signature or ID! The transaction ID doesn't match the expected SHA-256 hash of the signature.\");\n      return this.crypto.verify(c.owner, f, h);\n    }\n    async post(c) {\n      if (typeof c == \"string\" ? c = new o.default(JSON.parse(c)) : typeof c.readInt32BE == \"function\" ? c = new o.default(JSON.parse(c.toString())) : typeof c == \"object\" && !(c instanceof o.default) && (c = new o.default(c)), !(c instanceof o.default))\n        throw new Error(\"Must be Transaction object\");\n      c.chunks || await c.prepareChunks(c.data);\n      const f = await this.getUploader(c, c.data);\n      try {\n        for (; !f.isComplete; )\n          await f.uploadChunk();\n      } catch (h) {\n        if (f.lastResponseStatus > 0)\n          return {\n            status: f.lastResponseStatus,\n            statusText: f.lastResponseError,\n            data: {\n              error: f.lastResponseError\n            }\n          };\n        throw h;\n      }\n      return {\n        status: 200,\n        statusText: \"OK\",\n        data: {}\n      };\n    }\n    /**\n     * Gets an uploader than can be used to upload a transaction chunk by chunk, giving progress\n     * and the ability to resume.\n     *\n     * Usage example:\n     *\n     * ```\n     * const uploader = arweave.transactions.getUploader(transaction);\n     * while (!uploader.isComplete) {\n     *   await uploader.uploadChunk();\n     *   console.log(`${uploader.pctComplete}%`);\n     * }\n     * ```\n     *\n     * @param upload a Transaction object, a previously save progress object, or a transaction id.\n     * @param data the data of the transaction. Required when resuming an upload.\n     */\n    async getUploader(c, f) {\n      let h;\n      if (f instanceof ArrayBuffer && (f = new Uint8Array(f)), c instanceof o.default) {\n        if (f || (f = c.data), !(f instanceof Uint8Array))\n          throw new Error(\"Data format is invalid\");\n        c.chunks || await c.prepareChunks(f), h = new s.TransactionUploader(this.api, c), (!h.data || h.data.length === 0) && (h.data = f);\n      } else {\n        if (typeof c == \"string\" && (c = await s.TransactionUploader.fromTransactionId(this.api, c)), !f || !(f instanceof Uint8Array))\n          throw new Error(\"Must provide data when resuming upload\");\n        h = await s.TransactionUploader.fromSerialized(this.api, c, f);\n      }\n      return h;\n    }\n    /**\n     * Async generator version of uploader\n     *\n     * Usage example:\n     *\n     * ```\n     * for await (const uploader of arweave.transactions.upload(tx)) {\n     *  console.log(`${uploader.pctComplete}%`);\n     * }\n     * ```\n     *\n     * @param upload a Transaction object, a previously save uploader, or a transaction id.\n     * @param data the data of the transaction. Required when resuming an upload.\n     */\n    async *upload(c, f) {\n      const h = await this.getUploader(c, f);\n      for (; !h.isComplete; )\n        await h.uploadChunk(), yield h;\n      return h;\n    }\n  }\n  return hi.default = l, hi;\n}\nvar $c = {}, Rx = ue && ue.__createBinding || (Object.create ? function(t, e, r, n) {\n  n === void 0 && (n = r);\n  var i = Object.getOwnPropertyDescriptor(e, r);\n  (!i || (\"get\" in i ? !e.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {\n    return e[r];\n  } }), Object.defineProperty(t, n, i);\n} : function(t, e, r, n) {\n  n === void 0 && (n = r), t[n] = e[r];\n}), Bx = ue && ue.__setModuleDefault || (Object.create ? function(t, e) {\n  Object.defineProperty(t, \"default\", { enumerable: !0, value: e });\n} : function(t, e) {\n  t.default = e;\n}), Ix = ue && ue.__importStar || function(t) {\n  if (t && t.__esModule)\n    return t;\n  var e = {};\n  if (t != null)\n    for (var r in t)\n      r !== \"default\" && Object.prototype.hasOwnProperty.call(t, r) && Rx(e, t, r);\n  return Bx(e, t), e;\n};\nObject.defineProperty($c, \"__esModule\", { value: !0 });\nconst wf = Ix($e);\nclass Dx {\n  constructor(e, r) {\n    this.api = e, this.crypto = r;\n  }\n  /**\n   * Get the wallet balance for the given address.\n   *\n   * @param {string} address - The arweave address to get the balance for.\n   *\n   * @returns {Promise<string>} - Promise which resolves with a winston string balance.\n   */\n  getBalance(e) {\n    return this.api.get(`wallet/${e}/balance`).then((r) => r.data);\n  }\n  /**\n   * Get the last transaction ID for the given wallet address.\n   *\n   * @param {string} address - The arweave address to get the transaction for.\n   *\n   * @returns {Promise<string>} - Promise which resolves with a transaction ID.\n   */\n  getLastTransactionID(e) {\n    return this.api.get(`wallet/${e}/last_tx`).then((r) => r.data);\n  }\n  generate() {\n    return this.crypto.generateJWK();\n  }\n  async jwkToAddress(e) {\n    return !e || e === \"use_wallet\" ? this.getAddress() : this.getAddress(e);\n  }\n  async getAddress(e) {\n    if (!e || e === \"use_wallet\") {\n      try {\n        await arweaveWallet.connect([\"ACCESS_ADDRESS\"]);\n      } catch {\n      }\n      return arweaveWallet.getActiveAddress();\n    } else\n      return this.ownerToAddress(e.n);\n  }\n  async ownerToAddress(e) {\n    return wf.bufferTob64Url(await this.crypto.hash(wf.b64UrlToBuffer(e)));\n  }\n}\n$c.default = Dx;\nvar ni = {}, Nx = ue && ue.__createBinding || (Object.create ? function(t, e, r, n) {\n  n === void 0 && (n = r);\n  var i = Object.getOwnPropertyDescriptor(e, r);\n  (!i || (\"get\" in i ? !e.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {\n    return e[r];\n  } }), Object.defineProperty(t, n, i);\n} : function(t, e, r, n) {\n  n === void 0 && (n = r), t[n] = e[r];\n}), Fx = ue && ue.__setModuleDefault || (Object.create ? function(t, e) {\n  Object.defineProperty(t, \"default\", { enumerable: !0, value: e });\n} : function(t, e) {\n  t.default = e;\n}), Lx = ue && ue.__importStar || function(t) {\n  if (t && t.__esModule)\n    return t;\n  var e = {};\n  if (t != null)\n    for (var r in t)\n      r !== \"default\" && Object.prototype.hasOwnProperty.call(t, r) && Nx(e, t, r);\n  return Fx(e, t), e;\n};\nObject.defineProperty(ni, \"__esModule\", { value: !0 });\nni.SiloResource = void 0;\nconst bf = Lx($e);\nclass jx {\n  constructor(e, r, n) {\n    this.api = e, this.crypto = r, this.transactions = n;\n  }\n  async get(e) {\n    if (!e)\n      throw new Error(\"No Silo URI specified\");\n    const r = await this.parseUri(e), n = await this.transactions.search(\"Silo-Name\", r.getAccessKey());\n    if (n.length == 0)\n      throw new Error(`No data could be found for the Silo URI: ${e}`);\n    const i = await this.transactions.get(n[0]);\n    if (!i)\n      throw new Error(`No data could be found for the Silo URI: ${e}`);\n    const o = i.get(\"data\", { decode: !0, string: !1 });\n    return this.crypto.decrypt(o, r.getEncryptionKey());\n  }\n  async readTransactionData(e, r) {\n    if (!r)\n      throw new Error(\"No Silo URI specified\");\n    const n = await this.parseUri(r), i = e.get(\"data\", { decode: !0, string: !1 });\n    return this.crypto.decrypt(i, n.getEncryptionKey());\n  }\n  async parseUri(e) {\n    const r = e.match(/^([a-z0-9-_]+)\\.([0-9]+)/i);\n    if (!r)\n      throw new Error(\"Invalid Silo name, must be a name in the format of [a-z0-9]+.[0-9]+, e.g. 'bubble.7'\");\n    const n = r[1], i = Math.pow(2, parseInt(r[2])), o = await this.hash(bf.stringToBuffer(n), i), a = bf.bufferTob64(o.slice(0, 15)), s = await this.hash(o.slice(16, 31), 1);\n    return new md(e, a, s);\n  }\n  async hash(e, r) {\n    let n = await this.crypto.hash(e);\n    for (let i = 0; i < r - 1; i++)\n      n = await this.crypto.hash(n);\n    return n;\n  }\n}\nni.default = jx;\nclass md {\n  constructor(e, r, n) {\n    this.uri = e, this.accessKey = r, this.encryptionKey = n;\n  }\n  getUri() {\n    return this.uri;\n  }\n  getAccessKey() {\n    return this.accessKey;\n  }\n  getEncryptionKey() {\n    return this.encryptionKey;\n  }\n}\nni.SiloResource = md;\nvar Hc = {}, Ux = ue && ue.__createBinding || (Object.create ? function(t, e, r, n) {\n  n === void 0 && (n = r);\n  var i = Object.getOwnPropertyDescriptor(e, r);\n  (!i || (\"get\" in i ? !e.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {\n    return e[r];\n  } }), Object.defineProperty(t, n, i);\n} : function(t, e, r, n) {\n  n === void 0 && (n = r), t[n] = e[r];\n}), Vx = ue && ue.__setModuleDefault || (Object.create ? function(t, e) {\n  Object.defineProperty(t, \"default\", { enumerable: !0, value: e });\n} : function(t, e) {\n  t.default = e;\n}), $x = ue && ue.__importStar || function(t) {\n  if (t && t.__esModule)\n    return t;\n  var e = {};\n  if (t != null)\n    for (var r in t)\n      r !== \"default\" && Object.prototype.hasOwnProperty.call(t, r) && Ux(e, t, r);\n  return Vx(e, t), e;\n};\nObject.defineProperty(Hc, \"__esModule\", { value: !0 });\nconst _f = Er, Hx = $x($e);\nclass Wx {\n  constructor(e) {\n    this.api = e;\n  }\n  async getTransactionOffset(e) {\n    const r = await this.api.get(`tx/${e}/offset`);\n    if (r.status === 200)\n      return r.data;\n    throw new Error(`Unable to get transaction offset: ${(0, _f.getError)(r)}`);\n  }\n  async getChunk(e) {\n    const r = await this.api.get(`chunk/${e}`);\n    if (r.status === 200)\n      return r.data;\n    throw new Error(`Unable to get chunk: ${(0, _f.getError)(r)}`);\n  }\n  async getChunkData(e) {\n    const r = await this.getChunk(e);\n    return Hx.b64UrlToBuffer(r.chunk);\n  }\n  firstChunkOffset(e) {\n    return parseInt(e.offset) - parseInt(e.size) + 1;\n  }\n  async downloadChunkedData(e) {\n    const r = await this.getTransactionOffset(e), n = parseInt(r.size), o = parseInt(r.offset) - n + 1, a = new Uint8Array(n);\n    let s = 0;\n    for (; s < n; ) {\n      this.api.config.logging && console.log(`[chunk] ${s}/${n}`);\n      let l;\n      try {\n        l = await this.getChunkData(o + s);\n      } catch {\n        console.error(`[chunk] Failed to fetch chunk at offset ${o + s}`), console.error(\"[chunk] This could indicate that the chunk wasn't uploaded or hasn't yet seeded properly to a particular gateway/node\");\n      }\n      if (l)\n        a.set(l, s), s += l.length;\n      else\n        throw new Error(`Couldn't complete data download at ${s}/${n}`);\n    }\n    return a;\n  }\n}\nHc.default = Wx;\nvar Wc = {}, zx = ue && ue.__importDefault || function(t) {\n  return t && t.__esModule ? t : { default: t };\n};\nObject.defineProperty(Wc, \"__esModule\", { value: !0 });\nconst qx = zx(Er);\nclass qo {\n  constructor(e, r) {\n    this.api = e, this.network = r;\n  }\n  /**\n   * Gets a block by its \"indep_hash\"\n   */\n  async get(e) {\n    const r = await this.api.get(`${qo.ENDPOINT}${e}`);\n    if (r.status === 200)\n      return r.data;\n    throw r.status === 404 ? new qx.default(\n      \"BLOCK_NOT_FOUND\"\n      /* ArweaveErrorType.BLOCK_NOT_FOUND */\n    ) : new Error(`Error while loading block data: ${r}`);\n  }\n  /**\n   * Gets current block data (ie. block with indep_hash = Network.getInfo().current)\n   */\n  async getCurrent() {\n    const { current: e } = await this.network.getInfo();\n    return await this.get(e);\n  }\n}\nWc.default = qo;\nqo.ENDPOINT = \"block/hash/\";\nvar Af;\nfunction zc() {\n  if (Af)\n    return fi;\n  Af = 1;\n  var t = ue && ue.__createBinding || (Object.create ? function(T, A, w, O) {\n    O === void 0 && (O = w);\n    var R = Object.getOwnPropertyDescriptor(A, w);\n    (!R || (\"get\" in R ? !A.__esModule : R.writable || R.configurable)) && (R = { enumerable: !0, get: function() {\n      return A[w];\n    } }), Object.defineProperty(T, O, R);\n  } : function(T, A, w, O) {\n    O === void 0 && (O = w), T[O] = A[w];\n  }), e = ue && ue.__setModuleDefault || (Object.create ? function(T, A) {\n    Object.defineProperty(T, \"default\", { enumerable: !0, value: A });\n  } : function(T, A) {\n    T.default = A;\n  }), r = ue && ue.__importStar || function(T) {\n    if (T && T.__esModule)\n      return T;\n    var A = {};\n    if (T != null)\n      for (var w in T)\n        w !== \"default\" && Object.prototype.hasOwnProperty.call(T, w) && t(A, T, w);\n    return e(A, T), A;\n  }, n = ue && ue.__importDefault || function(T) {\n    return T && T.__esModule ? T : { default: T };\n  };\n  Object.defineProperty(fi, \"__esModule\", { value: !0 });\n  const i = n(Ec), o = n(Sc), a = n(Pc), s = n(Uc), l = n(kx()), u = n($c), c = n(Vc()), f = r($e), h = n(ni), p = n(Hc), g = n(Wc);\n  class _ {\n    constructor(A) {\n      this.api = new o.default(A), this.wallets = new u.default(this.api, _.crypto), this.chunks = new p.default(this.api), this.transactions = new l.default(this.api, _.crypto, this.chunks), this.silo = new h.default(this.api, this.crypto, this.transactions), this.network = new s.default(this.api), this.blocks = new g.default(this.api, this.network), this.ar = new i.default();\n    }\n    /** @deprecated */\n    get crypto() {\n      return _.crypto;\n    }\n    /** @deprecated */\n    get utils() {\n      return _.utils;\n    }\n    getConfig() {\n      return {\n        api: this.api.getConfig(),\n        crypto: null\n      };\n    }\n    async createTransaction(A, w) {\n      const O = {};\n      if (Object.assign(O, A), !A.data && !(A.target && A.quantity))\n        throw new Error(\"A new Arweave transaction must have a 'data' value, or 'target' and 'quantity' values.\");\n      if (A.owner == null && w && w !== \"use_wallet\" && (O.owner = w.n), A.last_tx == null && (O.last_tx = await this.transactions.getTransactionAnchor()), typeof A.data == \"string\" && (A.data = f.stringToBuffer(A.data)), A.data instanceof ArrayBuffer && (A.data = new Uint8Array(A.data)), A.data && !(A.data instanceof Uint8Array))\n        throw new Error(\"Expected data to be a string, Uint8Array or ArrayBuffer\");\n      if (A.reward == null) {\n        const $ = A.data ? A.data.byteLength : 0;\n        O.reward = await this.transactions.getPrice($, O.target);\n      }\n      O.data_root = \"\", O.data_size = A.data ? A.data.byteLength.toString() : \"0\", O.data = A.data || new Uint8Array(0);\n      const R = new c.default(O);\n      return await R.getSignatureData(), R;\n    }\n    async createSiloTransaction(A, w, O) {\n      const R = {};\n      if (Object.assign(R, A), !A.data)\n        throw new Error(\"Silo transactions must have a 'data' value\");\n      if (!O)\n        throw new Error(\"No Silo URI specified.\");\n      if (A.target || A.quantity)\n        throw new Error(\"Silo transactions can only be used for storing data, sending AR to other wallets isn't supported.\");\n      if (A.owner == null) {\n        if (!w || !w.n)\n          throw new Error(\"A new Arweave transaction must either have an 'owner' attribute, or you must provide the jwk parameter.\");\n        R.owner = w.n;\n      }\n      A.last_tx == null && (R.last_tx = await this.transactions.getTransactionAnchor());\n      const $ = await this.silo.parseUri(O);\n      if (typeof A.data == \"string\") {\n        const W = await this.crypto.encrypt(f.stringToBuffer(A.data), $.getEncryptionKey());\n        R.reward = await this.transactions.getPrice(W.byteLength), R.data = f.bufferTob64Url(W);\n      }\n      if (A.data instanceof Uint8Array) {\n        const W = await this.crypto.encrypt(A.data, $.getEncryptionKey());\n        R.reward = await this.transactions.getPrice(W.byteLength), R.data = f.bufferTob64Url(W);\n      }\n      const U = new c.default(R);\n      return U.addTag(\"Silo-Name\", $.getAccessKey()), U.addTag(\"Silo-Version\", \"0.1.0\"), U;\n    }\n    arql(A) {\n      return this.api.post(\"/arql\", A).then((w) => w.data || []);\n    }\n  }\n  return fi.default = _, _.crypto = new a.default(), _.utils = f, fi;\n}\nvar Kx = zc();\nconst Gx = /* @__PURE__ */ iy(Kx);\nfunction vd() {\n  const [t, e] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0), { state: r } = _t();\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    (async () => {\n      var o;\n      if (!r.activeAddress)\n        return;\n      const n = new Gx(\n        ((o = r == null ? void 0 : r.config) == null ? void 0 : o.gatewayConfig) || {\n          host: \"arweave.net\",\n          port: 443,\n          protocol: \"https\"\n        }\n      ), i = n.ar.winstonToAr(\n        await n.wallets.getBalance(r.activeAddress)\n      );\n      e(Number(i));\n    })();\n  }, [r == null ? void 0 : r.activeAddress]), t;\n}\nfunction Yx(t) {\n  var e = /* @__PURE__ */ Object.create(null);\n  return function(r) {\n    return e[r] === void 0 && (e[r] = t(r)), e[r];\n  };\n}\nvar Zx = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|enterKeyHint|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/, Ks = /* @__PURE__ */ Yx(\n  function(t) {\n    return Zx.test(t) || t.charCodeAt(0) === 111 && t.charCodeAt(1) === 110 && t.charCodeAt(2) < 91;\n  }\n  /* Z+1 */\n), Xx = function() {\n  const e = Array.prototype.slice.call(arguments).filter(Boolean), r = {}, n = [];\n  e.forEach((o) => {\n    (o ? o.split(\" \") : []).forEach((s) => {\n      if (s.startsWith(\"atm_\")) {\n        const [, l] = s.split(\"_\");\n        r[l] = s;\n      } else\n        n.push(s);\n    });\n  });\n  const i = [];\n  for (const o in r)\n    Object.prototype.hasOwnProperty.call(r, o) && i.push(r[o]);\n  return i.push(...n), i.join(\" \");\n}, Tf = Xx, Jx = (t) => t.toUpperCase() === t, Qx = (t) => (e) => t.indexOf(e) === -1, gd = (t, e) => {\n  const r = {};\n  return Object.keys(t).filter(Qx(e)).forEach((n) => {\n    r[n] = t[n];\n  }), r;\n};\nfunction ew(t, e, r) {\n  const n = gd(e, r);\n  if (!t) {\n    const i = typeof Ks == \"function\" ? { default: Ks } : Ks;\n    Object.keys(n).forEach((o) => {\n      i.default(o) || delete n[o];\n    });\n  }\n  return n;\n}\nvar tw = (t, e) => {\n  if (true) {\n    if (typeof t == \"string\" || typeof t == \"number\" && isFinite(t))\n      return;\n    const r = typeof t == \"object\" ? JSON.stringify(t) : String(t);\n    console.warn(\n      `An interpolation evaluated to '${r}' in the component '${e}', which is probably a mistake. You should explicitly cast or transform the value to a string.`\n    );\n  }\n}, rw = 0;\nfunction Ef(t) {\n  var e;\n  let r = `mocked-styled-${rw++}`;\n  return (e = t == null ? void 0 : t.__linaria) != null && e.className && (r += ` ${t.__linaria.className}`), (n) => {\n    if ( true && Array.isArray(n))\n      throw new Error(\n        'Using the \"styled\" tag in runtime is not supported. Make sure you have set up the Babel plugin correctly. See https://github.com/callstack/linaria#setup'\n      );\n    const i = (a, s) => {\n      const { as: l = t, class: u = r } = a, c = n.propsAsIs === void 0 ? !(typeof l == \"string\" && l.indexOf(\"-\") === -1 && !Jx(l[0])) : n.propsAsIs, f = ew(c, a, [\n        \"as\",\n        \"class\"\n      ]);\n      f.ref = s, f.className = n.atomic ? Tf(n.class, f.className || u) : Tf(f.className || u, n.class);\n      const { vars: h } = n;\n      if (h) {\n        const p = {};\n        for (const T in h) {\n          const A = h[T], w = A[0], O = A[1] || \"\", R = typeof w == \"function\" ? w(a) : w;\n          tw(R, n.name), p[`--${T}`] = `${R}${O}`;\n        }\n        const g = f.style || {}, _ = Object.keys(g);\n        _.length > 0 && _.forEach((T) => {\n          p[T] = g[T];\n        }), f.style = p;\n      }\n      return t.__linaria && t !== l ? (f.as = l, react__WEBPACK_IMPORTED_MODULE_0__.createElement(t, f)) : react__WEBPACK_IMPORTED_MODULE_0__.createElement(l, f);\n    }, o = react__WEBPACK_IMPORTED_MODULE_0__.forwardRef ? react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(i) : (a) => {\n      const s = gd(a, [\"innerRef\"]);\n      return i(s, a.innerRef);\n    };\n    return o.displayName = n.name, o.__linaria = {\n      className: n.class || r,\n      extends: t\n    }, o;\n  };\n}\nvar Me =  true ? new Proxy(Ef, {\n  get(t, e) {\n    return t(e);\n  }\n}) : 0;\nfunction qc() {\n  var r;\n  const { state: t } = _t();\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    var i;\n    const n = (i = t == null ? void 0 : t.config) == null ? void 0 : i.gatewayConfig;\n    return n ? `${n.protocol}://${n.host}:${n.port}` : \"https://arweave.net\";\n  }, [(r = t == null ? void 0 : t.config) == null ? void 0 : r.gatewayConfig]);\n}\nfunction xd() {\n  const [t, e] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(), r = Uo(), n = qc();\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    (async () => {\n      if (!r)\n        return e(void 0);\n      try {\n        const o = await (await fetch(\n          `https://ans-stats.decent.land/profile/${r}`\n        )).json();\n        if (!(o != null && o.currentLabel))\n          return e(void 0);\n        e({\n          ...o,\n          currentLabel: o.currentLabel + \".ar\",\n          avatar: o.avatar ? `${n}/${o.avatar}` : void 0\n        });\n      } catch (i) {\n        console.error(\n          `[Arweave Wallet Kit] Failed to fetch ans profile\n${(i == null ? void 0 : i.message) || i}`\n        );\n      }\n    })();\n  }, [r, n]), t;\n}\nconst nw = () => (t) => t.theme.themeConfig.font.fontFamily, iw = () => (t) => t.theme.theme, ow = () => (t) => ({\n  default: 30,\n  minimal: 6,\n  none: 0\n})[t.theme.themeConfig.radius] + \"px\", sw = () => (t) => t.theme.displayTheme === \"light\" ? `0px 0px 2px rgba(${t.theme.displayTheme === \"light\" ? \"0, 0, 0\" : \"255, 255, 255\"}, .15), 0px 4px 7px rgba(${t.theme.displayTheme === \"light\" ? \"0, 0, 0\" : \"255, 255, 255\"}, .1)` : \"none\", br = ft(/* @__PURE__ */ Me(\"button\")({\n  name: \"Button\",\n  class: \"b1cb9caz\",\n  propsAsIs: !1,\n  vars: {\n    \"b1cb9caz-0\": [nw()],\n    \"b1cb9caz-1\": [iw()],\n    \"b1cb9caz-2\": [ow()],\n    \"b1cb9caz-3\": [sw()]\n  }\n}));\nfunction c2({\n  accent: t,\n  showBalance: e = !0,\n  showProfilePicture: r = !0,\n  onClick: n,\n  useAns: i = !0,\n  profileModal: o = !0,\n  ...a\n}) {\n  const {\n    connected: s,\n    connect: l,\n    disconnect: u\n  } = Tc(), c = Uo(), f = vd(), h = xd(), p = T1();\n  return /* @__PURE__ */ be(lw, {\n    accent: t,\n    onClick: async (g) => {\n      if (s ? o ? p.setOpen(!0) : await u() : await l(), n)\n        return n(g);\n    },\n    ...a,\n    children: s && /* @__PURE__ */ Ue(zn, {\n      children: [e && /* @__PURE__ */ be(yw, {\n        children: f.toLocaleString(void 0, {\n          maximumFractionDigits: 2\n        }) + \" AR\"\n      }), /* @__PURE__ */ Ue(pw, {\n        showBalance: e,\n        children: [r && /* @__PURE__ */ be(zn, {\n          children: (h == null ? void 0 : h.avatar) && i && /* @__PURE__ */ be(xw, {\n            src: h == null ? void 0 : h.avatar,\n            draggable: !1\n          }) || /* @__PURE__ */ be(Aw, {\n            children: /* @__PURE__ */ be(bw, {})\n          })\n        }), i && (h == null ? void 0 : h.currentLabel) || ih(c || \"\", 5), /* @__PURE__ */ be(vw, {})]\n      })]\n    }) || /* @__PURE__ */ be(fw, {\n      children: \"Connect Wallet\"\n    })\n  });\n}\nconst aw = () => br, cw = () => (t) => ({\n  default: 18,\n  minimal: 10,\n  none: 0\n})[t.theme.themeConfig.radius] + \"px\", uw = () => (t) => t.accent || `rgb(${t.theme.theme})`, lw = ft(/* @__PURE__ */ Me(aw())({\n  name: \"Wrapper\",\n  class: \"w14emrir\",\n  propsAsIs: !0,\n  vars: {\n    \"w14emrir-0\": [cw()],\n    \"w14emrir-1\": [uw()]\n  }\n})), fw = /* @__PURE__ */ Me(\"span\")({\n  name: \"ConnectText\",\n  class: \"czh4f0e\",\n  propsAsIs: !1\n}), hw = () => (t) => t.showBalance ? t.theme.background : \"transparent\", dw = () => (t) => ({\n  default: 18,\n  minimal: 10,\n  none: 0\n})[t.theme.themeConfig.radius] - 3 + \"px\", pw = ft(/* @__PURE__ */ Me(\"div\")({\n  name: \"ProfileSection\",\n  class: \"pwkn5es\",\n  propsAsIs: !1,\n  vars: {\n    \"pwkn5es-0\": [hw()],\n    \"pwkn5es-1\": [dw()]\n  }\n})), yw = /* @__PURE__ */ Me(\"span\")({\n  name: \"Balance\",\n  class: \"bdt02oh\",\n  propsAsIs: !1\n}), mw = () => Ig, vw = /* @__PURE__ */ Me(mw())({\n  name: \"ExpandIcon\",\n  class: \"e3hlv71\",\n  propsAsIs: !0\n}), gw = () => (t) => ({\n  default: \"100%\",\n  minimal: \"5px\",\n  none: \"0px\"\n})[t.theme.themeConfig.radius], xw = ft(/* @__PURE__ */ Me(\"img\")({\n  name: \"Avatar\",\n  class: \"a1jsmwxp\",\n  propsAsIs: !1,\n  vars: {\n    \"a1jsmwxp-0\": [gw()]\n  }\n})), ww = () => Bh, bw = /* @__PURE__ */ Me(ww())({\n  name: \"AvatarIcon\",\n  class: \"as6ir6f\",\n  propsAsIs: !0\n}), _w = () => (t) => ({\n  default: \"100%\",\n  minimal: \"5px\",\n  none: \"0px\"\n})[t.theme.themeConfig.radius], Aw = ft(/* @__PURE__ */ Me(\"span\")({\n  name: \"AvatarPlaceholder\",\n  class: \"av7js2i\",\n  propsAsIs: !1,\n  vars: {\n    \"av7js2i-0\": [_w()]\n  }\n})), Tw = \"1.0.4\";\nfunction Ew(t = 720) {\n  const [e, r] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(!1), n = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => typeof window > \"u\" ? null : window.matchMedia(`(max-width: ${t}px)`), [t]);\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (!n)\n      return;\n    const i = (o) => r(o.matches);\n    return n.addEventListener(\"change\", i), r(n.matches), () => n.removeEventListener(\"change\", i);\n  }, [n]), e;\n}\nconst Kc = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n  transformPagePoint: (t) => t,\n  isStatic: !1,\n  reducedMotion: \"never\"\n}), Ko = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({});\nfunction Sw() {\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(Ko).visualElement;\n}\nconst ii = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(null), Go = typeof document < \"u\", go = Go ? react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect : react__WEBPACK_IMPORTED_MODULE_0__.useEffect, wd = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({ strict: !1 });\nfunction Pw(t, e, r, n) {\n  const i = Sw(), o = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(wd), a = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(ii), s = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(Kc).reducedMotion, l = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n  n = n || o.renderer, !l.current && n && (l.current = n(t, {\n    visualState: e,\n    parent: i,\n    props: r,\n    presenceId: a ? a.id : void 0,\n    blockInitialAnimation: a ? a.initial === !1 : !1,\n    reducedMotionConfig: s\n  }));\n  const u = l.current;\n  return go(() => {\n    u && u.render();\n  }), go(() => {\n    u && u.animationState && u.animationState.animateChanges();\n  }), u;\n}\nfunction rn(t) {\n  return typeof t == \"object\" && Object.prototype.hasOwnProperty.call(t, \"current\");\n}\nfunction Cw(t, e, r) {\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (n) => {\n      n && t.mount && t.mount(n), e && (n ? e.mount(n) : e.unmount()), r && (typeof r == \"function\" ? r(n) : rn(r) && (r.current = n));\n    },\n    /**\n     * Only pass a new ref callback to React if we've received a visual element\n     * factory. Otherwise we'll be mounting/remounting every time externalRef\n     * or other dependencies change.\n     */\n    [e]\n  );\n}\nfunction qn(t) {\n  return typeof t == \"string\" || Array.isArray(t);\n}\nfunction Yo(t) {\n  return typeof t == \"object\" && typeof t.start == \"function\";\n}\nconst Ow = [\n  \"initial\",\n  \"animate\",\n  \"exit\",\n  \"whileHover\",\n  \"whileDrag\",\n  \"whileTap\",\n  \"whileFocus\",\n  \"whileInView\"\n];\nfunction Zo(t) {\n  return Yo(t.animate) || Ow.some((e) => qn(t[e]));\n}\nfunction bd(t) {\n  return Boolean(Zo(t) || t.variants);\n}\nfunction Mw(t, e) {\n  if (Zo(t)) {\n    const { initial: r, animate: n } = t;\n    return {\n      initial: r === !1 || qn(r) ? r : void 0,\n      animate: qn(n) ? n : void 0\n    };\n  }\n  return t.inherit !== !1 ? e : {};\n}\nfunction kw(t) {\n  const { initial: e, animate: r } = Mw(t, (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(Ko));\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => ({ initial: e, animate: r }), [Sf(e), Sf(r)]);\n}\nfunction Sf(t) {\n  return Array.isArray(t) ? t.join(\" \") : t;\n}\nconst or = (t) => ({\n  isEnabled: (e) => t.some((r) => !!e[r])\n}), Kn = {\n  measureLayout: or([\"layout\", \"layoutId\", \"drag\"]),\n  animation: or([\n    \"animate\",\n    \"exit\",\n    \"variants\",\n    \"whileHover\",\n    \"whileTap\",\n    \"whileFocus\",\n    \"whileDrag\",\n    \"whileInView\"\n  ]),\n  exit: or([\"exit\"]),\n  drag: or([\"drag\", \"dragControls\"]),\n  focus: or([\"whileFocus\"]),\n  hover: or([\"whileHover\", \"onHoverStart\", \"onHoverEnd\"]),\n  tap: or([\"whileTap\", \"onTap\", \"onTapStart\", \"onTapCancel\"]),\n  pan: or([\n    \"onPan\",\n    \"onPanStart\",\n    \"onPanSessionStart\",\n    \"onPanEnd\"\n  ]),\n  inView: or([\n    \"whileInView\",\n    \"onViewportEnter\",\n    \"onViewportLeave\"\n  ])\n};\nfunction Rw(t) {\n  for (const e in t)\n    e === \"projectionNodeConstructor\" ? Kn.projectionNodeConstructor = t[e] : Kn[e].Component = t[e];\n}\nfunction Xo(t) {\n  const e = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  return e.current === null && (e.current = t()), e.current;\n}\nconst Nn = {\n  /**\n   * Global flag as to whether the tree has animated since the last time\n   * we resized the window\n   */\n  hasAnimatedSinceResize: !0,\n  /**\n   * We set this to true once, on the first update. Any nodes added to the tree beyond that\n   * update will be given a `data-projection-id` attribute.\n   */\n  hasEverUpdated: !1\n};\nlet Bw = 1;\nfunction Iw() {\n  return Xo(() => {\n    if (Nn.hasEverUpdated)\n      return Bw++;\n  });\n}\nconst Gc = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({});\nclass Dw extends react__WEBPACK_IMPORTED_MODULE_0__.Component {\n  /**\n   * Update visual element props as soon as we know this update is going to be commited.\n   */\n  getSnapshotBeforeUpdate() {\n    const { visualElement: e, props: r } = this.props;\n    return e && e.setProps(r), null;\n  }\n  componentDidUpdate() {\n  }\n  render() {\n    return this.props.children;\n  }\n}\nconst _d = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({}), Nw = Symbol.for(\"motionComponentSymbol\");\nfunction Fw({ preloadedFeatures: t, createVisualElement: e, projectionNodeConstructor: r, useRender: n, useVisualState: i, Component: o }) {\n  t && Rw(t);\n  function a(l, u) {\n    const c = {\n      ...(0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(Kc),\n      ...l,\n      layoutId: Lw(l)\n    }, { isStatic: f } = c;\n    let h = null;\n    const p = kw(l), g = f ? void 0 : Iw(), _ = i(l, f);\n    if (!f && Go) {\n      p.visualElement = Pw(o, _, c, e);\n      const T = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(wd).strict, A = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(_d);\n      p.visualElement && (h = p.visualElement.loadFeatures(\n        // Note: Pass the full new combined props to correctly re-render dynamic feature components.\n        c,\n        T,\n        t,\n        g,\n        r || Kn.projectionNodeConstructor,\n        A\n      ));\n    }\n    return react__WEBPACK_IMPORTED_MODULE_0__.createElement(\n      Dw,\n      { visualElement: p.visualElement, props: c },\n      h,\n      react__WEBPACK_IMPORTED_MODULE_0__.createElement(Ko.Provider, { value: p }, n(o, l, g, Cw(_, p.visualElement, u), _, f, p.visualElement))\n    );\n  }\n  const s = (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(a);\n  return s[Nw] = o, s;\n}\nfunction Lw({ layoutId: t }) {\n  const e = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(Gc).id;\n  return e && t !== void 0 ? e + \"-\" + t : t;\n}\nfunction jw(t) {\n  function e(n, i = {}) {\n    return Fw(t(n, i));\n  }\n  if (typeof Proxy > \"u\")\n    return e;\n  const r = /* @__PURE__ */ new Map();\n  return new Proxy(e, {\n    /**\n     * Called when `motion` is referenced with a prop: `motion.div`, `motion.input` etc.\n     * The prop name is passed through as `key` and we can use that to generate a `motion`\n     * DOM component with that name.\n     */\n    get: (n, i) => (r.has(i) || r.set(i, e(i)), r.get(i))\n  });\n}\nconst Uw = [\n  \"animate\",\n  \"circle\",\n  \"defs\",\n  \"desc\",\n  \"ellipse\",\n  \"g\",\n  \"image\",\n  \"line\",\n  \"filter\",\n  \"marker\",\n  \"mask\",\n  \"metadata\",\n  \"path\",\n  \"pattern\",\n  \"polygon\",\n  \"polyline\",\n  \"rect\",\n  \"stop\",\n  \"switch\",\n  \"symbol\",\n  \"svg\",\n  \"text\",\n  \"tspan\",\n  \"use\",\n  \"view\"\n];\nfunction Yc(t) {\n  return (\n    /**\n     * If it's not a string, it's a custom React component. Currently we only support\n     * HTML custom React components.\n     */\n    typeof t != \"string\" || /**\n     * If it contains a dash, the element is a custom HTML webcomponent.\n     */\n    t.includes(\"-\") ? !1 : (\n      /**\n       * If it's in our list of lowercase SVG tags, it's an SVG component\n       */\n      !!(Uw.indexOf(t) > -1 || /**\n       * If it contains a capital letter, it's an SVG component\n       */\n      /[A-Z]/.test(t))\n    )\n  );\n}\nconst xo = {};\nfunction Vw(t) {\n  Object.assign(xo, t);\n}\nconst wo = [\n  \"transformPerspective\",\n  \"x\",\n  \"y\",\n  \"z\",\n  \"translateX\",\n  \"translateY\",\n  \"translateZ\",\n  \"scale\",\n  \"scaleX\",\n  \"scaleY\",\n  \"rotate\",\n  \"rotateX\",\n  \"rotateY\",\n  \"rotateZ\",\n  \"skew\",\n  \"skewX\",\n  \"skewY\"\n], Hr = new Set(wo);\nfunction Ad(t, { layout: e, layoutId: r }) {\n  return Hr.has(t) || t.startsWith(\"origin\") || (e || r !== void 0) && (!!xo[t] || t === \"opacity\");\n}\nconst Ht = (t) => !!(t != null && t.getVelocity), $w = {\n  x: \"translateX\",\n  y: \"translateY\",\n  z: \"translateZ\",\n  transformPerspective: \"perspective\"\n}, Hw = (t, e) => wo.indexOf(t) - wo.indexOf(e);\nfunction Ww({ transform: t, transformKeys: e }, { enableHardwareAcceleration: r = !0, allowTransformNone: n = !0 }, i, o) {\n  let a = \"\";\n  e.sort(Hw);\n  for (const s of e)\n    a += `${$w[s] || s}(${t[s]}) `;\n  return r && !t.z && (a += \"translateZ(0)\"), a = a.trim(), o ? a = o(t, i ? \"\" : a) : n && i && (a = \"none\"), a;\n}\nfunction Td(t) {\n  return t.startsWith(\"--\");\n}\nconst zw = (t, e) => e && typeof t == \"number\" ? e.transform(t) : t, mn = (t, e, r) => Math.min(Math.max(r, t), e), Wr = {\n  test: (t) => typeof t == \"number\",\n  parse: parseFloat,\n  transform: (t) => t\n}, Fn = {\n  ...Wr,\n  transform: (t) => mn(0, 1, t)\n}, pi = {\n  ...Wr,\n  default: 1\n}, Ln = (t) => Math.round(t * 1e5) / 1e5, Gn = /(-)?([\\d]*\\.?[\\d])+/g, Pa = /(#[0-9a-f]{6}|#[0-9a-f]{3}|#(?:[0-9a-f]{2}){2,4}|(rgb|hsl)a?\\((-?[\\d\\.]+%?[,\\s]+){2}(-?[\\d\\.]+%?)\\s*[\\,\\/]?\\s*[\\d\\.]*%?\\))/gi, qw = /^(#[0-9a-f]{3}|#(?:[0-9a-f]{2}){2,4}|(rgb|hsl)a?\\((-?[\\d\\.]+%?[,\\s]+){2}(-?[\\d\\.]+%?)\\s*[\\,\\/]?\\s*[\\d\\.]*%?\\))$/i;\nfunction oi(t) {\n  return typeof t == \"string\";\n}\nconst si = (t) => ({\n  test: (e) => oi(e) && e.endsWith(t) && e.split(\" \").length === 1,\n  parse: parseFloat,\n  transform: (e) => `${e}${t}`\n}), mr = si(\"deg\"), rr = si(\"%\"), Ce = si(\"px\"), Kw = si(\"vh\"), Gw = si(\"vw\"), Pf = {\n  ...rr,\n  parse: (t) => rr.parse(t) / 100,\n  transform: (t) => rr.transform(t * 100)\n}, Cf = {\n  ...Wr,\n  transform: Math.round\n}, Ed = {\n  // Border props\n  borderWidth: Ce,\n  borderTopWidth: Ce,\n  borderRightWidth: Ce,\n  borderBottomWidth: Ce,\n  borderLeftWidth: Ce,\n  borderRadius: Ce,\n  radius: Ce,\n  borderTopLeftRadius: Ce,\n  borderTopRightRadius: Ce,\n  borderBottomRightRadius: Ce,\n  borderBottomLeftRadius: Ce,\n  // Positioning props\n  width: Ce,\n  maxWidth: Ce,\n  height: Ce,\n  maxHeight: Ce,\n  size: Ce,\n  top: Ce,\n  right: Ce,\n  bottom: Ce,\n  left: Ce,\n  // Spacing props\n  padding: Ce,\n  paddingTop: Ce,\n  paddingRight: Ce,\n  paddingBottom: Ce,\n  paddingLeft: Ce,\n  margin: Ce,\n  marginTop: Ce,\n  marginRight: Ce,\n  marginBottom: Ce,\n  marginLeft: Ce,\n  // Transform props\n  rotate: mr,\n  rotateX: mr,\n  rotateY: mr,\n  rotateZ: mr,\n  scale: pi,\n  scaleX: pi,\n  scaleY: pi,\n  scaleZ: pi,\n  skew: mr,\n  skewX: mr,\n  skewY: mr,\n  distance: Ce,\n  translateX: Ce,\n  translateY: Ce,\n  translateZ: Ce,\n  x: Ce,\n  y: Ce,\n  z: Ce,\n  perspective: Ce,\n  transformPerspective: Ce,\n  opacity: Fn,\n  originX: Pf,\n  originY: Pf,\n  originZ: Ce,\n  // Misc\n  zIndex: Cf,\n  // SVG\n  fillOpacity: Fn,\n  strokeOpacity: Fn,\n  numOctaves: Cf\n};\nfunction Zc(t, e, r, n) {\n  const { style: i, vars: o, transform: a, transformKeys: s, transformOrigin: l } = t;\n  s.length = 0;\n  let u = !1, c = !1, f = !0;\n  for (const h in e) {\n    const p = e[h];\n    if (Td(h)) {\n      o[h] = p;\n      continue;\n    }\n    const g = Ed[h], _ = zw(p, g);\n    if (Hr.has(h)) {\n      if (u = !0, a[h] = _, s.push(h), !f)\n        continue;\n      p !== (g.default || 0) && (f = !1);\n    } else\n      h.startsWith(\"origin\") ? (c = !0, l[h] = _) : i[h] = _;\n  }\n  if (e.transform || (u || n ? i.transform = Ww(t, r, f, n) : i.transform && (i.transform = \"none\")), c) {\n    const { originX: h = \"50%\", originY: p = \"50%\", originZ: g = 0 } = l;\n    i.transformOrigin = `${h} ${p} ${g}`;\n  }\n}\nconst Xc = () => ({\n  style: {},\n  transform: {},\n  transformKeys: [],\n  transformOrigin: {},\n  vars: {}\n});\nfunction Sd(t, e, r) {\n  for (const n in e)\n    !Ht(e[n]) && !Ad(n, r) && (t[n] = e[n]);\n}\nfunction Yw({ transformTemplate: t }, e, r) {\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    const n = Xc();\n    return Zc(n, e, { enableHardwareAcceleration: !r }, t), Object.assign({}, n.vars, n.style);\n  }, [e]);\n}\nfunction Zw(t, e, r) {\n  const n = t.style || {}, i = {};\n  return Sd(i, n, t), Object.assign(i, Yw(t, e, r)), t.transformValues ? t.transformValues(i) : i;\n}\nfunction Xw(t, e, r) {\n  const n = {}, i = Zw(t, e, r);\n  return t.drag && t.dragListener !== !1 && (n.draggable = !1, i.userSelect = i.WebkitUserSelect = i.WebkitTouchCallout = \"none\", i.touchAction = t.drag === !0 ? \"none\" : `pan-${t.drag === \"x\" ? \"y\" : \"x\"}`), n.style = i, n;\n}\nconst Jw = [\n  \"animate\",\n  \"exit\",\n  \"variants\",\n  \"whileHover\",\n  \"whileTap\",\n  \"whileFocus\",\n  \"whileDrag\",\n  \"whileInView\"\n], Qw = [\"whileTap\", \"onTap\", \"onTapStart\", \"onTapCancel\"], eb = [\"onPan\", \"onPanStart\", \"onPanSessionStart\", \"onPanEnd\"], tb = [\n  \"whileInView\",\n  \"onViewportEnter\",\n  \"onViewportLeave\",\n  \"viewport\"\n], rb = /* @__PURE__ */ new Set([\n  \"initial\",\n  \"style\",\n  \"values\",\n  \"variants\",\n  \"transition\",\n  \"transformTemplate\",\n  \"transformValues\",\n  \"custom\",\n  \"inherit\",\n  \"layout\",\n  \"layoutId\",\n  \"layoutDependency\",\n  \"onLayoutAnimationStart\",\n  \"onLayoutAnimationComplete\",\n  \"onLayoutMeasure\",\n  \"onBeforeLayoutMeasure\",\n  \"onAnimationStart\",\n  \"onAnimationComplete\",\n  \"onUpdate\",\n  \"onDragStart\",\n  \"onDrag\",\n  \"onDragEnd\",\n  \"onMeasureDragConstraints\",\n  \"onDirectionLock\",\n  \"onDragTransitionEnd\",\n  \"drag\",\n  \"dragControls\",\n  \"dragListener\",\n  \"dragConstraints\",\n  \"dragDirectionLock\",\n  \"dragSnapToOrigin\",\n  \"_dragX\",\n  \"_dragY\",\n  \"dragElastic\",\n  \"dragMomentum\",\n  \"dragPropagation\",\n  \"dragTransition\",\n  \"onHoverStart\",\n  \"onHoverEnd\",\n  \"layoutScroll\",\n  ...tb,\n  ...Qw,\n  ...Jw,\n  ...eb\n]);\nfunction bo(t) {\n  return rb.has(t);\n}\nlet Pd = (t) => !bo(t);\nfunction nb(t) {\n  t && (Pd = (e) => e.startsWith(\"on\") ? !bo(e) : t(e));\n}\ntry {\n  nb(require(\"@emotion/is-prop-valid\").default);\n} catch {\n}\nfunction ib(t, e, r) {\n  const n = {};\n  for (const i in t)\n    (Pd(i) || r === !0 && bo(i) || !e && !bo(i) || t.draggable && i.startsWith(\"onDrag\")) && (n[i] = t[i]);\n  return n;\n}\nfunction Of(t, e, r) {\n  return typeof t == \"string\" ? t : Ce.transform(e + r * t);\n}\nfunction ob(t, e, r) {\n  const n = Of(e, t.x, t.width), i = Of(r, t.y, t.height);\n  return `${n} ${i}`;\n}\nconst sb = {\n  offset: \"stroke-dashoffset\",\n  array: \"stroke-dasharray\"\n}, ab = {\n  offset: \"strokeDashoffset\",\n  array: \"strokeDasharray\"\n};\nfunction cb(t, e, r = 1, n = 0, i = !0) {\n  t.pathLength = 1;\n  const o = i ? sb : ab;\n  t[o.offset] = Ce.transform(-n);\n  const a = Ce.transform(e), s = Ce.transform(r);\n  t[o.array] = `${a} ${s}`;\n}\nfunction Jc(t, {\n  attrX: e,\n  attrY: r,\n  originX: n,\n  originY: i,\n  pathLength: o,\n  pathSpacing: a = 1,\n  pathOffset: s = 0,\n  // This is object creation, which we try to avoid per-frame.\n  ...l\n}, u, c, f) {\n  if (Zc(t, l, u, f), c) {\n    t.style.viewBox && (t.attrs.viewBox = t.style.viewBox);\n    return;\n  }\n  t.attrs = t.style, t.style = {};\n  const { attrs: h, style: p, dimensions: g } = t;\n  h.transform && (g && (p.transform = h.transform), delete h.transform), g && (n !== void 0 || i !== void 0 || p.transform) && (p.transformOrigin = ob(g, n !== void 0 ? n : 0.5, i !== void 0 ? i : 0.5)), e !== void 0 && (h.x = e), r !== void 0 && (h.y = r), o !== void 0 && cb(h, o, a, s, !1);\n}\nconst Cd = () => ({\n  ...Xc(),\n  attrs: {}\n}), Qc = (t) => typeof t == \"string\" && t.toLowerCase() === \"svg\";\nfunction ub(t, e, r, n) {\n  const i = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    const o = Cd();\n    return Jc(o, e, { enableHardwareAcceleration: !1 }, Qc(n), t.transformTemplate), {\n      ...o.attrs,\n      style: { ...o.style }\n    };\n  }, [e]);\n  if (t.style) {\n    const o = {};\n    Sd(o, t.style, t), i.style = { ...o, ...i.style };\n  }\n  return i;\n}\nfunction lb(t = !1) {\n  return (r, n, i, o, { latestValues: a }, s) => {\n    const u = (Yc(r) ? ub : Xw)(n, a, s, r), f = {\n      ...ib(n, typeof r == \"string\", t),\n      ...u,\n      ref: o\n    };\n    return i && (f[\"data-projection-id\"] = i), (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(r, f);\n  };\n}\nconst eu = (t) => t.replace(/([a-z])([A-Z])/g, \"$1-$2\").toLowerCase();\nfunction Od(t, { style: e, vars: r }, n, i) {\n  Object.assign(t.style, e, i && i.getProjectionStyles(n));\n  for (const o in r)\n    t.style.setProperty(o, r[o]);\n}\nconst Md = /* @__PURE__ */ new Set([\n  \"baseFrequency\",\n  \"diffuseConstant\",\n  \"kernelMatrix\",\n  \"kernelUnitLength\",\n  \"keySplines\",\n  \"keyTimes\",\n  \"limitingConeAngle\",\n  \"markerHeight\",\n  \"markerWidth\",\n  \"numOctaves\",\n  \"targetX\",\n  \"targetY\",\n  \"surfaceScale\",\n  \"specularConstant\",\n  \"specularExponent\",\n  \"stdDeviation\",\n  \"tableValues\",\n  \"viewBox\",\n  \"gradientTransform\",\n  \"pathLength\",\n  \"startOffset\",\n  \"textLength\",\n  \"lengthAdjust\"\n]);\nfunction kd(t, e, r, n) {\n  Od(t, e, void 0, n);\n  for (const i in e.attrs)\n    t.setAttribute(Md.has(i) ? i : eu(i), e.attrs[i]);\n}\nfunction tu(t, e) {\n  const { style: r } = t, n = {};\n  for (const i in r)\n    (Ht(r[i]) || e.style && Ht(e.style[i]) || Ad(i, t)) && (n[i] = r[i]);\n  return n;\n}\nfunction Rd(t, e) {\n  const r = tu(t, e);\n  for (const n in t)\n    if (Ht(t[n]) || Ht(e[n])) {\n      const i = n === \"x\" || n === \"y\" ? \"attr\" + n.toUpperCase() : n;\n      r[i] = t[n];\n    }\n  return r;\n}\nfunction ru(t, e, r, n = {}, i = {}) {\n  return typeof e == \"function\" && (e = e(r !== void 0 ? r : t.custom, n, i)), typeof e == \"string\" && (e = t.variants && t.variants[e]), typeof e == \"function\" && (e = e(r !== void 0 ? r : t.custom, n, i)), e;\n}\nconst _o = (t) => Array.isArray(t), fb = (t) => Boolean(t && typeof t == \"object\" && t.mix && t.toValue), hb = (t) => _o(t) ? t[t.length - 1] || 0 : t;\nfunction Ei(t) {\n  const e = Ht(t) ? t.get() : t;\n  return fb(e) ? e.toValue() : e;\n}\nfunction db({ scrapeMotionValuesFromProps: t, createRenderState: e, onMount: r }, n, i, o) {\n  const a = {\n    latestValues: pb(n, i, o, t),\n    renderState: e()\n  };\n  return r && (a.mount = (s) => r(n, s, a)), a;\n}\nconst Bd = (t) => (e, r) => {\n  const n = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(Ko), i = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(ii), o = () => db(t, e, n, i);\n  return r ? o() : Xo(o);\n};\nfunction pb(t, e, r, n) {\n  const i = {}, o = n(t, {});\n  for (const h in o)\n    i[h] = Ei(o[h]);\n  let { initial: a, animate: s } = t;\n  const l = Zo(t), u = bd(t);\n  e && u && !l && t.inherit !== !1 && (a === void 0 && (a = e.initial), s === void 0 && (s = e.animate));\n  let c = r ? r.initial === !1 : !1;\n  c = c || a === !1;\n  const f = c ? s : a;\n  return f && typeof f != \"boolean\" && !Yo(f) && (Array.isArray(f) ? f : [f]).forEach((p) => {\n    const g = ru(t, p);\n    if (!g)\n      return;\n    const { transitionEnd: _, transition: T, ...A } = g;\n    for (const w in A) {\n      let O = A[w];\n      if (Array.isArray(O)) {\n        const R = c ? O.length - 1 : 0;\n        O = O[R];\n      }\n      O !== null && (i[w] = O);\n    }\n    for (const w in _)\n      i[w] = _[w];\n  }), i;\n}\nconst yb = {\n  useVisualState: Bd({\n    scrapeMotionValuesFromProps: Rd,\n    createRenderState: Cd,\n    onMount: (t, e, { renderState: r, latestValues: n }) => {\n      try {\n        r.dimensions = typeof e.getBBox == \"function\" ? e.getBBox() : e.getBoundingClientRect();\n      } catch {\n        r.dimensions = {\n          x: 0,\n          y: 0,\n          width: 0,\n          height: 0\n        };\n      }\n      Jc(r, n, { enableHardwareAcceleration: !1 }, Qc(e.tagName), t.transformTemplate), kd(e, r);\n    }\n  })\n}, mb = {\n  useVisualState: Bd({\n    scrapeMotionValuesFromProps: tu,\n    createRenderState: Xc\n  })\n};\nfunction vb(t, { forwardMotionProps: e = !1 }, r, n, i) {\n  return {\n    ...Yc(t) ? yb : mb,\n    preloadedFeatures: r,\n    useRender: lb(e),\n    createVisualElement: n,\n    projectionNodeConstructor: i,\n    Component: t\n  };\n}\nvar Xe;\n(function(t) {\n  t.Animate = \"animate\", t.Hover = \"whileHover\", t.Tap = \"whileTap\", t.Drag = \"whileDrag\", t.Focus = \"whileFocus\", t.InView = \"whileInView\", t.Exit = \"exit\";\n})(Xe || (Xe = {}));\nfunction Jo(t, e, r, n = { passive: !0 }) {\n  return t.addEventListener(e, r, n), () => t.removeEventListener(e, r);\n}\nfunction Ca(t, e, r, n) {\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    const i = t.current;\n    if (r && i)\n      return Jo(i, e, r, n);\n  }, [t, e, r, n]);\n}\nfunction gb({ whileFocus: t, visualElement: e }) {\n  const { animationState: r } = e, n = () => {\n    r && r.setActive(Xe.Focus, !0);\n  }, i = () => {\n    r && r.setActive(Xe.Focus, !1);\n  };\n  Ca(e, \"focus\", t ? n : void 0), Ca(e, \"blur\", t ? i : void 0);\n}\nconst Id = (t) => t.isPrimary !== !1;\nfunction nu(t, e = \"page\") {\n  return {\n    point: {\n      x: t[e + \"X\"],\n      y: t[e + \"Y\"]\n    }\n  };\n}\nconst Dd = (t) => (e) => Id(e) && t(e, nu(e));\nfunction cn(t, e, r, n) {\n  return Jo(t, e, Dd(r), n);\n}\nfunction Ao(t, e, r, n) {\n  return Ca(t, e, r && Dd(r), n);\n}\nfunction Nd(t) {\n  let e = null;\n  return () => {\n    const r = () => {\n      e = null;\n    };\n    return e === null ? (e = t, r) : !1;\n  };\n}\nconst Mf = Nd(\"dragHorizontal\"), kf = Nd(\"dragVertical\");\nfunction Fd(t) {\n  let e = !1;\n  if (t === \"y\")\n    e = kf();\n  else if (t === \"x\")\n    e = Mf();\n  else {\n    const r = Mf(), n = kf();\n    r && n ? e = () => {\n      r(), n();\n    } : (r && r(), n && n());\n  }\n  return e;\n}\nfunction Ld() {\n  const t = Fd(!0);\n  return t ? (t(), !1) : !0;\n}\nfunction xb(t) {\n  return t.type !== \"pen\" && t.type !== \"touch\";\n}\nfunction Rf(t, e, r) {\n  return (n, i) => {\n    !xb(n) || Ld() || (t.animationState && t.animationState.setActive(Xe.Hover, e), r && r(n, i));\n  };\n}\nfunction wb({ onHoverStart: t, onHoverEnd: e, whileHover: r, visualElement: n }) {\n  Ao(n, \"pointerenter\", t || r ? Rf(n, !0, t) : void 0, { passive: !t }), Ao(n, \"pointerleave\", e || r ? Rf(n, !1, e) : void 0, { passive: !e });\n}\nconst jd = (t, e) => e ? t === e ? !0 : jd(t, e.parentElement) : !1;\nfunction iu(t) {\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => () => t(), []);\n}\nconst bb = (t, e) => (r) => e(t(r)), Qo = (...t) => t.reduce(bb);\nfunction _b({ onTap: t, onTapStart: e, onTapCancel: r, whileTap: n, visualElement: i }) {\n  const o = t || e || r || n, a = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(!1), s = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null), l = {\n    passive: !(e || t || r || p)\n  };\n  function u() {\n    s.current && s.current(), s.current = null;\n  }\n  function c() {\n    return u(), a.current = !1, i.animationState && i.animationState.setActive(Xe.Tap, !1), !Ld();\n  }\n  function f(g, _) {\n    c() && (jd(i.current, g.target) ? t && t(g, _) : r && r(g, _));\n  }\n  function h(g, _) {\n    c() && r && r(g, _);\n  }\n  function p(g, _) {\n    u(), !a.current && (a.current = !0, s.current = Qo(cn(window, \"pointerup\", f, l), cn(window, \"pointercancel\", h, l)), i.animationState && i.animationState.setActive(Xe.Tap, !0), e && e(g, _));\n  }\n  Ao(i, \"pointerdown\", o ? p : void 0, l), iu(u);\n}\nconst Bf = /* @__PURE__ */ new Set();\nfunction es(t, e, r) {\n  t || Bf.has(e) || (console.warn(e), r && console.warn(r), Bf.add(e));\n}\nconst Oa = /* @__PURE__ */ new WeakMap(), Gs = /* @__PURE__ */ new WeakMap(), Ab = (t) => {\n  const e = Oa.get(t.target);\n  e && e(t);\n}, Tb = (t) => {\n  t.forEach(Ab);\n};\nfunction Eb({ root: t, ...e }) {\n  const r = t || document;\n  Gs.has(r) || Gs.set(r, {});\n  const n = Gs.get(r), i = JSON.stringify(e);\n  return n[i] || (n[i] = new IntersectionObserver(Tb, { root: t, ...e })), n[i];\n}\nfunction Sb(t, e, r) {\n  const n = Eb(e);\n  return Oa.set(t, r), n.observe(t), () => {\n    Oa.delete(t), n.unobserve(t);\n  };\n}\nfunction Pb({ visualElement: t, whileInView: e, onViewportEnter: r, onViewportLeave: n, viewport: i = {} }) {\n  const o = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n    hasEnteredView: !1,\n    isInView: !1\n  });\n  let a = Boolean(e || r || n);\n  i.once && o.current.hasEnteredView && (a = !1), (typeof IntersectionObserver > \"u\" ? Mb : Ob)(a, o.current, t, i);\n}\nconst Cb = {\n  some: 0,\n  all: 1\n};\nfunction Ob(t, e, r, { root: n, margin: i, amount: o = \"some\", once: a }) {\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (!t || !r.current)\n      return;\n    const s = {\n      root: n == null ? void 0 : n.current,\n      rootMargin: i,\n      threshold: typeof o == \"number\" ? o : Cb[o]\n    }, l = (u) => {\n      const { isIntersecting: c } = u;\n      if (e.isInView === c || (e.isInView = c, a && !c && e.hasEnteredView))\n        return;\n      c && (e.hasEnteredView = !0), r.animationState && r.animationState.setActive(Xe.InView, c);\n      const f = r.getProps(), h = c ? f.onViewportEnter : f.onViewportLeave;\n      h && h(u);\n    };\n    return Sb(r.current, s, l);\n  }, [t, n, i, o]);\n}\nfunction Mb(t, e, r, { fallback: n = !0 }) {\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    !t || !n || ( true && es(!1, \"IntersectionObserver not available on this device. whileInView animations will trigger on mount.\"), requestAnimationFrame(() => {\n      e.hasEnteredView = !0;\n      const { onViewportEnter: i } = r.getProps();\n      i && i(null), r.animationState && r.animationState.setActive(Xe.InView, !0);\n    }));\n  }, [t]);\n}\nconst wr = (t) => (e) => (t(e), null), kb = {\n  inView: wr(Pb),\n  tap: wr(_b),\n  focus: wr(gb),\n  hover: wr(wb)\n};\nfunction Ud() {\n  const t = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(ii);\n  if (t === null)\n    return [!0, null];\n  const { isPresent: e, onExitComplete: r, register: n } = t, i = (0,react__WEBPACK_IMPORTED_MODULE_0__.useId)();\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => n(i), []), !e && r ? [!1, () => r && r(i)] : [!0];\n}\nfunction Vd(t, e) {\n  if (!Array.isArray(e))\n    return !1;\n  const r = e.length;\n  if (r !== t.length)\n    return !1;\n  for (let n = 0; n < r; n++)\n    if (e[n] !== t[n])\n      return !1;\n  return !0;\n}\nconst Rb = (t) => /^\\-?\\d*\\.?\\d+$/.test(t), Bb = (t) => /^0[^.\\s]+$/.test(t), lr = {\n  delta: 0,\n  timestamp: 0\n}, $d = 1 / 60 * 1e3, Ib = typeof performance < \"u\" ? () => performance.now() : () => Date.now(), Hd = typeof window < \"u\" ? (t) => window.requestAnimationFrame(t) : (t) => setTimeout(() => t(Ib()), $d);\nfunction Db(t) {\n  let e = [], r = [], n = 0, i = !1, o = !1;\n  const a = /* @__PURE__ */ new WeakSet(), s = {\n    /**\n     * Schedule a process to run on the next frame.\n     */\n    schedule: (l, u = !1, c = !1) => {\n      const f = c && i, h = f ? e : r;\n      return u && a.add(l), h.indexOf(l) === -1 && (h.push(l), f && i && (n = e.length)), l;\n    },\n    /**\n     * Cancel the provided callback from running on the next frame.\n     */\n    cancel: (l) => {\n      const u = r.indexOf(l);\n      u !== -1 && r.splice(u, 1), a.delete(l);\n    },\n    /**\n     * Execute all schedule callbacks.\n     */\n    process: (l) => {\n      if (i) {\n        o = !0;\n        return;\n      }\n      if (i = !0, [e, r] = [r, e], r.length = 0, n = e.length, n)\n        for (let u = 0; u < n; u++) {\n          const c = e[u];\n          c(l), a.has(c) && (s.schedule(c), t());\n        }\n      i = !1, o && (o = !1, s.process(l));\n    }\n  };\n  return s;\n}\nconst Nb = 40;\nlet Ma = !0, Yn = !1, ka = !1;\nconst ai = [\n  \"read\",\n  \"update\",\n  \"preRender\",\n  \"render\",\n  \"postRender\"\n], ts = ai.reduce((t, e) => (t[e] = Db(() => Yn = !0), t), {}), Tt = ai.reduce((t, e) => {\n  const r = ts[e];\n  return t[e] = (n, i = !1, o = !1) => (Yn || Lb(), r.schedule(n, i, o)), t;\n}, {}), _r = ai.reduce((t, e) => (t[e] = ts[e].cancel, t), {}), Ys = ai.reduce((t, e) => (t[e] = () => ts[e].process(lr), t), {}), Fb = (t) => ts[t].process(lr), Wd = (t) => {\n  Yn = !1, lr.delta = Ma ? $d : Math.max(Math.min(t - lr.timestamp, Nb), 1), lr.timestamp = t, ka = !0, ai.forEach(Fb), ka = !1, Yn && (Ma = !1, Hd(Wd));\n}, Lb = () => {\n  Yn = !0, Ma = !0, ka || Hd(Wd);\n};\nfunction ou(t, e) {\n  t.indexOf(e) === -1 && t.push(e);\n}\nfunction su(t, e) {\n  const r = t.indexOf(e);\n  r > -1 && t.splice(r, 1);\n}\nclass au {\n  constructor() {\n    this.subscriptions = [];\n  }\n  add(e) {\n    return ou(this.subscriptions, e), () => su(this.subscriptions, e);\n  }\n  notify(e, r, n) {\n    const i = this.subscriptions.length;\n    if (i)\n      if (i === 1)\n        this.subscriptions[0](e, r, n);\n      else\n        for (let o = 0; o < i; o++) {\n          const a = this.subscriptions[o];\n          a && a(e, r, n);\n        }\n  }\n  getSize() {\n    return this.subscriptions.length;\n  }\n  clear() {\n    this.subscriptions.length = 0;\n  }\n}\nfunction cu(t, e) {\n  return e ? t * (1e3 / e) : 0;\n}\nconst jb = (t) => !isNaN(parseFloat(t));\nclass Ub {\n  /**\n   * @param init - The initiating value\n   * @param config - Optional configuration options\n   *\n   * -  `transformer`: A function to transform incoming values with.\n   *\n   * @internal\n   */\n  constructor(e, r = {}) {\n    this.version = \"8.1.9\", this.timeDelta = 0, this.lastUpdated = 0, this.canTrackVelocity = !1, this.events = {}, this.updateAndNotify = (n, i = !0) => {\n      this.prev = this.current, this.current = n;\n      const { delta: o, timestamp: a } = lr;\n      this.lastUpdated !== a && (this.timeDelta = o, this.lastUpdated = a, Tt.postRender(this.scheduleVelocityCheck)), this.prev !== this.current && this.events.change && this.events.change.notify(this.current), this.events.velocityChange && this.events.velocityChange.notify(this.getVelocity()), i && this.events.renderRequest && this.events.renderRequest.notify(this.current);\n    }, this.scheduleVelocityCheck = () => Tt.postRender(this.velocityCheck), this.velocityCheck = ({ timestamp: n }) => {\n      n !== this.lastUpdated && (this.prev = this.current, this.events.velocityChange && this.events.velocityChange.notify(this.getVelocity()));\n    }, this.hasAnimated = !1, this.prev = this.current = e, this.canTrackVelocity = jb(this.current), this.owner = r.owner;\n  }\n  /**\n   * Adds a function that will be notified when the `MotionValue` is updated.\n   *\n   * It returns a function that, when called, will cancel the subscription.\n   *\n   * When calling `onChange` inside a React component, it should be wrapped with the\n   * `useEffect` hook. As it returns an unsubscribe function, this should be returned\n   * from the `useEffect` function to ensure you don't add duplicate subscribers..\n   *\n   * ```jsx\n   * export const MyComponent = () => {\n   *   const x = useMotionValue(0)\n   *   const y = useMotionValue(0)\n   *   const opacity = useMotionValue(1)\n   *\n   *   useEffect(() => {\n   *     function updateOpacity() {\n   *       const maxXY = Math.max(x.get(), y.get())\n   *       const newOpacity = transform(maxXY, [0, 100], [1, 0])\n   *       opacity.set(newOpacity)\n   *     }\n   *\n   *     const unsubscribeX = x.on(\"change\", updateOpacity)\n   *     const unsubscribeY = y.on(\"change\", updateOpacity)\n   *\n   *     return () => {\n   *       unsubscribeX()\n   *       unsubscribeY()\n   *     }\n   *   }, [])\n   *\n   *   return <motion.div style={{ x }} />\n   * }\n   * ```\n   *\n   * @param subscriber - A function that receives the latest value.\n   * @returns A function that, when called, will cancel this subscription.\n   *\n   * @deprecated\n   */\n  onChange(e) {\n    return this.on(\"change\", e);\n  }\n  on(e, r) {\n    this.events[e] || (this.events[e] = new au());\n    const n = this.events[e].add(r);\n    return e === \"change\" ? () => {\n      n(), Tt.read(() => {\n        this.events.change.getSize() || this.stop();\n      });\n    } : n;\n  }\n  clearListeners() {\n    for (const e in this.events)\n      this.events[e].clear();\n  }\n  /**\n   * Attaches a passive effect to the `MotionValue`.\n   *\n   * @internal\n   */\n  attach(e, r) {\n    this.passiveEffect = e, this.stopPassiveEffect = r;\n  }\n  /**\n   * Sets the state of the `MotionValue`.\n   *\n   * @remarks\n   *\n   * ```jsx\n   * const x = useMotionValue(0)\n   * x.set(10)\n   * ```\n   *\n   * @param latest - Latest value to set.\n   * @param render - Whether to notify render subscribers. Defaults to `true`\n   *\n   * @public\n   */\n  set(e, r = !0) {\n    !r || !this.passiveEffect ? this.updateAndNotify(e, r) : this.passiveEffect(e, this.updateAndNotify);\n  }\n  setWithVelocity(e, r, n) {\n    this.set(r), this.prev = e, this.timeDelta = n;\n  }\n  /**\n   * Set the state of the `MotionValue`, stopping any active animations,\n   * effects, and resets velocity to `0`.\n   */\n  jump(e) {\n    this.updateAndNotify(e), this.prev = e, this.stop(), this.stopPassiveEffect && this.stopPassiveEffect();\n  }\n  /**\n   * Returns the latest state of `MotionValue`\n   *\n   * @returns - The latest state of `MotionValue`\n   *\n   * @public\n   */\n  get() {\n    return this.current;\n  }\n  /**\n   * @public\n   */\n  getPrevious() {\n    return this.prev;\n  }\n  /**\n   * Returns the latest velocity of `MotionValue`\n   *\n   * @returns - The latest velocity of `MotionValue`. Returns `0` if the state is non-numerical.\n   *\n   * @public\n   */\n  getVelocity() {\n    return this.canTrackVelocity ? (\n      // These casts could be avoided if parseFloat would be typed better\n      cu(parseFloat(this.current) - parseFloat(this.prev), this.timeDelta)\n    ) : 0;\n  }\n  /**\n   * Registers a new animation to control this `MotionValue`. Only one\n   * animation can drive a `MotionValue` at one time.\n   *\n   * ```jsx\n   * value.start()\n   * ```\n   *\n   * @param animation - A function that starts the provided animation\n   *\n   * @internal\n   */\n  start(e) {\n    return this.stop(), new Promise((r) => {\n      this.hasAnimated = !0, this.stopAnimation = e(r), this.events.animationStart && this.events.animationStart.notify();\n    }).then(() => {\n      this.events.animationComplete && this.events.animationComplete.notify(), this.clearAnimation();\n    });\n  }\n  /**\n   * Stop the currently active animation.\n   *\n   * @public\n   */\n  stop() {\n    this.stopAnimation && (this.stopAnimation(), this.events.animationCancel && this.events.animationCancel.notify()), this.clearAnimation();\n  }\n  /**\n   * Returns `true` if this value is currently animating.\n   *\n   * @public\n   */\n  isAnimating() {\n    return !!this.stopAnimation;\n  }\n  clearAnimation() {\n    this.stopAnimation = null;\n  }\n  /**\n   * Destroy and clean up subscribers to this `MotionValue`.\n   *\n   * The `MotionValue` hooks like `useMotionValue` and `useTransform` automatically\n   * handle the lifecycle of the returned `MotionValue`, so this method is only necessary if you've manually\n   * created a `MotionValue` via the `motionValue` function.\n   *\n   * @public\n   */\n  destroy() {\n    this.clearListeners(), this.stop(), this.stopPassiveEffect && this.stopPassiveEffect();\n  }\n}\nfunction vn(t, e) {\n  return new Ub(t, e);\n}\nconst uu = (t, e) => (r) => Boolean(oi(r) && qw.test(r) && r.startsWith(t) || e && Object.prototype.hasOwnProperty.call(r, e)), zd = (t, e, r) => (n) => {\n  if (!oi(n))\n    return n;\n  const [i, o, a, s] = n.match(Gn);\n  return {\n    [t]: parseFloat(i),\n    [e]: parseFloat(o),\n    [r]: parseFloat(a),\n    alpha: s !== void 0 ? parseFloat(s) : 1\n  };\n}, Vb = (t) => mn(0, 255, t), Zs = {\n  ...Wr,\n  transform: (t) => Math.round(Vb(t))\n}, Dr = {\n  test: uu(\"rgb\", \"red\"),\n  parse: zd(\"red\", \"green\", \"blue\"),\n  transform: ({ red: t, green: e, blue: r, alpha: n = 1 }) => \"rgba(\" + Zs.transform(t) + \", \" + Zs.transform(e) + \", \" + Zs.transform(r) + \", \" + Ln(Fn.transform(n)) + \")\"\n};\nfunction $b(t) {\n  let e = \"\", r = \"\", n = \"\", i = \"\";\n  return t.length > 5 ? (e = t.substring(1, 3), r = t.substring(3, 5), n = t.substring(5, 7), i = t.substring(7, 9)) : (e = t.substring(1, 2), r = t.substring(2, 3), n = t.substring(3, 4), i = t.substring(4, 5), e += e, r += r, n += n, i += i), {\n    red: parseInt(e, 16),\n    green: parseInt(r, 16),\n    blue: parseInt(n, 16),\n    alpha: i ? parseInt(i, 16) / 255 : 1\n  };\n}\nconst Ra = {\n  test: uu(\"#\"),\n  parse: $b,\n  transform: Dr.transform\n}, nn = {\n  test: uu(\"hsl\", \"hue\"),\n  parse: zd(\"hue\", \"saturation\", \"lightness\"),\n  transform: ({ hue: t, saturation: e, lightness: r, alpha: n = 1 }) => \"hsla(\" + Math.round(t) + \", \" + rr.transform(Ln(e)) + \", \" + rr.transform(Ln(r)) + \", \" + Ln(Fn.transform(n)) + \")\"\n}, At = {\n  test: (t) => Dr.test(t) || Ra.test(t) || nn.test(t),\n  parse: (t) => Dr.test(t) ? Dr.parse(t) : nn.test(t) ? nn.parse(t) : Ra.parse(t),\n  transform: (t) => oi(t) ? t : t.hasOwnProperty(\"red\") ? Dr.transform(t) : nn.transform(t)\n}, qd = \"${c}\", Kd = \"${n}\";\nfunction Hb(t) {\n  var e, r;\n  return isNaN(t) && oi(t) && (((e = t.match(Gn)) === null || e === void 0 ? void 0 : e.length) || 0) + (((r = t.match(Pa)) === null || r === void 0 ? void 0 : r.length) || 0) > 0;\n}\nfunction To(t) {\n  typeof t == \"number\" && (t = `${t}`);\n  const e = [];\n  let r = 0, n = 0;\n  const i = t.match(Pa);\n  i && (r = i.length, t = t.replace(Pa, qd), e.push(...i.map(At.parse)));\n  const o = t.match(Gn);\n  return o && (n = o.length, t = t.replace(Gn, Kd), e.push(...o.map(Wr.parse))), { values: e, numColors: r, numNumbers: n, tokenised: t };\n}\nfunction Gd(t) {\n  return To(t).values;\n}\nfunction Yd(t) {\n  const { values: e, numColors: r, tokenised: n } = To(t), i = e.length;\n  return (o) => {\n    let a = n;\n    for (let s = 0; s < i; s++)\n      a = a.replace(s < r ? qd : Kd, s < r ? At.transform(o[s]) : Ln(o[s]));\n    return a;\n  };\n}\nconst Wb = (t) => typeof t == \"number\" ? 0 : t;\nfunction zb(t) {\n  const e = Gd(t);\n  return Yd(t)(e.map(Wb));\n}\nconst Ar = { test: Hb, parse: Gd, createTransformer: Yd, getAnimatableNone: zb }, qb = /* @__PURE__ */ new Set([\"brightness\", \"contrast\", \"saturate\", \"opacity\"]);\nfunction Kb(t) {\n  const [e, r] = t.slice(0, -1).split(\"(\");\n  if (e === \"drop-shadow\")\n    return t;\n  const [n] = r.match(Gn) || [];\n  if (!n)\n    return t;\n  const i = r.replace(n, \"\");\n  let o = qb.has(e) ? 1 : 0;\n  return n !== r && (o *= 100), e + \"(\" + o + i + \")\";\n}\nconst Gb = /([a-z-]*)\\(.*?\\)/g, Ba = {\n  ...Ar,\n  getAnimatableNone: (t) => {\n    const e = t.match(Gb);\n    return e ? e.map(Kb).join(\" \") : t;\n  }\n}, Yb = {\n  ...Ed,\n  // Color props\n  color: At,\n  backgroundColor: At,\n  outlineColor: At,\n  fill: At,\n  stroke: At,\n  // Border props\n  borderColor: At,\n  borderTopColor: At,\n  borderRightColor: At,\n  borderBottomColor: At,\n  borderLeftColor: At,\n  filter: Ba,\n  WebkitFilter: Ba\n}, lu = (t) => Yb[t];\nfunction fu(t, e) {\n  var r;\n  let n = lu(t);\n  return n !== Ba && (n = Ar), (r = n.getAnimatableNone) === null || r === void 0 ? void 0 : r.call(n, e);\n}\nconst Zd = (t) => (e) => e.test(t), Zb = {\n  test: (t) => t === \"auto\",\n  parse: (t) => t\n}, Xd = [Wr, Ce, rr, mr, Gw, Kw, Zb], On = (t) => Xd.find(Zd(t)), Xb = [...Xd, At, Ar], Jb = (t) => Xb.find(Zd(t));\nfunction Qb(t) {\n  const e = {};\n  return t.values.forEach((r, n) => e[n] = r.get()), e;\n}\nfunction e_(t) {\n  const e = {};\n  return t.values.forEach((r, n) => e[n] = r.getVelocity()), e;\n}\nfunction rs(t, e, r) {\n  const n = t.getProps();\n  return ru(n, e, r !== void 0 ? r : n.custom, Qb(t), e_(t));\n}\nfunction t_(t, e, r) {\n  t.hasValue(e) ? t.getValue(e).set(r) : t.addValue(e, vn(r));\n}\nfunction r_(t, e) {\n  const r = rs(t, e);\n  let { transitionEnd: n = {}, transition: i = {}, ...o } = r ? t.makeTargetAnimatable(r, !1) : {};\n  o = { ...o, ...n };\n  for (const a in o) {\n    const s = hb(o[a]);\n    t_(t, a, s);\n  }\n}\nfunction n_(t, e, r) {\n  var n, i;\n  const o = Object.keys(e).filter((s) => !t.hasValue(s)), a = o.length;\n  if (a)\n    for (let s = 0; s < a; s++) {\n      const l = o[s], u = e[l];\n      let c = null;\n      Array.isArray(u) && (c = u[0]), c === null && (c = (i = (n = r[l]) !== null && n !== void 0 ? n : t.readValue(l)) !== null && i !== void 0 ? i : e[l]), c != null && (typeof c == \"string\" && (Rb(c) || Bb(c)) ? c = parseFloat(c) : !Jb(c) && Ar.test(u) && (c = fu(l, u)), t.addValue(l, vn(c, { owner: t })), r[l] === void 0 && (r[l] = c), c !== null && t.setBaseTarget(l, c));\n    }\n}\nfunction i_(t, e) {\n  return e ? (e[t] || e.default || e).from : void 0;\n}\nfunction o_(t, e, r) {\n  var n;\n  const i = {};\n  for (const o in t) {\n    const a = i_(o, e);\n    i[o] = a !== void 0 ? a : (n = r.getValue(o)) === null || n === void 0 ? void 0 : n.get();\n  }\n  return i;\n}\nfunction Eo(t) {\n  return Boolean(Ht(t) && t.add);\n}\nconst s_ = (t, e) => `${t}: ${e}`;\nfunction a_(t, e) {\n  const { MotionAppearAnimations: r } = window, n = s_(t, Hr.has(e) ? \"transform\" : e), i = r && r.get(n);\n  return i ? (Tt.render(() => {\n    try {\n      i.cancel(), r.delete(n);\n    } catch {\n    }\n  }), i.currentTime || 0) : 0;\n}\nconst c_ = \"framerAppearId\", u_ = \"data-\" + eu(c_);\nvar ns = function() {\n}, Gt = function() {\n};\n true && (ns = function(t, e) {\n  !t && typeof console < \"u\" && console.warn(e);\n}, Gt = function(t, e) {\n  if (!t)\n    throw new Error(e);\n});\nconst Si = (t) => t * 1e3, l_ = {\n  current: !1\n}, hu = (t) => (e) => e <= 0.5 ? t(2 * e) / 2 : (2 - t(2 * (1 - e))) / 2, du = (t) => (e) => 1 - t(1 - e), pu = (t) => t * t, f_ = du(pu), yu = hu(pu), ct = (t, e, r) => -r * t + r * e + t;\nfunction Xs(t, e, r) {\n  return r < 0 && (r += 1), r > 1 && (r -= 1), r < 1 / 6 ? t + (e - t) * 6 * r : r < 1 / 2 ? e : r < 2 / 3 ? t + (e - t) * (2 / 3 - r) * 6 : t;\n}\nfunction h_({ hue: t, saturation: e, lightness: r, alpha: n }) {\n  t /= 360, e /= 100, r /= 100;\n  let i = 0, o = 0, a = 0;\n  if (!e)\n    i = o = a = r;\n  else {\n    const s = r < 0.5 ? r * (1 + e) : r + e - r * e, l = 2 * r - s;\n    i = Xs(l, s, t + 1 / 3), o = Xs(l, s, t), a = Xs(l, s, t - 1 / 3);\n  }\n  return {\n    red: Math.round(i * 255),\n    green: Math.round(o * 255),\n    blue: Math.round(a * 255),\n    alpha: n\n  };\n}\nconst Js = (t, e, r) => {\n  const n = t * t;\n  return Math.sqrt(Math.max(0, r * (e * e - n) + n));\n}, d_ = [Ra, Dr, nn], p_ = (t) => d_.find((e) => e.test(t));\nfunction If(t) {\n  const e = p_(t);\n  Gt(Boolean(e), `'${t}' is not an animatable color. Use the equivalent color code instead.`);\n  let r = e.parse(t);\n  return e === nn && (r = h_(r)), r;\n}\nconst Jd = (t, e) => {\n  const r = If(t), n = If(e), i = { ...r };\n  return (o) => (i.red = Js(r.red, n.red, o), i.green = Js(r.green, n.green, o), i.blue = Js(r.blue, n.blue, o), i.alpha = ct(r.alpha, n.alpha, o), Dr.transform(i));\n};\nfunction Qd(t, e) {\n  return typeof t == \"number\" ? (r) => ct(t, e, r) : At.test(t) ? Jd(t, e) : tp(t, e);\n}\nconst ep = (t, e) => {\n  const r = [...t], n = r.length, i = t.map((o, a) => Qd(o, e[a]));\n  return (o) => {\n    for (let a = 0; a < n; a++)\n      r[a] = i[a](o);\n    return r;\n  };\n}, y_ = (t, e) => {\n  const r = { ...t, ...e }, n = {};\n  for (const i in r)\n    t[i] !== void 0 && e[i] !== void 0 && (n[i] = Qd(t[i], e[i]));\n  return (i) => {\n    for (const o in n)\n      r[o] = n[o](i);\n    return r;\n  };\n}, tp = (t, e) => {\n  const r = Ar.createTransformer(e), n = To(t), i = To(e);\n  return n.numColors === i.numColors && n.numNumbers >= i.numNumbers ? Qo(ep(n.values, i.values), r) : (ns(!0, `Complex values '${t}' and '${e}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`), (a) => `${a > 0 ? e : t}`);\n}, So = (t, e, r) => {\n  const n = e - t;\n  return n === 0 ? 1 : (r - t) / n;\n}, Df = (t, e) => (r) => ct(t, e, r);\nfunction m_(t) {\n  return typeof t == \"number\" ? Df : typeof t == \"string\" ? At.test(t) ? Jd : tp : Array.isArray(t) ? ep : typeof t == \"object\" ? y_ : Df;\n}\nfunction v_(t, e, r) {\n  const n = [], i = r || m_(t[0]), o = t.length - 1;\n  for (let a = 0; a < o; a++) {\n    let s = i(t[a], t[a + 1]);\n    if (e) {\n      const l = Array.isArray(e) ? e[a] : e;\n      s = Qo(l, s);\n    }\n    n.push(s);\n  }\n  return n;\n}\nfunction rp(t, e, { clamp: r = !0, ease: n, mixer: i } = {}) {\n  const o = t.length;\n  Gt(o === e.length, \"Both input and output ranges must be the same length\"), Gt(!n || !Array.isArray(n) || n.length === o - 1, \"Array of easing functions must be of length `input.length - 1`, as it applies to the transitions **between** the defined values.\"), t[0] > t[o - 1] && (t = [...t].reverse(), e = [...e].reverse());\n  const a = v_(e, n, i), s = a.length, l = (u) => {\n    let c = 0;\n    if (s > 1)\n      for (; c < t.length - 2 && !(u < t[c + 1]); c++)\n        ;\n    const f = So(t[c], t[c + 1], u);\n    return a[c](f);\n  };\n  return r ? (u) => l(mn(t[0], t[o - 1], u)) : l;\n}\nconst mu = (t) => t, np = (t, e, r) => (((1 - 3 * r + 3 * e) * t + (3 * r - 6 * e)) * t + 3 * e) * t, g_ = 1e-7, x_ = 12;\nfunction w_(t, e, r, n, i) {\n  let o, a, s = 0;\n  do\n    a = e + (r - e) / 2, o = np(a, n, i) - t, o > 0 ? r = a : e = a;\n  while (Math.abs(o) > g_ && ++s < x_);\n  return a;\n}\nfunction ip(t, e, r, n) {\n  if (t === e && r === n)\n    return mu;\n  const i = (o) => w_(o, 0, 1, t, r);\n  return (o) => o === 0 || o === 1 ? o : np(i(o), e, n);\n}\nconst op = (t) => 1 - Math.sin(Math.acos(t)), vu = du(op), b_ = hu(vu), sp = ip(0.33, 1.53, 0.69, 0.99), gu = du(sp), __ = hu(gu), A_ = (t) => (t *= 2) < 1 ? 0.5 * gu(t) : 0.5 * (2 - Math.pow(2, -10 * (t - 1))), Nf = {\n  linear: mu,\n  easeIn: pu,\n  easeInOut: yu,\n  easeOut: f_,\n  circIn: op,\n  circInOut: b_,\n  circOut: vu,\n  backIn: gu,\n  backInOut: __,\n  backOut: sp,\n  anticipate: A_\n}, Ff = (t) => {\n  if (Array.isArray(t)) {\n    Gt(t.length === 4, \"Cubic bezier arrays must contain four numerical values.\");\n    const [e, r, n, i] = t;\n    return ip(e, r, n, i);\n  } else if (typeof t == \"string\")\n    return Gt(Nf[t] !== void 0, `Invalid easing type '${t}'`), Nf[t];\n  return t;\n}, T_ = (t) => Array.isArray(t) && typeof t[0] != \"number\";\nfunction E_(t, e) {\n  return t.map(() => e || yu).splice(0, t.length - 1);\n}\nfunction S_(t) {\n  const e = t.length;\n  return t.map((r, n) => n !== 0 ? n / (e - 1) : 0);\n}\nfunction P_(t, e) {\n  return t.map((r) => r * e);\n}\nfunction Ia({ keyframes: t, ease: e = yu, times: r, duration: n = 300 }) {\n  t = [...t];\n  const i = T_(e) ? e.map(Ff) : Ff(e), o = {\n    done: !1,\n    value: t[0]\n  }, a = P_(\n    // Only use the provided offsets if they're the correct length\n    // TODO Maybe we should warn here if there's a length mismatch\n    r && r.length === t.length ? r : S_(t),\n    n\n  );\n  function s() {\n    return rp(a, t, {\n      ease: Array.isArray(i) ? i : E_(t, i)\n    });\n  }\n  let l = s();\n  return {\n    next: (u) => (o.value = l(u), o.done = u >= n, o),\n    flipTarget: () => {\n      t.reverse(), l = s();\n    }\n  };\n}\nconst Qs = 1e-3, C_ = 0.01, Lf = 10, O_ = 0.05, M_ = 1;\nfunction k_({ duration: t = 800, bounce: e = 0.25, velocity: r = 0, mass: n = 1 }) {\n  let i, o;\n  ns(t <= Lf * 1e3, \"Spring duration must be 10 seconds or less\");\n  let a = 1 - e;\n  a = mn(O_, M_, a), t = mn(C_, Lf, t / 1e3), a < 1 ? (i = (u) => {\n    const c = u * a, f = c * t, h = c - r, p = Da(u, a), g = Math.exp(-f);\n    return Qs - h / p * g;\n  }, o = (u) => {\n    const f = u * a * t, h = f * r + r, p = Math.pow(a, 2) * Math.pow(u, 2) * t, g = Math.exp(-f), _ = Da(Math.pow(u, 2), a);\n    return (-i(u) + Qs > 0 ? -1 : 1) * ((h - p) * g) / _;\n  }) : (i = (u) => {\n    const c = Math.exp(-u * t), f = (u - r) * t + 1;\n    return -Qs + c * f;\n  }, o = (u) => {\n    const c = Math.exp(-u * t), f = (r - u) * (t * t);\n    return c * f;\n  });\n  const s = 5 / t, l = B_(i, o, s);\n  if (t = t * 1e3, isNaN(l))\n    return {\n      stiffness: 100,\n      damping: 10,\n      duration: t\n    };\n  {\n    const u = Math.pow(l, 2) * n;\n    return {\n      stiffness: u,\n      damping: a * 2 * Math.sqrt(n * u),\n      duration: t\n    };\n  }\n}\nconst R_ = 12;\nfunction B_(t, e, r) {\n  let n = r;\n  for (let i = 1; i < R_; i++)\n    n = n - t(n) / e(n);\n  return n;\n}\nfunction Da(t, e) {\n  return t * Math.sqrt(1 - e * e);\n}\nconst I_ = [\"duration\", \"bounce\"], D_ = [\"stiffness\", \"damping\", \"mass\"];\nfunction jf(t, e) {\n  return e.some((r) => t[r] !== void 0);\n}\nfunction N_(t) {\n  let e = {\n    velocity: 0,\n    stiffness: 100,\n    damping: 10,\n    mass: 1,\n    isResolvedFromDuration: !1,\n    ...t\n  };\n  if (!jf(t, D_) && jf(t, I_)) {\n    const r = k_(t);\n    e = {\n      ...e,\n      ...r,\n      velocity: 0,\n      mass: 1\n    }, e.isResolvedFromDuration = !0;\n  }\n  return e;\n}\nconst F_ = 5;\nfunction ap({ keyframes: t, restSpeed: e = 2, restDelta: r = 0.01, ...n }) {\n  let i = t[0], o = t[t.length - 1];\n  const a = { done: !1, value: i }, { stiffness: s, damping: l, mass: u, velocity: c, duration: f, isResolvedFromDuration: h } = N_(n);\n  let p = L_, g = c ? -(c / 1e3) : 0;\n  const _ = l / (2 * Math.sqrt(s * u));\n  function T() {\n    const A = o - i, w = Math.sqrt(s / u) / 1e3;\n    if (r === void 0 && (r = Math.min(Math.abs(o - i) / 100, 0.4)), _ < 1) {\n      const O = Da(w, _);\n      p = (R) => {\n        const $ = Math.exp(-_ * w * R);\n        return o - $ * ((g + _ * w * A) / O * Math.sin(O * R) + A * Math.cos(O * R));\n      };\n    } else if (_ === 1)\n      p = (O) => o - Math.exp(-w * O) * (A + (g + w * A) * O);\n    else {\n      const O = w * Math.sqrt(_ * _ - 1);\n      p = (R) => {\n        const $ = Math.exp(-_ * w * R), U = Math.min(O * R, 300);\n        return o - $ * ((g + _ * w * A) * Math.sinh(U) + O * A * Math.cosh(U)) / O;\n      };\n    }\n  }\n  return T(), {\n    next: (A) => {\n      const w = p(A);\n      if (h)\n        a.done = A >= f;\n      else {\n        let O = g;\n        if (A !== 0)\n          if (_ < 1) {\n            const U = Math.max(0, A - F_);\n            O = cu(w - p(U), A - U);\n          } else\n            O = 0;\n        const R = Math.abs(O) <= e, $ = Math.abs(o - w) <= r;\n        a.done = R && $;\n      }\n      return a.value = a.done ? o : w, a;\n    },\n    flipTarget: () => {\n      g = -g, [i, o] = [o, i], T();\n    }\n  };\n}\nap.needsInterpolation = (t, e) => typeof t == \"string\" || typeof e == \"string\";\nconst L_ = (t) => 0;\nfunction j_({\n  /**\n   * The decay animation dynamically calculates an end of the animation\n   * based on the initial keyframe, so we only need to define a single keyframe\n   * as default.\n   */\n  keyframes: t = [0],\n  velocity: e = 0,\n  power: r = 0.8,\n  timeConstant: n = 350,\n  restDelta: i = 0.5,\n  modifyTarget: o\n}) {\n  const a = t[0], s = { done: !1, value: a };\n  let l = r * e;\n  const u = a + l, c = o === void 0 ? u : o(u);\n  return c !== u && (l = c - a), {\n    next: (f) => {\n      const h = -l * Math.exp(-f / n);\n      return s.done = !(h > i || h < -i), s.value = s.done ? c : c + h, s;\n    },\n    flipTarget: () => {\n    }\n  };\n}\nconst U_ = {\n  decay: j_,\n  keyframes: Ia,\n  tween: Ia,\n  spring: ap\n};\nfunction cp(t, e, r = 0) {\n  return t - e - r;\n}\nfunction V_(t, e = 0, r = 0, n = !0) {\n  return n ? cp(e + -t, e, r) : e - (t - e) + r;\n}\nfunction $_(t, e, r, n) {\n  return n ? t >= e + r : t <= -r;\n}\nconst H_ = (t) => {\n  const e = ({ delta: r }) => t(r);\n  return {\n    start: () => Tt.update(e, !0),\n    stop: () => _r.update(e)\n  };\n};\nfunction Po({ duration: t, driver: e = H_, elapsed: r = 0, repeat: n = 0, repeatType: i = \"loop\", repeatDelay: o = 0, keyframes: a, autoplay: s = !0, onPlay: l, onStop: u, onComplete: c, onRepeat: f, onUpdate: h, type: p = \"keyframes\", ...g }) {\n  var _, T;\n  const A = r;\n  let w, O = 0, R = t, $ = !1, U = !0, W;\n  const G = U_[a.length > 2 ? \"keyframes\" : p] || Ia, Z = a[0], j = a[a.length - 1];\n  let P = { done: !1, value: Z };\n  !((T = (_ = G).needsInterpolation) === null || T === void 0) && T.call(_, Z, j) && (W = rp([0, 100], [Z, j], {\n    clamp: !1\n  }), a = [0, 100]);\n  const d = G({\n    ...g,\n    duration: t,\n    keyframes: a\n  });\n  function x() {\n    O++, i === \"reverse\" ? (U = O % 2 === 0, r = V_(r, R, o, U)) : (r = cp(r, R, o), i === \"mirror\" && d.flipTarget()), $ = !1, f && f();\n  }\n  function C() {\n    w && w.stop(), c && c();\n  }\n  function M(z) {\n    U || (z = -z), r += z, $ || (P = d.next(Math.max(0, r)), W && (P.value = W(P.value)), $ = U ? P.done : r <= 0), h && h(P.value), $ && (O === 0 && (R = R !== void 0 ? R : r), O < n ? $_(r, R, o, U) && x() : C());\n  }\n  function D() {\n    l && l(), w = e(M), w.start();\n  }\n  return s && D(), {\n    stop: () => {\n      u && u(), w && w.stop();\n    },\n    /**\n     * animate() can't yet be sampled for time, instead it\n     * consumes time. So to sample it we have to run a low\n     * temporal-resolution version.\n     */\n    sample: (z) => {\n      r = A;\n      const Y = t && typeof t == \"number\" ? Math.max(t * 0.5, 50) : 50;\n      let L = 0;\n      for (M(0); L <= z; ) {\n        const m = z - L;\n        M(Math.min(m, Y)), L += Y;\n      }\n      return P;\n    }\n  };\n}\nfunction W_(t) {\n  return !t || // Default easing\n  Array.isArray(t) || typeof t == \"string\" && up[t];\n}\nconst Bn = ([t, e, r, n]) => `cubic-bezier(${t}, ${e}, ${r}, ${n})`, up = {\n  linear: \"linear\",\n  ease: \"ease\",\n  easeIn: \"ease-in\",\n  easeOut: \"ease-out\",\n  easeInOut: \"ease-in-out\",\n  circIn: Bn([0, 0.65, 0.55, 1]),\n  circOut: Bn([0.55, 0, 1, 0.45]),\n  backIn: Bn([0.31, 0.01, 0.66, -0.59]),\n  backOut: Bn([0.33, 1.53, 0.69, 0.99])\n};\nfunction z_(t) {\n  if (t)\n    return Array.isArray(t) ? Bn(t) : up[t];\n}\nfunction q_(t, e, r, { delay: n = 0, duration: i, repeat: o = 0, repeatType: a = \"loop\", ease: s, times: l } = {}) {\n  return t.animate({ [e]: r, offset: l }, {\n    delay: n,\n    duration: i,\n    easing: z_(s),\n    fill: \"both\",\n    iterations: o + 1,\n    direction: a === \"reverse\" ? \"alternate\" : \"normal\"\n  });\n}\nconst Uf = {\n  waapi: () => Object.hasOwnProperty.call(Element.prototype, \"animate\")\n}, ea = {}, lp = {};\nfor (const t in Uf)\n  lp[t] = () => (ea[t] === void 0 && (ea[t] = Uf[t]()), ea[t]);\nfunction K_(t, { repeat: e, repeatType: r = \"loop\" }) {\n  const n = e && r !== \"loop\" && e % 2 === 1 ? 0 : t.length - 1;\n  return t[n];\n}\nconst G_ = /* @__PURE__ */ new Set([\"opacity\"]), yi = 10;\nfunction Y_(t, e, { onUpdate: r, onComplete: n, ...i }) {\n  if (!(lp.waapi() && G_.has(e) && !i.repeatDelay && i.repeatType !== \"mirror\" && i.damping !== 0))\n    return !1;\n  let { keyframes: a, duration: s = 300, elapsed: l = 0, ease: u } = i;\n  if (i.type === \"spring\" || !W_(i.ease)) {\n    if (i.repeat === 1 / 0)\n      return;\n    const f = Po(i);\n    let h = { done: !1, value: a[0] };\n    const p = [];\n    let g = 0;\n    for (; !h.done && g < 2e4; )\n      h = f.sample(g), p.push(h.value), g += yi;\n    a = p, s = g - yi, u = \"linear\";\n  }\n  const c = q_(t.owner.current, e, a, {\n    ...i,\n    delay: -l,\n    duration: s,\n    /**\n     * This function is currently not called if ease is provided\n     * as a function so the cast is safe.\n     *\n     * However it would be possible for a future refinement to port\n     * in easing pregeneration from Motion One for browsers that\n     * support the upcoming `linear()` easing function.\n     */\n    ease: u\n  });\n  return c.onfinish = () => {\n    t.set(K_(a, i)), n && n();\n  }, () => {\n    const { currentTime: f } = c;\n    if (f) {\n      const h = Po({ ...i, autoplay: !1 });\n      t.setWithVelocity(h.sample(f - yi).value, h.sample(f).value, yi);\n    }\n    Tt.update(() => c.cancel());\n  };\n}\nfunction fp(t, e) {\n  const r = performance.now(), n = ({ timestamp: i }) => {\n    const o = i - r;\n    o >= e && (_r.read(n), t(o - e));\n  };\n  return Tt.read(n, !0), () => _r.read(n);\n}\nfunction Z_({ keyframes: t, elapsed: e, onUpdate: r, onComplete: n }) {\n  const i = () => (r && r(t[t.length - 1]), n && n(), () => {\n  });\n  return e ? fp(i, -e) : i();\n}\nfunction X_({ keyframes: t, velocity: e = 0, min: r, max: n, power: i = 0.8, timeConstant: o = 750, bounceStiffness: a = 500, bounceDamping: s = 10, restDelta: l = 1, modifyTarget: u, driver: c, onUpdate: f, onComplete: h, onStop: p }) {\n  const g = t[0];\n  let _;\n  function T(R) {\n    return r !== void 0 && R < r || n !== void 0 && R > n;\n  }\n  function A(R) {\n    return r === void 0 ? n : n === void 0 || Math.abs(r - R) < Math.abs(n - R) ? r : n;\n  }\n  function w(R) {\n    _ == null || _.stop(), _ = Po({\n      keyframes: [0, 1],\n      velocity: 0,\n      ...R,\n      driver: c,\n      onUpdate: ($) => {\n        var U;\n        f == null || f($), (U = R.onUpdate) === null || U === void 0 || U.call(R, $);\n      },\n      onComplete: h,\n      onStop: p\n    });\n  }\n  function O(R) {\n    w({\n      type: \"spring\",\n      stiffness: a,\n      damping: s,\n      restDelta: l,\n      ...R\n    });\n  }\n  if (T(g))\n    O({\n      velocity: e,\n      keyframes: [g, A(g)]\n    });\n  else {\n    let R = i * e + g;\n    typeof u < \"u\" && (R = u(R));\n    const $ = A(R), U = $ === r ? -1 : 1;\n    let W, G;\n    const Z = (j) => {\n      W = G, G = j, e = cu(j - W, lr.delta), (U === 1 && j > $ || U === -1 && j < $) && O({ keyframes: [j, $], velocity: e });\n    };\n    w({\n      type: \"decay\",\n      keyframes: [g, 0],\n      velocity: e,\n      timeConstant: o,\n      power: i,\n      restDelta: l,\n      modifyTarget: u,\n      onUpdate: T(R) ? Z : void 0\n    });\n  }\n  return {\n    stop: () => _ == null ? void 0 : _.stop()\n  };\n}\nconst Mr = () => ({\n  type: \"spring\",\n  stiffness: 500,\n  damping: 25,\n  restSpeed: 10\n}), mi = (t) => ({\n  type: \"spring\",\n  stiffness: 550,\n  damping: t === 0 ? 2 * Math.sqrt(550) : 30,\n  restSpeed: 10\n}), ta = () => ({\n  type: \"keyframes\",\n  ease: \"linear\",\n  duration: 0.3\n}), J_ = {\n  type: \"keyframes\",\n  duration: 0.8\n}, Vf = {\n  x: Mr,\n  y: Mr,\n  z: Mr,\n  rotate: Mr,\n  rotateX: Mr,\n  rotateY: Mr,\n  rotateZ: Mr,\n  scaleX: mi,\n  scaleY: mi,\n  scale: mi,\n  opacity: ta,\n  backgroundColor: ta,\n  color: ta,\n  default: mi\n}, Q_ = (t, { keyframes: e }) => e.length > 2 ? J_ : (Vf[t] || Vf.default)(e[1]), Na = (t, e) => t === \"zIndex\" ? !1 : !!(typeof e == \"number\" || Array.isArray(e) || typeof e == \"string\" && // It's animatable if we have a string\nAr.test(e) && // And it contains numbers and/or colors\n!e.startsWith(\"url(\"));\nfunction eA({ when: t, delay: e, delayChildren: r, staggerChildren: n, staggerDirection: i, repeat: o, repeatType: a, repeatDelay: s, from: l, elapsed: u, ...c }) {\n  return !!Object.keys(c).length;\n}\nfunction $f(t) {\n  return t === 0 || typeof t == \"string\" && parseFloat(t) === 0 && t.indexOf(\" \") === -1;\n}\nfunction Hf(t) {\n  return typeof t == \"number\" ? 0 : fu(\"\", t);\n}\nfunction hp(t, e) {\n  return t[e] || t.default || t;\n}\nfunction tA(t, e, r, n) {\n  const i = Na(e, r);\n  let o = n.from !== void 0 ? n.from : t.get();\n  return o === \"none\" && i && typeof r == \"string\" ? o = fu(e, r) : $f(o) && typeof r == \"string\" ? o = Hf(r) : !Array.isArray(r) && $f(r) && typeof o == \"string\" && (r = Hf(o)), Array.isArray(r) ? (r[0] === null && (r[0] = o), r) : [o, r];\n}\nconst xu = (t, e, r, n = {}) => (i) => {\n  const o = hp(n, t) || {}, a = o.delay || n.delay || 0;\n  let { elapsed: s = 0 } = n;\n  s = s - Si(a);\n  const l = tA(e, t, r, o), u = l[0], c = l[l.length - 1], f = Na(t, u), h = Na(t, c);\n  ns(f === h, `You are trying to animate ${t} from \"${u}\" to \"${c}\". ${u} is not an animatable value - to enable this animation set ${u} to a value animatable to ${c} via the \\`style\\` property.`);\n  let p = {\n    keyframes: l,\n    velocity: e.getVelocity(),\n    ...o,\n    elapsed: s,\n    onUpdate: (A) => {\n      e.set(A), o.onUpdate && o.onUpdate(A);\n    },\n    onComplete: () => {\n      i(), o.onComplete && o.onComplete();\n    }\n  };\n  if (!f || !h || l_.current || o.type === !1)\n    return Z_(p);\n  if (o.type === \"inertia\") {\n    const A = X_(p);\n    return () => A.stop();\n  }\n  eA(o) || (p = {\n    ...p,\n    ...Q_(t, p)\n  }), p.duration && (p.duration = Si(p.duration)), p.repeatDelay && (p.repeatDelay = Si(p.repeatDelay));\n  const g = e.owner, _ = g && g.current;\n  if (g && _ instanceof HTMLElement && !(g != null && g.getProps().onUpdate)) {\n    const A = Y_(e, t, p);\n    if (A)\n      return A;\n  }\n  const T = Po(p);\n  return () => T.stop();\n};\nfunction rA(t, e, r = {}) {\n  t.notify(\"AnimationStart\", e);\n  let n;\n  if (Array.isArray(e)) {\n    const i = e.map((o) => Fa(t, o, r));\n    n = Promise.all(i);\n  } else if (typeof e == \"string\")\n    n = Fa(t, e, r);\n  else {\n    const i = typeof e == \"function\" ? rs(t, e, r.custom) : e;\n    n = dp(t, i, r);\n  }\n  return n.then(() => t.notify(\"AnimationComplete\", e));\n}\nfunction Fa(t, e, r = {}) {\n  var n;\n  const i = rs(t, e, r.custom);\n  let { transition: o = t.getDefaultTransition() || {} } = i || {};\n  r.transitionOverride && (o = r.transitionOverride);\n  const a = i ? () => dp(t, i, r) : () => Promise.resolve(), s = !((n = t.variantChildren) === null || n === void 0) && n.size ? (u = 0) => {\n    const { delayChildren: c = 0, staggerChildren: f, staggerDirection: h } = o;\n    return nA(t, e, c + u, f, h, r);\n  } : () => Promise.resolve(), { when: l } = o;\n  if (l) {\n    const [u, c] = l === \"beforeChildren\" ? [a, s] : [s, a];\n    return u().then(c);\n  } else\n    return Promise.all([a(), s(r.delay)]);\n}\nfunction dp(t, e, { delay: r = 0, transitionOverride: n, type: i } = {}) {\n  var o;\n  let { transition: a = t.getDefaultTransition(), transitionEnd: s, ...l } = t.makeTargetAnimatable(e);\n  const u = t.getValue(\"willChange\");\n  n && (a = n);\n  const c = [], f = i && ((o = t.animationState) === null || o === void 0 ? void 0 : o.getState()[i]);\n  for (const h in l) {\n    const p = t.getValue(h), g = l[h];\n    if (!p || g === void 0 || f && oA(f, h))\n      continue;\n    let _ = { delay: r, elapsed: 0, ...a };\n    if (t.shouldReduceMotion && Hr.has(h) && (_ = {\n      ..._,\n      type: !1,\n      delay: 0\n    }), !p.hasAnimated) {\n      const A = t.getProps()[u_];\n      A && (_.elapsed = a_(A, h));\n    }\n    let T = p.start(xu(h, p, g, _));\n    Eo(u) && (u.add(h), T = T.then(() => u.remove(h))), c.push(T);\n  }\n  return Promise.all(c).then(() => {\n    s && r_(t, s);\n  });\n}\nfunction nA(t, e, r = 0, n = 0, i = 1, o) {\n  const a = [], s = (t.variantChildren.size - 1) * n, l = i === 1 ? (u = 0) => u * n : (u = 0) => s - u * n;\n  return Array.from(t.variantChildren).sort(iA).forEach((u, c) => {\n    u.notify(\"AnimationStart\", e), a.push(Fa(u, e, {\n      ...o,\n      delay: r + l(c)\n    }).then(() => u.notify(\"AnimationComplete\", e)));\n  }), Promise.all(a);\n}\nfunction iA(t, e) {\n  return t.sortNodePosition(e);\n}\nfunction oA({ protectedKeys: t, needsAnimating: e }, r) {\n  const n = t.hasOwnProperty(r) && e[r] !== !0;\n  return e[r] = !1, n;\n}\nconst wu = [\n  Xe.Animate,\n  Xe.InView,\n  Xe.Focus,\n  Xe.Hover,\n  Xe.Tap,\n  Xe.Drag,\n  Xe.Exit\n], sA = [...wu].reverse(), aA = wu.length;\nfunction cA(t) {\n  return (e) => Promise.all(e.map(({ animation: r, options: n }) => rA(t, r, n)));\n}\nfunction uA(t) {\n  let e = cA(t);\n  const r = fA();\n  let n = !0;\n  const i = (l, u) => {\n    const c = rs(t, u);\n    if (c) {\n      const { transition: f, transitionEnd: h, ...p } = c;\n      l = { ...l, ...p, ...h };\n    }\n    return l;\n  };\n  function o(l) {\n    e = l(t);\n  }\n  function a(l, u) {\n    const c = t.getProps(), f = t.getVariantContext(!0) || {}, h = [], p = /* @__PURE__ */ new Set();\n    let g = {}, _ = 1 / 0;\n    for (let A = 0; A < aA; A++) {\n      const w = sA[A], O = r[w], R = c[w] !== void 0 ? c[w] : f[w], $ = qn(R), U = w === u ? O.isActive : null;\n      U === !1 && (_ = A);\n      let W = R === f[w] && R !== c[w] && $;\n      if (W && n && t.manuallyAnimateOnMount && (W = !1), O.protectedKeys = { ...g }, !O.isActive && U === null || !R && !O.prevProp || // Or if the prop doesn't define an animation\n      Yo(R) || typeof R == \"boolean\")\n        continue;\n      const G = lA(O.prevProp, R);\n      let Z = G || w === u && O.isActive && !W && $ || A > _ && $;\n      const j = Array.isArray(R) ? R : [R];\n      let P = j.reduce(i, {});\n      U === !1 && (P = {});\n      const { prevResolvedValues: d = {} } = O, x = {\n        ...d,\n        ...P\n      }, C = (M) => {\n        Z = !0, p.delete(M), O.needsAnimating[M] = !0;\n      };\n      for (const M in x) {\n        const D = P[M], z = d[M];\n        g.hasOwnProperty(M) || (D !== z ? _o(D) && _o(z) ? !Vd(D, z) || G ? C(M) : O.protectedKeys[M] = !0 : D !== void 0 ? C(M) : p.add(M) : D !== void 0 && p.has(M) ? C(M) : O.protectedKeys[M] = !0);\n      }\n      O.prevProp = R, O.prevResolvedValues = P, O.isActive && (g = { ...g, ...P }), n && t.blockInitialAnimation && (Z = !1), Z && !W && h.push(...j.map((M) => ({\n        animation: M,\n        options: { type: w, ...l }\n      })));\n    }\n    if (p.size) {\n      const A = {};\n      p.forEach((w) => {\n        const O = t.getBaseTarget(w);\n        O !== void 0 && (A[w] = O);\n      }), h.push({ animation: A });\n    }\n    let T = Boolean(h.length);\n    return n && c.initial === !1 && !t.manuallyAnimateOnMount && (T = !1), n = !1, T ? e(h) : Promise.resolve();\n  }\n  function s(l, u, c) {\n    var f;\n    if (r[l].isActive === u)\n      return Promise.resolve();\n    (f = t.variantChildren) === null || f === void 0 || f.forEach((p) => {\n      var g;\n      return (g = p.animationState) === null || g === void 0 ? void 0 : g.setActive(l, u);\n    }), r[l].isActive = u;\n    const h = a(c, l);\n    for (const p in r)\n      r[p].protectedKeys = {};\n    return h;\n  }\n  return {\n    animateChanges: a,\n    setActive: s,\n    setAnimateFunction: o,\n    getState: () => r\n  };\n}\nfunction lA(t, e) {\n  return typeof e == \"string\" ? e !== t : Array.isArray(e) ? !Vd(e, t) : !1;\n}\nfunction kr(t = !1) {\n  return {\n    isActive: t,\n    protectedKeys: {},\n    needsAnimating: {},\n    prevResolvedValues: {}\n  };\n}\nfunction fA() {\n  return {\n    [Xe.Animate]: kr(!0),\n    [Xe.InView]: kr(),\n    [Xe.Hover]: kr(),\n    [Xe.Tap]: kr(),\n    [Xe.Drag]: kr(),\n    [Xe.Focus]: kr(),\n    [Xe.Exit]: kr()\n  };\n}\nconst hA = {\n  animation: wr(({ visualElement: t, animate: e }) => {\n    t.animationState || (t.animationState = uA(t)), Yo(e) && (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => e.subscribe(t), [e]);\n  }),\n  exit: wr((t) => {\n    const { custom: e, visualElement: r } = t, [n, i] = Ud(), o = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(ii);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n      r.isPresent = n;\n      const a = r.animationState && r.animationState.setActive(Xe.Exit, !n, {\n        custom: o && o.custom || e\n      });\n      a && !n && a.then(i);\n    }, [n]);\n  })\n}, Wf = (t, e) => Math.abs(t - e);\nfunction dA(t, e) {\n  const r = Wf(t.x, e.x), n = Wf(t.y, e.y);\n  return Math.sqrt(r ** 2 + n ** 2);\n}\nclass pp {\n  constructor(e, r, { transformPagePoint: n } = {}) {\n    if (this.startEvent = null, this.lastMoveEvent = null, this.lastMoveEventInfo = null, this.handlers = {}, this.updatePoint = () => {\n      if (!(this.lastMoveEvent && this.lastMoveEventInfo))\n        return;\n      const u = na(this.lastMoveEventInfo, this.history), c = this.startEvent !== null, f = dA(u.offset, { x: 0, y: 0 }) >= 3;\n      if (!c && !f)\n        return;\n      const { point: h } = u, { timestamp: p } = lr;\n      this.history.push({ ...h, timestamp: p });\n      const { onStart: g, onMove: _ } = this.handlers;\n      c || (g && g(this.lastMoveEvent, u), this.startEvent = this.lastMoveEvent), _ && _(this.lastMoveEvent, u);\n    }, this.handlePointerMove = (u, c) => {\n      this.lastMoveEvent = u, this.lastMoveEventInfo = ra(c, this.transformPagePoint), Tt.update(this.updatePoint, !0);\n    }, this.handlePointerUp = (u, c) => {\n      this.end();\n      const { onEnd: f, onSessionEnd: h } = this.handlers, p = na(ra(c, this.transformPagePoint), this.history);\n      this.startEvent && f && f(u, p), h && h(u, p);\n    }, !Id(e))\n      return;\n    this.handlers = r, this.transformPagePoint = n;\n    const i = nu(e), o = ra(i, this.transformPagePoint), { point: a } = o, { timestamp: s } = lr;\n    this.history = [{ ...a, timestamp: s }];\n    const { onSessionStart: l } = r;\n    l && l(e, na(o, this.history)), this.removeListeners = Qo(cn(window, \"pointermove\", this.handlePointerMove), cn(window, \"pointerup\", this.handlePointerUp), cn(window, \"pointercancel\", this.handlePointerUp));\n  }\n  updateHandlers(e) {\n    this.handlers = e;\n  }\n  end() {\n    this.removeListeners && this.removeListeners(), _r.update(this.updatePoint);\n  }\n}\nfunction ra(t, e) {\n  return e ? { point: e(t.point) } : t;\n}\nfunction zf(t, e) {\n  return { x: t.x - e.x, y: t.y - e.y };\n}\nfunction na({ point: t }, e) {\n  return {\n    point: t,\n    delta: zf(t, yp(e)),\n    offset: zf(t, pA(e)),\n    velocity: yA(e, 0.1)\n  };\n}\nfunction pA(t) {\n  return t[0];\n}\nfunction yp(t) {\n  return t[t.length - 1];\n}\nfunction yA(t, e) {\n  if (t.length < 2)\n    return { x: 0, y: 0 };\n  let r = t.length - 1, n = null;\n  const i = yp(t);\n  for (; r >= 0 && (n = t[r], !(i.timestamp - n.timestamp > Si(e))); )\n    r--;\n  if (!n)\n    return { x: 0, y: 0 };\n  const o = (i.timestamp - n.timestamp) / 1e3;\n  if (o === 0)\n    return { x: 0, y: 0 };\n  const a = {\n    x: (i.x - n.x) / o,\n    y: (i.y - n.y) / o\n  };\n  return a.x === 1 / 0 && (a.x = 0), a.y === 1 / 0 && (a.y = 0), a;\n}\nfunction Bt(t) {\n  return t.max - t.min;\n}\nfunction La(t, e = 0, r = 0.01) {\n  return Math.abs(t - e) <= r;\n}\nfunction qf(t, e, r, n = 0.5) {\n  t.origin = n, t.originPoint = ct(e.min, e.max, t.origin), t.scale = Bt(r) / Bt(e), (La(t.scale, 1, 1e-4) || isNaN(t.scale)) && (t.scale = 1), t.translate = ct(r.min, r.max, t.origin) - t.originPoint, (La(t.translate) || isNaN(t.translate)) && (t.translate = 0);\n}\nfunction jn(t, e, r, n) {\n  qf(t.x, e.x, r.x, n == null ? void 0 : n.originX), qf(t.y, e.y, r.y, n == null ? void 0 : n.originY);\n}\nfunction Kf(t, e, r) {\n  t.min = r.min + e.min, t.max = t.min + Bt(e);\n}\nfunction mA(t, e, r) {\n  Kf(t.x, e.x, r.x), Kf(t.y, e.y, r.y);\n}\nfunction Gf(t, e, r) {\n  t.min = e.min - r.min, t.max = t.min + Bt(e);\n}\nfunction Un(t, e, r) {\n  Gf(t.x, e.x, r.x), Gf(t.y, e.y, r.y);\n}\nfunction vA(t, { min: e, max: r }, n) {\n  return e !== void 0 && t < e ? t = n ? ct(e, t, n.min) : Math.max(t, e) : r !== void 0 && t > r && (t = n ? ct(r, t, n.max) : Math.min(t, r)), t;\n}\nfunction Yf(t, e, r) {\n  return {\n    min: e !== void 0 ? t.min + e : void 0,\n    max: r !== void 0 ? t.max + r - (t.max - t.min) : void 0\n  };\n}\nfunction gA(t, { top: e, left: r, bottom: n, right: i }) {\n  return {\n    x: Yf(t.x, r, i),\n    y: Yf(t.y, e, n)\n  };\n}\nfunction Zf(t, e) {\n  let r = e.min - t.min, n = e.max - t.max;\n  return e.max - e.min < t.max - t.min && ([r, n] = [n, r]), { min: r, max: n };\n}\nfunction xA(t, e) {\n  return {\n    x: Zf(t.x, e.x),\n    y: Zf(t.y, e.y)\n  };\n}\nfunction wA(t, e) {\n  let r = 0.5;\n  const n = Bt(t), i = Bt(e);\n  return i > n ? r = So(e.min, e.max - n, t.min) : n > i && (r = So(t.min, t.max - i, e.min)), mn(0, 1, r);\n}\nfunction bA(t, e) {\n  const r = {};\n  return e.min !== void 0 && (r.min = e.min - t.min), e.max !== void 0 && (r.max = e.max - t.min), r;\n}\nconst ja = 0.35;\nfunction _A(t = ja) {\n  return t === !1 ? t = 0 : t === !0 && (t = ja), {\n    x: Xf(t, \"left\", \"right\"),\n    y: Xf(t, \"top\", \"bottom\")\n  };\n}\nfunction Xf(t, e, r) {\n  return {\n    min: Jf(t, e),\n    max: Jf(t, r)\n  };\n}\nfunction Jf(t, e) {\n  return typeof t == \"number\" ? t : t[e] || 0;\n}\nconst Qf = () => ({\n  translate: 0,\n  scale: 1,\n  origin: 0,\n  originPoint: 0\n}), Vn = () => ({\n  x: Qf(),\n  y: Qf()\n}), e0 = () => ({ min: 0, max: 0 }), dt = () => ({\n  x: e0(),\n  y: e0()\n});\nfunction Xt(t) {\n  return [t(\"x\"), t(\"y\")];\n}\nfunction mp({ top: t, left: e, right: r, bottom: n }) {\n  return {\n    x: { min: e, max: r },\n    y: { min: t, max: n }\n  };\n}\nfunction AA({ x: t, y: e }) {\n  return { top: e.min, right: t.max, bottom: e.max, left: t.min };\n}\nfunction TA(t, e) {\n  if (!e)\n    return t;\n  const r = e({ x: t.left, y: t.top }), n = e({ x: t.right, y: t.bottom });\n  return {\n    top: r.y,\n    left: r.x,\n    bottom: n.y,\n    right: n.x\n  };\n}\nfunction ia(t) {\n  return t === void 0 || t === 1;\n}\nfunction Ua({ scale: t, scaleX: e, scaleY: r }) {\n  return !ia(t) || !ia(e) || !ia(r);\n}\nfunction Br(t) {\n  return Ua(t) || vp(t) || t.z || t.rotate || t.rotateX || t.rotateY;\n}\nfunction vp(t) {\n  return t0(t.x) || t0(t.y);\n}\nfunction t0(t) {\n  return t && t !== \"0%\";\n}\nfunction Co(t, e, r) {\n  const n = t - r, i = e * n;\n  return r + i;\n}\nfunction r0(t, e, r, n, i) {\n  return i !== void 0 && (t = Co(t, i, n)), Co(t, r, n) + e;\n}\nfunction Va(t, e = 0, r = 1, n, i) {\n  t.min = r0(t.min, e, r, n, i), t.max = r0(t.max, e, r, n, i);\n}\nfunction gp(t, { x: e, y: r }) {\n  Va(t.x, e.translate, e.scale, e.originPoint), Va(t.y, r.translate, r.scale, r.originPoint);\n}\nfunction EA(t, e, r, n = !1) {\n  var i, o;\n  const a = r.length;\n  if (!a)\n    return;\n  e.x = e.y = 1;\n  let s, l;\n  for (let u = 0; u < a; u++)\n    s = r[u], l = s.projectionDelta, ((o = (i = s.instance) === null || i === void 0 ? void 0 : i.style) === null || o === void 0 ? void 0 : o.display) !== \"contents\" && (n && s.options.layoutScroll && s.scroll && s !== s.root && on(t, {\n      x: -s.scroll.offset.x,\n      y: -s.scroll.offset.y\n    }), l && (e.x *= l.x.scale, e.y *= l.y.scale, gp(t, l)), n && Br(s.latestValues) && on(t, s.latestValues));\n  e.x = n0(e.x), e.y = n0(e.y);\n}\nfunction n0(t) {\n  return Number.isInteger(t) || t > 1.0000000000001 || t < 0.999999999999 ? t : 1;\n}\nfunction vr(t, e) {\n  t.min = t.min + e, t.max = t.max + e;\n}\nfunction i0(t, e, [r, n, i]) {\n  const o = e[i] !== void 0 ? e[i] : 0.5, a = ct(t.min, t.max, o);\n  Va(t, e[r], e[n], a, e.scale);\n}\nconst SA = [\"x\", \"scaleX\", \"originX\"], PA = [\"y\", \"scaleY\", \"originY\"];\nfunction on(t, e) {\n  i0(t.x, e, SA), i0(t.y, e, PA);\n}\nfunction xp(t, e) {\n  return mp(TA(t.getBoundingClientRect(), e));\n}\nfunction CA(t, e, r) {\n  const n = xp(t, r), { scroll: i } = e;\n  return i && (vr(n.x, i.offset.x), vr(n.y, i.offset.y)), n;\n}\nconst OA = /* @__PURE__ */ new WeakMap();\nclass MA {\n  constructor(e) {\n    this.openGlobalLock = null, this.isDragging = !1, this.currentDirection = null, this.originPoint = { x: 0, y: 0 }, this.constraints = !1, this.hasMutatedConstraints = !1, this.elastic = dt(), this.visualElement = e;\n  }\n  start(e, { snapToCursor: r = !1 } = {}) {\n    if (this.visualElement.isPresent === !1)\n      return;\n    const n = (s) => {\n      this.stopAnimation(), r && this.snapToCursor(nu(s, \"page\").point);\n    }, i = (s, l) => {\n      var u;\n      const { drag: c, dragPropagation: f, onDragStart: h } = this.getProps();\n      c && !f && (this.openGlobalLock && this.openGlobalLock(), this.openGlobalLock = Fd(c), !this.openGlobalLock) || (this.isDragging = !0, this.currentDirection = null, this.resolveConstraints(), this.visualElement.projection && (this.visualElement.projection.isAnimationBlocked = !0, this.visualElement.projection.target = void 0), Xt((p) => {\n        var g, _;\n        let T = this.getAxisMotionValue(p).get() || 0;\n        if (rr.test(T)) {\n          const A = (_ = (g = this.visualElement.projection) === null || g === void 0 ? void 0 : g.layout) === null || _ === void 0 ? void 0 : _.layoutBox[p];\n          A && (T = Bt(A) * (parseFloat(T) / 100));\n        }\n        this.originPoint[p] = T;\n      }), h == null || h(s, l), (u = this.visualElement.animationState) === null || u === void 0 || u.setActive(Xe.Drag, !0));\n    }, o = (s, l) => {\n      const { dragPropagation: u, dragDirectionLock: c, onDirectionLock: f, onDrag: h } = this.getProps();\n      if (!u && !this.openGlobalLock)\n        return;\n      const { offset: p } = l;\n      if (c && this.currentDirection === null) {\n        this.currentDirection = kA(p), this.currentDirection !== null && (f == null || f(this.currentDirection));\n        return;\n      }\n      this.updateAxis(\"x\", l.point, p), this.updateAxis(\"y\", l.point, p), this.visualElement.render(), h == null || h(s, l);\n    }, a = (s, l) => this.stop(s, l);\n    this.panSession = new pp(e, {\n      onSessionStart: n,\n      onStart: i,\n      onMove: o,\n      onSessionEnd: a\n    }, { transformPagePoint: this.visualElement.getTransformPagePoint() });\n  }\n  stop(e, r) {\n    const n = this.isDragging;\n    if (this.cancel(), !n)\n      return;\n    const { velocity: i } = r;\n    this.startAnimation(i);\n    const { onDragEnd: o } = this.getProps();\n    o == null || o(e, r);\n  }\n  cancel() {\n    var e, r;\n    this.isDragging = !1, this.visualElement.projection && (this.visualElement.projection.isAnimationBlocked = !1), (e = this.panSession) === null || e === void 0 || e.end(), this.panSession = void 0;\n    const { dragPropagation: n } = this.getProps();\n    !n && this.openGlobalLock && (this.openGlobalLock(), this.openGlobalLock = null), (r = this.visualElement.animationState) === null || r === void 0 || r.setActive(Xe.Drag, !1);\n  }\n  updateAxis(e, r, n) {\n    const { drag: i } = this.getProps();\n    if (!n || !vi(e, i, this.currentDirection))\n      return;\n    const o = this.getAxisMotionValue(e);\n    let a = this.originPoint[e] + n[e];\n    this.constraints && this.constraints[e] && (a = vA(a, this.constraints[e], this.elastic[e])), o.set(a);\n  }\n  resolveConstraints() {\n    const { dragConstraints: e, dragElastic: r } = this.getProps(), { layout: n } = this.visualElement.projection || {}, i = this.constraints;\n    e && rn(e) ? this.constraints || (this.constraints = this.resolveRefConstraints()) : e && n ? this.constraints = gA(n.layoutBox, e) : this.constraints = !1, this.elastic = _A(r), i !== this.constraints && n && this.constraints && !this.hasMutatedConstraints && Xt((o) => {\n      this.getAxisMotionValue(o) && (this.constraints[o] = bA(n.layoutBox[o], this.constraints[o]));\n    });\n  }\n  resolveRefConstraints() {\n    const { dragConstraints: e, onMeasureDragConstraints: r } = this.getProps();\n    if (!e || !rn(e))\n      return !1;\n    const n = e.current;\n    Gt(n !== null, \"If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop.\");\n    const { projection: i } = this.visualElement;\n    if (!i || !i.layout)\n      return !1;\n    const o = CA(n, i.root, this.visualElement.getTransformPagePoint());\n    let a = xA(i.layout.layoutBox, o);\n    if (r) {\n      const s = r(AA(a));\n      this.hasMutatedConstraints = !!s, s && (a = mp(s));\n    }\n    return a;\n  }\n  startAnimation(e) {\n    const { drag: r, dragMomentum: n, dragElastic: i, dragTransition: o, dragSnapToOrigin: a, onDragTransitionEnd: s } = this.getProps(), l = this.constraints || {}, u = Xt((c) => {\n      if (!vi(c, r, this.currentDirection))\n        return;\n      let f = (l == null ? void 0 : l[c]) || {};\n      a && (f = { min: 0, max: 0 });\n      const h = i ? 200 : 1e6, p = i ? 40 : 1e7, g = {\n        type: \"inertia\",\n        velocity: n ? e[c] : 0,\n        bounceStiffness: h,\n        bounceDamping: p,\n        timeConstant: 750,\n        restDelta: 1,\n        restSpeed: 10,\n        ...o,\n        ...f\n      };\n      return this.startAxisValueAnimation(c, g);\n    });\n    return Promise.all(u).then(s);\n  }\n  startAxisValueAnimation(e, r) {\n    const n = this.getAxisMotionValue(e);\n    return n.start(xu(e, n, 0, r));\n  }\n  stopAnimation() {\n    Xt((e) => this.getAxisMotionValue(e).stop());\n  }\n  /**\n   * Drag works differently depending on which props are provided.\n   *\n   * - If _dragX and _dragY are provided, we output the gesture delta directly to those motion values.\n   * - Otherwise, we apply the delta to the x/y motion values.\n   */\n  getAxisMotionValue(e) {\n    var r;\n    const n = \"_drag\" + e.toUpperCase(), i = this.visualElement.getProps()[n];\n    return i || this.visualElement.getValue(e, ((r = this.visualElement.getProps().initial) === null || r === void 0 ? void 0 : r[e]) || 0);\n  }\n  snapToCursor(e) {\n    Xt((r) => {\n      const { drag: n } = this.getProps();\n      if (!vi(r, n, this.currentDirection))\n        return;\n      const { projection: i } = this.visualElement, o = this.getAxisMotionValue(r);\n      if (i && i.layout) {\n        const { min: a, max: s } = i.layout.layoutBox[r];\n        o.set(e[r] - ct(a, s, 0.5));\n      }\n    });\n  }\n  /**\n   * When the viewport resizes we want to check if the measured constraints\n   * have changed and, if so, reposition the element within those new constraints\n   * relative to where it was before the resize.\n   */\n  scalePositionWithinConstraints() {\n    var e;\n    if (!this.visualElement.current)\n      return;\n    const { drag: r, dragConstraints: n } = this.getProps(), { projection: i } = this.visualElement;\n    if (!rn(n) || !i || !this.constraints)\n      return;\n    this.stopAnimation();\n    const o = { x: 0, y: 0 };\n    Xt((s) => {\n      const l = this.getAxisMotionValue(s);\n      if (l) {\n        const u = l.get();\n        o[s] = wA({ min: u, max: u }, this.constraints[s]);\n      }\n    });\n    const { transformTemplate: a } = this.visualElement.getProps();\n    this.visualElement.current.style.transform = a ? a({}, \"\") : \"none\", (e = i.root) === null || e === void 0 || e.updateScroll(), i.updateLayout(), this.resolveConstraints(), Xt((s) => {\n      if (!vi(s, r, null))\n        return;\n      const l = this.getAxisMotionValue(s), { min: u, max: c } = this.constraints[s];\n      l.set(ct(u, c, o[s]));\n    });\n  }\n  addListeners() {\n    var e;\n    if (!this.visualElement.current)\n      return;\n    OA.set(this.visualElement, this);\n    const r = this.visualElement.current, n = cn(r, \"pointerdown\", (u) => {\n      const { drag: c, dragListener: f = !0 } = this.getProps();\n      c && f && this.start(u);\n    }), i = () => {\n      const { dragConstraints: u } = this.getProps();\n      rn(u) && (this.constraints = this.resolveRefConstraints());\n    }, { projection: o } = this.visualElement, a = o.addEventListener(\"measure\", i);\n    o && !o.layout && ((e = o.root) === null || e === void 0 || e.updateScroll(), o.updateLayout()), i();\n    const s = Jo(window, \"resize\", () => this.scalePositionWithinConstraints()), l = o.addEventListener(\"didUpdate\", ({ delta: u, hasLayoutChanged: c }) => {\n      this.isDragging && c && (Xt((f) => {\n        const h = this.getAxisMotionValue(f);\n        h && (this.originPoint[f] += u[f].translate, h.set(h.get() + u[f].translate));\n      }), this.visualElement.render());\n    });\n    return () => {\n      s(), n(), a(), l == null || l();\n    };\n  }\n  getProps() {\n    const e = this.visualElement.getProps(), { drag: r = !1, dragDirectionLock: n = !1, dragPropagation: i = !1, dragConstraints: o = !1, dragElastic: a = ja, dragMomentum: s = !0 } = e;\n    return {\n      ...e,\n      drag: r,\n      dragDirectionLock: n,\n      dragPropagation: i,\n      dragConstraints: o,\n      dragElastic: a,\n      dragMomentum: s\n    };\n  }\n}\nfunction vi(t, e, r) {\n  return (e === !0 || e === t) && (r === null || r === t);\n}\nfunction kA(t, e = 10) {\n  let r = null;\n  return Math.abs(t.y) > e ? r = \"y\" : Math.abs(t.x) > e && (r = \"x\"), r;\n}\nfunction RA(t) {\n  const { dragControls: e, visualElement: r } = t, n = Xo(() => new MA(r));\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => e && e.subscribe(n), [n, e]), (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => n.addListeners(), [n]);\n}\nfunction BA({ onPan: t, onPanStart: e, onPanEnd: r, onPanSessionStart: n, visualElement: i }) {\n  const o = t || e || r || n, a = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null), { transformPagePoint: s } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(Kc), l = {\n    onSessionStart: n,\n    onStart: e,\n    onMove: t,\n    onEnd: (c, f) => {\n      a.current = null, r && r(c, f);\n    }\n  };\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    a.current !== null && a.current.updateHandlers(l);\n  });\n  function u(c) {\n    a.current = new pp(c, l, {\n      transformPagePoint: s\n    });\n  }\n  Ao(i, \"pointerdown\", o && u), iu(() => a.current && a.current.end());\n}\nconst IA = {\n  pan: wr(BA),\n  drag: wr(RA)\n};\nfunction $a(t) {\n  return typeof t == \"string\" && t.startsWith(\"var(--\");\n}\nconst wp = /var\\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\\)/;\nfunction DA(t) {\n  const e = wp.exec(t);\n  if (!e)\n    return [,];\n  const [, r, n] = e;\n  return [r, n];\n}\nconst NA = 4;\nfunction Ha(t, e, r = 1) {\n  Gt(r <= NA, `Max CSS variable fallback depth detected in property \"${t}\". This may indicate a circular fallback dependency.`);\n  const [n, i] = DA(t);\n  if (!n)\n    return;\n  const o = window.getComputedStyle(e).getPropertyValue(n);\n  return o ? o.trim() : $a(i) ? Ha(i, e, r + 1) : i;\n}\nfunction FA(t, { ...e }, r) {\n  const n = t.current;\n  if (!(n instanceof Element))\n    return { target: e, transitionEnd: r };\n  r && (r = { ...r }), t.values.forEach((i) => {\n    const o = i.get();\n    if (!$a(o))\n      return;\n    const a = Ha(o, n);\n    a && i.set(a);\n  });\n  for (const i in e) {\n    const o = e[i];\n    if (!$a(o))\n      continue;\n    const a = Ha(o, n);\n    a && (e[i] = a, r && r[i] === void 0 && (r[i] = o));\n  }\n  return { target: e, transitionEnd: r };\n}\nconst LA = /* @__PURE__ */ new Set([\n  \"width\",\n  \"height\",\n  \"top\",\n  \"left\",\n  \"right\",\n  \"bottom\",\n  \"x\",\n  \"y\"\n]), bp = (t) => LA.has(t), jA = (t) => Object.keys(t).some(bp), gi = (t) => t === Wr || t === Ce;\nvar o0;\n(function(t) {\n  t.width = \"width\", t.height = \"height\", t.left = \"left\", t.right = \"right\", t.top = \"top\", t.bottom = \"bottom\";\n})(o0 || (o0 = {}));\nconst s0 = (t, e) => parseFloat(t.split(\", \")[e]), a0 = (t, e) => (r, { transform: n }) => {\n  if (n === \"none\" || !n)\n    return 0;\n  const i = n.match(/^matrix3d\\((.+)\\)$/);\n  if (i)\n    return s0(i[1], e);\n  {\n    const o = n.match(/^matrix\\((.+)\\)$/);\n    return o ? s0(o[1], t) : 0;\n  }\n}, UA = /* @__PURE__ */ new Set([\"x\", \"y\", \"z\"]), VA = wo.filter((t) => !UA.has(t));\nfunction $A(t) {\n  const e = [];\n  return VA.forEach((r) => {\n    const n = t.getValue(r);\n    n !== void 0 && (e.push([r, n.get()]), n.set(r.startsWith(\"scale\") ? 1 : 0));\n  }), e.length && t.render(), e;\n}\nconst c0 = {\n  // Dimensions\n  width: ({ x: t }, { paddingLeft: e = \"0\", paddingRight: r = \"0\" }) => t.max - t.min - parseFloat(e) - parseFloat(r),\n  height: ({ y: t }, { paddingTop: e = \"0\", paddingBottom: r = \"0\" }) => t.max - t.min - parseFloat(e) - parseFloat(r),\n  top: (t, { top: e }) => parseFloat(e),\n  left: (t, { left: e }) => parseFloat(e),\n  bottom: ({ y: t }, { top: e }) => parseFloat(e) + (t.max - t.min),\n  right: ({ x: t }, { left: e }) => parseFloat(e) + (t.max - t.min),\n  // Transform\n  x: a0(4, 13),\n  y: a0(5, 14)\n}, HA = (t, e, r) => {\n  const n = e.measureViewportBox(), i = e.current, o = getComputedStyle(i), { display: a } = o, s = {};\n  a === \"none\" && e.setStaticValue(\"display\", t.display || \"block\"), r.forEach((u) => {\n    s[u] = c0[u](n, o);\n  }), e.render();\n  const l = e.measureViewportBox();\n  return r.forEach((u) => {\n    const c = e.getValue(u);\n    c && c.jump(s[u]), t[u] = c0[u](l, o);\n  }), t;\n}, WA = (t, e, r = {}, n = {}) => {\n  e = { ...e }, n = { ...n };\n  const i = Object.keys(e).filter(bp);\n  let o = [], a = !1;\n  const s = [];\n  if (i.forEach((l) => {\n    const u = t.getValue(l);\n    if (!t.hasValue(l))\n      return;\n    let c = r[l], f = On(c);\n    const h = e[l];\n    let p;\n    if (_o(h)) {\n      const g = h.length, _ = h[0] === null ? 1 : 0;\n      c = h[_], f = On(c);\n      for (let T = _; T < g; T++)\n        p ? Gt(On(h[T]) === p, \"All keyframes must be of the same type\") : (p = On(h[T]), Gt(p === f || gi(f) && gi(p), \"Keyframes must be of the same dimension as the current value\"));\n    } else\n      p = On(h);\n    if (f !== p)\n      if (gi(f) && gi(p)) {\n        const g = u.get();\n        typeof g == \"string\" && u.set(parseFloat(g)), typeof h == \"string\" ? e[l] = parseFloat(h) : Array.isArray(h) && p === Ce && (e[l] = h.map(parseFloat));\n      } else\n        f != null && f.transform && (p != null && p.transform) && (c === 0 || h === 0) ? c === 0 ? u.set(p.transform(c)) : e[l] = f.transform(h) : (a || (o = $A(t), a = !0), s.push(l), n[l] = n[l] !== void 0 ? n[l] : e[l], u.jump(h));\n  }), s.length) {\n    const l = s.indexOf(\"height\") >= 0 ? window.pageYOffset : null, u = HA(e, t, s);\n    return o.length && o.forEach(([c, f]) => {\n      t.getValue(c).set(f);\n    }), t.render(), Go && l !== null && window.scrollTo({ top: l }), { target: u, transitionEnd: n };\n  } else\n    return { target: e, transitionEnd: n };\n};\nfunction zA(t, e, r, n) {\n  return jA(e) ? WA(t, e, r, n) : { target: e, transitionEnd: n };\n}\nconst qA = (t, e, r, n) => {\n  const i = FA(t, e, n);\n  return e = i.target, n = i.transitionEnd, zA(t, e, r, n);\n}, Wa = { current: null }, _p = { current: !1 };\nfunction KA() {\n  if (_p.current = !0, !!Go)\n    if (window.matchMedia) {\n      const t = window.matchMedia(\"(prefers-reduced-motion)\"), e = () => Wa.current = t.matches;\n      t.addListener(e), e();\n    } else\n      Wa.current = !1;\n}\nfunction GA(t, e, r) {\n  const { willChange: n } = e;\n  for (const i in e) {\n    const o = e[i], a = r[i];\n    if (Ht(o))\n      t.addValue(i, o), Eo(n) && n.add(i),  true && es(o.version === \"8.1.9\", `Attempting to mix Framer Motion versions ${o.version} with 8.1.9 may not work as expected.`);\n    else if (Ht(a))\n      t.addValue(i, vn(o, { owner: t })), Eo(n) && n.remove(i);\n    else if (a !== o)\n      if (t.hasValue(i)) {\n        const s = t.getValue(i);\n        !s.hasAnimated && s.set(o);\n      } else {\n        const s = t.getStaticValue(i);\n        t.addValue(i, vn(s !== void 0 ? s : o));\n      }\n  }\n  for (const i in r)\n    e[i] === void 0 && t.removeValue(i);\n  return e;\n}\nconst Ap = Object.keys(Kn), YA = Ap.length, u0 = [\n  \"AnimationStart\",\n  \"AnimationComplete\",\n  \"Update\",\n  \"BeforeLayoutMeasure\",\n  \"LayoutMeasure\",\n  \"LayoutAnimationStart\",\n  \"LayoutAnimationComplete\"\n];\nclass ZA {\n  constructor({ parent: e, props: r, reducedMotionConfig: n, visualState: i }, o = {}) {\n    this.current = null, this.children = /* @__PURE__ */ new Set(), this.isVariantNode = !1, this.isControllingVariants = !1, this.shouldReduceMotion = null, this.values = /* @__PURE__ */ new Map(), this.isPresent = !0, this.valueSubscriptions = /* @__PURE__ */ new Map(), this.prevMotionValues = {}, this.events = {}, this.propEventSubscriptions = {}, this.notifyUpdate = () => this.notify(\"Update\", this.latestValues), this.render = () => {\n      this.current && (this.triggerBuild(), this.renderInstance(this.current, this.renderState, this.props.style, this.projection));\n    }, this.scheduleRender = () => Tt.render(this.render, !1, !0);\n    const { latestValues: a, renderState: s } = i;\n    this.latestValues = a, this.baseTarget = { ...a }, this.initialValues = r.initial ? { ...a } : {}, this.renderState = s, this.parent = e, this.props = r, this.depth = e ? e.depth + 1 : 0, this.reducedMotionConfig = n, this.options = o, this.isControllingVariants = Zo(r), this.isVariantNode = bd(r), this.isVariantNode && (this.variantChildren = /* @__PURE__ */ new Set()), this.manuallyAnimateOnMount = Boolean(e && e.current);\n    const { willChange: l, ...u } = this.scrapeMotionValuesFromProps(r, {});\n    for (const c in u) {\n      const f = u[c];\n      a[c] !== void 0 && Ht(f) && (f.set(a[c], !1), Eo(l) && l.add(c));\n    }\n  }\n  /**\n   * This method takes React props and returns found MotionValues. For example, HTML\n   * MotionValues will be found within the style prop, whereas for Three.js within attribute arrays.\n   *\n   * This isn't an abstract method as it needs calling in the constructor, but it is\n   * intended to be one.\n   */\n  scrapeMotionValuesFromProps(e, r) {\n    return {};\n  }\n  mount(e) {\n    var r;\n    this.current = e, this.projection && this.projection.mount(e), this.parent && this.isVariantNode && !this.isControllingVariants && (this.removeFromVariantTree = (r = this.parent) === null || r === void 0 ? void 0 : r.addVariantChild(this)), this.values.forEach((n, i) => this.bindToMotionValue(i, n)), _p.current || KA(), this.shouldReduceMotion = this.reducedMotionConfig === \"never\" ? !1 : this.reducedMotionConfig === \"always\" ? !0 : Wa.current,  true && es(this.shouldReduceMotion !== !0, \"You have Reduced Motion enabled on your device. Animations may not appear as expected.\"), this.parent && this.parent.children.add(this), this.setProps(this.props);\n  }\n  unmount() {\n    var e, r, n;\n    (e = this.projection) === null || e === void 0 || e.unmount(), _r.update(this.notifyUpdate), _r.render(this.render), this.valueSubscriptions.forEach((i) => i()), (r = this.removeFromVariantTree) === null || r === void 0 || r.call(this), (n = this.parent) === null || n === void 0 || n.children.delete(this);\n    for (const i in this.events)\n      this.events[i].clear();\n    this.current = null;\n  }\n  bindToMotionValue(e, r) {\n    const n = Hr.has(e), i = r.on(\"change\", (a) => {\n      this.latestValues[e] = a, this.props.onUpdate && Tt.update(this.notifyUpdate, !1, !0), n && this.projection && (this.projection.isTransformDirty = !0);\n    }), o = r.on(\"renderRequest\", this.scheduleRender);\n    this.valueSubscriptions.set(e, () => {\n      i(), o();\n    });\n  }\n  sortNodePosition(e) {\n    return !this.current || !this.sortInstanceNodePosition || this.type !== e.type ? 0 : this.sortInstanceNodePosition(this.current, e.current);\n  }\n  loadFeatures(e, r, n, i, o, a) {\n    const s = [];\n     true && n && r && Gt(!1, \"You have rendered a `motion` component within a `LazyMotion` component. This will break tree shaking. Import and render a `m` component instead.\");\n    for (let l = 0; l < YA; l++) {\n      const u = Ap[l], { isEnabled: c, Component: f } = Kn[u];\n      c(e) && f && s.push((0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(f, {\n        key: u,\n        ...e,\n        visualElement: this\n      }));\n    }\n    if (!this.projection && o) {\n      this.projection = new o(i, this.latestValues, this.parent && this.parent.projection);\n      const { layoutId: l, layout: u, drag: c, dragConstraints: f, layoutScroll: h } = e;\n      this.projection.setOptions({\n        layoutId: l,\n        layout: u,\n        alwaysMeasureLayout: Boolean(c) || f && rn(f),\n        visualElement: this,\n        scheduleRender: () => this.scheduleRender(),\n        /**\n         * TODO: Update options in an effect. This could be tricky as it'll be too late\n         * to update by the time layout animations run.\n         * We also need to fix this safeToRemove by linking it up to the one returned by usePresence,\n         * ensuring it gets called if there's no potential layout animations.\n         *\n         */\n        animationType: typeof u == \"string\" ? u : \"both\",\n        initialPromotionConfig: a,\n        layoutScroll: h\n      });\n    }\n    return s;\n  }\n  triggerBuild() {\n    this.build(this.renderState, this.latestValues, this.options, this.props);\n  }\n  /**\n   * Measure the current viewport box with or without transforms.\n   * Only measures axis-aligned boxes, rotate and skew must be manually\n   * removed with a re-render to work.\n   */\n  measureViewportBox() {\n    return this.current ? this.measureInstanceViewportBox(this.current, this.props) : dt();\n  }\n  getStaticValue(e) {\n    return this.latestValues[e];\n  }\n  setStaticValue(e, r) {\n    this.latestValues[e] = r;\n  }\n  /**\n   * Make a target animatable by Popmotion. For instance, if we're\n   * trying to animate width from 100px to 100vw we need to measure 100vw\n   * in pixels to determine what we really need to animate to. This is also\n   * pluggable to support Framer's custom value types like Color,\n   * and CSS variables.\n   */\n  makeTargetAnimatable(e, r = !0) {\n    return this.makeTargetAnimatableFromInstance(e, this.props, r);\n  }\n  /**\n   * Update the provided props. Ensure any newly-added motion values are\n   * added to our map, old ones removed, and listeners updated.\n   */\n  setProps(e) {\n    (e.transformTemplate || this.props.transformTemplate) && this.scheduleRender();\n    const r = this.props;\n    this.props = e;\n    for (let n = 0; n < u0.length; n++) {\n      const i = u0[n];\n      this.propEventSubscriptions[i] && (this.propEventSubscriptions[i](), delete this.propEventSubscriptions[i]);\n      const o = e[\"on\" + i];\n      o && (this.propEventSubscriptions[i] = this.on(i, o));\n    }\n    this.prevMotionValues = GA(this, this.scrapeMotionValuesFromProps(e, r), this.prevMotionValues);\n  }\n  getProps() {\n    return this.props;\n  }\n  /**\n   * Returns the variant definition with a given name.\n   */\n  getVariant(e) {\n    var r;\n    return (r = this.props.variants) === null || r === void 0 ? void 0 : r[e];\n  }\n  /**\n   * Returns the defined default transition on this component.\n   */\n  getDefaultTransition() {\n    return this.props.transition;\n  }\n  getTransformPagePoint() {\n    return this.props.transformPagePoint;\n  }\n  getClosestVariantNode() {\n    var e;\n    return this.isVariantNode ? this : (e = this.parent) === null || e === void 0 ? void 0 : e.getClosestVariantNode();\n  }\n  getVariantContext(e = !1) {\n    var r, n;\n    if (e)\n      return (r = this.parent) === null || r === void 0 ? void 0 : r.getVariantContext();\n    if (!this.isControllingVariants) {\n      const o = ((n = this.parent) === null || n === void 0 ? void 0 : n.getVariantContext()) || {};\n      return this.props.initial !== void 0 && (o.initial = this.props.initial), o;\n    }\n    const i = {};\n    for (let o = 0; o < XA; o++) {\n      const a = Tp[o], s = this.props[a];\n      (qn(s) || s === !1) && (i[a] = s);\n    }\n    return i;\n  }\n  /**\n   * Add a child visual element to our set of children.\n   */\n  addVariantChild(e) {\n    var r;\n    const n = this.getClosestVariantNode();\n    if (n)\n      return (r = n.variantChildren) === null || r === void 0 || r.add(e), () => n.variantChildren.delete(e);\n  }\n  /**\n   * Add a motion value and bind it to this visual element.\n   */\n  addValue(e, r) {\n    r !== this.values.get(e) && (this.removeValue(e), this.bindToMotionValue(e, r)), this.values.set(e, r), this.latestValues[e] = r.get();\n  }\n  /**\n   * Remove a motion value and unbind any active subscriptions.\n   */\n  removeValue(e) {\n    var r;\n    this.values.delete(e), (r = this.valueSubscriptions.get(e)) === null || r === void 0 || r(), this.valueSubscriptions.delete(e), delete this.latestValues[e], this.removeValueFromRenderState(e, this.renderState);\n  }\n  /**\n   * Check whether we have a motion value for this key\n   */\n  hasValue(e) {\n    return this.values.has(e);\n  }\n  getValue(e, r) {\n    if (this.props.values && this.props.values[e])\n      return this.props.values[e];\n    let n = this.values.get(e);\n    return n === void 0 && r !== void 0 && (n = vn(r, { owner: this }), this.addValue(e, n)), n;\n  }\n  /**\n   * If we're trying to animate to a previously unencountered value,\n   * we need to check for it in our state and as a last resort read it\n   * directly from the instance (which might have performance implications).\n   */\n  readValue(e) {\n    return this.latestValues[e] !== void 0 || !this.current ? this.latestValues[e] : this.readValueFromInstance(this.current, e, this.options);\n  }\n  /**\n   * Set the base target to later animate back to. This is currently\n   * only hydrated on creation and when we first read a value.\n   */\n  setBaseTarget(e, r) {\n    this.baseTarget[e] = r;\n  }\n  /**\n   * Find the base target for a value thats been removed from all animation\n   * props.\n   */\n  getBaseTarget(e) {\n    var r;\n    const { initial: n } = this.props, i = typeof n == \"string\" || typeof n == \"object\" ? (r = ru(this.props, n)) === null || r === void 0 ? void 0 : r[e] : void 0;\n    if (n && i !== void 0)\n      return i;\n    const o = this.getBaseTargetFromProps(this.props, e);\n    return o !== void 0 && !Ht(o) ? o : this.initialValues[e] !== void 0 && i === void 0 ? void 0 : this.baseTarget[e];\n  }\n  on(e, r) {\n    return this.events[e] || (this.events[e] = new au()), this.events[e].add(r);\n  }\n  notify(e, ...r) {\n    var n;\n    (n = this.events[e]) === null || n === void 0 || n.notify(...r);\n  }\n}\nconst Tp = [\"initial\", ...wu], XA = Tp.length;\nclass Ep extends ZA {\n  sortInstanceNodePosition(e, r) {\n    return e.compareDocumentPosition(r) & 2 ? 1 : -1;\n  }\n  getBaseTargetFromProps(e, r) {\n    var n;\n    return (n = e.style) === null || n === void 0 ? void 0 : n[r];\n  }\n  removeValueFromRenderState(e, { vars: r, style: n }) {\n    delete r[e], delete n[e];\n  }\n  makeTargetAnimatableFromInstance({ transition: e, transitionEnd: r, ...n }, { transformValues: i }, o) {\n    let a = o_(n, e || {}, this);\n    if (i && (r && (r = i(r)), n && (n = i(n)), a && (a = i(a))), o) {\n      n_(this, n, a);\n      const s = qA(this, n, a, r);\n      r = s.transitionEnd, n = s.target;\n    }\n    return {\n      transition: e,\n      transitionEnd: r,\n      ...n\n    };\n  }\n}\nfunction JA(t) {\n  return window.getComputedStyle(t);\n}\nclass QA extends Ep {\n  readValueFromInstance(e, r) {\n    if (Hr.has(r)) {\n      const n = lu(r);\n      return n && n.default || 0;\n    } else {\n      const n = JA(e), i = (Td(r) ? n.getPropertyValue(r) : n[r]) || 0;\n      return typeof i == \"string\" ? i.trim() : i;\n    }\n  }\n  measureInstanceViewportBox(e, { transformPagePoint: r }) {\n    return xp(e, r);\n  }\n  build(e, r, n, i) {\n    Zc(e, r, n, i.transformTemplate);\n  }\n  scrapeMotionValuesFromProps(e, r) {\n    return tu(e, r);\n  }\n  renderInstance(e, r, n, i) {\n    Od(e, r, n, i);\n  }\n}\nclass eT extends Ep {\n  constructor() {\n    super(...arguments), this.isSVGTag = !1;\n  }\n  getBaseTargetFromProps(e, r) {\n    return e[r];\n  }\n  readValueFromInstance(e, r) {\n    var n;\n    return Hr.has(r) ? ((n = lu(r)) === null || n === void 0 ? void 0 : n.default) || 0 : (r = Md.has(r) ? r : eu(r), e.getAttribute(r));\n  }\n  measureInstanceViewportBox() {\n    return dt();\n  }\n  scrapeMotionValuesFromProps(e, r) {\n    return Rd(e, r);\n  }\n  build(e, r, n, i) {\n    Jc(e, r, n, this.isSVGTag, i.transformTemplate);\n  }\n  renderInstance(e, r, n, i) {\n    kd(e, r, n, i);\n  }\n  mount(e) {\n    this.isSVGTag = Qc(e.tagName), super.mount(e);\n  }\n}\nconst tT = (t, e) => Yc(t) ? new eT(e, { enableHardwareAcceleration: !1 }) : new QA(e, { enableHardwareAcceleration: !0 });\nfunction l0(t, e) {\n  return e.max === e.min ? 0 : t / (e.max - e.min) * 100;\n}\nconst Mn = {\n  correct: (t, e) => {\n    if (!e.target)\n      return t;\n    if (typeof t == \"string\")\n      if (Ce.test(t))\n        t = parseFloat(t);\n      else\n        return t;\n    const r = l0(t, e.target.x), n = l0(t, e.target.y);\n    return `${r}% ${n}%`;\n  }\n}, f0 = \"_$css\", rT = {\n  correct: (t, { treeScale: e, projectionDelta: r }) => {\n    const n = t, i = t.includes(\"var(\"), o = [];\n    i && (t = t.replace(wp, (p) => (o.push(p), f0)));\n    const a = Ar.parse(t);\n    if (a.length > 5)\n      return n;\n    const s = Ar.createTransformer(t), l = typeof a[0] != \"number\" ? 1 : 0, u = r.x.scale * e.x, c = r.y.scale * e.y;\n    a[0 + l] /= u, a[1 + l] /= c;\n    const f = ct(u, c, 0.5);\n    typeof a[2 + l] == \"number\" && (a[2 + l] /= f), typeof a[3 + l] == \"number\" && (a[3 + l] /= f);\n    let h = s(a);\n    if (i) {\n      let p = 0;\n      h = h.replace(f0, () => {\n        const g = o[p];\n        return p++, g;\n      });\n    }\n    return h;\n  }\n};\nclass nT extends react__WEBPACK_IMPORTED_MODULE_0__.Component {\n  /**\n   * This only mounts projection nodes for components that\n   * need measuring, we might want to do it for all components\n   * in order to incorporate transforms\n   */\n  componentDidMount() {\n    const { visualElement: e, layoutGroup: r, switchLayoutGroup: n, layoutId: i } = this.props, { projection: o } = e;\n    Vw(oT), o && (r.group && r.group.add(o), n && n.register && i && n.register(o), o.root.didUpdate(), o.addEventListener(\"animationComplete\", () => {\n      this.safeToRemove();\n    }), o.setOptions({\n      ...o.options,\n      onExitComplete: () => this.safeToRemove()\n    })), Nn.hasEverUpdated = !0;\n  }\n  getSnapshotBeforeUpdate(e) {\n    const { layoutDependency: r, visualElement: n, drag: i, isPresent: o } = this.props, a = n.projection;\n    return a && (a.isPresent = o, i || e.layoutDependency !== r || r === void 0 ? a.willUpdate() : this.safeToRemove(), e.isPresent !== o && (o ? a.promote() : a.relegate() || Tt.postRender(() => {\n      var s;\n      !((s = a.getStack()) === null || s === void 0) && s.members.length || this.safeToRemove();\n    }))), null;\n  }\n  componentDidUpdate() {\n    const { projection: e } = this.props.visualElement;\n    e && (e.root.didUpdate(), !e.currentAnimation && e.isLead() && this.safeToRemove());\n  }\n  componentWillUnmount() {\n    const { visualElement: e, layoutGroup: r, switchLayoutGroup: n } = this.props, { projection: i } = e;\n    i && (i.scheduleCheckAfterUnmount(), r != null && r.group && r.group.remove(i), n != null && n.deregister && n.deregister(i));\n  }\n  safeToRemove() {\n    const { safeToRemove: e } = this.props;\n    e == null || e();\n  }\n  render() {\n    return null;\n  }\n}\nfunction iT(t) {\n  const [e, r] = Ud(), n = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(Gc);\n  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(nT, { ...t, layoutGroup: n, switchLayoutGroup: (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(_d), isPresent: e, safeToRemove: r });\n}\nconst oT = {\n  borderRadius: {\n    ...Mn,\n    applyTo: [\n      \"borderTopLeftRadius\",\n      \"borderTopRightRadius\",\n      \"borderBottomLeftRadius\",\n      \"borderBottomRightRadius\"\n    ]\n  },\n  borderTopLeftRadius: Mn,\n  borderTopRightRadius: Mn,\n  borderBottomLeftRadius: Mn,\n  borderBottomRightRadius: Mn,\n  boxShadow: rT\n}, sT = {\n  measureLayout: iT\n};\nfunction aT(t, e, r = {}) {\n  const n = Ht(t) ? t : vn(t);\n  return n.start(xu(\"\", n, e, r)), {\n    stop: () => n.stop(),\n    isAnimating: () => n.isAnimating()\n  };\n}\nconst Sp = [\"TopLeft\", \"TopRight\", \"BottomLeft\", \"BottomRight\"], cT = Sp.length, h0 = (t) => typeof t == \"string\" ? parseFloat(t) : t, d0 = (t) => typeof t == \"number\" || Ce.test(t);\nfunction uT(t, e, r, n, i, o) {\n  i ? (t.opacity = ct(\n    0,\n    // TODO Reinstate this if only child\n    r.opacity !== void 0 ? r.opacity : 1,\n    lT(n)\n  ), t.opacityExit = ct(e.opacity !== void 0 ? e.opacity : 1, 0, fT(n))) : o && (t.opacity = ct(e.opacity !== void 0 ? e.opacity : 1, r.opacity !== void 0 ? r.opacity : 1, n));\n  for (let a = 0; a < cT; a++) {\n    const s = `border${Sp[a]}Radius`;\n    let l = p0(e, s), u = p0(r, s);\n    if (l === void 0 && u === void 0)\n      continue;\n    l || (l = 0), u || (u = 0), l === 0 || u === 0 || d0(l) === d0(u) ? (t[s] = Math.max(ct(h0(l), h0(u), n), 0), (rr.test(u) || rr.test(l)) && (t[s] += \"%\")) : t[s] = u;\n  }\n  (e.rotate || r.rotate) && (t.rotate = ct(e.rotate || 0, r.rotate || 0, n));\n}\nfunction p0(t, e) {\n  return t[e] !== void 0 ? t[e] : t.borderRadius;\n}\nconst lT = Pp(0, 0.5, vu), fT = Pp(0.5, 0.95, mu);\nfunction Pp(t, e, r) {\n  return (n) => n < t ? 0 : n > e ? 1 : r(So(t, e, n));\n}\nfunction y0(t, e) {\n  t.min = e.min, t.max = e.max;\n}\nfunction qt(t, e) {\n  y0(t.x, e.x), y0(t.y, e.y);\n}\nfunction m0(t, e, r, n, i) {\n  return t -= e, t = Co(t, 1 / r, n), i !== void 0 && (t = Co(t, 1 / i, n)), t;\n}\nfunction hT(t, e = 0, r = 1, n = 0.5, i, o = t, a = t) {\n  if (rr.test(e) && (e = parseFloat(e), e = ct(a.min, a.max, e / 100) - a.min), typeof e != \"number\")\n    return;\n  let s = ct(o.min, o.max, n);\n  t === o && (s -= e), t.min = m0(t.min, e, r, s, i), t.max = m0(t.max, e, r, s, i);\n}\nfunction v0(t, e, [r, n, i], o, a) {\n  hT(t, e[r], e[n], e[i], e.scale, o, a);\n}\nconst dT = [\"x\", \"scaleX\", \"originX\"], pT = [\"y\", \"scaleY\", \"originY\"];\nfunction g0(t, e, r, n) {\n  v0(t.x, e, dT, r == null ? void 0 : r.x, n == null ? void 0 : n.x), v0(t.y, e, pT, r == null ? void 0 : r.y, n == null ? void 0 : n.y);\n}\nfunction x0(t) {\n  return t.translate === 0 && t.scale === 1;\n}\nfunction Cp(t) {\n  return x0(t.x) && x0(t.y);\n}\nfunction Op(t, e) {\n  return t.x.min === e.x.min && t.x.max === e.x.max && t.y.min === e.y.min && t.y.max === e.y.max;\n}\nfunction w0(t) {\n  return Bt(t.x) / Bt(t.y);\n}\nclass yT {\n  constructor() {\n    this.members = [];\n  }\n  add(e) {\n    ou(this.members, e), e.scheduleRender();\n  }\n  remove(e) {\n    if (su(this.members, e), e === this.prevLead && (this.prevLead = void 0), e === this.lead) {\n      const r = this.members[this.members.length - 1];\n      r && this.promote(r);\n    }\n  }\n  relegate(e) {\n    const r = this.members.findIndex((i) => e === i);\n    if (r === 0)\n      return !1;\n    let n;\n    for (let i = r; i >= 0; i--) {\n      const o = this.members[i];\n      if (o.isPresent !== !1) {\n        n = o;\n        break;\n      }\n    }\n    return n ? (this.promote(n), !0) : !1;\n  }\n  promote(e, r) {\n    var n;\n    const i = this.lead;\n    if (e !== i && (this.prevLead = i, this.lead = e, e.show(), i)) {\n      i.instance && i.scheduleRender(), e.scheduleRender(), e.resumeFrom = i, r && (e.resumeFrom.preserveOpacity = !0), i.snapshot && (e.snapshot = i.snapshot, e.snapshot.latestValues = i.animationValues || i.latestValues), !((n = e.root) === null || n === void 0) && n.isUpdating && (e.isLayoutDirty = !0);\n      const { crossfade: o } = e.options;\n      o === !1 && i.hide();\n    }\n  }\n  exitAnimationComplete() {\n    this.members.forEach((e) => {\n      var r, n, i, o, a;\n      (n = (r = e.options).onExitComplete) === null || n === void 0 || n.call(r), (a = (i = e.resumingFrom) === null || i === void 0 ? void 0 : (o = i.options).onExitComplete) === null || a === void 0 || a.call(o);\n    });\n  }\n  scheduleRender() {\n    this.members.forEach((e) => {\n      e.instance && e.scheduleRender(!1);\n    });\n  }\n  /**\n   * Clear any leads that have been removed this render to prevent them from being\n   * used in future animations and to prevent memory leaks\n   */\n  removeLeadSnapshot() {\n    this.lead && this.lead.snapshot && (this.lead.snapshot = void 0);\n  }\n}\nfunction b0(t, e, r) {\n  let n = \"\";\n  const i = t.x.translate / e.x, o = t.y.translate / e.y;\n  if ((i || o) && (n = `translate3d(${i}px, ${o}px, 0) `), (e.x !== 1 || e.y !== 1) && (n += `scale(${1 / e.x}, ${1 / e.y}) `), r) {\n    const { rotate: l, rotateX: u, rotateY: c } = r;\n    l && (n += `rotate(${l}deg) `), u && (n += `rotateX(${u}deg) `), c && (n += `rotateY(${c}deg) `);\n  }\n  const a = t.x.scale * e.x, s = t.y.scale * e.y;\n  return (a !== 1 || s !== 1) && (n += `scale(${a}, ${s})`), n || \"none\";\n}\nconst mT = (t, e) => t.depth - e.depth;\nclass vT {\n  constructor() {\n    this.children = [], this.isDirty = !1;\n  }\n  add(e) {\n    ou(this.children, e), this.isDirty = !0;\n  }\n  remove(e) {\n    su(this.children, e), this.isDirty = !0;\n  }\n  forEach(e) {\n    this.isDirty && this.children.sort(mT), this.isDirty = !1, this.children.forEach(e);\n  }\n}\nconst _0 = [\"\", \"X\", \"Y\", \"Z\"], A0 = 1e3;\nlet gT = 0;\nfunction Mp({ attachResizeListener: t, defaultParent: e, measureScroll: r, checkIsScrollRoot: n, resetTransform: i }) {\n  return class {\n    constructor(a, s = {}, l = e == null ? void 0 : e()) {\n      this.id = gT++, this.animationId = 0, this.children = /* @__PURE__ */ new Set(), this.options = {}, this.isTreeAnimating = !1, this.isAnimationBlocked = !1, this.isLayoutDirty = !1, this.isTransformDirty = !1, this.isProjectionDirty = !1, this.updateManuallyBlocked = !1, this.updateBlockedByResize = !1, this.isUpdating = !1, this.isSVG = !1, this.needsReset = !1, this.shouldResetTransform = !1, this.treeScale = { x: 1, y: 1 }, this.eventHandlers = /* @__PURE__ */ new Map(), this.potentialNodes = /* @__PURE__ */ new Map(), this.checkUpdateFailed = () => {\n        this.isUpdating && (this.isUpdating = !1, this.clearAllSnapshots());\n      }, this.updateProjection = () => {\n        this.nodes.forEach(bT), this.nodes.forEach(TT), this.nodes.forEach(ET);\n      }, this.hasProjected = !1, this.isVisible = !0, this.animationProgress = 0, this.sharedNodes = /* @__PURE__ */ new Map(), this.elementId = a, this.latestValues = s, this.root = l ? l.root || l : this, this.path = l ? [...l.path, l] : [], this.parent = l, this.depth = l ? l.depth + 1 : 0, a && this.root.registerPotentialNode(a, this);\n      for (let u = 0; u < this.path.length; u++)\n        this.path[u].shouldResetTransform = !0;\n      this.root === this && (this.nodes = new vT());\n    }\n    addEventListener(a, s) {\n      return this.eventHandlers.has(a) || this.eventHandlers.set(a, new au()), this.eventHandlers.get(a).add(s);\n    }\n    notifyListeners(a, ...s) {\n      const l = this.eventHandlers.get(a);\n      l == null || l.notify(...s);\n    }\n    hasListeners(a) {\n      return this.eventHandlers.has(a);\n    }\n    registerPotentialNode(a, s) {\n      this.potentialNodes.set(a, s);\n    }\n    /**\n     * Lifecycles\n     */\n    mount(a, s = !1) {\n      var l;\n      if (this.instance)\n        return;\n      this.isSVG = a instanceof SVGElement && a.tagName !== \"svg\", this.instance = a;\n      const { layoutId: u, layout: c, visualElement: f } = this.options;\n      if (f && !f.current && f.mount(a), this.root.nodes.add(this), (l = this.parent) === null || l === void 0 || l.children.add(this), this.elementId && this.root.potentialNodes.delete(this.elementId), s && (c || u) && (this.isLayoutDirty = !0), t) {\n        let h;\n        const p = () => this.root.updateBlockedByResize = !1;\n        t(a, () => {\n          this.root.updateBlockedByResize = !0, h && h(), h = fp(p, 250), Nn.hasAnimatedSinceResize && (Nn.hasAnimatedSinceResize = !1, this.nodes.forEach(E0));\n        });\n      }\n      u && this.root.registerSharedNode(u, this), this.options.animate !== !1 && f && (u || c) && this.addEventListener(\"didUpdate\", ({ delta: h, hasLayoutChanged: p, hasRelativeTargetChanged: g, layout: _ }) => {\n        var T, A, w, O, R;\n        if (this.isTreeAnimationBlocked()) {\n          this.target = void 0, this.relativeTarget = void 0;\n          return;\n        }\n        const $ = (A = (T = this.options.transition) !== null && T !== void 0 ? T : f.getDefaultTransition()) !== null && A !== void 0 ? A : MT, { onLayoutAnimationStart: U, onLayoutAnimationComplete: W } = f.getProps(), G = !this.targetLayout || !Op(this.targetLayout, _) || g, Z = !p && g;\n        if (!((w = this.resumeFrom) === null || w === void 0) && w.instance || Z || p && (G || !this.currentAnimation)) {\n          this.resumeFrom && (this.resumingFrom = this.resumeFrom, this.resumingFrom.resumingFrom = void 0), this.setAnimationOrigin(h, Z);\n          const j = {\n            ...hp($, \"layout\"),\n            onPlay: U,\n            onComplete: W\n          };\n          f.shouldReduceMotion && (j.delay = 0, j.type = !1), this.startAnimation(j);\n        } else\n          !p && this.animationProgress === 0 && E0(this), this.isLead() && ((R = (O = this.options).onExitComplete) === null || R === void 0 || R.call(O));\n        this.targetLayout = _;\n      });\n    }\n    unmount() {\n      var a, s;\n      this.options.layoutId && this.willUpdate(), this.root.nodes.remove(this), (a = this.getStack()) === null || a === void 0 || a.remove(this), (s = this.parent) === null || s === void 0 || s.children.delete(this), this.instance = void 0, _r.preRender(this.updateProjection);\n    }\n    // only on the root\n    blockUpdate() {\n      this.updateManuallyBlocked = !0;\n    }\n    unblockUpdate() {\n      this.updateManuallyBlocked = !1;\n    }\n    isUpdateBlocked() {\n      return this.updateManuallyBlocked || this.updateBlockedByResize;\n    }\n    isTreeAnimationBlocked() {\n      var a;\n      return this.isAnimationBlocked || ((a = this.parent) === null || a === void 0 ? void 0 : a.isTreeAnimationBlocked()) || !1;\n    }\n    // Note: currently only running on root node\n    startUpdate() {\n      var a;\n      this.isUpdateBlocked() || (this.isUpdating = !0, (a = this.nodes) === null || a === void 0 || a.forEach(ST), this.animationId++);\n    }\n    willUpdate(a = !0) {\n      var s, l, u;\n      if (this.root.isUpdateBlocked()) {\n        (l = (s = this.options).onExitComplete) === null || l === void 0 || l.call(s);\n        return;\n      }\n      if (!this.root.isUpdating && this.root.startUpdate(), this.isLayoutDirty)\n        return;\n      this.isLayoutDirty = !0;\n      for (let p = 0; p < this.path.length; p++) {\n        const g = this.path[p];\n        g.shouldResetTransform = !0, g.updateScroll(\"snapshot\");\n      }\n      const { layoutId: c, layout: f } = this.options;\n      if (c === void 0 && !f)\n        return;\n      const h = (u = this.options.visualElement) === null || u === void 0 ? void 0 : u.getProps().transformTemplate;\n      this.prevTransformTemplateValue = h == null ? void 0 : h(this.latestValues, \"\"), this.updateSnapshot(), a && this.notifyListeners(\"willUpdate\");\n    }\n    // Note: Currently only running on root node\n    didUpdate() {\n      if (this.isUpdateBlocked()) {\n        this.unblockUpdate(), this.clearAllSnapshots(), this.nodes.forEach(T0);\n        return;\n      }\n      this.isUpdating && (this.isUpdating = !1, this.potentialNodes.size && (this.potentialNodes.forEach(kT), this.potentialNodes.clear()), this.nodes.forEach(AT), this.nodes.forEach(xT), this.nodes.forEach(wT), this.clearAllSnapshots(), Ys.update(), Ys.preRender(), Ys.render());\n    }\n    clearAllSnapshots() {\n      this.nodes.forEach(_T), this.sharedNodes.forEach(PT);\n    }\n    scheduleUpdateProjection() {\n      Tt.preRender(this.updateProjection, !1, !0);\n    }\n    scheduleCheckAfterUnmount() {\n      Tt.postRender(() => {\n        this.isLayoutDirty ? this.root.didUpdate() : this.root.checkUpdateFailed();\n      });\n    }\n    /**\n     * Update measurements\n     */\n    updateSnapshot() {\n      this.snapshot || !this.instance || (this.snapshot = this.measure());\n    }\n    updateLayout() {\n      var a;\n      if (!this.instance || (this.updateScroll(), !(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty))\n        return;\n      if (this.resumeFrom && !this.resumeFrom.instance)\n        for (let l = 0; l < this.path.length; l++)\n          this.path[l].updateScroll();\n      const s = this.layout;\n      this.layout = this.measure(!1), this.layoutCorrected = dt(), this.isLayoutDirty = !1, this.projectionDelta = void 0, this.notifyListeners(\"measure\", this.layout.layoutBox), (a = this.options.visualElement) === null || a === void 0 || a.notify(\"LayoutMeasure\", this.layout.layoutBox, s == null ? void 0 : s.layoutBox);\n    }\n    updateScroll(a = \"measure\") {\n      let s = Boolean(this.options.layoutScroll && this.instance);\n      this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === a && (s = !1), s && (this.scroll = {\n        animationId: this.root.animationId,\n        phase: a,\n        isRoot: n(this.instance),\n        offset: r(this.instance)\n      });\n    }\n    resetTransform() {\n      var a;\n      if (!i)\n        return;\n      const s = this.isLayoutDirty || this.shouldResetTransform, l = this.projectionDelta && !Cp(this.projectionDelta), u = (a = this.options.visualElement) === null || a === void 0 ? void 0 : a.getProps().transformTemplate, c = u == null ? void 0 : u(this.latestValues, \"\"), f = c !== this.prevTransformTemplateValue;\n      s && (l || Br(this.latestValues) || f) && (i(this.instance, c), this.shouldResetTransform = !1, this.scheduleRender());\n    }\n    measure(a = !0) {\n      const s = this.measurePageBox();\n      let l = this.removeElementScroll(s);\n      return a && (l = this.removeTransform(l)), RT(l), {\n        animationId: this.root.animationId,\n        measuredBox: s,\n        layoutBox: l,\n        latestValues: {},\n        source: this.id\n      };\n    }\n    measurePageBox() {\n      const { visualElement: a } = this.options;\n      if (!a)\n        return dt();\n      const s = a.measureViewportBox(), { scroll: l } = this.root;\n      return l && (vr(s.x, l.offset.x), vr(s.y, l.offset.y)), s;\n    }\n    removeElementScroll(a) {\n      const s = dt();\n      qt(s, a);\n      for (let l = 0; l < this.path.length; l++) {\n        const u = this.path[l], { scroll: c, options: f } = u;\n        if (u !== this.root && c && f.layoutScroll) {\n          if (c.isRoot) {\n            qt(s, a);\n            const { scroll: h } = this.root;\n            h && (vr(s.x, -h.offset.x), vr(s.y, -h.offset.y));\n          }\n          vr(s.x, c.offset.x), vr(s.y, c.offset.y);\n        }\n      }\n      return s;\n    }\n    applyTransform(a, s = !1) {\n      const l = dt();\n      qt(l, a);\n      for (let u = 0; u < this.path.length; u++) {\n        const c = this.path[u];\n        !s && c.options.layoutScroll && c.scroll && c !== c.root && on(l, {\n          x: -c.scroll.offset.x,\n          y: -c.scroll.offset.y\n        }), Br(c.latestValues) && on(l, c.latestValues);\n      }\n      return Br(this.latestValues) && on(l, this.latestValues), l;\n    }\n    removeTransform(a) {\n      var s;\n      const l = dt();\n      qt(l, a);\n      for (let u = 0; u < this.path.length; u++) {\n        const c = this.path[u];\n        if (!c.instance || !Br(c.latestValues))\n          continue;\n        Ua(c.latestValues) && c.updateSnapshot();\n        const f = dt(), h = c.measurePageBox();\n        qt(f, h), g0(l, c.latestValues, (s = c.snapshot) === null || s === void 0 ? void 0 : s.layoutBox, f);\n      }\n      return Br(this.latestValues) && g0(l, this.latestValues), l;\n    }\n    /**\n     *\n     */\n    setTargetDelta(a) {\n      this.targetDelta = a, this.isProjectionDirty = !0, this.root.scheduleUpdateProjection();\n    }\n    setOptions(a) {\n      this.options = {\n        ...this.options,\n        ...a,\n        crossfade: a.crossfade !== void 0 ? a.crossfade : !0\n      };\n    }\n    clearMeasurements() {\n      this.scroll = void 0, this.layout = void 0, this.snapshot = void 0, this.prevTransformTemplateValue = void 0, this.targetDelta = void 0, this.target = void 0, this.isLayoutDirty = !1;\n    }\n    /**\n     * Frame calculations\n     */\n    resolveTargetDelta() {\n      var a;\n      const s = this.getLead();\n      if (this.isProjectionDirty || (this.isProjectionDirty = s.isProjectionDirty), this.isTransformDirty || (this.isTransformDirty = s.isTransformDirty), !this.isProjectionDirty && !this.attemptToResolveRelativeTarget)\n        return;\n      const { layout: l, layoutId: u } = this.options;\n      if (!(!this.layout || !(l || u))) {\n        if (!this.targetDelta && !this.relativeTarget) {\n          const c = this.getClosestProjectingParent();\n          c && c.layout ? (this.relativeParent = c, this.relativeTarget = dt(), this.relativeTargetOrigin = dt(), Un(this.relativeTargetOrigin, this.layout.layoutBox, c.layout.layoutBox), qt(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0;\n        }\n        if (!(!this.relativeTarget && !this.targetDelta) && (this.target || (this.target = dt(), this.targetWithTransforms = dt()), this.relativeTarget && this.relativeTargetOrigin && (!((a = this.relativeParent) === null || a === void 0) && a.target) ? mA(this.target, this.relativeTarget, this.relativeParent.target) : this.targetDelta ? (Boolean(this.resumingFrom) ? this.target = this.applyTransform(this.layout.layoutBox) : qt(this.target, this.layout.layoutBox), gp(this.target, this.targetDelta)) : qt(this.target, this.layout.layoutBox), this.attemptToResolveRelativeTarget)) {\n          this.attemptToResolveRelativeTarget = !1;\n          const c = this.getClosestProjectingParent();\n          c && Boolean(c.resumingFrom) === Boolean(this.resumingFrom) && !c.options.layoutScroll && c.target ? (this.relativeParent = c, this.relativeTarget = dt(), this.relativeTargetOrigin = dt(), Un(this.relativeTargetOrigin, this.target, c.target), qt(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0;\n        }\n      }\n    }\n    getClosestProjectingParent() {\n      if (!(!this.parent || Ua(this.parent.latestValues) || vp(this.parent.latestValues)))\n        return (this.parent.relativeTarget || this.parent.targetDelta) && this.parent.layout ? this.parent : this.parent.getClosestProjectingParent();\n    }\n    calcProjection() {\n      var a;\n      const { isProjectionDirty: s, isTransformDirty: l } = this;\n      this.isProjectionDirty = this.isTransformDirty = !1;\n      const u = this.getLead(), c = Boolean(this.resumingFrom) || this !== u;\n      let f = !0;\n      if (s && (f = !1), c && l && (f = !1), f)\n        return;\n      const { layout: h, layoutId: p } = this.options;\n      if (this.isTreeAnimating = Boolean(((a = this.parent) === null || a === void 0 ? void 0 : a.isTreeAnimating) || this.currentAnimation || this.pendingAnimation), this.isTreeAnimating || (this.targetDelta = this.relativeTarget = void 0), !this.layout || !(h || p))\n        return;\n      qt(this.layoutCorrected, this.layout.layoutBox), EA(this.layoutCorrected, this.treeScale, this.path, c);\n      const { target: g } = u;\n      if (!g)\n        return;\n      this.projectionDelta || (this.projectionDelta = Vn(), this.projectionDeltaWithTransform = Vn());\n      const _ = this.treeScale.x, T = this.treeScale.y, A = this.projectionTransform;\n      jn(this.projectionDelta, this.layoutCorrected, g, this.latestValues), this.projectionTransform = b0(this.projectionDelta, this.treeScale), (this.projectionTransform !== A || this.treeScale.x !== _ || this.treeScale.y !== T) && (this.hasProjected = !0, this.scheduleRender(), this.notifyListeners(\"projectionUpdate\", g));\n    }\n    hide() {\n      this.isVisible = !1;\n    }\n    show() {\n      this.isVisible = !0;\n    }\n    scheduleRender(a = !0) {\n      var s, l, u;\n      (l = (s = this.options).scheduleRender) === null || l === void 0 || l.call(s), a && ((u = this.getStack()) === null || u === void 0 || u.scheduleRender()), this.resumingFrom && !this.resumingFrom.instance && (this.resumingFrom = void 0);\n    }\n    setAnimationOrigin(a, s = !1) {\n      var l, u;\n      const c = this.snapshot, f = (c == null ? void 0 : c.latestValues) || {}, h = { ...this.latestValues }, p = Vn();\n      this.relativeTarget = this.relativeTargetOrigin = void 0, this.attemptToResolveRelativeTarget = !s;\n      const g = dt(), _ = (c == null ? void 0 : c.source) !== ((l = this.layout) === null || l === void 0 ? void 0 : l.source), T = (((u = this.getStack()) === null || u === void 0 ? void 0 : u.members.length) || 0) <= 1, A = Boolean(_ && !T && this.options.crossfade === !0 && !this.path.some(OT));\n      this.animationProgress = 0, this.mixTargetDelta = (w) => {\n        var O;\n        const R = w / 1e3;\n        S0(p.x, a.x, R), S0(p.y, a.y, R), this.setTargetDelta(p), this.relativeTarget && this.relativeTargetOrigin && this.layout && (!((O = this.relativeParent) === null || O === void 0) && O.layout) && (Un(g, this.layout.layoutBox, this.relativeParent.layout.layoutBox), CT(this.relativeTarget, this.relativeTargetOrigin, g, R)), _ && (this.animationValues = h, uT(h, f, this.latestValues, R, A, T)), this.root.scheduleUpdateProjection(), this.scheduleRender(), this.animationProgress = R;\n      }, this.mixTargetDelta(0);\n    }\n    startAnimation(a) {\n      var s, l;\n      this.notifyListeners(\"animationStart\"), (s = this.currentAnimation) === null || s === void 0 || s.stop(), this.resumingFrom && ((l = this.resumingFrom.currentAnimation) === null || l === void 0 || l.stop()), this.pendingAnimation && (_r.update(this.pendingAnimation), this.pendingAnimation = void 0), this.pendingAnimation = Tt.update(() => {\n        Nn.hasAnimatedSinceResize = !0, this.currentAnimation = aT(0, A0, {\n          ...a,\n          onUpdate: (u) => {\n            var c;\n            this.mixTargetDelta(u), (c = a.onUpdate) === null || c === void 0 || c.call(a, u);\n          },\n          onComplete: () => {\n            var u;\n            (u = a.onComplete) === null || u === void 0 || u.call(a), this.completeAnimation();\n          }\n        }), this.resumingFrom && (this.resumingFrom.currentAnimation = this.currentAnimation), this.pendingAnimation = void 0;\n      });\n    }\n    completeAnimation() {\n      var a;\n      this.resumingFrom && (this.resumingFrom.currentAnimation = void 0, this.resumingFrom.preserveOpacity = void 0), (a = this.getStack()) === null || a === void 0 || a.exitAnimationComplete(), this.resumingFrom = this.currentAnimation = this.animationValues = void 0, this.notifyListeners(\"animationComplete\");\n    }\n    finishAnimation() {\n      var a;\n      this.currentAnimation && ((a = this.mixTargetDelta) === null || a === void 0 || a.call(this, A0), this.currentAnimation.stop()), this.completeAnimation();\n    }\n    applyTransformsToTarget() {\n      const a = this.getLead();\n      let { targetWithTransforms: s, target: l, layout: u, latestValues: c } = a;\n      if (!(!s || !l || !u)) {\n        if (this !== a && this.layout && u && kp(this.options.animationType, this.layout.layoutBox, u.layoutBox)) {\n          l = this.target || dt();\n          const f = Bt(this.layout.layoutBox.x);\n          l.x.min = a.target.x.min, l.x.max = l.x.min + f;\n          const h = Bt(this.layout.layoutBox.y);\n          l.y.min = a.target.y.min, l.y.max = l.y.min + h;\n        }\n        qt(s, l), on(s, c), jn(this.projectionDeltaWithTransform, this.layoutCorrected, s, c);\n      }\n    }\n    registerSharedNode(a, s) {\n      var l, u, c;\n      this.sharedNodes.has(a) || this.sharedNodes.set(a, new yT()), this.sharedNodes.get(a).add(s), s.promote({\n        transition: (l = s.options.initialPromotionConfig) === null || l === void 0 ? void 0 : l.transition,\n        preserveFollowOpacity: (c = (u = s.options.initialPromotionConfig) === null || u === void 0 ? void 0 : u.shouldPreserveFollowOpacity) === null || c === void 0 ? void 0 : c.call(u, s)\n      });\n    }\n    isLead() {\n      const a = this.getStack();\n      return a ? a.lead === this : !0;\n    }\n    getLead() {\n      var a;\n      const { layoutId: s } = this.options;\n      return s ? ((a = this.getStack()) === null || a === void 0 ? void 0 : a.lead) || this : this;\n    }\n    getPrevLead() {\n      var a;\n      const { layoutId: s } = this.options;\n      return s ? (a = this.getStack()) === null || a === void 0 ? void 0 : a.prevLead : void 0;\n    }\n    getStack() {\n      const { layoutId: a } = this.options;\n      if (a)\n        return this.root.sharedNodes.get(a);\n    }\n    promote({ needsReset: a, transition: s, preserveFollowOpacity: l } = {}) {\n      const u = this.getStack();\n      u && u.promote(this, l), a && (this.projectionDelta = void 0, this.needsReset = !0), s && this.setOptions({ transition: s });\n    }\n    relegate() {\n      const a = this.getStack();\n      return a ? a.relegate(this) : !1;\n    }\n    resetRotation() {\n      const { visualElement: a } = this.options;\n      if (!a)\n        return;\n      let s = !1;\n      const { latestValues: l } = a;\n      if ((l.rotate || l.rotateX || l.rotateY || l.rotateZ) && (s = !0), !s)\n        return;\n      const u = {};\n      for (let c = 0; c < _0.length; c++) {\n        const f = \"rotate\" + _0[c];\n        l[f] && (u[f] = l[f], a.setStaticValue(f, 0));\n      }\n      a == null || a.render();\n      for (const c in u)\n        a.setStaticValue(c, u[c]);\n      a.scheduleRender();\n    }\n    getProjectionStyles(a = {}) {\n      var s, l, u;\n      const c = {};\n      if (!this.instance || this.isSVG)\n        return c;\n      if (this.isVisible)\n        c.visibility = \"\";\n      else\n        return { visibility: \"hidden\" };\n      const f = (s = this.options.visualElement) === null || s === void 0 ? void 0 : s.getProps().transformTemplate;\n      if (this.needsReset)\n        return this.needsReset = !1, c.opacity = \"\", c.pointerEvents = Ei(a.pointerEvents) || \"\", c.transform = f ? f(this.latestValues, \"\") : \"none\", c;\n      const h = this.getLead();\n      if (!this.projectionDelta || !this.layout || !h.target) {\n        const T = {};\n        return this.options.layoutId && (T.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1, T.pointerEvents = Ei(a.pointerEvents) || \"\"), this.hasProjected && !Br(this.latestValues) && (T.transform = f ? f({}, \"\") : \"none\", this.hasProjected = !1), T;\n      }\n      const p = h.animationValues || h.latestValues;\n      this.applyTransformsToTarget(), c.transform = b0(this.projectionDeltaWithTransform, this.treeScale, p), f && (c.transform = f(p, c.transform));\n      const { x: g, y: _ } = this.projectionDelta;\n      c.transformOrigin = `${g.origin * 100}% ${_.origin * 100}% 0`, h.animationValues ? c.opacity = h === this ? (u = (l = p.opacity) !== null && l !== void 0 ? l : this.latestValues.opacity) !== null && u !== void 0 ? u : 1 : this.preserveOpacity ? this.latestValues.opacity : p.opacityExit : c.opacity = h === this ? p.opacity !== void 0 ? p.opacity : \"\" : p.opacityExit !== void 0 ? p.opacityExit : 0;\n      for (const T in xo) {\n        if (p[T] === void 0)\n          continue;\n        const { correct: A, applyTo: w } = xo[T], O = A(p[T], h);\n        if (w) {\n          const R = w.length;\n          for (let $ = 0; $ < R; $++)\n            c[w[$]] = O;\n        } else\n          c[T] = O;\n      }\n      return this.options.layoutId && (c.pointerEvents = h === this ? Ei(a.pointerEvents) || \"\" : \"none\"), c;\n    }\n    clearSnapshot() {\n      this.resumeFrom = this.snapshot = void 0;\n    }\n    // Only run on root\n    resetTree() {\n      this.root.nodes.forEach((a) => {\n        var s;\n        return (s = a.currentAnimation) === null || s === void 0 ? void 0 : s.stop();\n      }), this.root.nodes.forEach(T0), this.root.sharedNodes.clear();\n    }\n  };\n}\nfunction xT(t) {\n  t.updateLayout();\n}\nfunction wT(t) {\n  var e, r, n;\n  const i = ((e = t.resumeFrom) === null || e === void 0 ? void 0 : e.snapshot) || t.snapshot;\n  if (t.isLead() && t.layout && i && t.hasListeners(\"didUpdate\")) {\n    const { layoutBox: o, measuredBox: a } = t.layout, { animationType: s } = t.options, l = i.source !== t.layout.source;\n    s === \"size\" ? Xt((p) => {\n      const g = l ? i.measuredBox[p] : i.layoutBox[p], _ = Bt(g);\n      g.min = o[p].min, g.max = g.min + _;\n    }) : kp(s, i.layoutBox, o) && Xt((p) => {\n      const g = l ? i.measuredBox[p] : i.layoutBox[p], _ = Bt(o[p]);\n      g.max = g.min + _;\n    });\n    const u = Vn();\n    jn(u, o, i.layoutBox);\n    const c = Vn();\n    l ? jn(c, t.applyTransform(a, !0), i.measuredBox) : jn(c, o, i.layoutBox);\n    const f = !Cp(u);\n    let h = !1;\n    if (!t.resumeFrom) {\n      const p = t.getClosestProjectingParent();\n      if (p && !p.resumeFrom) {\n        const { snapshot: g, layout: _ } = p;\n        if (g && _) {\n          const T = dt();\n          Un(T, i.layoutBox, g.layoutBox);\n          const A = dt();\n          Un(A, o, _.layoutBox), Op(T, A) || (h = !0);\n        }\n      }\n    }\n    t.notifyListeners(\"didUpdate\", {\n      layout: o,\n      snapshot: i,\n      delta: c,\n      layoutDelta: u,\n      hasLayoutChanged: f,\n      hasRelativeTargetChanged: h\n    });\n  } else\n    t.isLead() && ((n = (r = t.options).onExitComplete) === null || n === void 0 || n.call(r));\n  t.options.transition = void 0;\n}\nfunction bT(t) {\n  t.isProjectionDirty || (t.isProjectionDirty = Boolean(t.parent && t.parent.isProjectionDirty)), t.isTransformDirty || (t.isTransformDirty = Boolean(t.parent && t.parent.isTransformDirty));\n}\nfunction _T(t) {\n  t.clearSnapshot();\n}\nfunction T0(t) {\n  t.clearMeasurements();\n}\nfunction AT(t) {\n  const { visualElement: e } = t.options;\n  e != null && e.getProps().onBeforeLayoutMeasure && e.notify(\"BeforeLayoutMeasure\"), t.resetTransform();\n}\nfunction E0(t) {\n  t.finishAnimation(), t.targetDelta = t.relativeTarget = t.target = void 0;\n}\nfunction TT(t) {\n  t.resolveTargetDelta();\n}\nfunction ET(t) {\n  t.calcProjection();\n}\nfunction ST(t) {\n  t.resetRotation();\n}\nfunction PT(t) {\n  t.removeLeadSnapshot();\n}\nfunction S0(t, e, r) {\n  t.translate = ct(e.translate, 0, r), t.scale = ct(e.scale, 1, r), t.origin = e.origin, t.originPoint = e.originPoint;\n}\nfunction P0(t, e, r, n) {\n  t.min = ct(e.min, r.min, n), t.max = ct(e.max, r.max, n);\n}\nfunction CT(t, e, r, n) {\n  P0(t.x, e.x, r.x, n), P0(t.y, e.y, r.y, n);\n}\nfunction OT(t) {\n  return t.animationValues && t.animationValues.opacityExit !== void 0;\n}\nconst MT = {\n  duration: 0.45,\n  ease: [0.4, 0, 0.1, 1]\n};\nfunction kT(t, e) {\n  let r = t.root;\n  for (let o = t.path.length - 1; o >= 0; o--)\n    if (Boolean(t.path[o].instance)) {\n      r = t.path[o];\n      break;\n    }\n  const i = (r && r !== t.root ? r.instance : document).querySelector(`[data-projection-id=\"${e}\"]`);\n  i && t.mount(i, !0);\n}\nfunction C0(t) {\n  t.min = Math.round(t.min), t.max = Math.round(t.max);\n}\nfunction RT(t) {\n  C0(t.x), C0(t.y);\n}\nfunction kp(t, e, r) {\n  return t === \"position\" || t === \"preserve-aspect\" && !La(w0(e), w0(r), 0.2);\n}\nconst BT = Mp({\n  attachResizeListener: (t, e) => Jo(t, \"resize\", e),\n  measureScroll: () => ({\n    x: document.documentElement.scrollLeft || document.body.scrollLeft,\n    y: document.documentElement.scrollTop || document.body.scrollTop\n  }),\n  checkIsScrollRoot: () => !0\n}), oa = {\n  current: void 0\n}, IT = Mp({\n  measureScroll: (t) => ({\n    x: t.scrollLeft,\n    y: t.scrollTop\n  }),\n  defaultParent: () => {\n    if (!oa.current) {\n      const t = new BT(0, {});\n      t.mount(window), t.setOptions({ layoutScroll: !0 }), oa.current = t;\n    }\n    return oa.current;\n  },\n  resetTransform: (t, e) => {\n    t.style.transform = e !== void 0 ? e : \"none\";\n  },\n  checkIsScrollRoot: (t) => Boolean(window.getComputedStyle(t).position === \"fixed\")\n}), DT = {\n  ...hA,\n  ...kb,\n  ...IA,\n  ...sT\n}, Rp = /* @__PURE__ */ jw((t, e) => vb(t, e, DT, tT, IT));\nfunction Bp() {\n  const t = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(!1);\n  return go(() => (t.current = !0, () => {\n    t.current = !1;\n  }), []), t;\n}\nfunction NT() {\n  const t = Bp(), [e, r] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0), n = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n    t.current && r(e + 1);\n  }, [e]);\n  return [(0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => Tt.postRender(n), [n]), e];\n}\nclass FT extends react__WEBPACK_IMPORTED_MODULE_0__.Component {\n  getSnapshotBeforeUpdate(e) {\n    const r = this.props.childRef.current;\n    if (r && e.isPresent && !this.props.isPresent) {\n      const n = this.props.sizeRef.current;\n      n.height = r.offsetHeight || 0, n.width = r.offsetWidth || 0, n.top = r.offsetTop, n.left = r.offsetLeft;\n    }\n    return null;\n  }\n  /**\n   * Required with getSnapshotBeforeUpdate to stop React complaining.\n   */\n  componentDidUpdate() {\n  }\n  render() {\n    return this.props.children;\n  }\n}\nfunction LT({ children: t, isPresent: e }) {\n  const r = (0,react__WEBPACK_IMPORTED_MODULE_0__.useId)(), n = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null), i = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n    width: 0,\n    height: 0,\n    top: 0,\n    left: 0\n  });\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useInsertionEffect)(() => {\n    const { width: o, height: a, top: s, left: l } = i.current;\n    if (e || !n.current || !o || !a)\n      return;\n    n.current.dataset.motionPopId = r;\n    const u = document.createElement(\"style\");\n    return document.head.appendChild(u), u.sheet && u.sheet.insertRule(`\n          [data-motion-pop-id=\"${r}\"] {\n            position: absolute !important;\n            width: ${o}px !important;\n            height: ${a}px !important;\n            top: ${s}px !important;\n            left: ${l}px !important;\n          }\n        `), () => {\n      document.head.removeChild(u);\n    };\n  }, [e]), react__WEBPACK_IMPORTED_MODULE_0__.createElement(FT, { isPresent: e, childRef: n, sizeRef: i }, react__WEBPACK_IMPORTED_MODULE_0__.cloneElement(t, { ref: n }));\n}\nconst sa = ({ children: t, initial: e, isPresent: r, onExitComplete: n, custom: i, presenceAffectsLayout: o, mode: a }) => {\n  const s = Xo(jT), l = (0,react__WEBPACK_IMPORTED_MODULE_0__.useId)(), u = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(\n    () => ({\n      id: l,\n      initial: e,\n      isPresent: r,\n      custom: i,\n      onExitComplete: (c) => {\n        s.set(c, !0);\n        for (const f of s.values())\n          if (!f)\n            return;\n        n && n();\n      },\n      register: (c) => (s.set(c, !1), () => s.delete(c))\n    }),\n    /**\n     * If the presence of a child affects the layout of the components around it,\n     * we want to make a new context value to ensure they get re-rendered\n     * so they can detect that layout change.\n     */\n    o ? void 0 : [r]\n  );\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    s.forEach((c, f) => s.set(f, !1));\n  }, [r]), react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    !r && !s.size && n && n();\n  }, [r]), a === \"popLayout\" && (t = react__WEBPACK_IMPORTED_MODULE_0__.createElement(LT, { isPresent: r }, t)), react__WEBPACK_IMPORTED_MODULE_0__.createElement(ii.Provider, { value: u }, t);\n};\nfunction jT() {\n  return /* @__PURE__ */ new Map();\n}\nconst Jr = (t) => t.key || \"\";\nfunction UT(t, e) {\n  t.forEach((r) => {\n    const n = Jr(r);\n    e.set(n, r);\n  });\n}\nfunction VT(t) {\n  const e = [];\n  return react__WEBPACK_IMPORTED_MODULE_0__.Children.forEach(t, (r) => {\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.isValidElement)(r) && e.push(r);\n  }), e;\n}\nconst $T = ({ children: t, custom: e, initial: r = !0, onExitComplete: n, exitBeforeEnter: i, presenceAffectsLayout: o = !0, mode: a = \"sync\" }) => {\n  i && (a = \"wait\",  true && es(!1, \"Replace exitBeforeEnter with mode='wait'\"));\n  let [s] = NT();\n  const l = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(Gc).forceRender;\n  l && (s = l);\n  const u = Bp(), c = VT(t);\n  let f = c;\n  const h = /* @__PURE__ */ new Set(), p = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(f), g = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(/* @__PURE__ */ new Map()).current, _ = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(!0);\n  if (go(() => {\n    _.current = !1, UT(c, g), p.current = f;\n  }), iu(() => {\n    _.current = !0, g.clear(), h.clear();\n  }), _.current)\n    return react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, f.map((O) => react__WEBPACK_IMPORTED_MODULE_0__.createElement(sa, { key: Jr(O), isPresent: !0, initial: r ? void 0 : !1, presenceAffectsLayout: o, mode: a }, O)));\n  f = [...f];\n  const T = p.current.map(Jr), A = c.map(Jr), w = T.length;\n  for (let O = 0; O < w; O++) {\n    const R = T[O];\n    A.indexOf(R) === -1 && h.add(R);\n  }\n  return a === \"wait\" && h.size && (f = []), h.forEach((O) => {\n    if (A.indexOf(O) !== -1)\n      return;\n    const R = g.get(O);\n    if (!R)\n      return;\n    const $ = T.indexOf(O), U = () => {\n      g.delete(O), h.delete(O);\n      const W = p.current.findIndex((G) => G.key === O);\n      if (p.current.splice(W, 1), !h.size) {\n        if (p.current = c, u.current === !1)\n          return;\n        s(), n && n();\n      }\n    };\n    f.splice($, 0, react__WEBPACK_IMPORTED_MODULE_0__.createElement(sa, { key: Jr(R), isPresent: !1, onExitComplete: U, custom: e, presenceAffectsLayout: o, mode: a }, R));\n  }), f = f.map((O) => {\n    const R = O.key;\n    return h.has(R) ? O : react__WEBPACK_IMPORTED_MODULE_0__.createElement(sa, { key: Jr(O), isPresent: !0, presenceAffectsLayout: o, mode: a }, O);\n  }),  true && a === \"wait\" && f.length > 1 && console.warn(`You're attempting to animate multiple children within AnimatePresence, but its mode is set to \"wait\". This will lead to odd visual behaviour.`), react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, h.size ? f : f.map((O) => (0,react__WEBPACK_IMPORTED_MODULE_0__.cloneElement)(O)));\n};\nfunction bu({\n  open: t,\n  onClose: e,\n  children: r,\n  className: n,\n  variants: i,\n  noWatermark: o = !1\n}) {\n  const a = Ew();\n  return /* @__PURE__ */ be($T, {\n    children: t && /* @__PURE__ */ Ue(KT, {\n      className: \"modal-screen\",\n      children: [/* @__PURE__ */ be(zT, {\n        className: \"modal-background\",\n        variants: HT,\n        initial: \"hidden\",\n        animate: \"shown\",\n        exit: \"hidden\",\n        transition: {\n          ease: \"easeInOut\",\n          duration: 0.23\n        },\n        onClick: e,\n        children: !o && /* @__PURE__ */ Ue(rE, {\n          children: [\"Arweave Wallet Kit v\", Tw]\n        })\n      }, \"bg\"), /* @__PURE__ */ be(GT, {\n        className: \"modal-aligner\",\n        children: /* @__PURE__ */ be(XT, {\n          className: \"modal-animator \" + (n ? \" \" + n : \"\"),\n          variants: i || qT(a),\n          initial: \"hidden\",\n          animate: \"shown\",\n          exit: \"hidden\",\n          children: /* @__PURE__ */ be(eE, {\n            children: r\n          })\n        }, \"modal-animator\")\n      }, \"modal-aligner\")]\n    }, \"modal-screen\")\n  });\n}\nconst HT = {\n  shown: {\n    opacity: 1\n  },\n  hidden: {\n    opacity: 0\n  }\n}, WT = () => Rp.div, zT = /* @__PURE__ */ Me(WT())({\n  name: \"BackgroundLayer\",\n  class: \"bbvkbel\",\n  propsAsIs: !0\n}), qT = (t = !1) => ({\n  shown: {\n    top: 0,\n    opacity: 1,\n    width: t ? \"100vw\" : \"50vw\",\n    transition: {\n      type: \"spring\",\n      duration: 0.4,\n      delayChildren: 0.2,\n      staggerChildren: 0.05\n    }\n  },\n  hidden: {\n    top: \"100%\",\n    width: t ? \"100vw\" : \"50vw\",\n    opacity: 0.4,\n    // TODO(crookse) What's the reason for stopping at 0.4? Asking because a pause in animation is seen.\n    transition: {\n      type: \"spring\",\n      duration: 0.4\n    }\n  }\n}), KT = /* @__PURE__ */ Me(\"div\")({\n  name: \"ModalScreen\",\n  class: \"m1767o4q\",\n  propsAsIs: !1\n}), GT = /* @__PURE__ */ Me(\"div\")({\n  name: \"ModalAligner\",\n  class: \"mzdiz37\",\n  propsAsIs: !1\n}), YT = () => Rp.div, ZT = () => (t) => t.theme.themeConfig.font.fontFamily, XT = ft(/* @__PURE__ */ Me(YT())({\n  name: \"ModalAnimator\",\n  class: \"m69h97z\",\n  propsAsIs: !0,\n  vars: {\n    \"m69h97z-0\": [ZT()]\n  }\n})), JT = () => (t) => t.theme.background, QT = () => (t) => ({\n  default: 30,\n  minimal: 12,\n  none: 0\n})[t.theme.themeConfig.radius] + \"px\", eE = ft(/* @__PURE__ */ Me(\"div\")({\n  name: \"ModalContents\",\n  class: \"mh21eb7\",\n  propsAsIs: !1,\n  vars: {\n    \"mh21eb7-0\": [JT()],\n    \"mh21eb7-1\": [QT()]\n  }\n})), tE = () => (t) => t.theme.themeConfig.font.fontFamily, rE = ft(/* @__PURE__ */ Me(\"p\")({\n  name: \"KitName\",\n  class: \"k17wyawm\",\n  propsAsIs: !1,\n  vars: {\n    \"k17wyawm-0\": [tE()]\n  }\n}));\nfunction _u(t = !1) {\n  const [e, r] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(t);\n  return {\n    setOpen: r,\n    open: e,\n    bindings: {\n      open: e,\n      onClose: () => r(!1)\n    }\n  };\n}\nfunction nE() {\n  const t = _u(), {\n    state: e,\n    dispatch: r\n  } = _t(), [n, i] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)();\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    (async () => {\n      const l = await Pg((e == null ? void 0 : e.config.permissions) || [], !!(e != null && e.config.ensurePermissions));\n      l && l.resumeSession ? (i(l), t.setOpen(!0)) : r({\n        type: \"UPDATE_STRATEGY\",\n        payload: !!l && l.id || !1\n      });\n    })();\n  }, []);\n  function o() {\n    localStorage.removeItem(ti), r({\n      type: \"DISCONNECT\"\n    });\n  }\n  async function a() {\n    let l = !1;\n    if (n != null && n.resumeSession) {\n      l = n;\n      try {\n        await n.resumeSession();\n      } catch {\n        l = !1;\n      }\n    }\n    i(void 0), t.setOpen(!1), r({\n      type: \"UPDATE_STRATEGY\",\n      payload: !!l && l.id || !1\n    }), l || o();\n  }\n  function s() {\n    i(void 0), t.setOpen(!1), o();\n  }\n  return /* @__PURE__ */ Ue(aE, {\n    variants: iE,\n    ...t.bindings,\n    onClose: s,\n    noWatermark: !0,\n    children: [/* @__PURE__ */ Ue(uE, {\n      children: [\"Would you like to restore your \", (n == null ? void 0 : n.name) + \" \" || 0, \"session?\"]\n    }), /* @__PURE__ */ Ue(lE, {\n      children: [/* @__PURE__ */ be(br, {\n        onClick: a,\n        children: \"Restore\"\n      }), /* @__PURE__ */ be(pE, {\n        onClick: s,\n        children: \"Cancel\"\n      })]\n    })]\n  });\n}\nconst iE = {\n  shown: {\n    opacity: 1,\n    translateY: \"-1.5rem\",\n    transition: {\n      type: \"spring\",\n      duration: 0.4,\n      delayChildren: 0.2,\n      staggerChildren: 0.025\n    }\n  },\n  hidden: {\n    opacity: 0.4,\n    translateY: \"200%\",\n    transition: {\n      type: \"spring\",\n      duration: 0.4\n    }\n  }\n}, oE = () => bu, sE = () => (t) => ({\n  default: 15,\n  minimal: 8,\n  none: 0\n})[t.theme.themeConfig.radius] + \"px\", aE = ft(/* @__PURE__ */ Me(oE())({\n  name: \"BottomModal\",\n  class: \"b7jc8fb\",\n  propsAsIs: !0,\n  vars: {\n    \"b7jc8fb-0\": [sE()]\n  }\n})), cE = () => (t) => t.theme.primaryText, uE = ft(/* @__PURE__ */ Me(\"p\")({\n  name: \"Text\",\n  class: \"typmncv\",\n  propsAsIs: !1,\n  vars: {\n    \"typmncv-0\": [cE()]\n  }\n})), lE = /* @__PURE__ */ Me(\"div\")({\n  name: \"Buttons\",\n  class: \"b14qolsb\",\n  propsAsIs: !1\n}), fE = () => br, hE = () => (t) => t.theme.primaryText, dE = () => (t) => t.theme.theme, pE = ft(/* @__PURE__ */ Me(fE())({\n  name: \"CloseButton\",\n  class: \"c1jq17m8\",\n  propsAsIs: !0,\n  vars: {\n    \"c1jq17m8-0\": [hE()],\n    \"c1jq17m8-1\": [dE()]\n  }\n}));\nconst yE = () => (t) => t.small ? \".7rem\" : \".9rem\", mE = () => (t) => t.theme.secondaryText, un = ft(/* @__PURE__ */ Me(\"p\")({\n  name: \"Paragraph\",\n  class: \"p1jty3xq\",\n  propsAsIs: !1,\n  vars: {\n    \"p1jty3xq-0\": [yE()],\n    \"p1jty3xq-1\": [mE()]\n  }\n}));\nconst vE = () => (t) => t.theme.themeConfig.font.fontFamily, gE = () => (t) => t.small ? \"1.05rem\" : \"1.2rem\", xE = () => (t) => t.themed ? oh(t.theme.themeConfig.titleHighlight) : t.theme.primaryText, wE = () => (t) => t.themed ? \"pointer\" : \"text\", Nr = ft(/* @__PURE__ */ Me(\"h1\")({\n  name: \"Title\",\n  class: \"t1sgzzc0\",\n  propsAsIs: !1,\n  vars: {\n    \"t1sgzzc0-0\": [vE()],\n    \"t1sgzzc0-1\": [gE()],\n    \"t1sgzzc0-2\": [xE()],\n    \"t1sgzzc0-3\": [wE()]\n  }\n})), bE = /* @__PURE__ */ Me(\"div\")({\n  name: \"TitleWithParagraph\",\n  class: \"tb205ol\",\n  propsAsIs: !1\n});\nfunction _E({\n  logo: t,\n  name: e,\n  description: r,\n  onClick: n,\n  theme: i\n}) {\n  return /* @__PURE__ */ Ue(AE, {\n    children: [/* @__PURE__ */ Ue(TE, {\n      children: [/* @__PURE__ */ be(Dp, {\n        colorTheme: i,\n        clickable: !0,\n        onClick: n,\n        children: /* @__PURE__ */ be(Ip, {\n          src: t,\n          draggable: !1\n        })\n      }), /* @__PURE__ */ Ue(OE, {\n        children: [/* @__PURE__ */ be(Nr, {\n          small: !0,\n          children: e\n        }), /* @__PURE__ */ be(un, {\n          small: !0,\n          children: r\n        })]\n      })]\n    }), /* @__PURE__ */ be(br, {\n      onClick: n,\n      children: \"Go\"\n    })]\n  });\n}\nconst AE = /* @__PURE__ */ Me(\"div\")({\n  name: \"Wrapper\",\n  class: \"wzg6vks\",\n  propsAsIs: !1\n}), TE = /* @__PURE__ */ Me(\"div\")({\n  name: \"AppInfo\",\n  class: \"a1vzc1qt\",\n  propsAsIs: !1\n}), Ip = /* @__PURE__ */ Me(\"img\")({\n  name: \"Logo\",\n  class: \"l1rbotc6\",\n  propsAsIs: !1\n}), EE = () => (t) => ({\n  default: 15,\n  minimal: 6,\n  none: 0\n})[t.theme.themeConfig.radius] + \"px\", SE = () => (t) => t.colorTheme || t.theme.primaryText, PE = () => (t) => t.clickable ? \"pointer\" : \"default\", CE = () => (t) => t.clickable ? \".95\" : \"1\", Dp = ft(/* @__PURE__ */ Me(\"div\")({\n  name: \"AppIcon\",\n  class: \"acuhj7u\",\n  propsAsIs: !1,\n  vars: {\n    \"acuhj7u-0\": [EE()],\n    \"acuhj7u-1\": [SE()],\n    \"acuhj7u-2\": [PE()],\n    \"acuhj7u-3\": [CE()]\n  }\n})), OE = /* @__PURE__ */ Me(\"div\")({\n  name: \"AppNameAndDescription\",\n  class: \"a143ijem\",\n  propsAsIs: !1\n});\nfunction ME({\n  children: t\n}) {\n  return /* @__PURE__ */ be(RE, {\n    children: t\n  });\n}\nconst kE = () => (t) => t.theme.light, RE = ft(/* @__PURE__ */ Me(\"div\")({\n  name: \"Wrapper\",\n  class: \"wv1c1ab\",\n  propsAsIs: !1,\n  vars: {\n    \"wv1c1ab-0\": [kE()]\n  }\n}));\nconst BE = (t) => /* @__PURE__ */ Ue(IE, {\n  viewBox: \"0 0 48 48\",\n  xmlns: \"http://www.w3.org/2000/svg\",\n  ...t,\n  children: [/* @__PURE__ */ be(\"circle\", {\n    cx: \"24\",\n    cy: \"24\",\n    fill: \"none\",\n    r: \"20\",\n    strokeDasharray: \"80\",\n    strokeLinecap: \"round\",\n    stroke: \"currentColor\",\n    strokeWidth: \"4\"\n  }), /* @__PURE__ */ be(\"circle\", {\n    cx: \"24\",\n    cy: \"24\",\n    fill: \"none\",\n    opacity: \"0.3\",\n    r: \"20\",\n    strokeLinecap: \"round\",\n    stroke: \"currentColor\",\n    strokeWidth: \"4\"\n  })]\n}), IE = /* @__PURE__ */ Me(\"svg\")({\n  name: \"SvgWrapper\",\n  class: \"s9sva\",\n  propsAsIs: !1\n});\nfunction Np({\n  children: t,\n  onClose: e\n}) {\n  return /* @__PURE__ */ Ue(DE, {\n    children: [t, /* @__PURE__ */ be(LE, {\n      onClick: e,\n      children: /* @__PURE__ */ be(Ng, {})\n    })]\n  });\n}\nconst DE = /* @__PURE__ */ Me(\"div\")({\n  name: \"HeadWrapper\",\n  class: \"h1mmuqym\",\n  propsAsIs: !1\n}), NE = () => (t) => t.theme.light, FE = () => (t) => t.theme.secondaryText, LE = ft(/* @__PURE__ */ Me(\"div\")({\n  name: \"CloseButton\",\n  class: \"c86k5gq\",\n  propsAsIs: !1,\n  vars: {\n    \"c86k5gq-0\": [NE()],\n    \"c86k5gq-1\": [FE()]\n  }\n}));\nfunction jE() {\n  const t = _u(), {\n    state: e,\n    dispatch: r\n  } = _t();\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    t.setOpen((e == null ? void 0 : e.activeModal) === \"connect\");\n  }, [e == null ? void 0 : e.activeModal]), (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    t.open || (o(void 0), r({\n      type: \"CLOSE_MODAL\"\n    }));\n  }, [t.open]);\n  const {\n    connected: n\n  } = Tc();\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    !n || (e == null ? void 0 : e.activeModal) !== \"connect\" || r({\n      type: \"CLOSE_MODAL\"\n    });\n  }, [n, e]);\n  const [i, o] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(), a = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => i ? tn(i) : void 0, [i, Dn]), [s, l] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(!1), [u, c] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(!1), [f, h] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(!1), [p, g] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(!1);\n  async function _(U) {\n    const W = Dn.find((Z) => Z.id === U);\n    if (!W)\n      return;\n    c(!0), o(U);\n    let G = !1;\n    try {\n      G = await W.isAvailable();\n    } catch {\n      G = !1;\n    }\n    h(G), c(!1), G && await T(W);\n  }\n  async function T(U) {\n    g(!1), l(!0);\n    try {\n      await U.connect(e.config.permissions, e.config.appInfo, e.config.gatewayConfig), postMessage({\n        type: \"connect_result\",\n        res: !0\n      }), r({\n        type: \"CLOSE_MODAL\"\n      }), Ea(U.id), r({\n        type: \"UPDATE_STRATEGY\",\n        payload: U.id\n      });\n    } catch {\n      O(), g(!0), r({\n        type: \"UPDATE_STRATEGY\",\n        payload: !1\n      });\n    }\n    l(!1);\n  }\n  function A() {\n    postMessage({\n      type: \"connect_result\",\n      res: !1\n    }), r({\n      type: \"CLOSE_MODAL\"\n    });\n  }\n  const w = qc();\n  function O() {\n    try {\n      document.querySelectorAll(\".arconnect_connect_overlay_extension_temporary\").forEach((U) => U.remove());\n    } catch {\n    }\n  }\n  const [R, $] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(!1);\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    (async () => {\n      const U = navigator.brave && await navigator.brave.isBrave();\n      $(U);\n    })();\n  }, []), /* @__PURE__ */ Ue(bu, {\n    ...t.bindings,\n    onClose: A,\n    children: [/* @__PURE__ */ be(Np, {\n      onClose: A,\n      children: /* @__PURE__ */ Ue(Nr, {\n        themed: !!i,\n        onClick: () => {\n          i && o(void 0);\n        },\n        children: [i && /* @__PURE__ */ be(ZE, {}), a ? a.name : \"Connect wallet\"]\n      })\n    }), !i && /* @__PURE__ */ be(UE, {\n      children: Dn.map((U, W) => /* @__PURE__ */ be(_E, {\n        name: U.name,\n        description: U.description,\n        logo: `${w}/${U.logo}`,\n        theme: U.theme,\n        onClick: () => _(U.id)\n      }, W))\n    }) || /* @__PURE__ */ be(VE, {\n      children: /* @__PURE__ */ Ue($E, {\n        children: [/* @__PURE__ */ be(Dp, {\n          colorTheme: a == null ? void 0 : a.theme,\n          children: /* @__PURE__ */ be(Ip, {\n            src: `${w}/${a == null ? void 0 : a.logo}`,\n            draggable: !1\n          })\n        }), f && /* @__PURE__ */ Ue(zn, {\n          children: [/* @__PURE__ */ Ue(Nr, {\n            small: !0,\n            children: [\"Connecting to \", (a == null ? void 0 : a.name) || \"\", \"...\"]\n          }), /* @__PURE__ */ be(un, {\n            children: \"Confirm connection request in the wallet popup window\"\n          }), (a == null ? void 0 : a.id) === \"othent\" && R && /* @__PURE__ */ Ue(zE, {\n            children: [\"You might need to \", /* @__PURE__ */ be(\"b\", {\n              children: \"disable Brave shields\"\n            }), \" for this to work properly.\"]\n          }), p && a && /* @__PURE__ */ be(br, {\n            onClick: () => T(a),\n            children: \"Retry\"\n          })]\n        }) || !u && /* @__PURE__ */ Ue(zn, {\n          children: [\n            /* @__PURE__ */ Ue(Nr, {\n              small: !0,\n              children: [(a == null ? void 0 : a.name) || \"\", \" is not available.\"]\n            }),\n            /* @__PURE__ */ be(un, {\n              children: \"If you don't have it yet, you can try to download it\"\n            }),\n            // @ts-expect-error\n            (a == null ? void 0 : a.url) && /* @__PURE__ */ be(br, {\n              onClick: () => {\n                window.open(a.url);\n              },\n              children: \"Download\"\n            })\n          ]\n        }), (s || u) && /* @__PURE__ */ be(GE, {})]\n      })\n    }), /* @__PURE__ */ Ue(ME, {\n      children: [/* @__PURE__ */ Ue(bE, {\n        children: [/* @__PURE__ */ be(Nr, {\n          small: !0,\n          children: \"Don't have a wallet?\"\n        }), /* @__PURE__ */ be(un, {\n          small: !0,\n          children: \"Click to learn more about the permaweb & wallets.\"\n        })]\n      }), /* @__PURE__ */ be(br, {\n        onClick: () => window.open(\"https://arwiki.wiki/#/en/wallets\"),\n        children: \"Get\"\n      })]\n    })]\n  });\n}\nconst UE = /* @__PURE__ */ Me(\"div\")({\n  name: \"Apps\",\n  class: \"a1osnke6\",\n  propsAsIs: !1\n}), VE = /* @__PURE__ */ Me(\"div\")({\n  name: \"Connecting\",\n  class: \"c15u83h7\",\n  propsAsIs: !1\n}), $E = /* @__PURE__ */ Me(\"div\")({\n  name: \"WalletData\",\n  class: \"w5r445t\",\n  propsAsIs: !1\n}), HE = () => un, WE = () => (t) => ({\n  default: 14,\n  minimal: 8,\n  none: 0\n})[t.theme.themeConfig.radius] + \"px\", zE = ft(/* @__PURE__ */ Me(HE())({\n  name: \"BraveParagraph\",\n  class: \"bukrfi8\",\n  propsAsIs: !0,\n  vars: {\n    \"bukrfi8-0\": [WE()]\n  }\n})), qE = () => BE, KE = () => (t) => t.theme.primaryText, GE = ft(/* @__PURE__ */ Me(qE())({\n  name: \"ConnectLoading\",\n  class: \"c13sms3\",\n  propsAsIs: !0,\n  vars: {\n    \"c13sms3-0\": [KE()]\n  }\n})), YE = () => Dg, ZE = /* @__PURE__ */ Me(YE())({\n  name: \"BackButton\",\n  class: \"b1r2gdr0\",\n  propsAsIs: !0\n});\nfunction XE() {\n  const t = _u(), {\n    state: e,\n    dispatch: r\n  } = _t();\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    t.setOpen((e == null ? void 0 : e.activeModal) === \"profile\");\n  }, [e == null ? void 0 : e.activeModal]), (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    t.open || r({\n      type: \"CLOSE_MODAL\"\n    });\n  }, [t.open, r]);\n  function n() {\n    r({\n      type: \"CLOSE_MODAL\"\n    });\n  }\n  const i = vd(), o = xd(), a = qc(), {\n    disconnect: s\n  } = Tc(), l = ir();\n  return /* @__PURE__ */ Ue(bu, {\n    ...t.bindings,\n    onClose: n,\n    children: [/* @__PURE__ */ be(Np, {\n      onClose: n,\n      children: /* @__PURE__ */ be(Nr, {\n        children: \"Profile\"\n      })\n    }), /* @__PURE__ */ Ue(QE, {\n      children: [/* @__PURE__ */ Ue(nS, {\n        profilePicture: o == null ? void 0 : o.avatar,\n        children: [!(o != null && o.avatar) && /* @__PURE__ */ be(cS, {}), /* @__PURE__ */ be(sS, {\n          strategyTheme: l == null ? void 0 : l.theme,\n          children: /* @__PURE__ */ be(\"img\", {\n            src: l != null && l.logo ? `${a}/${l.logo}` : \"\",\n            alt: (l == null ? void 0 : l.name) || \"active strategy logo\",\n            draggable: !1\n          })\n        })]\n      }), /* @__PURE__ */ Ue(Nr, {\n        children: [(o == null ? void 0 : o.currentLabel) || ih((e == null ? void 0 : e.activeAddress) || \"\", 8), /* @__PURE__ */ be(Fg, {\n          onClick: () => navigator.clipboard.writeText(e.activeAddress || \"\")\n        })]\n      }), /* @__PURE__ */ Ue(un, {\n        children: [i.toLocaleString(void 0, {\n          maximumFractionDigits: 4\n        }), \" AR\"]\n      }), /* @__PURE__ */ Ue(br, {\n        onClick: s,\n        children: [/* @__PURE__ */ be(Lg, {}), \"Disconnect\"]\n      })]\n    })]\n  });\n}\nconst JE = () => (t) => ({\n  default: 18,\n  minimal: 10,\n  none: 0\n})[t.theme.themeConfig.radius] + \"px\", QE = ft(/* @__PURE__ */ Me(\"div\")({\n  name: \"ProfileData\",\n  class: \"p1hjgol5\",\n  propsAsIs: !1,\n  vars: {\n    \"p1hjgol5-0\": [JE()]\n  }\n})), eS = () => (t) => ({\n  default: \"100%\",\n  minimal: \"8px\",\n  none: \"none\"\n})[t.theme.themeConfig.radius], tS = () => (t) => t.theme.theme, rS = () => (t) => t.profilePicture ? `background-image: url(${t.profilePicture});` : \"\", nS = ft(/* @__PURE__ */ Me(\"div\")({\n  name: \"ProfilePicture\",\n  class: \"publs4f\",\n  propsAsIs: !1,\n  vars: {\n    \"publs4f-0\": [eS()],\n    \"publs4f-1\": [tS()],\n    \"publs4f-2\": [rS()]\n  }\n})), iS = () => (t) => t.strategyTheme || t.theme.theme, oS = () => (t) => t.theme.background, sS = ft(/* @__PURE__ */ Me(\"div\")({\n  name: \"ActiveStrategy\",\n  class: \"alzinag\",\n  propsAsIs: !1,\n  vars: {\n    \"alzinag-0\": [iS()],\n    \"alzinag-1\": [oS()]\n  }\n})), aS = () => Bh, cS = /* @__PURE__ */ Me(aS())({\n  name: \"ProfileIcon\",\n  class: \"p1qewrlg\",\n  propsAsIs: !0\n});\nfunction uS(t = vc, e) {\n  switch (e.type) {\n    case \"OPEN_MODAL\":\n      return {\n        ...t,\n        activeModal: e.payload\n      };\n    case \"CLOSE_MODAL\":\n      return {\n        ...t,\n        activeModal: !1\n      };\n    case \"DISCONNECT\":\n      return {\n        ...t,\n        activeStrategy: !1,\n        activeAddress: void 0,\n        givenPermissions: []\n      };\n    case \"UPDATE_STRATEGY\":\n      return {\n        ...t,\n        activeStrategy: e.payload\n      };\n    case \"UPDATE_CONFIG\":\n      return {\n        ...t,\n        config: e.payload\n      };\n    case \"UPDATE_ADDRESS\":\n      return {\n        ...t,\n        activeAddress: e.payload\n      };\n    case \"UPDATE_PERMISSIONS\":\n      return {\n        ...t,\n        givenPermissions: e.payload\n      };\n  }\n  return t;\n}\nvar Ze = {}, O0 = {\n  get exports() {\n    return Ze;\n  },\n  set exports(t) {\n    Ze = t;\n  }\n};\n/*\nobject-assign\n(c) Sindre Sorhus\n@license MIT\n*/\nvar M0 = Object.getOwnPropertySymbols, lS = Object.prototype.hasOwnProperty, fS = Object.prototype.propertyIsEnumerable;\nfunction hS(t) {\n  if (t == null)\n    throw new TypeError(\"Object.assign cannot be called with null or undefined\");\n  return Object(t);\n}\nfunction dS() {\n  try {\n    if (!Object.assign)\n      return !1;\n    var t = new String(\"abc\");\n    if (t[5] = \"de\", Object.getOwnPropertyNames(t)[0] === \"5\")\n      return !1;\n    for (var e = {}, r = 0; r < 10; r++)\n      e[\"_\" + String.fromCharCode(r)] = r;\n    var n = Object.getOwnPropertyNames(e).map(function(o) {\n      return e[o];\n    });\n    if (n.join(\"\") !== \"0123456789\")\n      return !1;\n    var i = {};\n    return \"abcdefghijklmnopqrst\".split(\"\").forEach(function(o) {\n      i[o] = o;\n    }), Object.keys(Object.assign({}, i)).join(\"\") === \"abcdefghijklmnopqrst\";\n  } catch {\n    return !1;\n  }\n}\nvar Fp = dS() ? Object.assign : function(t, e) {\n  for (var r, n = hS(t), i, o = 1; o < arguments.length; o++) {\n    r = Object(arguments[o]);\n    for (var a in r)\n      lS.call(r, a) && (n[a] = r[a]);\n    if (M0) {\n      i = M0(r);\n      for (var s = 0; s < i.length; s++)\n        fS.call(r, i[s]) && (n[i[s]] = r[i[s]]);\n    }\n  }\n  return n;\n}, aa, k0;\nfunction Au() {\n  if (k0)\n    return aa;\n  k0 = 1;\n  var t = \"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED\";\n  return aa = t, aa;\n}\nvar ca, R0;\nfunction Lp() {\n  return R0 || (R0 = 1, ca = Function.call.bind(Object.prototype.hasOwnProperty)), ca;\n}\nvar ua, B0;\nfunction pS() {\n  if (B0)\n    return ua;\n  B0 = 1;\n  var t = function() {\n  };\n  if (true) {\n    var e = Au(), r = {}, n = Lp();\n    t = function(o) {\n      var a = \"Warning: \" + o;\n      typeof console < \"u\" && console.error(a);\n      try {\n        throw new Error(a);\n      } catch {\n      }\n    };\n  }\n  function i(o, a, s, l, u) {\n    if (true) {\n      for (var c in o)\n        if (n(o, c)) {\n          var f;\n          try {\n            if (typeof o[c] != \"function\") {\n              var h = Error(\n                (l || \"React class\") + \": \" + s + \" type `\" + c + \"` is invalid; it must be a function, usually from the `prop-types` package, but received `\" + typeof o[c] + \"`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.\"\n              );\n              throw h.name = \"Invariant Violation\", h;\n            }\n            f = o[c](a, c, l, s, null, e);\n          } catch (g) {\n            f = g;\n          }\n          if (f && !(f instanceof Error) && t(\n            (l || \"React class\") + \": type specification of \" + s + \" `\" + c + \"` is invalid; the type checker function must return `null` or an `Error` but returned a \" + typeof f + \". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).\"\n          ), f instanceof Error && !(f.message in r)) {\n            r[f.message] = !0;\n            var p = u ? u() : \"\";\n            t(\n              \"Failed \" + s + \" type: \" + f.message + (p ?? \"\")\n            );\n          }\n        }\n    }\n  }\n  return i.resetWarningCache = function() {\n     true && (r = {});\n  }, ua = i, ua;\n}\nvar la, I0;\nfunction yS() {\n  if (I0)\n    return la;\n  I0 = 1;\n  var t = xc(), e = Fp, r = Au(), n = Lp(), i = pS(), o = function() {\n  };\n   true && (o = function(s) {\n    var l = \"Warning: \" + s;\n    typeof console < \"u\" && console.error(l);\n    try {\n      throw new Error(l);\n    } catch {\n    }\n  });\n  function a() {\n    return null;\n  }\n  return la = function(s, l) {\n    var u = typeof Symbol == \"function\" && Symbol.iterator, c = \"@@iterator\";\n    function f(m) {\n      var E = m && (u && m[u] || m[c]);\n      if (typeof E == \"function\")\n        return E;\n    }\n    var h = \"<<anonymous>>\", p = {\n      array: A(\"array\"),\n      bigint: A(\"bigint\"),\n      bool: A(\"boolean\"),\n      func: A(\"function\"),\n      number: A(\"number\"),\n      object: A(\"object\"),\n      string: A(\"string\"),\n      symbol: A(\"symbol\"),\n      any: w(),\n      arrayOf: O,\n      element: R(),\n      elementType: $(),\n      instanceOf: U,\n      node: j(),\n      objectOf: G,\n      oneOf: W,\n      oneOfType: Z,\n      shape: d,\n      exact: x\n    };\n    function g(m, E) {\n      return m === E ? m !== 0 || 1 / m === 1 / E : m !== m && E !== E;\n    }\n    function _(m, E) {\n      this.message = m, this.data = E && typeof E == \"object\" ? E : {}, this.stack = \"\";\n    }\n    _.prototype = Error.prototype;\n    function T(m) {\n      if (true)\n        var E = {}, B = 0;\n      function V(ne, se, ce, oe, he, k, H) {\n        if (oe = oe || h, k = k || ce, H !== r) {\n          if (l) {\n            var N = new Error(\n              \"Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types\"\n            );\n            throw N.name = \"Invariant Violation\", N;\n          } else if ( true && typeof console < \"u\") {\n            var J = oe + \":\" + ce;\n            !E[J] && // Avoid spamming the console because they are often not actionable except for lib authors\n            B < 3 && (o(\n              \"You are manually calling a React.PropTypes validation function for the `\" + k + \"` prop on `\" + oe + \"`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details.\"\n            ), E[J] = !0, B++);\n          }\n        }\n        return se[ce] == null ? ne ? se[ce] === null ? new _(\"The \" + he + \" `\" + k + \"` is marked as required \" + (\"in `\" + oe + \"`, but its value is `null`.\")) : new _(\"The \" + he + \" `\" + k + \"` is marked as required in \" + (\"`\" + oe + \"`, but its value is `undefined`.\")) : null : m(se, ce, oe, he, k);\n      }\n      var I = V.bind(null, !1);\n      return I.isRequired = V.bind(null, !0), I;\n    }\n    function A(m) {\n      function E(B, V, I, ne, se, ce) {\n        var oe = B[V], he = D(oe);\n        if (he !== m) {\n          var k = z(oe);\n          return new _(\n            \"Invalid \" + ne + \" `\" + se + \"` of type \" + (\"`\" + k + \"` supplied to `\" + I + \"`, expected \") + (\"`\" + m + \"`.\"),\n            { expectedType: m }\n          );\n        }\n        return null;\n      }\n      return T(E);\n    }\n    function w() {\n      return T(a);\n    }\n    function O(m) {\n      function E(B, V, I, ne, se) {\n        if (typeof m != \"function\")\n          return new _(\"Property `\" + se + \"` of component `\" + I + \"` has invalid PropType notation inside arrayOf.\");\n        var ce = B[V];\n        if (!Array.isArray(ce)) {\n          var oe = D(ce);\n          return new _(\"Invalid \" + ne + \" `\" + se + \"` of type \" + (\"`\" + oe + \"` supplied to `\" + I + \"`, expected an array.\"));\n        }\n        for (var he = 0; he < ce.length; he++) {\n          var k = m(ce, he, I, ne, se + \"[\" + he + \"]\", r);\n          if (k instanceof Error)\n            return k;\n        }\n        return null;\n      }\n      return T(E);\n    }\n    function R() {\n      function m(E, B, V, I, ne) {\n        var se = E[B];\n        if (!s(se)) {\n          var ce = D(se);\n          return new _(\"Invalid \" + I + \" `\" + ne + \"` of type \" + (\"`\" + ce + \"` supplied to `\" + V + \"`, expected a single ReactElement.\"));\n        }\n        return null;\n      }\n      return T(m);\n    }\n    function $() {\n      function m(E, B, V, I, ne) {\n        var se = E[B];\n        if (!t.isValidElementType(se)) {\n          var ce = D(se);\n          return new _(\"Invalid \" + I + \" `\" + ne + \"` of type \" + (\"`\" + ce + \"` supplied to `\" + V + \"`, expected a single ReactElement type.\"));\n        }\n        return null;\n      }\n      return T(m);\n    }\n    function U(m) {\n      function E(B, V, I, ne, se) {\n        if (!(B[V] instanceof m)) {\n          var ce = m.name || h, oe = L(B[V]);\n          return new _(\"Invalid \" + ne + \" `\" + se + \"` of type \" + (\"`\" + oe + \"` supplied to `\" + I + \"`, expected \") + (\"instance of `\" + ce + \"`.\"));\n        }\n        return null;\n      }\n      return T(E);\n    }\n    function W(m) {\n      if (!Array.isArray(m))\n        return  true && (arguments.length > 1 ? o(\n          \"Invalid arguments supplied to oneOf, expected an array, got \" + arguments.length + \" arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z]).\"\n        ) : o(\"Invalid argument supplied to oneOf, expected an array.\")), a;\n      function E(B, V, I, ne, se) {\n        for (var ce = B[V], oe = 0; oe < m.length; oe++)\n          if (g(ce, m[oe]))\n            return null;\n        var he = JSON.stringify(m, function(H, N) {\n          var J = z(N);\n          return J === \"symbol\" ? String(N) : N;\n        });\n        return new _(\"Invalid \" + ne + \" `\" + se + \"` of value `\" + String(ce) + \"` \" + (\"supplied to `\" + I + \"`, expected one of \" + he + \".\"));\n      }\n      return T(E);\n    }\n    function G(m) {\n      function E(B, V, I, ne, se) {\n        if (typeof m != \"function\")\n          return new _(\"Property `\" + se + \"` of component `\" + I + \"` has invalid PropType notation inside objectOf.\");\n        var ce = B[V], oe = D(ce);\n        if (oe !== \"object\")\n          return new _(\"Invalid \" + ne + \" `\" + se + \"` of type \" + (\"`\" + oe + \"` supplied to `\" + I + \"`, expected an object.\"));\n        for (var he in ce)\n          if (n(ce, he)) {\n            var k = m(ce, he, I, ne, se + \".\" + he, r);\n            if (k instanceof Error)\n              return k;\n          }\n        return null;\n      }\n      return T(E);\n    }\n    function Z(m) {\n      if (!Array.isArray(m))\n        return  true && o(\"Invalid argument supplied to oneOfType, expected an instance of array.\"), a;\n      for (var E = 0; E < m.length; E++) {\n        var B = m[E];\n        if (typeof B != \"function\")\n          return o(\n            \"Invalid argument supplied to oneOfType. Expected an array of check functions, but received \" + Y(B) + \" at index \" + E + \".\"\n          ), a;\n      }\n      function V(I, ne, se, ce, oe) {\n        for (var he = [], k = 0; k < m.length; k++) {\n          var H = m[k], N = H(I, ne, se, ce, oe, r);\n          if (N == null)\n            return null;\n          N.data && n(N.data, \"expectedType\") && he.push(N.data.expectedType);\n        }\n        var J = he.length > 0 ? \", expected one of type [\" + he.join(\", \") + \"]\" : \"\";\n        return new _(\"Invalid \" + ce + \" `\" + oe + \"` supplied to \" + (\"`\" + se + \"`\" + J + \".\"));\n      }\n      return T(V);\n    }\n    function j() {\n      function m(E, B, V, I, ne) {\n        return C(E[B]) ? null : new _(\"Invalid \" + I + \" `\" + ne + \"` supplied to \" + (\"`\" + V + \"`, expected a ReactNode.\"));\n      }\n      return T(m);\n    }\n    function P(m, E, B, V, I) {\n      return new _(\n        (m || \"React class\") + \": \" + E + \" type `\" + B + \".\" + V + \"` is invalid; it must be a function, usually from the `prop-types` package, but received `\" + I + \"`.\"\n      );\n    }\n    function d(m) {\n      function E(B, V, I, ne, se) {\n        var ce = B[V], oe = D(ce);\n        if (oe !== \"object\")\n          return new _(\"Invalid \" + ne + \" `\" + se + \"` of type `\" + oe + \"` \" + (\"supplied to `\" + I + \"`, expected `object`.\"));\n        for (var he in m) {\n          var k = m[he];\n          if (typeof k != \"function\")\n            return P(I, ne, se, he, z(k));\n          var H = k(ce, he, I, ne, se + \".\" + he, r);\n          if (H)\n            return H;\n        }\n        return null;\n      }\n      return T(E);\n    }\n    function x(m) {\n      function E(B, V, I, ne, se) {\n        var ce = B[V], oe = D(ce);\n        if (oe !== \"object\")\n          return new _(\"Invalid \" + ne + \" `\" + se + \"` of type `\" + oe + \"` \" + (\"supplied to `\" + I + \"`, expected `object`.\"));\n        var he = e({}, B[V], m);\n        for (var k in he) {\n          var H = m[k];\n          if (n(m, k) && typeof H != \"function\")\n            return P(I, ne, se, k, z(H));\n          if (!H)\n            return new _(\n              \"Invalid \" + ne + \" `\" + se + \"` key `\" + k + \"` supplied to `\" + I + \"`.\\nBad object: \" + JSON.stringify(B[V], null, \"  \") + `\nValid keys: ` + JSON.stringify(Object.keys(m), null, \"  \")\n            );\n          var N = H(ce, k, I, ne, se + \".\" + k, r);\n          if (N)\n            return N;\n        }\n        return null;\n      }\n      return T(E);\n    }\n    function C(m) {\n      switch (typeof m) {\n        case \"number\":\n        case \"string\":\n        case \"undefined\":\n          return !0;\n        case \"boolean\":\n          return !m;\n        case \"object\":\n          if (Array.isArray(m))\n            return m.every(C);\n          if (m === null || s(m))\n            return !0;\n          var E = f(m);\n          if (E) {\n            var B = E.call(m), V;\n            if (E !== m.entries) {\n              for (; !(V = B.next()).done; )\n                if (!C(V.value))\n                  return !1;\n            } else\n              for (; !(V = B.next()).done; ) {\n                var I = V.value;\n                if (I && !C(I[1]))\n                  return !1;\n              }\n          } else\n            return !1;\n          return !0;\n        default:\n          return !1;\n      }\n    }\n    function M(m, E) {\n      return m === \"symbol\" ? !0 : E ? E[\"@@toStringTag\"] === \"Symbol\" || typeof Symbol == \"function\" && E instanceof Symbol : !1;\n    }\n    function D(m) {\n      var E = typeof m;\n      return Array.isArray(m) ? \"array\" : m instanceof RegExp ? \"object\" : M(E, m) ? \"symbol\" : E;\n    }\n    function z(m) {\n      if (typeof m > \"u\" || m === null)\n        return \"\" + m;\n      var E = D(m);\n      if (E === \"object\") {\n        if (m instanceof Date)\n          return \"date\";\n        if (m instanceof RegExp)\n          return \"regexp\";\n      }\n      return E;\n    }\n    function Y(m) {\n      var E = z(m);\n      switch (E) {\n        case \"array\":\n        case \"object\":\n          return \"an \" + E;\n        case \"boolean\":\n        case \"date\":\n        case \"regexp\":\n          return \"a \" + E;\n        default:\n          return E;\n      }\n    }\n    function L(m) {\n      return !m.constructor || !m.constructor.name ? h : m.constructor.name;\n    }\n    return p.checkPropTypes = i, p.resetWarningCache = i.resetWarningCache, p.PropTypes = p, p;\n  }, la;\n}\nvar fa, D0;\nfunction mS() {\n  if (D0)\n    return fa;\n  D0 = 1;\n  var t = Au();\n  function e() {\n  }\n  function r() {\n  }\n  return r.resetWarningCache = e, fa = function() {\n    function n(a, s, l, u, c, f) {\n      if (f !== t) {\n        var h = new Error(\n          \"Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types\"\n        );\n        throw h.name = \"Invariant Violation\", h;\n      }\n    }\n    n.isRequired = n;\n    function i() {\n      return n;\n    }\n    var o = {\n      array: n,\n      bigint: n,\n      bool: n,\n      func: n,\n      number: n,\n      object: n,\n      string: n,\n      symbol: n,\n      any: n,\n      arrayOf: i,\n      element: n,\n      elementType: n,\n      instanceOf: i,\n      node: n,\n      objectOf: i,\n      oneOf: i,\n      oneOfType: i,\n      shape: i,\n      exact: i,\n      checkPropTypes: r,\n      resetWarningCache: e\n    };\n    return o.PropTypes = o, o;\n  }, fa;\n}\nif (true) {\n  var vS = xc(), gS = !0;\n  O0.exports = yS()(vS.isElement, gS);\n} else\n  {}\nfunction xS(t) {\n  return t && typeof t == \"object\" && \"default\" in t ? t.default : t;\n}\nvar jp = react__WEBPACK_IMPORTED_MODULE_0__, wS = xS(jp);\nfunction N0(t, e, r) {\n  return e in t ? Object.defineProperty(t, e, {\n    value: r,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : t[e] = r, t;\n}\nfunction bS(t, e) {\n  t.prototype = Object.create(e.prototype), t.prototype.constructor = t, t.__proto__ = e;\n}\nvar _S = !!(typeof window < \"u\" && window.document && window.document.createElement);\nfunction AS(t, e, r) {\n  if (typeof t != \"function\")\n    throw new Error(\"Expected reducePropsToState to be a function.\");\n  if (typeof e != \"function\")\n    throw new Error(\"Expected handleStateChangeOnClient to be a function.\");\n  if (typeof r < \"u\" && typeof r != \"function\")\n    throw new Error(\"Expected mapStateOnServer to either be undefined or a function.\");\n  function n(i) {\n    return i.displayName || i.name || \"Component\";\n  }\n  return function(o) {\n    if (typeof o != \"function\")\n      throw new Error(\"Expected WrappedComponent to be a React component.\");\n    var a = [], s;\n    function l() {\n      s = t(a.map(function(c) {\n        return c.props;\n      })), u.canUseDOM ? e(s) : r && (s = r(s));\n    }\n    var u = /* @__PURE__ */ function(c) {\n      bS(f, c);\n      function f() {\n        return c.apply(this, arguments) || this;\n      }\n      f.peek = function() {\n        return s;\n      }, f.rewind = function() {\n        if (f.canUseDOM)\n          throw new Error(\"You may only call rewind() on the server. Call peek() to read the current state.\");\n        var g = s;\n        return s = void 0, a = [], g;\n      };\n      var h = f.prototype;\n      return h.UNSAFE_componentWillMount = function() {\n        a.push(this), l();\n      }, h.componentDidUpdate = function() {\n        l();\n      }, h.componentWillUnmount = function() {\n        var g = a.indexOf(this);\n        a.splice(g, 1), l();\n      }, h.render = function() {\n        return wS.createElement(o, this.props);\n      }, f;\n    }(jp.PureComponent);\n    return N0(u, \"displayName\", \"SideEffect(\" + n(o) + \")\"), N0(u, \"canUseDOM\", _S), u;\n  };\n}\nvar TS = AS, ES = typeof Element < \"u\", SS = typeof Map == \"function\", PS = typeof Set == \"function\", CS = typeof ArrayBuffer == \"function\" && !!ArrayBuffer.isView;\nfunction Pi(t, e) {\n  if (t === e)\n    return !0;\n  if (t && e && typeof t == \"object\" && typeof e == \"object\") {\n    if (t.constructor !== e.constructor)\n      return !1;\n    var r, n, i;\n    if (Array.isArray(t)) {\n      if (r = t.length, r != e.length)\n        return !1;\n      for (n = r; n-- !== 0; )\n        if (!Pi(t[n], e[n]))\n          return !1;\n      return !0;\n    }\n    var o;\n    if (SS && t instanceof Map && e instanceof Map) {\n      if (t.size !== e.size)\n        return !1;\n      for (o = t.entries(); !(n = o.next()).done; )\n        if (!e.has(n.value[0]))\n          return !1;\n      for (o = t.entries(); !(n = o.next()).done; )\n        if (!Pi(n.value[1], e.get(n.value[0])))\n          return !1;\n      return !0;\n    }\n    if (PS && t instanceof Set && e instanceof Set) {\n      if (t.size !== e.size)\n        return !1;\n      for (o = t.entries(); !(n = o.next()).done; )\n        if (!e.has(n.value[0]))\n          return !1;\n      return !0;\n    }\n    if (CS && ArrayBuffer.isView(t) && ArrayBuffer.isView(e)) {\n      if (r = t.length, r != e.length)\n        return !1;\n      for (n = r; n-- !== 0; )\n        if (t[n] !== e[n])\n          return !1;\n      return !0;\n    }\n    if (t.constructor === RegExp)\n      return t.source === e.source && t.flags === e.flags;\n    if (t.valueOf !== Object.prototype.valueOf)\n      return t.valueOf() === e.valueOf();\n    if (t.toString !== Object.prototype.toString)\n      return t.toString() === e.toString();\n    if (i = Object.keys(t), r = i.length, r !== Object.keys(e).length)\n      return !1;\n    for (n = r; n-- !== 0; )\n      if (!Object.prototype.hasOwnProperty.call(e, i[n]))\n        return !1;\n    if (ES && t instanceof Element)\n      return !1;\n    for (n = r; n-- !== 0; )\n      if (!((i[n] === \"_owner\" || i[n] === \"__v\" || i[n] === \"__o\") && t.$$typeof) && !Pi(t[i[n]], e[i[n]]))\n        return !1;\n    return !0;\n  }\n  return t !== t && e !== e;\n}\nvar OS = function(e, r) {\n  try {\n    return Pi(e, r);\n  } catch (n) {\n    if ((n.message || \"\").match(/stack|recursion/i))\n      return console.warn(\"react-fast-compare cannot handle circular refs\"), !1;\n    throw n;\n  }\n}, jr = {\n  BODY: \"bodyAttributes\",\n  HTML: \"htmlAttributes\",\n  TITLE: \"titleAttributes\"\n}, Oe = {\n  BASE: \"base\",\n  BODY: \"body\",\n  HEAD: \"head\",\n  HTML: \"html\",\n  LINK: \"link\",\n  META: \"meta\",\n  NOSCRIPT: \"noscript\",\n  SCRIPT: \"script\",\n  STYLE: \"style\",\n  TITLE: \"title\"\n}, F0 = Object.keys(Oe).map(function(t) {\n  return Oe[t];\n}), st = {\n  CHARSET: \"charset\",\n  CSS_TEXT: \"cssText\",\n  HREF: \"href\",\n  HTTPEQUIV: \"http-equiv\",\n  INNER_HTML: \"innerHTML\",\n  ITEM_PROP: \"itemprop\",\n  NAME: \"name\",\n  PROPERTY: \"property\",\n  REL: \"rel\",\n  SRC: \"src\",\n  TARGET: \"target\"\n}, Oo = {\n  accesskey: \"accessKey\",\n  charset: \"charSet\",\n  class: \"className\",\n  contenteditable: \"contentEditable\",\n  contextmenu: \"contextMenu\",\n  \"http-equiv\": \"httpEquiv\",\n  itemprop: \"itemProp\",\n  tabindex: \"tabIndex\"\n}, Zn = {\n  DEFAULT_TITLE: \"defaultTitle\",\n  DEFER: \"defer\",\n  ENCODE_SPECIAL_CHARACTERS: \"encodeSpecialCharacters\",\n  ON_CHANGE_CLIENT_STATE: \"onChangeClientState\",\n  TITLE_TEMPLATE: \"titleTemplate\"\n}, MS = Object.keys(Oo).reduce(function(t, e) {\n  return t[Oo[e]] = e, t;\n}, {}), kS = [Oe.NOSCRIPT, Oe.SCRIPT, Oe.STYLE], Kt = \"data-react-helmet\", RS = typeof Symbol == \"function\" && typeof Symbol.iterator == \"symbol\" ? function(t) {\n  return typeof t;\n} : function(t) {\n  return t && typeof Symbol == \"function\" && t.constructor === Symbol && t !== Symbol.prototype ? \"symbol\" : typeof t;\n}, BS = function(t, e) {\n  if (!(t instanceof e))\n    throw new TypeError(\"Cannot call a class as a function\");\n}, IS = function() {\n  function t(e, r) {\n    for (var n = 0; n < r.length; n++) {\n      var i = r[n];\n      i.enumerable = i.enumerable || !1, i.configurable = !0, \"value\" in i && (i.writable = !0), Object.defineProperty(e, i.key, i);\n    }\n  }\n  return function(e, r, n) {\n    return r && t(e.prototype, r), n && t(e, n), e;\n  };\n}(), Pt = Object.assign || function(t) {\n  for (var e = 1; e < arguments.length; e++) {\n    var r = arguments[e];\n    for (var n in r)\n      Object.prototype.hasOwnProperty.call(r, n) && (t[n] = r[n]);\n  }\n  return t;\n}, DS = function(t, e) {\n  if (typeof e != \"function\" && e !== null)\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof e);\n  t.prototype = Object.create(e && e.prototype, {\n    constructor: {\n      value: t,\n      enumerable: !1,\n      writable: !0,\n      configurable: !0\n    }\n  }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);\n}, L0 = function(t, e) {\n  var r = {};\n  for (var n in t)\n    e.indexOf(n) >= 0 || Object.prototype.hasOwnProperty.call(t, n) && (r[n] = t[n]);\n  return r;\n}, NS = function(t, e) {\n  if (!t)\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  return e && (typeof e == \"object\" || typeof e == \"function\") ? e : t;\n}, za = function(e) {\n  var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;\n  return r === !1 ? String(e) : String(e).replace(/&/g, \"&amp;\").replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\").replace(/\"/g, \"&quot;\").replace(/'/g, \"&#x27;\");\n}, FS = function(e) {\n  var r = ln(e, Oe.TITLE), n = ln(e, Zn.TITLE_TEMPLATE);\n  if (n && r)\n    return n.replace(/%s/g, function() {\n      return Array.isArray(r) ? r.join(\"\") : r;\n    });\n  var i = ln(e, Zn.DEFAULT_TITLE);\n  return r || i || void 0;\n}, LS = function(e) {\n  return ln(e, Zn.ON_CHANGE_CLIENT_STATE) || function() {\n  };\n}, ha = function(e, r) {\n  return r.filter(function(n) {\n    return typeof n[e] < \"u\";\n  }).map(function(n) {\n    return n[e];\n  }).reduce(function(n, i) {\n    return Pt({}, n, i);\n  }, {});\n}, jS = function(e, r) {\n  return r.filter(function(n) {\n    return typeof n[Oe.BASE] < \"u\";\n  }).map(function(n) {\n    return n[Oe.BASE];\n  }).reverse().reduce(function(n, i) {\n    if (!n.length)\n      for (var o = Object.keys(i), a = 0; a < o.length; a++) {\n        var s = o[a], l = s.toLowerCase();\n        if (e.indexOf(l) !== -1 && i[l])\n          return n.concat(i);\n      }\n    return n;\n  }, []);\n}, kn = function(e, r, n) {\n  var i = {};\n  return n.filter(function(o) {\n    return Array.isArray(o[e]) ? !0 : (typeof o[e] < \"u\" && Ka(\"Helmet: \" + e + ' should be of type \"Array\". Instead found type \"' + RS(o[e]) + '\"'), !1);\n  }).map(function(o) {\n    return o[e];\n  }).reverse().reduce(function(o, a) {\n    var s = {};\n    a.filter(function(h) {\n      for (var p = void 0, g = Object.keys(h), _ = 0; _ < g.length; _++) {\n        var T = g[_], A = T.toLowerCase();\n        r.indexOf(A) !== -1 && !(p === st.REL && h[p].toLowerCase() === \"canonical\") && !(A === st.REL && h[A].toLowerCase() === \"stylesheet\") && (p = A), r.indexOf(T) !== -1 && (T === st.INNER_HTML || T === st.CSS_TEXT || T === st.ITEM_PROP) && (p = T);\n      }\n      if (!p || !h[p])\n        return !1;\n      var w = h[p].toLowerCase();\n      return i[p] || (i[p] = {}), s[p] || (s[p] = {}), i[p][w] ? !1 : (s[p][w] = !0, !0);\n    }).reverse().forEach(function(h) {\n      return o.push(h);\n    });\n    for (var l = Object.keys(s), u = 0; u < l.length; u++) {\n      var c = l[u], f = Fp({}, i[c], s[c]);\n      i[c] = f;\n    }\n    return o;\n  }, []).reverse();\n}, ln = function(e, r) {\n  for (var n = e.length - 1; n >= 0; n--) {\n    var i = e[n];\n    if (i.hasOwnProperty(r))\n      return i[r];\n  }\n  return null;\n}, US = function(e) {\n  return {\n    baseTag: jS([st.HREF, st.TARGET], e),\n    bodyAttributes: ha(jr.BODY, e),\n    defer: ln(e, Zn.DEFER),\n    encode: ln(e, Zn.ENCODE_SPECIAL_CHARACTERS),\n    htmlAttributes: ha(jr.HTML, e),\n    linkTags: kn(Oe.LINK, [st.REL, st.HREF], e),\n    metaTags: kn(Oe.META, [st.NAME, st.CHARSET, st.HTTPEQUIV, st.PROPERTY, st.ITEM_PROP], e),\n    noscriptTags: kn(Oe.NOSCRIPT, [st.INNER_HTML], e),\n    onChangeClientState: LS(e),\n    scriptTags: kn(Oe.SCRIPT, [st.SRC, st.INNER_HTML], e),\n    styleTags: kn(Oe.STYLE, [st.CSS_TEXT], e),\n    title: FS(e),\n    titleAttributes: ha(jr.TITLE, e)\n  };\n}, qa = function() {\n  var t = Date.now();\n  return function(e) {\n    var r = Date.now();\n    r - t > 16 ? (t = r, e(r)) : setTimeout(function() {\n      qa(e);\n    }, 0);\n  };\n}(), j0 = function(e) {\n  return clearTimeout(e);\n}, VS = typeof window < \"u\" ? window.requestAnimationFrame && window.requestAnimationFrame.bind(window) || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || qa : global.requestAnimationFrame || qa, $S = typeof window < \"u\" ? window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || j0 : global.cancelAnimationFrame || j0, Ka = function(e) {\n  return console && typeof console.warn == \"function\" && console.warn(e);\n}, Rn = null, HS = function(e) {\n  Rn && $S(Rn), e.defer ? Rn = VS(function() {\n    U0(e, function() {\n      Rn = null;\n    });\n  }) : (U0(e), Rn = null);\n}, U0 = function(e, r) {\n  var n = e.baseTag, i = e.bodyAttributes, o = e.htmlAttributes, a = e.linkTags, s = e.metaTags, l = e.noscriptTags, u = e.onChangeClientState, c = e.scriptTags, f = e.styleTags, h = e.title, p = e.titleAttributes;\n  Ga(Oe.BODY, i), Ga(Oe.HTML, o), WS(h, p);\n  var g = {\n    baseTag: Zr(Oe.BASE, n),\n    linkTags: Zr(Oe.LINK, a),\n    metaTags: Zr(Oe.META, s),\n    noscriptTags: Zr(Oe.NOSCRIPT, l),\n    scriptTags: Zr(Oe.SCRIPT, c),\n    styleTags: Zr(Oe.STYLE, f)\n  }, _ = {}, T = {};\n  Object.keys(g).forEach(function(A) {\n    var w = g[A], O = w.newTags, R = w.oldTags;\n    O.length && (_[A] = O), R.length && (T[A] = g[A].oldTags);\n  }), r && r(), u(e, _, T);\n}, Up = function(e) {\n  return Array.isArray(e) ? e.join(\"\") : e;\n}, WS = function(e, r) {\n  typeof e < \"u\" && document.title !== e && (document.title = Up(e)), Ga(Oe.TITLE, r);\n}, Ga = function(e, r) {\n  var n = document.getElementsByTagName(e)[0];\n  if (n) {\n    for (var i = n.getAttribute(Kt), o = i ? i.split(\",\") : [], a = [].concat(o), s = Object.keys(r), l = 0; l < s.length; l++) {\n      var u = s[l], c = r[u] || \"\";\n      n.getAttribute(u) !== c && n.setAttribute(u, c), o.indexOf(u) === -1 && o.push(u);\n      var f = a.indexOf(u);\n      f !== -1 && a.splice(f, 1);\n    }\n    for (var h = a.length - 1; h >= 0; h--)\n      n.removeAttribute(a[h]);\n    o.length === a.length ? n.removeAttribute(Kt) : n.getAttribute(Kt) !== s.join(\",\") && n.setAttribute(Kt, s.join(\",\"));\n  }\n}, Zr = function(e, r) {\n  var n = document.head || document.querySelector(Oe.HEAD), i = n.querySelectorAll(e + \"[\" + Kt + \"]\"), o = Array.prototype.slice.call(i), a = [], s = void 0;\n  return r && r.length && r.forEach(function(l) {\n    var u = document.createElement(e);\n    for (var c in l)\n      if (l.hasOwnProperty(c))\n        if (c === st.INNER_HTML)\n          u.innerHTML = l.innerHTML;\n        else if (c === st.CSS_TEXT)\n          u.styleSheet ? u.styleSheet.cssText = l.cssText : u.appendChild(document.createTextNode(l.cssText));\n        else {\n          var f = typeof l[c] > \"u\" ? \"\" : l[c];\n          u.setAttribute(c, f);\n        }\n    u.setAttribute(Kt, \"true\"), o.some(function(h, p) {\n      return s = p, u.isEqualNode(h);\n    }) ? o.splice(s, 1) : a.push(u);\n  }), o.forEach(function(l) {\n    return l.parentNode.removeChild(l);\n  }), a.forEach(function(l) {\n    return n.appendChild(l);\n  }), {\n    oldTags: o,\n    newTags: a\n  };\n}, Vp = function(e) {\n  return Object.keys(e).reduce(function(r, n) {\n    var i = typeof e[n] < \"u\" ? n + '=\"' + e[n] + '\"' : \"\" + n;\n    return r ? r + \" \" + i : i;\n  }, \"\");\n}, zS = function(e, r, n, i) {\n  var o = Vp(n), a = Up(r);\n  return o ? \"<\" + e + \" \" + Kt + '=\"true\" ' + o + \">\" + za(a, i) + \"</\" + e + \">\" : \"<\" + e + \" \" + Kt + '=\"true\">' + za(a, i) + \"</\" + e + \">\";\n}, qS = function(e, r, n) {\n  return r.reduce(function(i, o) {\n    var a = Object.keys(o).filter(function(u) {\n      return !(u === st.INNER_HTML || u === st.CSS_TEXT);\n    }).reduce(function(u, c) {\n      var f = typeof o[c] > \"u\" ? c : c + '=\"' + za(o[c], n) + '\"';\n      return u ? u + \" \" + f : f;\n    }, \"\"), s = o.innerHTML || o.cssText || \"\", l = kS.indexOf(e) === -1;\n    return i + \"<\" + e + \" \" + Kt + '=\"true\" ' + a + (l ? \"/>\" : \">\" + s + \"</\" + e + \">\");\n  }, \"\");\n}, $p = function(e) {\n  var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n  return Object.keys(e).reduce(function(n, i) {\n    return n[Oo[i] || i] = e[i], n;\n  }, r);\n}, KS = function(e) {\n  var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n  return Object.keys(e).reduce(function(n, i) {\n    return n[MS[i] || i] = e[i], n;\n  }, r);\n}, GS = function(e, r, n) {\n  var i, o = (i = {\n    key: r\n  }, i[Kt] = !0, i), a = $p(n, o);\n  return [react__WEBPACK_IMPORTED_MODULE_0__.createElement(Oe.TITLE, a, r)];\n}, YS = function(e, r) {\n  return r.map(function(n, i) {\n    var o, a = (o = {\n      key: i\n    }, o[Kt] = !0, o);\n    return Object.keys(n).forEach(function(s) {\n      var l = Oo[s] || s;\n      if (l === st.INNER_HTML || l === st.CSS_TEXT) {\n        var u = n.innerHTML || n.cssText;\n        a.dangerouslySetInnerHTML = { __html: u };\n      } else\n        a[l] = n[s];\n    }), react__WEBPACK_IMPORTED_MODULE_0__.createElement(e, a);\n  });\n}, sr = function(e, r, n) {\n  switch (e) {\n    case Oe.TITLE:\n      return {\n        toComponent: function() {\n          return GS(e, r.title, r.titleAttributes);\n        },\n        toString: function() {\n          return zS(e, r.title, r.titleAttributes, n);\n        }\n      };\n    case jr.BODY:\n    case jr.HTML:\n      return {\n        toComponent: function() {\n          return $p(r);\n        },\n        toString: function() {\n          return Vp(r);\n        }\n      };\n    default:\n      return {\n        toComponent: function() {\n          return YS(e, r);\n        },\n        toString: function() {\n          return qS(e, r, n);\n        }\n      };\n  }\n}, Hp = function(e) {\n  var r = e.baseTag, n = e.bodyAttributes, i = e.encode, o = e.htmlAttributes, a = e.linkTags, s = e.metaTags, l = e.noscriptTags, u = e.scriptTags, c = e.styleTags, f = e.title, h = f === void 0 ? \"\" : f, p = e.titleAttributes;\n  return {\n    base: sr(Oe.BASE, r, i),\n    bodyAttributes: sr(jr.BODY, n, i),\n    htmlAttributes: sr(jr.HTML, o, i),\n    link: sr(Oe.LINK, a, i),\n    meta: sr(Oe.META, s, i),\n    noscript: sr(Oe.NOSCRIPT, l, i),\n    script: sr(Oe.SCRIPT, u, i),\n    style: sr(Oe.STYLE, c, i),\n    title: sr(Oe.TITLE, { title: h, titleAttributes: p }, i)\n  };\n}, ZS = function(e) {\n  var r, n;\n  return n = r = function(i) {\n    DS(o, i);\n    function o() {\n      return BS(this, o), NS(this, i.apply(this, arguments));\n    }\n    return o.prototype.shouldComponentUpdate = function(s) {\n      return !OS(this.props, s);\n    }, o.prototype.mapNestedChildrenToProps = function(s, l) {\n      if (!l)\n        return null;\n      switch (s.type) {\n        case Oe.SCRIPT:\n        case Oe.NOSCRIPT:\n          return {\n            innerHTML: l\n          };\n        case Oe.STYLE:\n          return {\n            cssText: l\n          };\n      }\n      throw new Error(\"<\" + s.type + \" /> elements are self-closing and can not contain children. Refer to our API for more information.\");\n    }, o.prototype.flattenArrayTypeChildren = function(s) {\n      var l, u = s.child, c = s.arrayTypeChildren, f = s.newChildProps, h = s.nestedChildren;\n      return Pt({}, c, (l = {}, l[u.type] = [].concat(c[u.type] || [], [Pt({}, f, this.mapNestedChildrenToProps(u, h))]), l));\n    }, o.prototype.mapObjectTypeChildren = function(s) {\n      var l, u, c = s.child, f = s.newProps, h = s.newChildProps, p = s.nestedChildren;\n      switch (c.type) {\n        case Oe.TITLE:\n          return Pt({}, f, (l = {}, l[c.type] = p, l.titleAttributes = Pt({}, h), l));\n        case Oe.BODY:\n          return Pt({}, f, {\n            bodyAttributes: Pt({}, h)\n          });\n        case Oe.HTML:\n          return Pt({}, f, {\n            htmlAttributes: Pt({}, h)\n          });\n      }\n      return Pt({}, f, (u = {}, u[c.type] = Pt({}, h), u));\n    }, o.prototype.mapArrayTypeChildrenToProps = function(s, l) {\n      var u = Pt({}, l);\n      return Object.keys(s).forEach(function(c) {\n        var f;\n        u = Pt({}, u, (f = {}, f[c] = s[c], f));\n      }), u;\n    }, o.prototype.warnOnInvalidChildren = function(s, l) {\n      if (true) {\n        if (!F0.some(function(u) {\n          return s.type === u;\n        }))\n          return typeof s.type == \"function\" ? Ka(\"You may be attempting to nest <Helmet> components within each other, which is not allowed. Refer to our API for more information.\") : Ka(\"Only elements types \" + F0.join(\", \") + \" are allowed. Helmet does not support rendering <\" + s.type + \"> elements. Refer to our API for more information.\");\n        if (l && typeof l != \"string\" && (!Array.isArray(l) || l.some(function(u) {\n          return typeof u != \"string\";\n        })))\n          throw new Error(\"Helmet expects a string as a child of <\" + s.type + \">. Did you forget to wrap your children in braces? ( <\" + s.type + \">{``}</\" + s.type + \"> ) Refer to our API for more information.\");\n      }\n      return !0;\n    }, o.prototype.mapChildrenToProps = function(s, l) {\n      var u = this, c = {};\n      return react__WEBPACK_IMPORTED_MODULE_0__.Children.forEach(s, function(f) {\n        if (!(!f || !f.props)) {\n          var h = f.props, p = h.children, g = L0(h, [\"children\"]), _ = KS(g);\n          switch (u.warnOnInvalidChildren(f, p), f.type) {\n            case Oe.LINK:\n            case Oe.META:\n            case Oe.NOSCRIPT:\n            case Oe.SCRIPT:\n            case Oe.STYLE:\n              c = u.flattenArrayTypeChildren({\n                child: f,\n                arrayTypeChildren: c,\n                newChildProps: _,\n                nestedChildren: p\n              });\n              break;\n            default:\n              l = u.mapObjectTypeChildren({\n                child: f,\n                newProps: l,\n                newChildProps: _,\n                nestedChildren: p\n              });\n              break;\n          }\n        }\n      }), l = this.mapArrayTypeChildrenToProps(c, l), l;\n    }, o.prototype.render = function() {\n      var s = this.props, l = s.children, u = L0(s, [\"children\"]), c = Pt({}, u);\n      return l && (c = this.mapChildrenToProps(l, c)), react__WEBPACK_IMPORTED_MODULE_0__.createElement(e, c);\n    }, IS(o, null, [{\n      key: \"canUseDOM\",\n      // Component.peek comes from react-side-effect:\n      // For testing, you may use a static peek() method available on the returned component.\n      // It lets you get the current state without resetting the mounted instance stack.\n      // Don’t use it for anything other than testing.\n      /**\n       * @param {Object} base: {\"target\": \"_blank\", \"href\": \"http://mysite.com/\"}\n       * @param {Object} bodyAttributes: {\"className\": \"root\"}\n       * @param {String} defaultTitle: \"Default Title\"\n       * @param {Boolean} defer: true\n       * @param {Boolean} encodeSpecialCharacters: true\n       * @param {Object} htmlAttributes: {\"lang\": \"en\", \"amp\": undefined}\n       * @param {Array} link: [{\"rel\": \"canonical\", \"href\": \"http://mysite.com/example\"}]\n       * @param {Array} meta: [{\"name\": \"description\", \"content\": \"Test description\"}]\n       * @param {Array} noscript: [{\"innerHTML\": \"<img src='http://mysite.com/js/test.js'\"}]\n       * @param {Function} onChangeClientState: \"(newState) => console.log(newState)\"\n       * @param {Array} script: [{\"type\": \"text/javascript\", \"src\": \"http://mysite.com/js/test.js\"}]\n       * @param {Array} style: [{\"type\": \"text/css\", \"cssText\": \"div { display: block; color: blue; }\"}]\n       * @param {String} title: \"Title\"\n       * @param {Object} titleAttributes: {\"itemprop\": \"name\"}\n       * @param {String} titleTemplate: \"MySite.com - %s\"\n       */\n      set: function(s) {\n        e.canUseDOM = s;\n      }\n    }]), o;\n  }(react__WEBPACK_IMPORTED_MODULE_0__.Component), r.propTypes = {\n    base: Ze.object,\n    bodyAttributes: Ze.object,\n    children: Ze.oneOfType([Ze.arrayOf(Ze.node), Ze.node]),\n    defaultTitle: Ze.string,\n    defer: Ze.bool,\n    encodeSpecialCharacters: Ze.bool,\n    htmlAttributes: Ze.object,\n    link: Ze.arrayOf(Ze.object),\n    meta: Ze.arrayOf(Ze.object),\n    noscript: Ze.arrayOf(Ze.object),\n    onChangeClientState: Ze.func,\n    script: Ze.arrayOf(Ze.object),\n    style: Ze.arrayOf(Ze.object),\n    title: Ze.string,\n    titleAttributes: Ze.object,\n    titleTemplate: Ze.string\n  }, r.defaultProps = {\n    defer: !0,\n    encodeSpecialCharacters: !0\n  }, r.peek = e.peek, r.rewind = function() {\n    var i = e.rewind();\n    return i || (i = Hp({\n      baseTag: [],\n      bodyAttributes: {},\n      encodeSpecialCharacters: !0,\n      htmlAttributes: {},\n      linkTags: [],\n      metaTags: [],\n      noscriptTags: [],\n      scriptTags: [],\n      styleTags: [],\n      title: \"\",\n      titleAttributes: {}\n    })), i;\n  }, n;\n}, XS = function() {\n  return null;\n}, JS = TS(US, HS, Hp)(XS), Ya = ZS(JS);\nYa.renderStatic = Ya.rewind;\nfunction l2({\n  children: t,\n  theme: e = V0,\n  config: r = e2\n}) {\n  const [n, i] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useReducer)(uS, {\n    ...vc,\n    config: r\n  });\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    i({\n      type: \"UPDATE_CONFIG\",\n      payload: r\n    });\n  }, [r]);\n  const o = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(\n    () => ({\n      ...V0,\n      ...e\n    }),\n    [e]\n  );\n  return /* @__PURE__ */ be(Rh.Provider, { value: { state: n, dispatch: i }, children: /* @__PURE__ */ be(\n    x1,\n    {\n      theme: {\n        ...o.displayTheme === \"light\" ? Fh : v1,\n        displayTheme: o.displayTheme || \"light\",\n        theme: oh(o.accent),\n        themeConfig: o\n      },\n      children: /* @__PURE__ */ Ue(QS, { children: [\n        /* @__PURE__ */ Ue(Ya, { children: [\n          /* @__PURE__ */ be(\"link\", { rel: \"preconnect\", href: \"https://fonts.googleapis.com\" }),\n          /* @__PURE__ */ be(\n            \"link\",\n            {\n              rel: \"preconnect\",\n              href: \"https://fonts.gstatic.com\",\n              crossOrigin: \"\"\n            }\n          ),\n          /* @__PURE__ */ be(\n            \"link\",\n            {\n              href: \"https://fonts.googleapis.com/css2?family=Manrope:wght@400;500;600;700;800&display=swap\",\n              rel: \"stylesheet\"\n            }\n          )\n        ] }),\n        t,\n        /* @__PURE__ */ be(jE, {}),\n        /* @__PURE__ */ be(XE, {}),\n        /* @__PURE__ */ be(nE, {})\n      ] })\n    }\n  ) });\n}\nconst QS = ({ children: t }) => (b1(), Og(), /* @__PURE__ */ be(zn, { children: t })), V0 = {\n  displayTheme: \"light\",\n  accent: {\n    r: 0,\n    g: 0,\n    b: 0\n  },\n  titleHighlight: {\n    r: 0,\n    g: 122,\n    b: 255\n  },\n  radius: \"default\",\n  font: {\n    fontFamily: \"Manrope\"\n  }\n}, e2 = {\n  permissions: [\"ACCESS_ADDRESS\", \"ACCESS_ALL_ADDRESSES\"],\n  ensurePermissions: !1\n};\n\n\n\n//# sourceURL=webpack://q2/./node_modules/arweave-wallet-kit/dist/index.es.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./script.js");
/******/ 	
/******/ })()
;
